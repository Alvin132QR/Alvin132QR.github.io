/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 83820:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const react_1 = __importDefault(__webpack_require__(67294));
const useFacetMemo_1 = __webpack_require__(44833);
const useFacetUnwrap_1 = __webpack_require__(88684);
const useFacetMap_1 = __webpack_require__(44283);
const types_1 = __webpack_require__(74093);
const Map = ({ array, children, equalityCheck }) => {
    var _a;
    const countValue = (_a = (0, useFacetUnwrap_1.useFacetUnwrap)((0, useFacetMap_1.useFacetMap)((array) => array.length, [], [array]))) !== null && _a !== void 0 ? _a : 0;
    return (react_1.default.createElement(react_1.default.Fragment, null, times((index) => equalityCheck !== undefined ? (react_1.default.createElement(MapChildMemo, { key: index, arrayFacet: array, index: index, equalityCheck: equalityCheck, children: children })) : (react_1.default.createElement(MapChild, { key: index, arrayFacet: array, index: index, children: children })), countValue !== types_1.NO_VALUE ? countValue : 0)));
};
exports.Map = Map;
const MapChildMemo = ({ arrayFacet, index, children, equalityCheck }) => {
    const childFacet = (0, useFacetMemo_1.useFacetMemo)((array) => {
        if (index < array.length)
            return array[index];
        return types_1.NO_VALUE;
    }, [index], [arrayFacet], equalityCheck);
    return children(childFacet, index);
};
const MapChild = ({ arrayFacet, index, children }) => {
    const childFacet = (0, useFacetMap_1.useFacetMap)((array) => {
        if (index < array.length)
            return array[index];
        return types_1.NO_VALUE;
    }, [index], [arrayFacet]);
    return children(childFacet, index);
};
const times = (fn, n) => {
    const result = [];
    for (let index = 0; index < n; index++) {
        result.push(fn(index));
    }
    return result;
};
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ 92885:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mount = void 0;
const useFacetUnwrap_1 = __webpack_require__(88684);
const Mount = ({ when, children, condition = true }) => {
    const whenValue = (0, useFacetUnwrap_1.useFacetUnwrap)(when);
    return whenValue === condition ? children : null;
};
exports.Mount = Mount;
//# sourceMappingURL=Mount.js.map

/***/ }),

/***/ 60725:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.With = void 0;
const useFacetUnwrap_1 = __webpack_require__(88684);
const useFacetMap_1 = __webpack_require__(44283);
const hasData = (_, shouldRender) => {
    return shouldRender === true;
};
const With = ({ data, children }) => {
    const shouldRenderFacet = (0, useFacetMap_1.useFacetMap)((data) => data !== null && data !== undefined, [], [data]);
    const shouldRender = (0, useFacetUnwrap_1.useFacetUnwrap)(shouldRenderFacet);
    return hasData(data, shouldRender) ? children(data) : null;
};
exports.With = With;
//# sourceMappingURL=With.js.map

/***/ }),

/***/ 12493:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(83820), exports);
__exportStar(__webpack_require__(92885), exports);
__exportStar(__webpack_require__(60725), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 41024:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createOptionalValueEqualityCheck = exports.createObjectWithKeySpecificEqualityCheck = exports.createUniformArrayEqualityCheck = exports.createUniformObjectEqualityCheck = exports.createNullableEqualityCheck = void 0;
const types_1 = __webpack_require__(74093);
/**
 * Creates an equality check that accepts null and undefined values
 *
 * @param comparator comparator to be wrapped with the null check
 */
const createNullableEqualityCheck = (comparator) => {
    const check = comparator();
    let previous = types_1.NO_VALUE;
    return (value) => {
        if (value === undefined || value === null || previous === undefined || previous === null) {
            if (value !== previous) {
                previous = value;
                return false;
            }
            else {
                return true;
            }
        }
        previous = value;
        return check(value);
    };
};
exports.createNullableEqualityCheck = createNullableEqualityCheck;
/**
 * Creates an equality check that tests that the values of all the properties in an object
 * haven't changed.
 *
 * The comparison used for the value of the properties is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each property
 */
const createUniformObjectEqualityCheck = (comparator) => () => {
    const previous = {};
    let previousKeys = new Set();
    let initialized = false;
    return (current) => {
        var _a;
        let isEquals = true;
        for (const key in current) {
            if (!(key in previous)) {
                previous[key] = comparator();
            }
            if (!((_a = previous[key]) === null || _a === void 0 ? void 0 : _a.call(previous, current[key]))) {
                isEquals = false;
            }
            previousKeys.delete(key);
        }
        if (previousKeys.size > 0) {
            for (const key of previousKeys) {
                delete previous[key];
            }
            isEquals = false;
        }
        previousKeys = new Set();
        for (const key in current) {
            previousKeys.add(key);
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformObjectEqualityCheck = createUniformObjectEqualityCheck;
/**
 * Creates an equality check that tests that the items in an array
 * haven't changed.
 *
 * The comparison used for the individual items is passed to it as an argument.
 *
 * @param comparator the equality check to be run for each item
 */
const createUniformArrayEqualityCheck = (comparator) => () => {
    const previous = [];
    let initialized = false;
    return (current) => {
        var _a, _b;
        const longestLength = Math.max((_a = previous === null || previous === void 0 ? void 0 : previous.length) !== null && _a !== void 0 ? _a : 0, (_b = current === null || current === void 0 ? void 0 : current.length) !== null && _b !== void 0 ? _b : 0);
        let isEquals = true;
        for (let i = 0; i < longestLength; i++) {
            if (previous[i] === undefined) {
                previous[i] = comparator();
            }
            if (!previous[i](current[i])) {
                isEquals = false;
            }
        }
        if (!initialized) {
            initialized = true;
            return false;
        }
        return isEquals;
    };
};
exports.createUniformArrayEqualityCheck = createUniformArrayEqualityCheck;
/**
 * Creates an equality check that tests whether each property of the target object has changed.
 * Each property is tested with a different comparator, so that they can be of different types.
 *
 * The comparator are passed down to it as an object with the same keys as the target object, but
 * comparators for each property as values.
 *
 * @param comparators the object containing the equality checks to be run for each property
 */
const createObjectWithKeySpecificEqualityCheck = (comparators) => () => {
    const initializingComparators = {};
    for (const key in comparators) {
        initializingComparators[key] = comparators[key]();
    }
    const initializedComparators = initializingComparators;
    return (current) => {
        let isEqual = true;
        for (const key in current) {
            if (!initializedComparators[key](current[key])) {
                // We don't break or skip the next comparators because we need all comparators
                // to run for their internal values to update, so we complete the for loop
                // even if one of the comparators reports false early on
                isEqual = false;
            }
        }
        return isEqual;
    };
};
exports.createObjectWithKeySpecificEqualityCheck = createObjectWithKeySpecificEqualityCheck;
/**
 * Creates an equality check that tests whether the value changed from null to defined or stayed the same
 *
 * If the value was not null before and it is not null currently, the comparison is done by the equality check
 * provided as an argument to this creator.
 *
 * This creator is useful to be able to make equality checkers for optional properties when you already have
 * an equality check for the underlying type.
 *
 * @param comparator the equality check to be run in case the value was defined before and now
 */
const createOptionalValueEqualityCheck = (comparator) => () => {
    let previousWasNullish = true;
    let initializedComparator = comparator();
    return (current) => {
        if (current === undefined || current === null) {
            if (previousWasNullish) {
                return true;
            }
            // If the next value is nullish, the current comparator will be outdated.
            // We cannot simply pass a nullish value to it, since it doesn't accept nullish.
            // Instead, we need to initialize a new comparator to reset it
            initializedComparator = comparator();
            previousWasNullish = true;
            return false;
        }
        previousWasNullish = false;
        return initializedComparator(current);
    };
};
exports.createOptionalValueEqualityCheck = createOptionalValueEqualityCheck;
//# sourceMappingURL=createEqualityChecks.js.map

/***/ }),

/***/ 27755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFacetContext = void 0;
const react_1 = __webpack_require__(67294);
function createFacetContext(initialValue) {
    let warnedAboutInvalidAccess = false;
    const facet = {
        get: () => initialValue,
        observe: (listener) => {
            if (false) {}
            listener(initialValue);
            return () => { };
        },
    };
    const context = (0, react_1.createContext)(facet);
    return context;
}
exports.createFacetContext = createFacetContext;
function parseInitialValue(initialValue) {
    try {
        return JSON.stringify(initialValue, null, 2);
    }
    catch (e) {
        return initialValue;
    }
}
//# sourceMappingURL=createFacetContext.js.map

/***/ }),

/***/ 52868:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEqualityCheck = exports.nullableShallowArrayEqualityCheck = exports.nullableShallowObjectArrayEqualityCheck = exports.nullableShallowObjectEqualityCheck = exports.shallowArrayEqualityCheck = exports.shallowObjectArrayEqualityCheck = exports.shallowObjectEqualityCheck = exports.strictEqualityCheck = void 0;
const createEqualityChecks_1 = __webpack_require__(41024);
const types_1 = __webpack_require__(74093);
/**
 * Checks that the current value is exactly the same as the other previous one. Accepts value of type
 * function, number, boolean, string, undefined or null
 */
// eslint-disable-next-line @typescript-eslint/ban-types
const strictEqualityCheck = () => {
    let previous = types_1.NO_VALUE;
    return (current) => {
        if (previous !== current) {
            previous = current;
            return false;
        }
        return true;
    };
};
exports.strictEqualityCheck = strictEqualityCheck;
/**
 * Equality check that verifies the values of each key of an object.
 * Each value must be a primitive (boolean, number or string)
 *
 * For null or undefined values see nullableShallowObjectEqualityCheck
 */
exports.shallowObjectEqualityCheck = (0, createEqualityChecks_1.createUniformObjectEqualityCheck)(exports.strictEqualityCheck);
/**
 * Does a shallow object equality check for each element in an array
 *
 * For null or undefined values see nullableShallowObjectArrayEqualityCheck
 */
exports.shallowObjectArrayEqualityCheck = (0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.shallowObjectEqualityCheck);
/**
 * Shallow equality check of primitives in an array
 *
 * For null or undefined values see nullableShallowArrayEqualityCheck
 */
exports.shallowArrayEqualityCheck = (0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.strictEqualityCheck);
/**
 * Equality check that verifies the values of each key of an object.
 * Each value must be a primitive (boolean, number or string)
 *
 * Supports nullable values
 */
const nullableShallowObjectEqualityCheck = () => (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformObjectEqualityCheck)(exports.strictEqualityCheck));
exports.nullableShallowObjectEqualityCheck = nullableShallowObjectEqualityCheck;
/**
 * Does a shallow object equality check for each element in an array
 *
 * Supports nullable values
 */
exports.nullableShallowObjectArrayEqualityCheck = (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.shallowObjectEqualityCheck));
/**
 * Shallow equality check of primitives in an array
 *
 * Supports nullable values
 */
exports.nullableShallowArrayEqualityCheck = (0, createEqualityChecks_1.createNullableEqualityCheck)((0, createEqualityChecks_1.createUniformArrayEqualityCheck)(exports.strictEqualityCheck));
/**
 * The default equality check that assumes data can be mutated.
 * It is used internally by default, so there is no need to provide it.
 */
const defaultEqualityCheck = () => {
    let previous = types_1.NO_VALUE;
    return (current) => {
        const typeofValue = typeof current;
        if (!(typeofValue === 'number' ||
            typeofValue === 'string' ||
            typeofValue === 'boolean' ||
            current === null ||
            current === undefined)) {
            return false;
        }
        if (current !== previous) {
            previous = current;
            return false;
        }
        return true;
    };
};
exports.defaultEqualityCheck = defaultEqualityCheck;
//# sourceMappingURL=equalityChecks.js.map

/***/ }),

/***/ 90486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFacet = void 0;
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
const scheduler_1 = __webpack_require__(82358);
/**
 * The low level function to create a Facet, not recommended to be used if you can use any of the react facet hooks to create facets instead (Ex: useFacetState, useFacetWrap)
 */
function createFacet({ initialValue, startSubscription, equalityCheck = equalityChecks_1.defaultEqualityCheck, }) {
    const listeners = new Set();
    let currentValue = initialValue;
    let cleanupSubscription;
    const checker = equalityCheck === null || equalityCheck === void 0 ? void 0 : equalityCheck();
    const update = (newValue) => {
        if (equalityCheck !== undefined) {
            // we optimize for the most common scenario of using the defaultEqualityCheck (by inline its implementation)
            if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                const typeofValue = typeof newValue;
                if ((typeofValue === 'number' ||
                    typeofValue === 'string' ||
                    typeofValue === 'boolean' ||
                    newValue === null ||
                    newValue === undefined) &&
                    currentValue === newValue) {
                    return;
                }
            }
            else {
                if (checker !== undefined && checker(newValue)) {
                    return;
                }
            }
        }
        (0, scheduler_1.batch)(() => {
            currentValue = newValue;
            for (const listener of listeners) {
                listener(currentValue);
            }
        });
    };
    /**
     * Simpler update implementation that only resets the value and runs all cleanup functions.
     * Done as a separated function to not interfere with the usual "hot-path" of the update function.
     */
    const updateToNoValue = () => {
        currentValue = types_1.NO_VALUE;
    };
    return {
        set: update,
        setWithCallback: (setter) => {
            const value = setter(currentValue);
            if (value === types_1.NO_VALUE) {
                updateToNoValue();
            }
            else {
                update(value);
            }
        },
        get: () => currentValue,
        observe: (listener) => {
            listeners.add(listener);
            if (currentValue !== types_1.NO_VALUE) {
                listener(currentValue);
            }
            // This is the first subscription, so we start subscribing to dependencies
            if (listeners.size === 1 && startSubscription) {
                cleanupSubscription = startSubscription(update);
            }
            return () => {
                listeners.delete(listener);
                // if this was the last to unsubscribe, we unsubscribe from our dependencies
                if (listeners.size === 0 && cleanupSubscription) {
                    currentValue = initialValue;
                    cleanupSubscription();
                }
            };
        },
    };
}
exports.createFacet = createFacet;
//# sourceMappingURL=createFacet.js.map

/***/ }),

/***/ 27200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReadOnlyFacet = void 0;
const createFacet_1 = __webpack_require__(90486);
function createReadOnlyFacet(options) {
    return (0, createFacet_1.createFacet)(options);
}
exports.createReadOnlyFacet = createReadOnlyFacet;
//# sourceMappingURL=createReadOnlyFacet.js.map

/***/ }),

/***/ 49095:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createStaticFacet = void 0;
/**
 * Creates a nonwritable barebones static facet to be used when you need an initial facet value outside the react context
 * that's meant to be replaced later by a real facet. Ex: with `createContext()`
 */
function createStaticFacet(value) {
    const facet = {
        get: () => value,
        observe: (listener) => {
            listener(value);
            return () => { };
        },
    };
    return facet;
}
exports.createStaticFacet = createStaticFacet;
//# sourceMappingURL=createStaticFacet.js.map

/***/ }),

/***/ 46103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(90486), exports);
__exportStar(__webpack_require__(27200), exports);
__exportStar(__webpack_require__(49095), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97190:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.areAllDefinedValues = void 0;
const hasDefinedValue_1 = __webpack_require__(83127);
const areAllDefinedValues = (facetValues) => {
    for (let i = 0; i < facetValues.length; i++) {
        if (!(0, hasDefinedValue_1.hasDefinedValue)(facetValues[i])) {
            return false;
        }
    }
    return true;
};
exports.areAllDefinedValues = areAllDefinedValues;
//# sourceMappingURL=areAllDefinedValues.js.map

/***/ }),

/***/ 83127:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasDefinedValue = void 0;
const types_1 = __webpack_require__(74093);
const hasDefinedValue = (value) => value !== undefined && value !== null && value !== types_1.NO_VALUE;
exports.hasDefinedValue = hasDefinedValue;
//# sourceMappingURL=hasDefinedValue.js.map

/***/ }),

/***/ 5900:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(97190), exports);
__exportStar(__webpack_require__(83127), exports);
__exportStar(__webpack_require__(86191), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiObserve = void 0;
const types_1 = __webpack_require__(74093);
/**
 * Allows running an effect based on facet updates. Similar to React's useEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
function multiObserve(effect, facets) {
    if (facets.length === 1) {
        return facets[0].observe(effect);
    }
    let cleanup;
    let hasAllDependencies = false;
    const unsubscribes = [];
    const values = facets.map(() => types_1.NO_VALUE);
    for (let i = 0; i < facets.length; i++) {
        unsubscribes[i] = facets[i].observe((value) => {
            values[i] = value;
            hasAllDependencies = hasAllDependencies || values.every((value) => value !== types_1.NO_VALUE);
            if (hasAllDependencies) {
                if (cleanup !== undefined) {
                    cleanup();
                }
                cleanup = effect(...values);
            }
        });
    }
    return () => {
        for (let index = 0; index < unsubscribes.length; index++) {
            unsubscribes[index]();
        }
        if (cleanup !== undefined) {
            cleanup();
        }
    };
}
exports.multiObserve = multiObserve;
//# sourceMappingURL=multiObserve.js.map

/***/ }),

/***/ 47923:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(2367), exports);
__exportStar(__webpack_require__(96955), exports);
__exportStar(__webpack_require__(28488), exports);
__exportStar(__webpack_require__(44283), exports);
__exportStar(__webpack_require__(44833), exports);
__exportStar(__webpack_require__(50813), exports);
__exportStar(__webpack_require__(80551), exports);
__exportStar(__webpack_require__(66280), exports);
__exportStar(__webpack_require__(95174), exports);
__exportStar(__webpack_require__(88684), exports);
__exportStar(__webpack_require__(99751), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2367:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetCallback = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
function useFacetCallback(callback, dependencies, facets, defaultReturnValue) {
    (0, react_1.useLayoutEffect)(() => {
        // Make sure to start subscriptions, even though we are getting the values directly from them
        // We read the values using `.get` to make sure they are always up-to-date
        const unsubscribes = facets.map((facet) => facet.observe(() => { }));
        return () => {
            unsubscribes.forEach((unsubscribe) => unsubscribe());
        };
        // We care about each individual facet and if any is a different reference
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, facets);
    // We care about each individual dependency and if any is a different reference
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const callbackMemoized = (0, react_1.useCallback)(callback, dependencies);
    // Setup a ref so that the callback instance below can be kept the same
    // when Facet instances change across re-renders
    const facetsRef = (0, react_1.useRef)(facets);
    facetsRef.current = facets;
    return (0, react_1.useCallback)((...args) => {
        const facets = facetsRef.current;
        const values = facets.map((facet) => facet.get());
        for (const value of values) {
            if (value === types_1.NO_VALUE)
                return defaultReturnValue !== undefined ? defaultReturnValue : types_1.NO_VALUE;
        }
        return callbackMemoized(...values)(...args);
    }, [callbackMemoized, defaultReturnValue]);
}
exports.useFacetCallback = useFacetCallback;
//# sourceMappingURL=useFacetCallback.js.map

/***/ }),

/***/ 96955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetEffect = exports.createUseFacetEffect = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
const scheduler_1 = __webpack_require__(82358);
const createUseFacetEffect = (useHook) => {
    return function (effect, dependencies, facets) {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        const effectMemoized = (0, react_1.useCallback)(effect, dependencies);
        useHook(() => {
            let cleanup;
            if (facets.length === 1) {
                const unsubscribe = facets[0].observe((value) => {
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                    cleanup = effectMemoized(value);
                });
                return () => {
                    unsubscribe();
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                };
            }
            let hasAllDependencies = false;
            const unsubscribes = [];
            const values = facets.map(() => types_1.NO_VALUE);
            const task = () => {
                hasAllDependencies = hasAllDependencies || values.every((value) => value !== types_1.NO_VALUE);
                if (hasAllDependencies) {
                    if (cleanup !== undefined) {
                        cleanup();
                    }
                    cleanup = effectMemoized(...values);
                }
            };
            facets.forEach((facet, index) => {
                unsubscribes[index] = facet.observe((value) => {
                    values[index] = value;
                    if (hasAllDependencies) {
                        (0, scheduler_1.scheduleTask)(task);
                    }
                    else {
                        task();
                    }
                });
            });
            return () => {
                (0, scheduler_1.cancelScheduledTask)(task);
                unsubscribes.forEach((unsubscribe) => unsubscribe());
                if (cleanup !== undefined) {
                    cleanup();
                }
            };
            // We care about each individual facet and if any is a different reference
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [effectMemoized, ...facets]);
    };
};
exports.createUseFacetEffect = createUseFacetEffect;
/**
 * Allows running an effect based on facet updates. Similar to React's useEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
exports.useFacetEffect = (0, exports.createUseFacetEffect)(react_1.useEffect);
//# sourceMappingURL=useFacetEffect.js.map

/***/ }),

/***/ 28488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetLayoutEffect = void 0;
const react_1 = __webpack_require__(67294);
const useFacetEffect_1 = __webpack_require__(96955);
/**
 * Allows running an effect based on facet updates. Similar to React's useLayoutEffect.
 *
 * @param effect function that will do the side-effect (ex: update the DOM)
 * @param dependencies variable used by the map that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that the effect listens to
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 */
exports.useFacetLayoutEffect = (0, useFacetEffect_1.createUseFacetEffect)(react_1.useLayoutEffect);
//# sourceMappingURL=useFacetLayoutEffect.js.map

/***/ }),

/***/ 44283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetMap = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const mapFacets_1 = __webpack_require__(12914);
/**
 * Helper hook that allows mapping a value from a facet with local variables/props in a React component
 *
 * @param selector function that takes value from provided facets and maps them to a new value
 * @param dependencies variable used by the selector that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that we will listen for its values to be mapped
 * @param equalityCheck optional, has a default for immutable values
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * @returns a new facet definition that can be consumed as a regular facet
 */
function useFacetMap(selector, dependencies, facets, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const selectorMemoized = (0, react_1.useCallback)(selector, dependencies);
    const facetComposition = (0, react_1.useMemo)(() => {
        return (0, mapFacets_1.mapFacetsLightweight)(facets, selectorMemoized, equalityCheck);
        // We need to disable the linter on the next line given we are spreading the facets as individual dependencies
        // of the effect. We do this to avoid re-running this effect when passing a new array with the same facets.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectorMemoized, equalityCheck, ...facets]);
    return facetComposition;
}
exports.useFacetMap = useFacetMap;
//# sourceMappingURL=useFacetMap.js.map

/***/ }),

/***/ 44833:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetMemo = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const mapFacets_1 = __webpack_require__(12914);
/**
 * Helper hook that allows mapping a value from a facet with local variables/props in a React component
 *
 * @param selector function that takes value from provided facets and maps them to a new value
 * @param dependencies variable used by the selector that are available in scope (similar as dependencies of useEffect)
 * @param facets facets that we will listen for its values to be mapped
 * @param equalityCheck optional, has a default for immutable values
 *
 * We pass the dependencies of the callback as the second argument so we can leverage the eslint-plugin-react-hooks option for additionalHooks.
 * Having this as the second argument allows the linter to work.
 *
 * @returns a new facet definition that can be consumed as a regular facet
 */
function useFacetMemo(selector, dependencies, facets, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const selectorMemoized = (0, react_1.useCallback)(selector, dependencies);
    const facetComposition = (0, react_1.useMemo)(() => {
        return (0, mapFacets_1.mapFacetsCached)(facets, selectorMemoized, equalityCheck);
        // We need to disable the linter on the next line given we are spreading the facets as individual dependencies
        // of the effect. We do this to avoid re-running this effect when passing a new array with the same facets.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [selectorMemoized, equalityCheck, ...facets]);
    return facetComposition;
}
exports.useFacetMemo = useFacetMemo;
//# sourceMappingURL=useFacetMemo.js.map

/***/ }),

/***/ 50813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetPropSetter = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
/**
 * Hook that returns a setter function to a specific property of a given a localFacet
 * Ex:
 * 	- Given a local facet { foo: 'bar' }
 *  - Could be used as useFacetSetter(facet, 'foo')
 *  - And the setter would set the foo property
 *
 * @param facet
 * @param prop the name of the prop to set
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useFacetPropSetter(facet, prop) {
    return (0, react_1.useMemo)(() => (value) => {
        facet.setWithCallback((prev) => (Object.assign(Object.assign({}, (prev !== types_1.NO_VALUE ? prev : {})), { [prop]: value })));
    }, [facet, prop]);
}
exports.useFacetPropSetter = useFacetPropSetter;
//# sourceMappingURL=useFacetPropSetter.js.map

/***/ }),

/***/ 66280:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetReducer = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const useFacetState_1 = __webpack_require__(95174);
/**
 * Provides a parallel to React's useReducer, but instead returns a facet as the value
 *
 * @param reducer function that will take the previous state and an action to return a new state
 * @param initialState mandatory initial state for the reducer's facet
 * @param equalityCheck optional equality check (has a default checker)
 * @returns
 */
const useFacetReducer = (reducer, initialState, equalityCheck = equalityChecks_1.defaultEqualityCheck) => {
    const [state, setState] = (0, useFacetState_1.useFacetState)(initialState, equalityCheck);
    const dispatch = (0, react_1.useCallback)((action) => {
        setState((previousState) => reducer(previousState, action));
    }, [reducer, setState]);
    return [state, dispatch];
};
exports.useFacetReducer = useFacetReducer;
//# sourceMappingURL=useFacetReducer.js.map

/***/ }),

/***/ 80551:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetRef = void 0;
const react_1 = __webpack_require__(67294);
const useFacetEffect_1 = __webpack_require__(96955);
const types_1 = __webpack_require__(74093);
function useFacetRef(facet, defaultValue) {
    let value = facet.get();
    if (value === types_1.NO_VALUE && defaultValue !== undefined) {
        value = defaultValue;
    }
    const ref = (0, react_1.useRef)(value);
    (0, useFacetEffect_1.useFacetEffect)((value) => {
        ref.current = value;
    }, [], [facet]);
    return ref;
}
exports.useFacetRef = useFacetRef;
//# sourceMappingURL=useFacetRef.js.map

/***/ }),

/***/ 95174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetState = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const facet_1 = __webpack_require__(46103);
/**
 * Provides a parallel to React's useState, but instead returns a facet as the value
 *
 * @param initialValue mandatory initial value (pass NO_VALUE to force it to be uninitialized)
 * @param equalityCheck optional (has a default checker)
 */
const useFacetState = (initialValue, equalityCheck = equalityChecks_1.defaultEqualityCheck) => {
    return (0, react_1.useMemo)(() => {
        const inlineFacet = (0, facet_1.createFacet)({ initialValue, equalityCheck });
        const setter = (setter) => {
            if (isSetterCallback(setter)) {
                inlineFacet.setWithCallback(setter);
            }
            else {
                inlineFacet.set(setter);
            }
        };
        return [inlineFacet, setter];
        /**
         * We ignore the changes to the initialValue since changes to the facet
         * done after creation must only be done through the setter, and we want
         * to ensure not to accidentally put more values in memory.
         */
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
};
exports.useFacetState = useFacetState;
const isSetterCallback = (setter) => {
    return typeof setter === 'function';
};
//# sourceMappingURL=useFacetState.js.map

/***/ }),

/***/ 88684:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetUnwrap = void 0;
const react_1 = __webpack_require__(67294);
const types_1 = __webpack_require__(74093);
const equalityChecks_1 = __webpack_require__(52868);
/**
 * Hook that allows consuming values from a Facet
 * It acts as a regular react state, triggering a re-render of the component
 *
 * @param facet
 */
function useFacetUnwrap(prop, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    const [state, setState] = (0, react_1.useState)(() => {
        if (!(0, types_1.isFacet)(prop))
            return { value: prop };
        return {
            value: prop.get(),
        };
    });
    (0, react_1.useLayoutEffect)(() => {
        if ((0, types_1.isFacet)(prop)) {
            // Initialize the equalityCheck
            const isEqual = equalityCheck();
            const startValue = prop.get();
            if (startValue !== types_1.NO_VALUE) {
                isEqual(startValue);
            }
            return prop.observe((value) => {
                setState((previousState) => {
                    const { value: previousValue } = previousState;
                    /**
                     * Performs this equality check locally to prevent triggering two consecutive renderings
                     * for facets that have immutable values (unfortunately we can't handle mutable values).
                     *
                     * The two renderings might happen for the same state value if the Facet has a value on mount.
                     *
                     * The unwrap will get the value:
                     * - Once on initialization of the useState above
                     * - And another time on this observe initialization
                     */
                    if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
                        const typeofValue = typeof previousValue;
                        if ((typeofValue === 'number' ||
                            typeofValue === 'string' ||
                            typeofValue === 'boolean' ||
                            value === undefined ||
                            value === null) &&
                            value === previousValue) {
                            return previousState;
                        }
                        return { value };
                    }
                    if (previousValue !== types_1.NO_VALUE && isEqual(previousValue)) {
                        return previousState;
                    }
                    return { value };
                });
            });
        }
    }, [prop, equalityCheck]);
    return (0, types_1.isFacet)(prop) ? state.value : prop;
}
exports.useFacetUnwrap = useFacetUnwrap;
//# sourceMappingURL=useFacetUnwrap.js.map

/***/ }),

/***/ 99751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useFacetWrap = void 0;
const react_1 = __webpack_require__(67294);
const equalityChecks_1 = __webpack_require__(52868);
const facet_1 = __webpack_require__(46103);
const types_1 = __webpack_require__(74093);
/**
 * Wraps a FacetProp as a Facet
 * @param value
 */
function useFacetWrap(prop, equalityCheck = equalityChecks_1.defaultEqualityCheck) {
    const is = (0, types_1.isFacet)(prop);
    /**
     * Inline facet that only created if the provided prop is not a facet.
     *
     * We ignore the dependency change of `prop` since we want to update the inline
     * facet value via the setter below.
     */
    const inlineFacet = (0, react_1.useMemo)(() => (is ? undefined : (0, facet_1.createFacet)({ initialValue: prop, equalityCheck })), 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [is]);
    if (inlineFacet === undefined) {
        return prop;
    }
    else {
        inlineFacet.set(prop);
        return inlineFacet;
    }
}
exports.useFacetWrap = useFacetWrap;
//# sourceMappingURL=useFacetWrap.js.map

/***/ }),

/***/ 88572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.batch = void 0;
__exportStar(__webpack_require__(12493), exports);
__exportStar(__webpack_require__(41024), exports);
__exportStar(__webpack_require__(27755), exports);
__exportStar(__webpack_require__(52868), exports);
__exportStar(__webpack_require__(46103), exports);
__exportStar(__webpack_require__(5900), exports);
__exportStar(__webpack_require__(47923), exports);
__exportStar(__webpack_require__(12914), exports);
__exportStar(__webpack_require__(74093), exports);
var scheduler_1 = __webpack_require__(82358);
Object.defineProperty(exports, "batch", ({ enumerable: true, get: function () { return scheduler_1.batch; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 12914:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(43118), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8273:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetArrayCached = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveArray_1 = __webpack_require__(71794);
const facet_1 = __webpack_require__(46103);
function mapFacetArrayCached(facets, fn, equalityCheck) {
    return (0, facet_1.createFacet)({
        // pass the equalityCheck to the mapIntoObserveArray to prevent even triggering the observable
        startSubscription: (0, mapIntoObserveArray_1.mapIntoObserveArray)(facets, fn, equalityCheck),
        initialValue: types_1.NO_VALUE,
    });
}
exports.mapFacetArrayCached = mapFacetArrayCached;
//# sourceMappingURL=mapFacetArrayCached.js.map

/***/ }),

/***/ 89160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetArrayLightweight = void 0;
const mapIntoObserveArray_1 = __webpack_require__(71794);
const types_1 = __webpack_require__(74093);
function mapFacetArrayLightweight(facets, fn, equalityCheck) {
    return {
        get: () => {
            const values = facets.map((facet) => facet.get());
            const hasAllValues = values.reduce((acc, value) => acc && value !== types_1.NO_VALUE, true);
            if (!hasAllValues)
                return types_1.NO_VALUE;
            return fn(...values);
        },
        observe: (0, mapIntoObserveArray_1.mapIntoObserveArray)(facets, fn, equalityCheck),
    };
}
exports.mapFacetArrayLightweight = mapFacetArrayLightweight;
//# sourceMappingURL=mapFacetArrayLightweight.js.map

/***/ }),

/***/ 26741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetSingleCached = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveSingle_1 = __webpack_require__(78781);
const facet_1 = __webpack_require__(46103);
function mapFacetSingleCached(facets, fn, equalityCheck) {
    return (0, facet_1.createFacet)({
        // pass the equalityCheck to the mapIntoObserveSingle to prevent even triggering the observable
        startSubscription: (0, mapIntoObserveSingle_1.mapIntoObserveSingle)(facets, fn, equalityCheck),
        initialValue: types_1.NO_VALUE,
    });
}
exports.mapFacetSingleCached = mapFacetSingleCached;
//# sourceMappingURL=mapFacetSingleCached.js.map

/***/ }),

/***/ 14714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetSingleLightweight = void 0;
const types_1 = __webpack_require__(74093);
const mapIntoObserveSingle_1 = __webpack_require__(78781);
function mapFacetSingleLightweight(facet, fn, equalityCheck) {
    return {
        get: () => {
            const value = facet.get();
            if (value === types_1.NO_VALUE)
                return types_1.NO_VALUE;
            return fn(value);
        },
        observe: (0, mapIntoObserveSingle_1.mapIntoObserveSingle)(facet, fn, equalityCheck),
    };
}
exports.mapFacetSingleLightweight = mapFacetSingleLightweight;
//# sourceMappingURL=mapFacetSingleLightweight.js.map

/***/ }),

/***/ 43118:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapFacetsCached = exports.mapFacetsLightweight = void 0;
const mapFacetArrayCached_1 = __webpack_require__(8273);
const mapFacetArrayLightweight_1 = __webpack_require__(89160);
const mapFacetSingleCached_1 = __webpack_require__(26741);
const mapFacetSingleLightweight_1 = __webpack_require__(14714);
function mapFacetsLightweight(facets, fn, equalityCheck) {
    if (facets.length === 1) {
        return (0, mapFacetSingleLightweight_1.mapFacetSingleLightweight)(facets[0], fn, equalityCheck);
    }
    else {
        return (0, mapFacetArrayLightweight_1.mapFacetArrayLightweight)(facets, fn, equalityCheck);
    }
}
exports.mapFacetsLightweight = mapFacetsLightweight;
function mapFacetsCached(facets, fn, equalityCheck) {
    if (facets.length === 1) {
        return (0, mapFacetSingleCached_1.mapFacetSingleCached)(facets[0], fn, equalityCheck);
    }
    else {
        return (0, mapFacetArrayCached_1.mapFacetArrayCached)(facets, fn, equalityCheck);
    }
}
exports.mapFacetsCached = mapFacetsCached;
//# sourceMappingURL=mapFacets.js.map

/***/ }),

/***/ 71794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapIntoObserveArray = void 0;
const scheduler_1 = __webpack_require__(82358);
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
function mapIntoObserveArray(facets, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
fn, equalityCheck) {
    return (listener) => {
        let currentValue = types_1.NO_VALUE;
        const checker = equalityCheck === null || equalityCheck === void 0 ? void 0 : equalityCheck();
        const dependencyValues = facets.map(() => types_1.NO_VALUE);
        let hasAllDependencies = false;
        const task = checker === undefined
            ? () => {
                hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value !== types_1.NO_VALUE);
                if (!hasAllDependencies)
                    return;
                const result = fn(...dependencyValues);
                if (result === types_1.NO_VALUE)
                    return;
                listener(result);
            }
            : equalityCheck === equalityChecks_1.defaultEqualityCheck
                ? () => {
                    hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value !== types_1.NO_VALUE);
                    if (!hasAllDependencies)
                        return;
                    const result = fn(...dependencyValues);
                    if (result === types_1.NO_VALUE)
                        return;
                    const typeofValue = typeof currentValue;
                    if ((typeofValue === 'number' ||
                        typeofValue === 'string' ||
                        typeofValue === 'boolean' ||
                        currentValue === null ||
                        currentValue === undefined) &&
                        currentValue === result) {
                        return;
                    }
                    currentValue = result;
                    listener(result);
                }
                : () => {
                    hasAllDependencies = hasAllDependencies || dependencyValues.every((value) => value !== types_1.NO_VALUE);
                    if (!hasAllDependencies)
                        return;
                    const result = fn(...dependencyValues);
                    if (result === types_1.NO_VALUE)
                        return;
                    if (checker(result))
                        return;
                    listener(result);
                };
        const subscriptions = facets.map((facet, index) => {
            return facet.observe((value) => {
                dependencyValues[index] = value;
                if (hasAllDependencies) {
                    (0, scheduler_1.scheduleTask)(task);
                }
                else {
                    task();
                }
            });
        });
        return () => {
            (0, scheduler_1.cancelScheduledTask)(task);
            subscriptions.forEach((unsubscribe) => unsubscribe());
        };
    };
}
exports.mapIntoObserveArray = mapIntoObserveArray;
//# sourceMappingURL=mapIntoObserveArray.js.map

/***/ }),

/***/ 78781:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapIntoObserveSingle = void 0;
const equalityChecks_1 = __webpack_require__(52868);
const types_1 = __webpack_require__(74093);
function mapIntoObserveSingle(facet, fn, equalityCheck) {
    // Most common scenario is not having any equality check
    if (equalityCheck === undefined) {
        return (listener) => {
            return facet.observe((value) => {
                const result = fn(value);
                if (result === types_1.NO_VALUE)
                    return;
                listener(result);
            });
        };
    }
    // Then we optimize for the second most common scenario of using the defaultEqualityCheck (by inline its implementation)
    if (equalityCheck === equalityChecks_1.defaultEqualityCheck) {
        return (listener) => {
            let currentValue = types_1.NO_VALUE;
            return facet.observe((value) => {
                const result = fn(value);
                if (result === types_1.NO_VALUE)
                    return;
                const typeofValue = typeof currentValue;
                if ((typeofValue === 'number' ||
                    typeofValue === 'string' ||
                    typeofValue === 'boolean' ||
                    currentValue === null ||
                    currentValue === undefined) &&
                    currentValue === result) {
                    return;
                }
                currentValue = result;
                listener(result);
            });
        };
    }
    // Finally we use the custom equality check
    return (listener) => {
        const checker = equalityCheck();
        return facet.observe((value) => {
            const result = fn(value);
            if (result === types_1.NO_VALUE)
                return;
            if (checker(result))
                return;
            listener(result);
        });
    };
}
exports.mapIntoObserveSingle = mapIntoObserveSingle;
//# sourceMappingURL=mapIntoObserveSingle.js.map

/***/ }),

/***/ 82358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.batch = exports.cancelScheduledTask = exports.scheduleTask = void 0;
let batchId = 0;
let taskQueue = [];
/**
 * Schedules a given task to be executed at the end of a current batch, or runs it immediately if no batch is active.
 * @param task
 */
const scheduleTask = (task) => {
    // Not currently within a batch, so we execute the task immediately.
    if (batchId === 0) {
        task();
        return;
    }
    // Only schedules a task once within this batch execution.
    if (!task.scheduled) {
        task.scheduled = true;
        taskQueue.push(task);
    }
};
exports.scheduleTask = scheduleTask;
/**
 * Cancels the scheduling of a previously scheduled task.
 * @param task
 */
const cancelScheduledTask = (task) => {
    // Mark a task as canceled instead of removing it.
    // Its reference might already have been taken while processing the tasks.
    task.scheduled = false;
};
exports.cancelScheduledTask = cancelScheduledTask;
/**
 * Starts a batch, scheduling Facet updates within the cb to be executed at the end of the batch.
 * @param b will be executed immediately to collect Facet changes
 */
const batch = (b) => {
    // Starts a batch
    batchId += 1;
    try {
        b();
        // If this is the root batch, we start executing the tasks
        if (batchId === 1) {
            do {
                // Starts a new queue, as we work through the current one
                const taskQueueCopy = taskQueue;
                taskQueue = [];
                try {
                    for (let index = 0; index < taskQueueCopy.length; index++) {
                        const task = taskQueueCopy[index];
                        if (task.scheduled) {
                            task.scheduled = false;
                            task();
                        }
                    }
                }
                catch (e) {
                    // If something goes wrong, we unschedule all remaining tasks
                    for (let index = 0; index < taskQueueCopy.length; index++) {
                        const task = taskQueueCopy[index];
                        task.scheduled = false;
                    }
                    taskQueue = [];
                    throw e;
                }
                // Exhaust all tasks
            } while (taskQueue.length > 0);
        }
    }
    finally {
        // Ends a batch
        batchId -= 1;
    }
};
exports.batch = batch;
//# sourceMappingURL=scheduler.js.map

/***/ }),

/***/ 74093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NO_VALUE = exports.isFacet = exports.FACET_FACTORY = void 0;
exports.FACET_FACTORY = Symbol('facet-factory');
const isFacet = (value) => {
    return (value !== null &&
        value !== undefined &&
        value.observe !== undefined &&
        value.get !== undefined);
};
exports.isFacet = isFacet;
exports.NO_VALUE = Symbol.for('NoValue');
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 1170:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PauseMountProvider = exports.ImmediateMount = exports.useIsPaused = exports.useIsDeferring = exports.DeferredMountWithCallback = exports.useNotifyMountComplete = exports.DeferredMount = exports.DeferredMountProvider = exports.InnerDeferredMountProvider = exports.DeferredMountConfigProvider = void 0;
const react_1 = __importStar(__webpack_require__(67294));
const core_1 = __webpack_require__(88572);
const DeferredMountConfig = (0, react_1.createContext)({ forceImmediateMount: false });
function DeferredMountConfigProvider({ config, children }) {
    return react_1.default.createElement(DeferredMountConfig.Provider, { value: config }, children);
}
exports.DeferredMountConfigProvider = DeferredMountConfigProvider;
function useConfig() {
    return (0, react_1.useContext)(DeferredMountConfig);
}
/**
 * Targeting around 60fps
 */
const DEFAULT_FRAME_TIME_BUDGET = 16;
function InnerDeferredMountProvider({ children, frameTimeBudget = DEFAULT_FRAME_TIME_BUDGET, }) {
    const [isDeferring, setIsDeferring] = (0, core_1.useFacetState)(true);
    const [requestingToRun, setRequestingToRun] = (0, core_1.useFacetState)(false);
    const waitingForMountCallback = (0, react_1.useRef)(false);
    const deferredMountsRef = (0, react_1.useRef)([]);
    const pushDeferUpdateFunction = (0, react_1.useCallback)((updateFn) => {
        // Causes a re-render of this component that will kick-off the effect below
        setRequestingToRun(true);
        deferredMountsRef.current.push(updateFn);
        /**
         * Cleanup function that makes sure that we don't try to "mount" a deferred component
         * if it has already been unmounted.
         */
        return () => {
            // It is most common that we will be cleaning up after all deferred mounting has been run
            if (deferredMountsRef.current.length === 0 && !waitingForMountCallback.current)
                return;
            const index = deferredMountsRef.current.indexOf(updateFn);
            if (index !== -1) {
                deferredMountsRef.current.splice(index, 1);
            }
        };
    }, [setRequestingToRun]);
    (0, core_1.useFacetEffect)((requestingToRun) => {
        // Even if we are not considered to be running, we need to check if there is still
        // work pending to be done. If there is... we still need to run this effect.
        if (!requestingToRun && deferredMountsRef.current.length === 0 && !waitingForMountCallback.current)
            return;
        const work = (startTimestamp) => {
            const deferredMounts = deferredMountsRef.current;
            // We need to request the new frame at the top
            // otherwise, the state change at the bottom will trigger a new render
            // before we have a chance to cancel
            // Its not possible to detect this with unit testing, so verify on the browser
            // after a change here that this function is not executing every frame unnecessarily
            if (deferredMounts.length > 0 || waitingForMountCallback.current) {
                frameId = window.requestAnimationFrame(work);
            }
            else {
                // Used to check if the requestAnimationFrame has stopped running
                frameId = -1;
            }
            let lastUpdateCost = 0;
            let now = startTimestamp;
            while (deferredMounts.length > 0 &&
                now - startTimestamp + lastUpdateCost < frameTimeBudget &&
                !waitingForMountCallback.current) {
                const before = now;
                const updateFn = deferredMounts.shift();
                const result = updateFn(false);
                const after = performance.now();
                lastUpdateCost = after - before;
                now = after;
                // Can be a function that takes a callback if using DeferredMountWithCallback
                const resultTakesCallback = typeof result === 'function';
                if (resultTakesCallback) {
                    waitingForMountCallback.current = true;
                    result(() => {
                        waitingForMountCallback.current = false;
                        // If the requestAnimationFrame stops running while waiting for the
                        // callback we need to restart it to process the rest of the queue.
                        if (frameId === -1) {
                            frameId = window.requestAnimationFrame(work);
                        }
                    });
                }
            }
            if (deferredMounts.length === 0 && !waitingForMountCallback.current) {
                setIsDeferring(false);
                setRequestingToRun(false);
            }
        };
        let frameId = window.requestAnimationFrame(work);
        return () => {
            window.cancelAnimationFrame(frameId);
        };
    }, [frameTimeBudget, setIsDeferring, setRequestingToRun], [requestingToRun]);
    return (react_1.default.createElement(isDeferringContext.Provider, { value: isDeferring },
        react_1.default.createElement(pushDeferUpdateContext.Provider, { value: pushDeferUpdateFunction }, children)));
}
exports.InnerDeferredMountProvider = InnerDeferredMountProvider;
/**
 * Provider that must wrap a tree with nodes being deferred
 */
function DeferredMountProvider(props) {
    const config = useConfig();
    if (config.forceImmediateMount) {
        return react_1.default.createElement(react_1.default.Fragment, null, props.children);
    }
    return react_1.default.createElement(InnerDeferredMountProvider, Object.assign({}, props));
}
exports.DeferredMountProvider = DeferredMountProvider;
/**
 * Component that should wrap some mounting that must be deferred to a later frame
 * @param children component to be mounted deferred
 */
function DeferredMount({ children }) {
    const pushDeferUpdateFunction = (0, react_1.useContext)(pushDeferUpdateContext);
    const [deferred, setDeferred] = (0, react_1.useState)(pushDeferUpdateFunction !== undefined);
    (0, react_1.useEffect)(() => {
        if (pushDeferUpdateFunction)
            pushDeferUpdateFunction(setDeferred);
    }, [pushDeferUpdateFunction]);
    if (deferred)
        return null;
    return children;
}
exports.DeferredMount = DeferredMount;
const NotifyMountComplete = (0, react_1.createContext)(() => { });
const useNotifyMountComplete = () => (0, react_1.useContext)(NotifyMountComplete);
exports.useNotifyMountComplete = useNotifyMountComplete;
/**
 * Component that should wrap some mounting that must be deferred to a later frame.
 * This will wait for a callback from the child component before marking itself as rendered.
 * @param children component to be mounted deferred
 */
function DeferredMountWithCallback({ children }) {
    const pushDeferUpdateFunction = (0, react_1.useContext)(pushDeferUpdateContext);
    const [deferred, setDeferred] = (0, react_1.useState)(pushDeferUpdateFunction !== undefined);
    const resolveMountComplete = (0, react_1.useRef)();
    const mountCompleteBeforeInitialization = (0, react_1.useRef)(false);
    const onMountComplete = (0, react_1.useCallback)(() => {
        if (resolveMountComplete.current !== undefined) {
            resolveMountComplete.current();
        }
        else {
            mountCompleteBeforeInitialization.current = true;
        }
    }, []);
    (0, react_1.useEffect)(() => {
        if (pushDeferUpdateFunction)
            pushDeferUpdateFunction((isDeferred) => {
                return (resolve) => {
                    setDeferred(isDeferred);
                    if (mountCompleteBeforeInitialization.current) {
                        resolve();
                    }
                    else {
                        resolveMountComplete.current = resolve;
                    }
                };
            });
    }, [pushDeferUpdateFunction, onMountComplete]);
    if (deferred)
        return null;
    return react_1.default.createElement(NotifyMountComplete.Provider, { value: onMountComplete }, children);
}
exports.DeferredMountWithCallback = DeferredMountWithCallback;
/**
 * Hook that informs if any mounting is currently being deferred
 * Can be used to show some loading indicator
 */
function useIsDeferring() {
    return (0, react_1.useContext)(isDeferringContext);
}
exports.useIsDeferring = useIsDeferring;
/**
 * Allow us to pause costly mounting (mounting) of components
 * So that transitions can occur
 */
function useIsPaused() {
    return (0, react_1.useContext)(isPausedContext);
}
exports.useIsPaused = useIsPaused;
/**
 * API compatible component with DeferredMount, but renders immediately
 */
function ImmediateMount({ children }) {
    return children;
}
exports.ImmediateMount = ImmediateMount;
const pushDeferUpdateContext = (0, react_1.createContext)(undefined);
const isDeferringContext = (0, react_1.createContext)((0, core_1.createFacet)({ initialValue: false }));
const isPausedContext = (0, react_1.createContext)(false);
/**
 * This pauses the mounting of children components.
 * Given it affects mounting, it should only happen the first time! Asking to pause again in the future is not possible
 */
function PauseMountProvider({ paused, children }) {
    const wasEverResumed = (0, react_1.useRef)(!paused);
    (0, react_1.useEffect)(() => {
        if (!paused) {
            wasEverResumed.current = true;
        }
    }, [paused]);
    return react_1.default.createElement(isPausedContext.Provider, { value: wasEverResumed.current ? false : paused }, children);
}
exports.PauseMountProvider = PauseMountProvider;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36982:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFiberRoot = void 0;
/**
 * @private consider using render instead
 */
const createFiberRoot = (reconciler) => (container) => reconciler.createContainer({
    children: new Set(),
    element: container,
    styleUnsubscribers: new Map(),
    style: container.style,
}, false, false);
exports.createFiberRoot = createFiberRoot;
//# sourceMappingURL=createFiberRoot.js.map

/***/ }),

/***/ 70024:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPortal = void 0;
// Extracted from React's codebase
const REACT_PORTAL_TYPE = Symbol.for('react.portal');
/**
 * Creates a React Portal.
 * More info: https://reactjs.org/docs/portals.html
 */
function createPortal(children, container, key) {
    return {
        $$typeof: REACT_PORTAL_TYPE,
        key,
        children,
        containerInfo: {
            children: new Set(),
            element: container,
            styleUnsubscribers: new Map(),
            style: container.style,
        },
    };
}
exports.createPortal = createPortal;
//# sourceMappingURL=createPortal.js.map

/***/ }),

/***/ 47811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReconciler = void 0;
const react_reconciler_1 = __importDefault(__webpack_require__(76525));
const setupHostConfig_1 = __webpack_require__(8446);
/**
 * @private consider using render instead
 */
const createReconciler = () => (0, react_reconciler_1.default)((0, setupHostConfig_1.setupHostConfig)());
exports.createReconciler = createReconciler;
//# sourceMappingURL=createReconciler.js.map

/***/ }),

/***/ 47154:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.render = void 0;
const createFiberRoot_1 = __webpack_require__(36982);
const createReconciler_1 = __webpack_require__(47811);
__exportStar(__webpack_require__(7358), exports);
__exportStar(__webpack_require__(70024), exports);
__exportStar(__webpack_require__(36982), exports);
__exportStar(__webpack_require__(47811), exports);
/**
 * Render the Facets as the root renderer
 */
function render(element, container) {
    if (container === null)
        return () => { };
    const reconcilerInstance = (0, createReconciler_1.createReconciler)();
    const fiberRoot = (0, createFiberRoot_1.createFiberRoot)(reconcilerInstance)(container);
    reconcilerInstance.updateContainer(element, fiberRoot, null, () => { });
    if (false) {}
    return () => {
        reconcilerInstance.updateContainer(null, fiberRoot, null, () => { });
    };
}
exports.render = render;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 92786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupAttributeUpdate = exports.setupViewBoxUpdate = exports.setupTextUpdate = exports.setupSrcUpdate = exports.setupValueUpdate = exports.setupRowsUpdate = exports.setupMaxLengthUpdate = exports.setupIdUpdate = exports.setupClassUpdate = void 0;
const core_1 = __webpack_require__(88572);
const setupClassUpdate = (className, element) => {
    const htmlElement = element;
    if ((0, core_1.isFacet)(className)) {
        return className.observe((className) => {
            htmlElement.className = className !== undefined ? className : '';
        });
    }
    else {
        htmlElement.className = className !== undefined ? className : '';
    }
};
exports.setupClassUpdate = setupClassUpdate;
const setupIdUpdate = (id, element) => {
    if ((0, core_1.isFacet)(id)) {
        return id.observe((id) => {
            element.id = id !== undefined ? id : '';
        });
    }
    else {
        element.id = id !== undefined ? id : '';
    }
};
exports.setupIdUpdate = setupIdUpdate;
const setupMaxLengthUpdate = (maxLength, element) => {
    if ((0, core_1.isFacet)(maxLength)) {
        return maxLength.observe((maxLength) => {
            const textElement = element;
            textElement.maxLength = maxLength !== undefined ? maxLength : Number.MAX_SAFE_INTEGER;
        });
    }
    else {
        const textElement = element;
        textElement.maxLength = maxLength !== undefined ? maxLength : Number.MAX_SAFE_INTEGER;
    }
};
exports.setupMaxLengthUpdate = setupMaxLengthUpdate;
const setupRowsUpdate = (rows, element) => {
    if ((0, core_1.isFacet)(rows)) {
        return rows.observe((rows) => {
            const textElement = element;
            textElement.rows = rows !== undefined ? rows : Number.MAX_SAFE_INTEGER;
        });
    }
    else {
        const textElement = element;
        textElement.rows = rows !== undefined ? rows : Number.MAX_SAFE_INTEGER;
    }
};
exports.setupRowsUpdate = setupRowsUpdate;
/**
 * The value attribute seems to behave differently to other
 * attributes. When using `setAttribute`, browsers and gameface
 * don't always update the element to have what's in the value,
 * so we need to set the `value` attribute directly to solve this.
 * ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMInput.js
 */
const updateValue = (element, value) => {
    const inputElement = element;
    // Only accept numerical characters if the input type is number
    if (inputElement.type === 'number' && isNaN(Number(value)))
        return;
    if (value !== undefined) {
        inputElement.value = value;
        inputElement.setAttribute('value', value);
    }
    else {
        inputElement.value = '';
        inputElement.removeAttribute('value');
    }
};
const setupValueUpdate = (value, element) => {
    if ((0, core_1.isFacet)(value)) {
        return value.observe((value) => updateValue(element, value));
    }
    else {
        updateValue(element, value);
    }
};
exports.setupValueUpdate = setupValueUpdate;
const setupSrcUpdate = (src, element) => {
    if ((0, core_1.isFacet)(src)) {
        return src.observe((src) => {
            const textElement = element;
            textElement.src = src !== undefined ? src : '';
        });
    }
    else {
        const textElement = element;
        textElement.src = src !== undefined ? src : '';
    }
};
exports.setupSrcUpdate = setupSrcUpdate;
const setupTextUpdate = (text, element) => {
    if ((0, core_1.isFacet)(text)) {
        return text.observe((text) => {
            const textElement = element;
            textElement.nodeValue = (text !== undefined ? text : '');
        });
    }
    else {
        const textElement = element;
        textElement.nodeValue = (text !== undefined ? text : '');
    }
};
exports.setupTextUpdate = setupTextUpdate;
/**
 * removeAttribute and setAttribute automatically convert the attribute name to lower case.
 * The DOM attribute viewBox is camel cased so setAttributeNS and removeAttributeNS are used
 */
const setupViewBoxUpdate = (viewBox, element) => {
    if ((0, core_1.isFacet)(viewBox)) {
        return viewBox.observe((value) => {
            if (value !== undefined) {
                element.setAttributeNS(null, 'viewBox', value);
            }
            else {
                element.removeAttributeNS(null, 'viewBox');
            }
        });
    }
    else {
        if (viewBox !== undefined) {
            element.setAttributeNS(null, 'viewBox', viewBox);
        }
        else {
            element.removeAttributeNS(null, 'viewBox');
        }
    }
};
exports.setupViewBoxUpdate = setupViewBoxUpdate;
const setupAttributeUpdate = (attribute, value, element) => {
    if ((0, core_1.isFacet)(value)) {
        return value.observe((value) => {
            if (value === true) {
                element.setAttribute(attribute, '');
            }
            else if (value === false) {
                element.removeAttribute(attribute);
            }
            else if (value !== undefined) {
                element.setAttribute(attribute, value);
            }
            else {
                element.removeAttribute(attribute);
            }
        });
    }
    else {
        if (value === true) {
            element.setAttribute(attribute, '');
        }
        else if (value === false) {
            element.removeAttribute(attribute);
        }
        else if (value !== undefined) {
            element.setAttribute(attribute, value);
        }
        else {
            element.removeAttribute(attribute);
        }
    }
};
exports.setupAttributeUpdate = setupAttributeUpdate;
//# sourceMappingURL=setupAttributes.js.map

/***/ }),

/***/ 8446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupHostConfig = void 0;
const types_1 = __webpack_require__(7358);
const core_1 = __webpack_require__(88572);
const setupAttributes_1 = __webpack_require__(92786);
/**
 * Custom React Renderer with support for Facets
 *
 * Based on https://blog.atulr.com/react-custom-renderer-1/
 * For more information check the official docs: https://github.com/facebook/react/tree/main/packages/react-reconciler
 */
const setupHostConfig = () => ({
    isPrimaryRenderer: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    now: Date.now,
    /**
     * We need to support setting up the host config in an environment where window is not available globally yet
     * Ex: screenshot testing
     */
    setTimeout: typeof window !== 'undefined'
        ? window.setTimeout
        : (handler, timeout) => window.setTimeout(handler, timeout),
    /**
     * We need to support setting up the host config in an environment where window is not available globally yet
     * Ex: screenshot testing
     */
    clearTimeout: typeof window !== 'undefined' ? window.clearTimeout : (id) => window.clearTimeout(id),
    noTimeout: noop,
    scheduleDeferredCallback: function (callback, options) {
        return window.setTimeout(callback, options ? options.timeout : 0);
    },
    cancelDeferredCallback: function (id) {
        return window.clearTimeout(id);
    },
    getRootHostContext: function () {
        return EMPTY;
    },
    getChildHostContext: function () {
        return EMPTY;
    },
    shouldSetTextContent: function () {
        return false;
    },
    createTextInstance: function (newText) {
        return {
            element: document.createTextNode(newText),
        };
    },
    createInstance: function (externalType, newProps) {
        var _a;
        if (externalType === 'fast-text') {
            const element = document.createTextNode('');
            return {
                children: new Set(),
                element,
                text: (0, setupAttributes_1.setupTextUpdate)(newProps.text, element),
            };
        }
        const typeHTML = (_a = fastTypeMapHTML[externalType]) !== null && _a !== void 0 ? _a : externalType;
        const typeSVG = fastTypeMapSVG[externalType];
        const element = typeSVG !== undefined
            ? document.createElementNS('http://www.w3.org/2000/svg', typeSVG)
            : document.createElement(typeHTML);
        let style;
        let styleUnsubscribers;
        if (newProps.style !== undefined) {
            style = element.style;
            styleUnsubscribers = new Map();
            // We know for sure here that style will never be null (we created it above)
            const notNullStyle = style;
            const notNullStyleUnsubscribers = styleUnsubscribers;
            const styleProp = newProps.style;
            for (const key in styleProp) {
                const value = styleProp[key];
                if (value !== undefined) {
                    if ((0, core_1.isFacet)(value)) {
                        notNullStyleUnsubscribers.set(key, value.observe((value) => {
                            notNullStyle[key] = value;
                        }));
                    }
                    else {
                        notNullStyle[key] = value;
                    }
                }
            }
        }
        if (newProps.dangerouslySetInnerHTML !== undefined) {
            element.innerHTML = newProps.dangerouslySetInnerHTML.__html;
        }
        if (newProps.onClick) {
            element.addEventListener('click', newProps.onClick);
        }
        if (newProps.onFocus) {
            element.addEventListener('focus', newProps.onFocus);
        }
        if (newProps.onBlur) {
            element.addEventListener('blur', newProps.onBlur);
        }
        if (newProps.onMouseDown) {
            element.addEventListener('mousedown', newProps.onMouseDown);
        }
        if (newProps.onMouseMove) {
            element.addEventListener('mousemove', newProps.onMouseMove);
        }
        if (newProps.onMouseUp) {
            element.addEventListener('mouseup', newProps.onMouseUp);
        }
        if (newProps.onTouchStart) {
            element.addEventListener('touchstart', newProps.onTouchStart);
        }
        if (newProps.onTouchMove) {
            element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd) {
            element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onMouseEnter) {
            element.addEventListener('mouseenter', newProps.onMouseEnter);
        }
        if (newProps.onMouseLeave) {
            element.addEventListener('mouseleave', newProps.onMouseLeave);
        }
        if (newProps.onKeyPress) {
            element.addEventListener('keypress', newProps.onKeyPress);
        }
        if (newProps.onKeyDown) {
            element.addEventListener('keydown', newProps.onKeyDown);
        }
        if (newProps.onKeyUp) {
            element.addEventListener('keyup', newProps.onKeyUp);
        }
        return {
            element,
            styleUnsubscribers,
            style,
            children: new Set(),
            className: newProps.className !== undefined ? (0, setupAttributes_1.setupClassUpdate)(newProps.className, element) : undefined,
            id: newProps.id !== undefined ? (0, setupAttributes_1.setupIdUpdate)(newProps.id, element) : undefined,
            autoPlay: newProps.autoPlay !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('autoplay', newProps.autoPlay, element) : undefined,
            loop: newProps.loop !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('loop', newProps.loop, element) : undefined,
            href: newProps.href !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('href', newProps.href, element) : undefined,
            target: newProps.target !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('target', newProps.target, element) : undefined,
            disabled: newProps.disabled !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('disabled', newProps.disabled, element) : undefined,
            maxLength: newProps.maxLength !== undefined ? (0, setupAttributes_1.setupMaxLengthUpdate)(newProps.maxLength, element) : undefined,
            rows: newProps.rows !== undefined ? (0, setupAttributes_1.setupRowsUpdate)(newProps.rows, element) : undefined,
            type: newProps.type !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('type', newProps.type, element) : undefined,
            value: newProps.value !== undefined ? (0, setupAttributes_1.setupValueUpdate)(newProps.value, element) : undefined,
            src: newProps.src !== undefined ? (0, setupAttributes_1.setupSrcUpdate)(newProps.src, element) : undefined,
            d: newProps.d !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('d', newProps.d, element) : undefined,
            fill: newProps.fill !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('fill', newProps.fill, element) : undefined,
            height: newProps.height !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('height', newProps.height, element) : undefined,
            stroke: newProps.stroke !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('stroke', newProps.stroke, element) : undefined,
            x: newProps.x !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('x', newProps.x, element) : undefined,
            width: newProps.width !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('width', newProps.width, element) : undefined,
            y: newProps.y !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('y', newProps.y, element) : undefined,
            cx: newProps.cx !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('cx', newProps.cx, element) : undefined,
            cy: newProps.cy !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('cy', newProps.cy, element) : undefined,
            r: newProps.r !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('r', newProps.r, element) : undefined,
            rx: newProps.rx !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('rx', newProps.rx, element) : undefined,
            ry: newProps.ry !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('ry', newProps.ry, element) : undefined,
            x1: newProps.x1 !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('x1', newProps.x1, element) : undefined,
            x2: newProps.x2 !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('x2', newProps.x2, element) : undefined,
            y1: newProps.y1 !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('y1', newProps.y1, element) : undefined,
            y2: newProps.y2 !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('y2', newProps.y2, element) : undefined,
            strokeWidth: newProps.strokeWidth !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-width', newProps.strokeWidth, element)
                : undefined,
            viewBox: newProps.viewBox !== undefined ? (0, setupAttributes_1.setupViewBoxUpdate)(newProps.viewBox, element) : undefined,
            xLinkHref: newProps.xLinkHref !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('xlink:href', newProps.xLinkHref, element) : undefined,
            fillOpacity: newProps.fillOpacity !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('fill-opacity', newProps.fillOpacity, element)
                : undefined,
            strokeOpacity: newProps.strokeOpacity !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-opacity', newProps.strokeOpacity, element)
                : undefined,
            strokeLinecap: newProps.strokeLinecap !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-linecap', newProps.strokeLinecap, element)
                : undefined,
            strokeLinejoin: newProps.strokeLinejoin !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('stroke-linejoin', newProps.strokeLinejoin, element)
                : undefined,
            points: newProps.points !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('points', newProps.points, element) : undefined,
            offset: newProps.offset !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('offset', newProps.offset, element) : undefined,
            stopColor: newProps.stopColor !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('stop-color', newProps.stopColor, element) : undefined,
            stopOpacity: newProps.stopOpacity !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('stop-opacity', newProps.stopOpacity, element)
                : undefined,
            fontFamily: newProps.fontFamily !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('font-family', newProps.fontFamily, element)
                : undefined,
            fontSize: newProps.fontSize !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('font-size', newProps.fontSize, element) : undefined,
            ['data-droppable']: newProps['data-droppable'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-droppable', newProps['data-droppable'], element)
                : undefined,
            ['data-narrate']: newProps['data-narrate'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate', newProps['data-narrate'], element)
                : undefined,
            ['data-narrate-as']: newProps['data-narrate-as'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-as', newProps['data-narrate-as'], element)
                : undefined,
            ['data-narrate-before']: newProps['data-narrate-before'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-before', newProps['data-narrate-before'], element)
                : undefined,
            ['data-narrate-after']: newProps['data-narrate-after'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-after', newProps['data-narrate-after'], element)
                : undefined,
            ['data-testid']: newProps['data-testid'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-testid', newProps['data-testid'], element)
                : undefined,
            ['data-x-ray']: newProps['data-x-ray'] !== undefined
                ? (0, setupAttributes_1.setupAttributeUpdate)('data-x-ray', newProps['data-x-ray'], element)
                : undefined,
            cohinline: newProps.cohinline !== undefined ? (0, setupAttributes_1.setupAttributeUpdate)('cohinline', newProps.cohinline, element) : undefined,
        };
    },
    finalizeInitialChildren: function () {
        return false;
    },
    prepareForCommit: function () { },
    resetAfterCommit: function () { },
    commitMount: function () { },
    prepareUpdate: function () {
        return true;
    },
    commitUpdate: function (instance, updatePayload, type, oldProps, newProps) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26;
        const { element: uncastElement } = instance;
        if (type === 'fast-text') {
            const textElement = uncastElement;
            if (newProps.text !== oldProps.text) {
                (_a = instance.text) === null || _a === void 0 ? void 0 : _a.call(instance);
                instance.text = (0, setupAttributes_1.setupTextUpdate)(newProps.text, textElement);
            }
            return;
        }
        const element = uncastElement;
        if (newProps.style !== oldProps.style) {
            const style = instance.style || element.style;
            const styleUnsubscribers = instance.styleUnsubscribers || new Map();
            instance.style = style;
            instance.styleUnsubscribers = styleUnsubscribers;
            const notNullStyle = style;
            const oldStyleProp = oldProps.style;
            const newStyleProp = newProps.style;
            if (oldStyleProp !== undefined) {
                for (const key in oldStyleProp) {
                    const oldValue = oldStyleProp[key];
                    const newValue = newStyleProp === null || newStyleProp === void 0 ? void 0 : newStyleProp[key];
                    if (oldValue !== newValue || newStyleProp === undefined) {
                        if ((0, core_1.isFacet)(oldValue)) {
                            (_b = styleUnsubscribers.get(key)) === null || _b === void 0 ? void 0 : _b();
                        }
                    }
                }
            }
            if (newStyleProp !== undefined) {
                for (const key in newStyleProp) {
                    const oldValue = oldStyleProp === null || oldStyleProp === void 0 ? void 0 : oldStyleProp[key];
                    const newValue = newStyleProp[key];
                    if (oldValue !== newValue || oldStyleProp === undefined) {
                        if ((0, core_1.isFacet)(newValue)) {
                            styleUnsubscribers.set(key, newValue.observe((value) => {
                                notNullStyle[key] = value;
                            }));
                        }
                        else {
                            notNullStyle[key] = newValue;
                        }
                    }
                }
            }
        }
        if (newProps.dangerouslySetInnerHTML !== oldProps.dangerouslySetInnerHTML) {
            if (newProps.dangerouslySetInnerHTML !== undefined) {
                element.innerHTML = newProps.dangerouslySetInnerHTML.__html;
            }
            else {
                element.innerHTML = '';
            }
        }
        if (newProps.autoPlay !== oldProps.autoPlay) {
            (_c = instance.autoPlay) === null || _c === void 0 ? void 0 : _c.call(instance);
            if (newProps.autoPlay === undefined) {
                element.removeAttribute('autoplay');
            }
            else {
                instance.autoPlay = (0, setupAttributes_1.setupAttributeUpdate)('autoplay', newProps.autoPlay, element);
            }
        }
        if (newProps.className !== oldProps.className) {
            (_d = instance.className) === null || _d === void 0 ? void 0 : _d.call(instance);
            if (newProps.className === undefined) {
                element.className = '';
            }
            else {
                instance.className = (0, setupAttributes_1.setupClassUpdate)(newProps.className, element);
            }
        }
        if (newProps.d !== oldProps.d) {
            (_e = instance.d) === null || _e === void 0 ? void 0 : _e.call(instance);
            if (newProps.d === undefined) {
                element.removeAttribute('d');
            }
            else {
                instance.d = (0, setupAttributes_1.setupAttributeUpdate)('d', newProps.d, element);
            }
        }
        if (newProps['data-droppable'] !== oldProps['data-droppable']) {
            (_f = instance['data-droppable']) === null || _f === void 0 ? void 0 : _f.call(instance);
            if (newProps['data-droppable'] === undefined) {
                element.removeAttribute('data-droppable');
            }
            else {
                instance['data-droppable'] = (0, setupAttributes_1.setupAttributeUpdate)('data-droppable', newProps['data-droppable'], element);
            }
        }
        if (newProps['data-narrate'] !== oldProps['data-narrate']) {
            (_g = instance['data-narrate']) === null || _g === void 0 ? void 0 : _g.call(instance);
            if (newProps['data-narrate'] === undefined) {
                element.removeAttribute('data-narrate');
            }
            else {
                instance['data-narrate'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate', newProps['data-narrate'], element);
            }
        }
        if (newProps['data-narrate-as'] !== oldProps['data-narrate-as']) {
            (_h = instance['data-narrate-as']) === null || _h === void 0 ? void 0 : _h.call(instance);
            if (newProps['data-narrate-as'] === undefined) {
                element.removeAttribute('data-narrate-as');
            }
            else {
                instance['data-narrate-as'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-as', newProps['data-narrate-as'], element);
            }
        }
        if (newProps['data-narrate-after'] !== oldProps['data-narrate-after']) {
            (_j = instance['data-narrate-after']) === null || _j === void 0 ? void 0 : _j.call(instance);
            if (newProps['data-narrate-after'] === undefined) {
                element.removeAttribute('data-narrate-after');
            }
            else {
                instance['data-narrate-after'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-after', newProps['data-narrate-after'], element);
            }
        }
        if (newProps['data-narrate-before'] !== oldProps['data-narrate-before']) {
            (_k = instance['data-narrate-before']) === null || _k === void 0 ? void 0 : _k.call(instance);
            if (newProps['data-narrate-before'] === undefined) {
                element.removeAttribute('data-narrate-before');
            }
            else {
                instance['data-narrate-before'] = (0, setupAttributes_1.setupAttributeUpdate)('data-narrate-before', newProps['data-narrate-before'], element);
            }
        }
        if (newProps['data-testid'] !== oldProps['data-testid']) {
            (_l = instance['data-testid']) === null || _l === void 0 ? void 0 : _l.call(instance);
            if (newProps['data-testid'] === undefined) {
                element.removeAttribute('data-testid');
            }
            else {
                instance['data-testid'] = (0, setupAttributes_1.setupAttributeUpdate)('data-testid', newProps['data-testid'], element);
            }
        }
        if (newProps['data-x-ray'] !== oldProps['data-x-ray']) {
            (_m = instance['data-x-ray']) === null || _m === void 0 ? void 0 : _m.call(instance);
            if (newProps['data-x-ray'] === undefined) {
                element.removeAttribute('data-x-ray');
            }
            else {
                instance['data-x-ray'] = (0, setupAttributes_1.setupAttributeUpdate)('data-x-ray', newProps['data-x-ray'], element);
            }
        }
        if (newProps.fill !== oldProps.fill) {
            (_o = instance.fill) === null || _o === void 0 ? void 0 : _o.call(instance);
            if (newProps.fill === undefined) {
                element.removeAttribute('fill');
            }
            else {
                instance.fill = (0, setupAttributes_1.setupAttributeUpdate)('fill', newProps.fill, element);
            }
        }
        if (newProps.id !== oldProps.id) {
            (_p = instance.id) === null || _p === void 0 ? void 0 : _p.call(instance);
            if (newProps.id === undefined) {
                element.id = '';
            }
            else {
                instance.id = (0, setupAttributes_1.setupIdUpdate)(newProps.id, element);
            }
        }
        if (newProps.loop !== oldProps.loop) {
            (_q = instance.loop) === null || _q === void 0 ? void 0 : _q.call(instance);
            if (newProps.loop === undefined) {
                element.removeAttribute('loop');
            }
            else {
                instance.loop = (0, setupAttributes_1.setupAttributeUpdate)('loop', newProps.loop, element);
            }
        }
        if (newProps.href !== oldProps.href) {
            (_r = instance.href) === null || _r === void 0 ? void 0 : _r.call(instance);
            if (newProps.href === undefined) {
                element.removeAttribute('href');
            }
            else {
                instance.href = (0, setupAttributes_1.setupAttributeUpdate)('href', newProps.href, element);
            }
        }
        if (newProps.target !== oldProps.target) {
            (_s = instance.target) === null || _s === void 0 ? void 0 : _s.call(instance);
            if (newProps.target === undefined) {
                element.removeAttribute('target');
            }
            else {
                instance.target = (0, setupAttributes_1.setupAttributeUpdate)('target', newProps.target, element);
            }
        }
        if (newProps.disabled !== oldProps.disabled) {
            (_t = instance.disabled) === null || _t === void 0 ? void 0 : _t.call(instance);
            if (newProps.disabled === undefined) {
                element.removeAttribute('disabled');
            }
            else {
                instance.disabled = (0, setupAttributes_1.setupAttributeUpdate)('disabled', newProps.disabled, element);
            }
        }
        if (newProps.height !== oldProps.height) {
            (_u = instance.height) === null || _u === void 0 ? void 0 : _u.call(instance);
            if (newProps.height === undefined) {
                element.removeAttribute('height');
            }
            else {
                instance.height = (0, setupAttributes_1.setupAttributeUpdate)('height', newProps.height, element);
            }
        }
        if (newProps.maxLength !== oldProps.maxLength) {
            (_v = instance.maxLength) === null || _v === void 0 ? void 0 : _v.call(instance);
            if (newProps.maxLength === undefined) {
                const textElement = element;
                textElement.removeAttribute('maxlength');
            }
            else {
                instance.maxLength = (0, setupAttributes_1.setupMaxLengthUpdate)(newProps.maxLength, element);
            }
        }
        if (newProps.rows !== oldProps.rows) {
            (_w = instance.rows) === null || _w === void 0 ? void 0 : _w.call(instance);
            if (newProps.rows === undefined) {
                const textElement = element;
                textElement.removeAttribute('rows');
            }
            else {
                instance.rows = (0, setupAttributes_1.setupRowsUpdate)(newProps.rows, element);
            }
        }
        if (newProps.stroke !== oldProps.stroke) {
            (_x = instance.stroke) === null || _x === void 0 ? void 0 : _x.call(instance);
            if (newProps.stroke === undefined) {
                element.removeAttribute('stroke');
            }
            else {
                instance.stroke = (0, setupAttributes_1.setupAttributeUpdate)('stroke', newProps.stroke, element);
            }
        }
        if (newProps.type !== oldProps.type) {
            (_y = instance.type) === null || _y === void 0 ? void 0 : _y.call(instance);
            if (newProps.type === undefined) {
                const textElement = element;
                textElement.removeAttribute('type');
            }
            else {
                instance.type = (0, setupAttributes_1.setupAttributeUpdate)('type', newProps.type, element);
            }
        }
        if (newProps.value !== oldProps.value) {
            (_z = instance.value) === null || _z === void 0 ? void 0 : _z.call(instance);
            if (newProps.value === undefined) {
                const textElement = element;
                textElement.removeAttribute('value');
            }
            else {
                instance.value = (0, setupAttributes_1.setupValueUpdate)(newProps.value, element);
            }
        }
        if (newProps.x !== oldProps.x) {
            (_0 = instance.x) === null || _0 === void 0 ? void 0 : _0.call(instance);
            if (newProps.x === undefined) {
                element.removeAttribute('x');
            }
            else {
                instance.x = (0, setupAttributes_1.setupAttributeUpdate)('x', newProps.x, element);
            }
        }
        if (newProps.width !== oldProps.width) {
            (_1 = instance.width) === null || _1 === void 0 ? void 0 : _1.call(instance);
            if (newProps.width === undefined) {
                element.removeAttribute('width');
            }
            else {
                instance.width = (0, setupAttributes_1.setupAttributeUpdate)('width', newProps.width, element);
            }
        }
        if (newProps.y !== oldProps.y) {
            (_2 = instance.y) === null || _2 === void 0 ? void 0 : _2.call(instance);
            if (newProps.y === undefined) {
                element.removeAttribute('y');
            }
            else {
                instance.y = (0, setupAttributes_1.setupAttributeUpdate)('y', newProps.y, element);
            }
        }
        if (newProps.cx !== oldProps.cx) {
            (_3 = instance.cx) === null || _3 === void 0 ? void 0 : _3.call(instance);
            if (newProps.cx === undefined) {
                element.removeAttribute('cx');
            }
            else {
                instance.cx = (0, setupAttributes_1.setupAttributeUpdate)('cx', newProps.cx, element);
            }
        }
        if (newProps.r !== oldProps.r) {
            (_4 = instance.r) === null || _4 === void 0 ? void 0 : _4.call(instance);
            if (newProps.r === undefined) {
                element.removeAttribute('r');
            }
            else {
                instance.r = (0, setupAttributes_1.setupAttributeUpdate)('r', newProps.r, element);
            }
        }
        if (newProps.cy !== oldProps.cy) {
            (_5 = instance.cy) === null || _5 === void 0 ? void 0 : _5.call(instance);
            if (newProps.cy === undefined) {
                element.removeAttribute('cy');
            }
            else {
                instance.cy = (0, setupAttributes_1.setupAttributeUpdate)('cy', newProps.cy, element);
            }
        }
        if (newProps.rx !== oldProps.rx) {
            (_6 = instance.rx) === null || _6 === void 0 ? void 0 : _6.call(instance);
            if (newProps.rx === undefined) {
                element.removeAttribute('rx');
            }
            else {
                instance.rx = (0, setupAttributes_1.setupAttributeUpdate)('rx', newProps.rx, element);
            }
        }
        if (newProps.ry !== oldProps.ry) {
            (_7 = instance.ry) === null || _7 === void 0 ? void 0 : _7.call(instance);
            if (newProps.ry === undefined) {
                element.removeAttribute('ry');
            }
            else {
                instance.ry = (0, setupAttributes_1.setupAttributeUpdate)('ry', newProps.ry, element);
            }
        }
        if (newProps.x1 !== oldProps.x1) {
            (_8 = instance.x1) === null || _8 === void 0 ? void 0 : _8.call(instance);
            if (newProps.x1 === undefined) {
                element.removeAttribute('x1');
            }
            else {
                instance.x1 = (0, setupAttributes_1.setupAttributeUpdate)('x1', newProps.x1, element);
            }
        }
        if (newProps.x2 !== oldProps.x2) {
            (_9 = instance.x2) === null || _9 === void 0 ? void 0 : _9.call(instance);
            if (newProps.x2 === undefined) {
                element.removeAttribute('x2');
            }
            else {
                instance.x2 = (0, setupAttributes_1.setupAttributeUpdate)('x2', newProps.x2, element);
            }
        }
        if (newProps.y1 !== oldProps.y1) {
            (_10 = instance.y1) === null || _10 === void 0 ? void 0 : _10.call(instance);
            if (newProps.y1 === undefined) {
                element.removeAttribute('y1');
            }
            else {
                instance.y1 = (0, setupAttributes_1.setupAttributeUpdate)('y1', newProps.y1, element);
            }
        }
        if (newProps.y2 !== oldProps.y2) {
            (_11 = instance.y2) === null || _11 === void 0 ? void 0 : _11.call(instance);
            if (newProps.y2 === undefined) {
                element.removeAttribute('y2');
            }
            else {
                instance.y2 = (0, setupAttributes_1.setupAttributeUpdate)('y2', newProps.y2, element);
            }
        }
        if (newProps.strokeWidth !== oldProps.strokeWidth) {
            (_12 = instance.strokeWidth) === null || _12 === void 0 ? void 0 : _12.call(instance);
            if (newProps.strokeWidth === undefined) {
                element.removeAttribute('strokeWidth');
            }
            else {
                instance.strokeWidth = (0, setupAttributes_1.setupAttributeUpdate)('stroke-width', newProps.strokeWidth, element);
            }
        }
        if (newProps.viewBox !== oldProps.viewBox) {
            (_13 = instance.viewBox) === null || _13 === void 0 ? void 0 : _13.call(instance);
            if (newProps.viewBox === undefined) {
                element.removeAttribute('viewBox');
            }
            else {
                instance.viewBox = (0, setupAttributes_1.setupViewBoxUpdate)(newProps.viewBox, element);
            }
        }
        if (newProps.xLinkHref !== oldProps.xLinkHref) {
            (_14 = instance.xLinkHref) === null || _14 === void 0 ? void 0 : _14.call(instance);
            if (newProps.xLinkHref === undefined) {
                element.removeAttribute('xlink:href');
            }
            else {
                instance.xLinkHref = (0, setupAttributes_1.setupAttributeUpdate)('xlink:href', newProps.xLinkHref, element);
            }
        }
        if (newProps.fillOpacity !== oldProps.fillOpacity) {
            (_15 = instance.fillOpacity) === null || _15 === void 0 ? void 0 : _15.call(instance);
            if (newProps.fillOpacity === undefined) {
                element.removeAttribute('fill-opacity');
            }
            else {
                instance.fillOpacity = (0, setupAttributes_1.setupAttributeUpdate)('fill-opacity', newProps.fillOpacity, element);
            }
        }
        if (newProps.strokeOpacity !== oldProps.strokeOpacity) {
            (_16 = instance.strokeOpacity) === null || _16 === void 0 ? void 0 : _16.call(instance);
            if (newProps.strokeOpacity === undefined) {
                element.removeAttribute('stroke-opacity');
            }
            else {
                instance.strokeOpacity = (0, setupAttributes_1.setupAttributeUpdate)('stroke-opacity', newProps.strokeOpacity, element);
            }
        }
        if (newProps.strokeLinecap !== oldProps.strokeLinecap) {
            (_17 = instance.strokeLinecap) === null || _17 === void 0 ? void 0 : _17.call(instance);
            if (newProps.strokeLinecap === undefined) {
                element.removeAttribute('stroke-linecap');
            }
            else {
                instance.strokeLinecap = (0, setupAttributes_1.setupAttributeUpdate)('stroke-linecap', newProps.strokeLinecap, element);
            }
        }
        if (newProps.strokeLinejoin !== oldProps.strokeLinejoin) {
            (_18 = instance.strokeLinejoin) === null || _18 === void 0 ? void 0 : _18.call(instance);
            if (newProps.strokeLinejoin === undefined) {
                element.removeAttribute('stroke-linejoin');
            }
            else {
                instance.strokeLinejoin = (0, setupAttributes_1.setupAttributeUpdate)('stroke-linejoin', newProps.strokeLinejoin, element);
            }
        }
        if (newProps.points !== oldProps.points) {
            (_19 = instance.points) === null || _19 === void 0 ? void 0 : _19.call(instance);
            if (newProps.points === undefined) {
                element.removeAttribute('points');
            }
            else {
                instance.points = (0, setupAttributes_1.setupAttributeUpdate)('points', newProps.points, element);
            }
        }
        if (newProps.offset !== oldProps.offset) {
            (_20 = instance.offset) === null || _20 === void 0 ? void 0 : _20.call(instance);
            if (newProps.offset === undefined) {
                element.removeAttribute('offset');
            }
            else {
                instance.offset = (0, setupAttributes_1.setupAttributeUpdate)('offset', newProps.offset, element);
            }
        }
        if (newProps.stopColor !== oldProps.stopColor) {
            (_21 = instance.stopColor) === null || _21 === void 0 ? void 0 : _21.call(instance);
            if (newProps.stopColor === undefined) {
                element.removeAttribute('stop-color');
            }
            else {
                instance.stopColor = (0, setupAttributes_1.setupAttributeUpdate)('stop-color', newProps.stopColor, element);
            }
        }
        if (newProps.stopOpacity !== oldProps.stopOpacity) {
            (_22 = instance.stopOpacity) === null || _22 === void 0 ? void 0 : _22.call(instance);
            if (newProps.stopOpacity === undefined) {
                element.removeAttribute('stop-opacity');
            }
            else {
                instance.stopOpacity = (0, setupAttributes_1.setupAttributeUpdate)('stop-opacity', newProps.stopOpacity, element);
            }
        }
        if (newProps.fontFamily !== oldProps.fontFamily) {
            (_23 = instance.fontFamily) === null || _23 === void 0 ? void 0 : _23.call(instance);
            if (newProps.fontFamily === undefined) {
                element.removeAttribute('font-family');
            }
            else {
                instance.fontFamily = (0, setupAttributes_1.setupAttributeUpdate)('font-family', newProps.fontFamily, element);
            }
        }
        if (newProps.fontSize !== oldProps.fontSize) {
            (_24 = instance.fontSize) === null || _24 === void 0 ? void 0 : _24.call(instance);
            if (newProps.fontSize === undefined) {
                element.removeAttribute('font-size');
            }
            else {
                instance.fontSize = (0, setupAttributes_1.setupAttributeUpdate)('font-size', newProps.fontSize, element);
            }
        }
        if (newProps.src !== oldProps.src) {
            (_25 = instance.src) === null || _25 === void 0 ? void 0 : _25.call(instance);
            if (newProps.src === undefined) {
                const textElement = element;
                textElement.removeAttribute('src');
            }
            else {
                instance.src = (0, setupAttributes_1.setupSrcUpdate)(newProps.src, element);
            }
        }
        if (newProps.cohinline !== oldProps.cohinline) {
            (_26 = instance.cohinline) === null || _26 === void 0 ? void 0 : _26.call(instance);
            if (newProps.cohinline === undefined) {
                element.removeAttribute('cohinline');
            }
            else {
                instance.cohinline = (0, setupAttributes_1.setupAttributeUpdate)('cohinline', newProps.cohinline, element);
            }
        }
        if (newProps.onClick !== oldProps.onClick) {
            if (oldProps.onClick)
                element.removeEventListener('click', oldProps.onClick);
            if (newProps.onClick)
                element.addEventListener('click', newProps.onClick);
        }
        if (newProps.onFocus !== oldProps.onFocus) {
            if (oldProps.onFocus)
                element.removeEventListener('focus', oldProps.onFocus);
            if (newProps.onFocus)
                element.addEventListener('focus', newProps.onFocus);
        }
        if (newProps.onBlur !== oldProps.onBlur) {
            if (oldProps.onBlur)
                element.removeEventListener('blur', oldProps.onBlur);
            if (newProps.onBlur)
                element.addEventListener('blur', newProps.onBlur);
        }
        if (newProps.onMouseDown !== oldProps.onMouseDown) {
            if (oldProps.onMouseDown)
                element.removeEventListener('mousedown', oldProps.onMouseDown);
            if (newProps.onMouseDown)
                element.addEventListener('mousedown', newProps.onMouseDown);
        }
        if (newProps.onMouseMove !== oldProps.onMouseMove) {
            if (oldProps.onMouseMove)
                element.removeEventListener('mousemove', oldProps.onMouseMove);
            if (newProps.onMouseMove)
                element.addEventListener('mousemove', newProps.onMouseMove);
        }
        if (newProps.onMouseEnter !== oldProps.onMouseEnter) {
            if (oldProps.onMouseEnter)
                element.removeEventListener('mouseenter', oldProps.onMouseEnter);
            if (newProps.onMouseEnter)
                element.addEventListener('mouseenter', newProps.onMouseEnter);
        }
        if (newProps.onMouseLeave !== oldProps.onMouseLeave) {
            if (oldProps.onMouseLeave)
                element.removeEventListener('mouseleave', oldProps.onMouseLeave);
            if (newProps.onMouseLeave)
                element.addEventListener('mouseleave', newProps.onMouseLeave);
        }
        if (newProps.onMouseUp !== oldProps.onMouseUp) {
            if (oldProps.onMouseUp)
                element.removeEventListener('mouseup', oldProps.onMouseUp);
            if (newProps.onMouseUp)
                element.addEventListener('mouseup', newProps.onMouseUp);
        }
        if (newProps.onTouchStart !== oldProps.onTouchStart) {
            if (oldProps.onTouchStart)
                element.removeEventListener('touchstart', oldProps.onTouchStart);
            if (newProps.onTouchStart)
                element.addEventListener('touchstart', newProps.onTouchStart);
        }
        if (newProps.onTouchMove !== oldProps.onTouchMove) {
            if (oldProps.onTouchMove)
                element.removeEventListener('touchmove', oldProps.onTouchMove);
            if (newProps.onTouchMove)
                element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd !== oldProps.onTouchEnd) {
            if (oldProps.onTouchEnd)
                element.removeEventListener('touchend', oldProps.onTouchEnd);
            if (newProps.onTouchEnd)
                element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onTouchMove !== oldProps.onTouchMove) {
            if (oldProps.onTouchMove)
                element.removeEventListener('touchmove', oldProps.onTouchMove);
            if (newProps.onTouchMove)
                element.addEventListener('touchmove', newProps.onTouchMove);
        }
        if (newProps.onTouchEnd !== oldProps.onTouchEnd) {
            if (oldProps.onTouchEnd)
                element.removeEventListener('touchend', oldProps.onTouchEnd);
            if (newProps.onTouchEnd)
                element.addEventListener('touchend', newProps.onTouchEnd);
        }
        if (newProps.onKeyPress !== oldProps.onKeyPress) {
            if (oldProps.onKeyPress)
                element.removeEventListener('keypress', oldProps.onKeyPress);
            if (newProps.onKeyPress)
                element.addEventListener('keypress', newProps.onKeyPress);
        }
        if (newProps.onKeyDown !== oldProps.onKeyDown) {
            if (oldProps.onKeyDown)
                element.removeEventListener('keydown', oldProps.onKeyDown);
            if (newProps.onKeyDown)
                element.addEventListener('keydown', newProps.onKeyDown);
        }
        if (newProps.onKeyUp !== oldProps.onKeyUp) {
            if (oldProps.onKeyUp)
                element.removeEventListener('keyup', oldProps.onKeyUp);
            if (newProps.onKeyUp)
                element.addEventListener('keyup', newProps.onKeyUp);
        }
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
        textInstance.element.nodeValue = newText;
    },
    appendInitialChild: function (parent, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parent.children.add(child);
        }
        parent.element.appendChild(child.element);
    },
    appendChildToContainer: function (parent, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parent.children.add(child);
        }
        parent.element.appendChild(child.element);
    },
    appendChild: function (parentInstance, child) {
        if ((0, types_1.isElementContainer)(child)) {
            parentInstance.children.add(child);
        }
        parentInstance.element.appendChild(child.element);
    },
    insertBefore: function (parentInstance, child, beforeChild) {
        parentInstance.element.insertBefore(child.element, beforeChild.element);
    },
    removeChild: function (parentInstance, child) {
        if ((0, types_1.isElementContainer)(child)) {
            cleanupElementContainer(parentInstance, child);
        }
        parentInstance.element.removeChild(child.element);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
        container.element.insertBefore(child.element, beforeChild.element);
    },
    removeChildFromContainer: function (container, child) {
        if ((0, types_1.isElementContainer)(child)) {
            cleanupElementContainer(container, child);
        }
        container.element.removeChild(child.element);
    },
    resetTextContent: function (instance) {
        instance.element.textContent = '';
    },
    shouldDeprioritizeSubtree: function () {
        return false;
    },
    getPublicInstance: function (instance) {
        return instance.element;
    },
});
exports.setupHostConfig = setupHostConfig;
const cleanupElementContainer = (parent, instance) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    parent.children.delete(instance);
    (_a = instance.styleUnsubscribers) === null || _a === void 0 ? void 0 : _a.forEach((unsubscribe) => unsubscribe());
    (_b = instance.styleUnsubscribers) === null || _b === void 0 ? void 0 : _b.clear();
    instance.children.forEach(cleanupElementContainer);
    instance.children.clear();
    (_c = instance.className) === null || _c === void 0 ? void 0 : _c.call(instance);
    (_d = instance['data-droppable']) === null || _d === void 0 ? void 0 : _d.call(instance);
    (_e = instance['data-narrate']) === null || _e === void 0 ? void 0 : _e.call(instance);
    (_f = instance['data-narrate-as']) === null || _f === void 0 ? void 0 : _f.call(instance);
    (_g = instance['data-narrate-after']) === null || _g === void 0 ? void 0 : _g.call(instance);
    (_h = instance['data-narrate-before']) === null || _h === void 0 ? void 0 : _h.call(instance);
    (_j = instance['data-testid']) === null || _j === void 0 ? void 0 : _j.call(instance);
    (_k = instance['data-x-ray']) === null || _k === void 0 ? void 0 : _k.call(instance);
    (_l = instance.id) === null || _l === void 0 ? void 0 : _l.call(instance);
    (_m = instance.src) === null || _m === void 0 ? void 0 : _m.call(instance);
    (_o = instance.href) === null || _o === void 0 ? void 0 : _o.call(instance);
    (_p = instance.target) === null || _p === void 0 ? void 0 : _p.call(instance);
    (_q = instance.autoPlay) === null || _q === void 0 ? void 0 : _q.call(instance);
    (_r = instance.loop) === null || _r === void 0 ? void 0 : _r.call(instance);
    (_s = instance.disabled) === null || _s === void 0 ? void 0 : _s.call(instance);
    (_t = instance.maxLength) === null || _t === void 0 ? void 0 : _t.call(instance);
    (_u = instance.rows) === null || _u === void 0 ? void 0 : _u.call(instance);
    (_v = instance.value) === null || _v === void 0 ? void 0 : _v.call(instance);
    (_w = instance.type) === null || _w === void 0 ? void 0 : _w.call(instance);
    (_x = instance.text) === null || _x === void 0 ? void 0 : _x.call(instance);
};
const noop = () => { };
const EMPTY = {};
const fastTypeMapHTML = {
    'fast-a': 'a',
    'fast-div': 'div',
    'fast-p': 'p',
    'fast-img': 'img',
    'fast-input': 'input',
    'fast-span': 'span',
    'fast-textarea': 'textarea',
    'fast-text': 'span',
    a: 'a',
    div: 'div',
    p: 'p',
    img: 'img',
    textarea: 'textarea',
    input: 'input',
    style: 'style',
};
const fastTypeMapSVG = {
    'fast-circle': 'circle',
    'fast-ellipse': 'ellipse',
    'fast-line': 'line',
    'fast-path': 'path',
    'fast-rect': 'rect',
    'fast-svg': 'svg',
    'fast-use': 'use',
    'fast-polyline': 'polyline',
    'fast-polygon': 'polygon',
    'fast-linearGradient': 'linearGradient',
    'fast-radialGradient': 'radialGradient',
    'fast-stop': 'stop',
    'fast-svg-text': 'text',
    'fast-pattern': 'pattern',
    circle: 'circle',
    ellipse: 'ellipse',
    line: 'line',
    path: 'path',
    rect: 'rect',
    svg: 'svg',
    symbol: 'symbol',
    g: 'g',
    use: 'use',
    defs: 'defs',
    polyline: 'polyline',
    polygon: 'polygon',
    linearGradient: 'linearGradient',
    radialGradient: 'radialGradient',
    stop: 'stop',
    text: 'text',
    pattern: 'pattern',
};
//# sourceMappingURL=setupHostConfig.js.map

/***/ }),

/***/ 7358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isElementContainer = void 0;
const isElementContainer = (value) => {
    return 'children' in value;
};
exports.isElementContainer = isElementContainer;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 3130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useSharedFacet = exports.SharedFacetDriverProvider = exports.sharedFacetDriverContext = void 0;
const react_1 = __webpack_require__(67294);
const dummyConstructor = () => () => { };
exports.sharedFacetDriverContext = (0, react_1.createContext)(dummyConstructor);
exports.SharedFacetDriverProvider = exports.sharedFacetDriverContext.Provider;
const useSharedFacet = (sharedFacet) => {
    return sharedFacet((0, react_1.useContext)(exports.sharedFacetDriverContext));
};
exports.useSharedFacet = useSharedFacet;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 30401:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(3130), exports);
__exportStar(__webpack_require__(37350), exports);
__exportStar(__webpack_require__(51090), exports);
__exportStar(__webpack_require__(15685), exports);
__exportStar(__webpack_require__(60815), exports);
__exportStar(__webpack_require__(20206), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Simple memoize implementation that supports a single argument
 *
 * TODO: handle cleaning up the cache.
 */
function memoize(fn) {
    const results = new Map();
    return (argument) => {
        const previousResult = results.get(argument);
        if (previousResult)
            return previousResult;
        const newResult = fn(argument);
        results.set(argument, newResult);
        return newResult;
    };
}
exports["default"] = memoize;
//# sourceMappingURL=memoize.js.map

/***/ }),

/***/ 37350:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedDynamicSelector = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
const sharedSelector_1 = __webpack_require__(15685);
/**
 * Defines a selector that can take a parameter
 * For more information check the documentation on defining a selector.
 *
 * @param selectorFactory differently from a selector, this is a function that takes the parameter to return the selector
 * @param equalityCheck optional, has a default for immutable values
 */
function sharedDynamicSelector(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
selectorFactory, equalityCheck = core_1.defaultEqualityCheck) {
    return (0, memoize_1.default)((parameter) => {
        const [selector, facets] = selectorFactory(parameter);
        const definition = (0, memoize_1.default)((sharedFacetDriver) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return sharedSelector_1.sharedSelector(selector, facets, equalityCheck)(sharedFacetDriver);
        });
        definition.factory = core_1.FACET_FACTORY;
        return definition;
    });
}
exports.sharedDynamicSelector = sharedDynamicSelector;
//# sourceMappingURL=sharedDynamicSelector.js.map

/***/ }),

/***/ 51090:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedFacet = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
/**
 * Defines a facet with shared data
 *
 * @param name the name of the facet (used to construct it with the sharedFacetDriver)
 * @param initialValue optional default value while constructor is not ready with the real value
 */
function sharedFacet(name, initialValue = core_1.NO_VALUE) {
    const definition = (0, memoize_1.default)((sharedFacetDriver) => (0, core_1.createFacet)({
        initialValue,
        startSubscription: (update) => {
            return sharedFacetDriver(name, update);
        },
    }));
    definition.factory = core_1.FACET_FACTORY;
    return definition;
}
exports.sharedFacet = sharedFacet;
//# sourceMappingURL=sharedFacet.js.map

/***/ }),

/***/ 15685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sharedSelector = void 0;
const memoize_1 = __importDefault(__webpack_require__(5811));
const core_1 = __webpack_require__(88572);
/**
 * Defines a selector to transform/map data from a facet
 *
 * When used correctly, it can limit components being re-rendered if they only
 * care about a specific attribute/function of a facet.
 *
 * To take full advantage of a selector, it is important to choose a proper equalityCheck
 * with an IMPORTANT understanding of the source of the data (if it is mutable for example).
 *
 * If the source of the data is an object or array that is being mutated, then it would mean that
 * the current and previous values passed to the equalityCheck would be same reference, making it
 * impossible to run any equality check. We recommend only using an equality check if the values
 * returned by the selector are numbers, booleans, strings, or objects/arrays constructed by the selector.
 *
 * @param facets which facets to read the data from
 * @param selector a function to transform the data from the facets
 * @param equalityCheck optional, has a default for immutable values
 */
function sharedSelector(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
selector, facets, equalityCheck = core_1.defaultEqualityCheck) {
    const definition = (0, memoize_1.default)((sharedFacetDriver) => (0, core_1.mapFacetsCached)(facets.map((facet) => facet(sharedFacetDriver)), selector, equalityCheck));
    definition.factory = core_1.FACET_FACTORY;
    return definition;
}
exports.sharedSelector = sharedSelector;
//# sourceMappingURL=sharedSelector.js.map

/***/ }),

/***/ 60815:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 20206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useSharedFacetPropSetter = void 0;
const core_1 = __webpack_require__(88572);
const context_1 = __webpack_require__(3130);
/**
 * Hook that returns a setter function to a specific property of a given sharedFacet
 * Ex:
 * 	- Given a shared facet { foo: 'bar' }
 *  - Could be used as useSharedFacetPropSetter(facet, 'foo')
 *  - And the setter would set the foo property
 *
 * @param sharedFacet
 * @param prop the name of the prop to set
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useSharedFacetPropSetter(sharedFacet, prop) {
    return (0, core_1.useFacetCallback)((facet) => (newValue) => {
        facet[prop] = newValue;
    }, [prop], [(0, context_1.useSharedFacet)(sharedFacet)]);
}
exports.useSharedFacetPropSetter = useSharedFacetPropSetter;
//# sourceMappingURL=useSharedFacetPropSetter.js.map

/***/ }),

/***/ 52910:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

window.__globalDevCoreUISoundDefinitions = window.__globalDevCoreUISoundDefinitions || {};
Object.assign(window.__globalDevCoreUISoundDefinitions, {
  "tokens.vanilla.release": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(99373)
    }]
  },
  "tokens.vanilla.snes_pop": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(43464)
    }]
  },
  "tokens.vanilla.modal_hide": {
    "category": "ui",
    "sounds": [{
      "name": __webpack_require__(60197)
    }]
  }
});

/***/ }),

/***/ 35341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*jslint browser: true, nomen: true, plusplus: true */
/// @file cohtml.js
/// @namespace engine
/// Coherent UI JavaScript interface.
/// The `engine` module contains all functions for communication between the UI and the game / application.
(function (factory) {
  console.log('Loading Client Side cohtml file...'); // This is a modified cohtml file so that it returns a function that calls the factory of the module,
  // allowing us to conditionally execute it from the outside.

  if ( true && module.exports) {
    module.exports = () => factory(__webpack_require__.g, __webpack_require__.g.engine, false);
  }
})(function (global, engine, hasOnLoad) {
  'use strict';

  var VERSION = [1, 5, 0, 8];
  /**
  * Event emitter
  *
  * @class Emitter
  */

  function Emitter() {
    this.events = {};
  }

  function Handler(code, context) {
    this.code = code;
    this.context = context;
  }

  Emitter.prototype._createClear = function (object, name, handler) {
    return function () {
      var handlers = object.events[name];

      if (handlers) {
        var index = -1; // this was in native previously

        if (handler == null) {
          for (var i = 0; i < handlers.length; ++i) {
            if (handlers[i].wasInCPP != null) {
              index = i;
              break;
            }
          }
        } else {
          index = handlers.indexOf(handler);
        }

        if (index != -1) {
          handlers.splice(index, 1);

          if (handlers.length === 0) {
            delete object.events[name];
          }
        }
      } else {
        if (engine.RemoveOnHandler != null) {
          engine.RemoveOnHandler(name);
        }
      }
    };
  };
  /**
  * Add a handler for an event
  *
  * @method on
  * @param name the event name
  * @param callback function to be called when the event is triggered
  * @param context this binding for executing the handler, defaults to the Emitter
  * @return connection object
  */


  Emitter.prototype.on = function (name, callback, context) {
    var handlers = this.events[name];
    if (handlers == null) handlers = this.events[name] = [];
    var handler = new Handler(callback, context || this);
    handlers.push(handler);
    return {
      clear: this._createClear(this, name, handler)
    };
  };
  /**
  * Remove a handler from an event
  *
  * @method off
  * @param name the event name
  * @param handler function to be called when the event is triggered
  * @param context this binding for executing the handler, defaults to the Emitter
  * @return connection object
  */


  Emitter.prototype.off = function (name, handler, context) {
    var handlers = this.events[name];

    if (handlers != null) {
      context = context || this;
      var index;
      var length = handlers.length;

      for (index = 0; index < length; ++index) {
        var reg = handlers[index];

        if (reg.code == handler && reg.context == context) {
          break;
        }
      }

      if (index < length) {
        handlers.splice(index, 1);

        if (handlers.length === 0) {
          delete this.events[name];
        }
      }
    } else {
      engine.RemoveOnHandler(name);
    }
  };

  var isAttached = engine != null;
  engine = engine || {}; /// @var {bool} engine.isAttached
  /// Indicates whether the script is currently running inside Cohtml

  engine.isAttached = isAttached;
  engine.onEventsReplayed = null;

  Emitter.prototype.trigger = function (name) {
    var handlers = this.events[name];

    if (handlers != null) {
      var args = Array.prototype.slice.call(arguments, 1);
      handlers.forEach(function (handler) {
        handler.code.apply(handler.context, args);
      });
      return true;
    }

    return false;
  };

  Emitter.prototype.merge = function (emitter) {
    var lhs = this.events,
        rhs = emitter.events,
        push = Array.prototype.push,
        events;

    for (var e in rhs) {
      events = lhs[e] = lhs[e] || [];
      push.apply(events, rhs[e]);
    }
  };

  var pending = 'pending';
  var fulfilled = 'fulfilled';
  var broken = 'broken';

  function callAsync(code, context, argument) {
    var async = function () {
      code.call(context, argument);
    };

    window.setTimeout(async, 1);
  }

  if (!engine.isAttached) {
    Emitter.prototype.on = function (name, callback, context) {
      var handlers = this.events[name];

      if (
      /** @type {any} */
      this.browserCallbackOn) {
        /** @type {any} */
        this.browserCallbackOn(name, callback, context);
      }

      if (handlers == null) {
        handlers = this.events[name] = [];
      }

      var handler = new Handler(callback, context || this);
      handlers.push(handler);
      return {
        clear: this._createClear(this, name, handler)
      };
    };

    Emitter.prototype.off = function (name, handler, context) {
      var handlers = this.events[name];

      if (handlers != null) {
        context = context || this;
        var index;
        var length = handlers.length;

        for (index = 0; index < length; ++index) {
          var reg = handlers[index];

          if (reg.code == handler && reg.context == context) {
            break;
          }
        }

        if (index < length) {
          handlers.splice(index, 1);

          if (handlers.length === 0) {
            delete this.events[name];

            if (
            /** @type {any} */
            this.browserCallbackOff) {
              /** @type {any} */
              this.browserCallbackOff(name, handler, context);
            }
          }
        }
      }
    };

    engine.SendMessage = function (name, id) {
      var args = Array.prototype.slice.call(arguments, 2);
      var deferred = engine._ActiveRequests[id];
      delete engine._ActiveRequests[id];

      var call = function () {
        var mock = engine._mocks[name];

        if (mock != null) {
          deferred.resolve(mock.apply(engine, args));
        }
      };

      window.setTimeout(call, 16);
    }; /// @function engine.TriggerEvent
    /// Tries to invoke handlers for an event.
    ///
    /// It will invoke any handler registered in C++ or the only handler registered in JavaScript.
    /// engine._trigger will handle the case where more than one event handler is registered in JavaScript
    /// or there are handlers from C++ and JavaScript at the same time.
    /// @param {String} name name of the event to be fired
    /// @param ... any extra parameters to be passed to event handlers
    /// @return true if any event handlers have been registered in C++ or exactly one in JavaScript
    /// @note this mock-mode version will return true if there is any event handler in JavaScript


    engine.TriggerEvent = function () {
      var args = Array.prototype.slice.call(arguments);

      var trigger = function () {
        var mock = engine._mocks[args[0]];

        if (mock != null) {
          mock.apply(engine, args.slice(1));
        }
      };

      window.setTimeout(trigger, 16);
      return engine._mocks[args[0]] != null;
    };

    engine.BindingsReady = function () {
      engine._OnReady();
    };

    engine.__observeLifetime = function () {};

    engine.beginEventRecording = engine.endEventRecording = engine.saveEventRecord = function () {
      console.warn("Event recording will not work in the browser!");
    };

    engine._mocks = {};

    engine._mockImpl = function (name, mock, isCppCall, isEvent) {
      if (mock) {
        this._mocks[name] = mock;
      } // Extract the name of the arguments from Function.prototype.toString


      var functionStripped = mock.toString().replace("function " + mock.name + "(", "");
      var rightParanthesis = functionStripped.indexOf(")");
      var args = functionStripped.substr(0, rightParanthesis);

      if (this.browserCallbackMock) {
        this.browserCallbackMock(name, args, isCppCall, Boolean(isEvent));
      }
    };

    engine.mock = function (name, mock, isEvent) {
      this._mockImpl(name, mock, true, isEvent);
    };
  }

  engine.events = {};

  for (var property in Emitter.prototype) {
    engine[property] = Emitter.prototype[property];
  }

  if (engine.isAttached) {
    /// @function engine.on
    /// Register handler for and event
    /// @param {String} name name of the event
    /// @param {Function} callback callback function to be executed when the event has been triggered
    /// @param context *this* context for the function, by default the engine object
    engine.on = function (name, callback, context) {
      var handlers = this.events[name];

      if (handlers == null && engine.AddOrRemoveOnHandler != null) {
        // Check where to cache the handler
        var prevEvent = engine.AddOrRemoveOnHandler(name, callback, context || engine); // handler cached in C++

        if (prevEvent == null) {
          return {
            clear: this._createClear(this, name, undefined)
          };
        }

        handlers = this.events[name] = []; // Add the previous handler

        var prevHandler = new Handler(prevEvent[0], prevEvent[1] || this);
        /** @type {any} */

        prevHandler.wasInCPP = true;
        handlers.push(prevHandler);
      } else if (handlers == null) {
        handlers = this.events[name] = [];
      }

      var handler = new Handler(callback, context || this);
      handlers.push(handler);
      return {
        clear: this._createClear(this, name, handler)
      };
    };
  }

  engine.whenReady = new Promise(resolve => {
    engine.on('Ready', resolve);
  }); /// @function engine.beginEventRecording
  /// Begins recording all events triggered using View::TriggerEvent from the game
  /// @function engine.endEventRecording
  /// Ends event recording
  /// @function engine.saveEventRecord
  /// Saves the events recorded in between the last calls to engine.beginEventRecording and engine.endEventRecording to a file
  /// @param {String} path The path to the file where to save the recorded events. Optional. Defaults to "eventRecord.json"
  /// @function engine.replayEvents
  /// Replays the events previously recorded and stored in path. If you need to be notified when all events
  /// are replayed, assign a callback to engine.onEventsReplayed
  /// @param {Number} timeScale The speed at which to replay the events (e.g. pass 2 to double the speed). Optional. Defaults to 1.
  /// @param {String} path The path to the file the recorded events are stored. Optional. Defaults to "eventRecord.json"
  /// @function engine.off
  /// Remove handler for an event
  /// @param {String} name name of the event, by default removes all events
  /// @param {Function} callback the callback function to be removed, by default removes all callbacks for a given event
  /// @param context *this* context for the function, by default all removes all callbacks, regardless of context
  /// @warning Removing all handlers for `engine` will remove some *Coherent UI* internal events, breaking some functionality.
  /// @function engine.trigger
  /// Trigger an event
  /// This function will trigger any C++ handler registered for this event with `Coherent::UI::View::RegisterForEvent`
  /// @param {String} name name of the event
  /// @param ... any extra arguments to be passed to the event handlers

  engine._trigger = Emitter.prototype.trigger;
  var concatArguments = Array.prototype.concat;

  engine.trigger = function (name) {
    if (!this._trigger.apply(this, arguments)) {
      this.TriggerEvent.apply(this, arguments);
    }

    if (this.events['all'] != null) {
      var allArguments = concatArguments.apply(['all'], arguments);

      this._trigger.apply(this, allArguments);
    }
  }; /// @function engine.showOverlay
  /// Shows the debugging overlay in the browser.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.


  engine.showOverlay = function () {}; /// @function engine.hideOverlay
  /// Hides the debugging overlay in the browser.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.


  engine.hideOverlay = function () {}; /// @function engine.mock
  /// Mocks a C++ function call with the specified function.
  /// Only works in the browser. Attempts to use it in Coherent UI will do nothing.
  /// @param {String} name name of the event
  /// @param {Function} mock a function to be called in-place of your native binding
  /// @param {Boolean} isEvent whether you are mocking an event or function call


  if (engine.isAttached) {
    engine.mock = function (name, mock, isEvent) {};
  }

  engine._BindingsReady = false;
  engine._WindowLoaded = false;
  engine._RequestId = 0;
  engine._ActiveRequests = {};

  if (global.engineCreateDeferred != null) {
    console.warn("engineCreateDeferred is depricated");
  } /// @function engine.call
  /// Call asynchronously a C++ handler and retrieve the result
  /// The C++ handler must have been registered with `Coherent::UI::View::BindCall`
  /// @param {String} name name of the C++ handler to be called
  /// @param ... any extra parameters to be passed to the C++ handler
  /// @return ECMAScript 6 promise


  engine.call = function () {
    engine._RequestId++;
    var id = engine._RequestId;
    var messageArguments = Array.prototype.slice.call(arguments);
    messageArguments.splice(1, 0, id);
    var promise = new Promise(function (resolve, reject) {
      engine._ActiveRequests[id] = {
        resolve: resolve,
        reject: reject
      };
      engine.SendMessage.apply(engine, messageArguments);
    });
    return promise;
  };

  engine._Result = function (requestId) {
    var deferred = engine._ActiveRequests[requestId];

    if (deferred != null) {
      delete engine._ActiveRequests[requestId];
      var resultArguments = Array.prototype.slice.call(arguments);
      resultArguments.shift();
      deferred.resolve.apply(deferred, resultArguments);
    }
  };

  engine._Errors = ['Success', 'ArgumentType', 'NoSuchMethod', 'NoResult'];

  engine._ForEachError = function (errors, callback) {
    var length = errors.length;

    for (var i = 0; i < length; ++i) {
      callback(errors[i].first, errors[i].second);
    }
  };

  engine._TriggerError = function (message) {
    engine.trigger('Error', message);
  };

  engine._OnError = function (requestId, errors) {
    if (requestId == null || requestId === 0) {
      engine._ForEachError(errors, engine._TriggerError);
    } else {
      var deferred = engine._ActiveRequests[requestId];
      delete engine._ActiveRequests[requestId];
      deferred.reject(new Error(errors[0].second));
    }

    if (errors.length) {
      throw new Error(errors[0].second);
    }
  };

  engine._eventHandles = {};

  engine._Register = function (eventName) {
    var trigger = function (name, engine) {
      return function () {
        var eventArguments = [name];
        eventArguments.push.apply(eventArguments, arguments);
        engine.TriggerEvent.apply(this, eventArguments);
      };
    }(eventName, engine);

    engine._eventHandles[eventName] = engine.on(eventName, trigger);
  };

  engine._removeEventThunk = function (name) {
    var handle = engine._eventHandles[name];
    handle.clear();
    delete engine._eventHandles[name];
  };

  engine._Unregister = function (name) {
    if (typeof name === 'string') {
      engine._removeEventThunk(name);
    } else {
      name.forEach(engine._removeEventThunk, engine);
    }
  };

  function createMethodStub(name) {
    var stub = function () {
      var args = Array.prototype.slice.call(arguments);
      args.splice(0, 0, name, this._id);
      return engine.call.apply(engine, args);
    };

    return stub;
  }

  engine._boundTypes = {};

  engine._createInstance = function (args) {
    var type = args[0],
        id = args[1],
        methods = args[2],
        constructor = engine._boundTypes[type];

    if (constructor == null) {
      constructor = function (id) {
        this._id = id;
      };

      constructor.prototype.__Type = type;
      methods.forEach(function (name) {
        constructor.prototype[name] = createMethodStub(type + '_' + name);
      });
      engine._boundTypes[type] = constructor;
    }

    var instance = new constructor(id);

    engine.__observeLifetime(instance);

    return instance;
  };

  engine._OnReady = function () {
    engine._BindingsReady = true;

    if (engine._WindowLoaded) {
      engine.trigger('Ready');
    }
  };

  engine._OnWindowLoaded = function () {
    engine._WindowLoaded = true;

    if (engine._BindingsReady) {
      engine.trigger('Ready');
    }
  };

  engine._ThrowError = function (error) {
    var prependTab = function (s) {
      return "\t" + s;
    };

    var errorString = error.name + ": " + error.message + "\n" + error.stack.split("\n").map(prependTab).join("\n");
    console.error(errorString);
  };

  if (hasOnLoad) {
    global.addEventListener("load", function () {
      engine._OnWindowLoaded();
    });
  } else {
    engine._WindowLoaded = true;
  }

  engine.on('_Result', engine._Result, engine);
  engine.on('_Register', engine._Register, engine);
  engine.on('_Unregister', engine._Unregister, engine);
  engine.on('_OnReady', engine._OnReady, engine);
  engine.on('_OnError', engine._OnError, engine);
  engine.on('__OnReplayRecordCompleted', function (jsonRecords) {
    if (engine.onEventsReplayed) {
      engine.onEventsReplayed();
    }
  }); //@ts-ignore

  engine.dependency = new WeakMap();
  engine.updateWholeModelCallbacks = [];
  engine.hasAttachedUpdateListner = false;

  engine.onUpdateWholeModel = object => {
    let deps = engine.dependency.get(object) || [];
    deps.forEach(dep => engine.updateWholeModel(dep));
  };

  engine.createObservableModel = observableName => {
    const handler = {
      set: (target, prop, value) => {
        engine.updateWholeModel(window[observableName]);
        target[prop] = value;
      }
    }; // @ts-ignore

    engine.createJSModel(observableName, new Proxy({}, handler));
  };

  engine.addSynchronizationDependency = (first, second) => {
    if (!engine.hasAttachedUpdateListner) {
      // will attach updateWholeModel callback for when there are one or more model dependencies
      engine.addDataBindEventListner("updateWholeModel", engine.onUpdateWholeModel);
      engine.hasAttachedUpdateListner = true;
    }

    let deps = engine.dependency.get(first);

    if (!deps) {
      deps = [];
      engine.dependency.set(first, deps);
    }

    deps.push(second);
  };

  engine.removeSynchronizationDependency = (first, second) => {
    let deps = engine.dependency.get(first) || [];
    deps.splice(deps.indexOf(first), 1);
  };

  engine.BindingsReady(VERSION[0], VERSION[1], VERSION[2], VERSION[3]);
  return engine;
});

/***/ }),

/***/ 35107:
/***/ (() => {



/***/ }),

/***/ 57811:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "facet": () => (/* binding */ facet),
/* harmony export */   "shallowObjectEqualityCheck": () => (/* binding */ shallowObjectEqualityCheck)
/* harmony export */ });
/* unused harmony exports strictShallowObjectEqualityCheck, localFacet, useFacet, useFacetSetter */
/* harmony import */ var _react_facet_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88572);
/* harmony import */ var _react_facet_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createPortal")) __webpack_require__.d(__webpack_exports__, { "createPortal": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createPortal; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_core__WEBPACK_IMPORTED_MODULE_0__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.useSharedFacet; } });
/* harmony import */ var _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47154);
/* harmony import */ var _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createPortal")) __webpack_require__.d(__webpack_exports__, { "createPortal": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createPortal; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_dom_fiber__WEBPACK_IMPORTED_MODULE_1__.useSharedFacet; } });
/* harmony import */ var _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30401);
/* harmony import */ var _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "Map")) __webpack_require__.d(__webpack_exports__, { "Map": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.Map; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "Mount")) __webpack_require__.d(__webpack_exports__, { "Mount": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.Mount; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "NO_VALUE")) __webpack_require__.d(__webpack_exports__, { "NO_VALUE": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.NO_VALUE; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "SharedFacetDriverProvider")) __webpack_require__.d(__webpack_exports__, { "SharedFacetDriverProvider": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.SharedFacetDriverProvider; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "With")) __webpack_require__.d(__webpack_exports__, { "With": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.With; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createFacet")) __webpack_require__.d(__webpack_exports__, { "createFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createFacetContext")) __webpack_require__.d(__webpack_exports__, { "createFacetContext": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createFacetContext; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createPortal")) __webpack_require__.d(__webpack_exports__, { "createPortal": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createPortal; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "createStaticFacet")) __webpack_require__.d(__webpack_exports__, { "createStaticFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.createStaticFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "isFacet")) __webpack_require__.d(__webpack_exports__, { "isFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.isFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "multiObserve")) __webpack_require__.d(__webpack_exports__, { "multiObserve": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.multiObserve; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "render")) __webpack_require__.d(__webpack_exports__, { "render": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.render; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedDynamicSelector")) __webpack_require__.d(__webpack_exports__, { "sharedDynamicSelector": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedDynamicSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedFacet")) __webpack_require__.d(__webpack_exports__, { "sharedFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedFacet; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "sharedSelector")) __webpack_require__.d(__webpack_exports__, { "sharedSelector": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedSelector; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetCallback")) __webpack_require__.d(__webpack_exports__, { "useFacetCallback": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetCallback; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetEffect": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetLayoutEffect")) __webpack_require__.d(__webpack_exports__, { "useFacetLayoutEffect": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetLayoutEffect; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetMap")) __webpack_require__.d(__webpack_exports__, { "useFacetMap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetMap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetMemo")) __webpack_require__.d(__webpack_exports__, { "useFacetMemo": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetMemo; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetRef")) __webpack_require__.d(__webpack_exports__, { "useFacetRef": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetRef; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetState")) __webpack_require__.d(__webpack_exports__, { "useFacetState": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetState; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetUnwrap")) __webpack_require__.d(__webpack_exports__, { "useFacetUnwrap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetUnwrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useFacetWrap")) __webpack_require__.d(__webpack_exports__, { "useFacetWrap": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useFacetWrap; } });
/* harmony reexport (checked) */ if(__webpack_require__.o(_react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__, "useSharedFacet")) __webpack_require__.d(__webpack_exports__, { "useSharedFacet": function() { return _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.useSharedFacet; } });









const strictShallowObjectEqualityCheck = (/* unused pure expression or super */ null && (originalShallowObjectEqualityCheck));
/**
 * @deprecated This object equality check has no guarantees that the keys of the object are Immutable.
 * Use `strictShallowObjectEqualityCheck` instead
 * */

const shallowObjectEqualityCheck = _react_facet_core__WEBPACK_IMPORTED_MODULE_0__.shallowObjectEqualityCheck;

/**
 * @deprecated use sharedFacet instead
 */

const facet = _react_facet_shared_facet__WEBPACK_IMPORTED_MODULE_2__.sharedFacet;
/**
 * @deprecated
 */

/**
 * @deprecated we recommend useFacetState instead
 */
function localFacet(initialValue) {
  const facet = createFacet({
    initialValue
  });

  const result = () => facet;

  result.factory = FACET_FACTORY;
  return result;
}
/**
 * @deprecated useFacetUnwrap and useSharedFacet instead
 */

function useFacet(sharedFacet) {
  const rawValue = useFacetUnwrap(useSharedFacet(sharedFacet));
  return rawValue === NO_VALUE ? undefined : rawValue;
}

const isSetterCallback = setter => {
  return typeof setter === 'function';
};
/**
 * @deprecated we recommend useFacetState instead
 */


function useFacetSetter(facet) {
  return setter => {
    if (isSetterCallback(setter)) {
      return facet().setWithCallback(setter);
    } else {
      return facet().set(setter);
    }
  };
}

/***/ }),

/***/ 79742:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 48764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(79742)
var ieee754 = __webpack_require__(80645)
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ 94184:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 17187:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 80645:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 35717:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 91296:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;


/***/ }),

/***/ 27418:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ 15523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var util = __webpack_require__(89539);

var tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
  // summary:
  //    Split a string by a regular expression with the ability to capture the delimeters
  // parseDelim:
  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns
  //    a value, it's added to the list of tokens.
  // instance:
  //    Used as the "this' instance when calling parseDelim
  var tokens = [];
  var match, content, lastIndex = 0;
  while((match = re.exec(str))){
    content = str.slice(lastIndex, re.lastIndex - match[0].length);
    if(content.length){
      tokens.push(content);
    }
    if(parseDelim){
      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
      if(typeof parsed != 'undefined'){
        if(parsed.specifier === '%'){
          tokens.push('%');
        }else{
          tokens.push(parsed);
        }
      }
    }
    lastIndex = re.lastIndex;
  }
  content = str.slice(lastIndex);
  if(content.length){
    tokens.push(content);
  }
  return tokens;
};

var Formatter = function(/*String*/ format){
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
};

// The old regexp `/\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/` has a cubic worst-case time complexity behavior due to overlapping capture groups `([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?`. And a pump string of 0 can be consumed by `([0 +\-\#]*), (\*|\d+)?, or (\*|\d+)?`.
// The solution replace the sub-regexp (\*|\d+)?(\.)?(\*|\d+)? with the sub-regexp `(\*|\d+)?(?:(\.)(\*|\d+)?)?`, see the figure in [#32](https://github.com/adaltas/node-printf/pull/32)
// There are also performance improvement, see in [#31](https://github.com/adaltas/node-printf/issues/31#issuecomment-776731490)
Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
};
Formatter.prototype._specifiers = {
  b: {
    base: 2,
    isInt: true
  },
  o: {
    base: 8,
    isInt: true
  },
  x: {
    base: 16,
    isInt: true
  },
  X: {
    extend: ['x'],
    toUpper: true
  },
  d: {
    base: 10,
    isInt: true
  },
  i: {
    extend: ['d']
  },
  u: {
    extend: ['d'],
    isUnsigned: true
  },
  c: {
    setArg: function(token){
      if(!isNaN(token.arg)){
        var num = parseInt(token.arg);
        if(num < 0 || num > 127){
          throw new Error('invalid character code passed to %c in printf');
        }
        token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
      }
    }
  },
  s: {
    setMaxWidth: function(token){
      token.maxWidth = (token.period == '.') ? token.precision : -1;
    }
  },
  e: {
    isDouble: true,
    doubleNotation: 'e'
  },
  E: {
    extend: ['e'],
    toUpper: true
  },
  f: {
    isDouble: true,
    doubleNotation: 'f'
  },
  F: {
    extend: ['f']
  },
  g: {
    isDouble: true,
    doubleNotation: 'g'
  },
  G: {
    extend: ['g'],
    toUpper: true
  },
  O: {
    isObject: true
  }
};
Formatter.prototype.format = function(/*mixed...*/ filler){
  if(this._mapped && typeof filler != 'object'){
    throw new Error('format requires a mapping');
  }

  var str = '';
  var position = 0;
  for(var i = 0, token; i < this._tokens.length; i++){
    token = this._tokens[i];

    if(typeof token == 'string'){
      str += token;
    }else{
      if(this._mapped){
        // Identify value of property defined in `token.mapping`
        var tokens = token.mapping.split('.');
        var value = filler;
        for (var j = 0, c = tokens.length; j < c; j++) {
          value = value[tokens[j]];
          if (typeof value === 'undefined') {
            break
          }
        }
        if(typeof value == 'undefined'){
          throw new Error('missing key \'' + token.mapping + '\'');
        }
        token.arg = value;
      }else{
        if(token.intmapping){
          position = parseInt(token.intmapping) - 1;
        }
        if(position >= arguments.length){
          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = '';
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case ' ':
              token.sign = ' ';
              break;
            case '+':
              token.sign = '+';
              break;
            case '0':
              token.zeroPad = (flags['-']) ? false : true;
              break;
            case '-':
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case '#':
              token.alternative = true;
              break;
            default:
              throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == '.'){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == 'undefined'){
          throw new Error('unexpected specifier \'' + token.specifier + '\'');
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k];
          }
          delete mixins.extend;
        }
        for(var l in mixins){
          token[l] = mixins[l];
        }
      }

      if(typeof token.setArg == 'function'){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == 'function'){
        token.setMaxWidth(token);
      }

      if(token._minWidth == '*'){
        if(this._mapped){
          throw new Error('* width not supported in mapped formats');
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth < 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == '*' && token.period == '.'){
        if(this._mapped){
          throw new Error('* precision not supported in mapped formats');
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
        }
        // negative precision means unspecified
        if (token.precision < 0) {
          token.precision = 1;
          token.period = '';
        }
      }
      if(token.isInt){
        // a specified precision means no zero padding
        if(token.period == '.'){
          token.zeroPad = false;
        }
        this.formatInt(token);
      }else if(token.isDouble){
        if(token.period != '.'){
          token.precision = 6;
        }
        this.formatDouble(token);
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.fitField(token);
      str += '' + token.arg;
    }
  }

  return str;
};
Formatter.prototype._zeros10 = '0000000000';
Formatter.prototype._spaces10 = '          ';
Formatter.prototype.formatInt = function(token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
    }
    //return '' + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
  if(i < 0 && (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  }

  if(i < 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = '-' + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as ''
    if(!i && !token.precision){
      token.arg = '';
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = '0x' + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative && token.arg.charAt(0) != '0'){
      token.arg = '0' + token.arg;
    }
  }
};
Formatter.prototype.formatDouble = function(token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
    }
    // C99 says that for 'f':
    //   infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')
    //   NaN -> a string  starting with 'nan' ('NAN' for 'F')
    // this is not commonly implemented though.
    //return '' + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case 'e': {
      token.arg = f.toExponential(token.precision);
      break;
    }
    case 'f': {
      token.arg = f.toFixed(token.precision);
      break;
    }
    case 'g': {
      // C says use 'e' notation if exponent is < -4 or is >= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is >= prec,
      // though step 17 of toPrecision indicates a test for < -6 to force exponential.
      if(Math.abs(f) < 0.0001){
        //print('forcing exponential notation for f=' + f);
        token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision);
      }

      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){
        //print('replacing trailing 0 in \'' + s + '\'');
        token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/,'');
      }
      break;
    }
    default: throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.
  // Note that s.replace(/e([\+\-])(\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.
  // And replace(re, func) isn't supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,'$1.');
    token.arg = token.arg.replace(/^(\d+)e/,'$1.e');
  }

  if(f >= 0 && token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
};
Formatter.prototype.formatObject = function(token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === '.') ? token.precision : null;
  // Historically, inspect was called with 3 options
  // token.arg = util.inspect(token.arg, !token.alternative, precision, token.sign);
  // Now using an object but not sure colors make any sense here
  token.arg = util.inspect(token.arg, {
    showHidden: !token.alternative,
    depth: precision,
    colors: token.sign,
    compact: true
  });
};
Formatter.prototype.zeroPad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != "string"){
    token.arg = "" + token.arg;
  }
  if (token.arg.substr(0,1) === '-') {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = '-' + token.arg;
};
Formatter.prototype.fitField = function(token) {
  if(token.maxWidth >= 0 && token.arg.length > token.maxWidth){
    token.arg = token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != 'string'){
    token.arg = '' + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length < tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
};

module.exports = function(){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof (__webpack_require__(42830).Stream)){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
};

module.exports.Formatter = Formatter;


/***/ }),

/***/ 63195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */


var bind =
/*#__PURE__*/
_curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

module.exports = bind;

/***/ }),

/***/ 50557:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pipe =
/*#__PURE__*/
__webpack_require__(4603);

var reverse =
/*#__PURE__*/
__webpack_require__(65814);
/**
 * Performs right-to-left function composition. The last argument may have
 * any arity; the remaining arguments must be unary.
 *
 * **Note:** The result of compose is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
 * @param {...Function} ...functions The functions to compose
 * @return {Function}
 * @see R.pipe
 * @example
 *
 *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
 *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
 *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
 *
 *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
 *
 * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
 */


function compose() {
  if (arguments.length === 0) {
    throw new Error('compose requires at least one argument');
  }

  return pipe.apply(this, reverse(arguments));
}

module.exports = compose;

/***/ }),

/***/ 2220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _curryN =
/*#__PURE__*/
__webpack_require__(32738);
/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */


var curryN =
/*#__PURE__*/
_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }

  return _arity(length, _curryN(length, [], fn));
});

module.exports = curryN;

/***/ }),

/***/ 51481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _equals =
/*#__PURE__*/
__webpack_require__(74023);
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      const a = {}; a.v = a;
 *      const b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */


var equals =
/*#__PURE__*/
_curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

module.exports = equals;

/***/ }),

/***/ 51383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _filter =
/*#__PURE__*/
__webpack_require__(34877);

var _isObject =
/*#__PURE__*/
__webpack_require__(8291);

var _reduce =
/*#__PURE__*/
__webpack_require__(39488);

var _xfilter =
/*#__PURE__*/
__webpack_require__(11383);

var keys =
/*#__PURE__*/
__webpack_require__(90368);
/**
 * Takes a predicate and a `Filterable`, and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate. Filterable objects include plain objects or any object
 * that has a filter method such as `Array`.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array} Filterable
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      const isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var filter =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable(['filter'], _xfilter, function (pred, filterable) {
  return _isObject(filterable) ? _reduce(function (acc, key) {
    if (pred(filterable[key])) {
      acc[key] = filterable[key];
    }

    return acc;
  }, {}, keys(filterable)) : // else
  _filter(pred, filterable);
}));

module.exports = filter;

/***/ }),

/***/ 46376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _xfind =
/*#__PURE__*/
__webpack_require__(47855);
/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */


var find =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable(['find'], _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }

    idx += 1;
  }
}));

module.exports = find;

/***/ }),

/***/ 53523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _dispatchable =
/*#__PURE__*/
__webpack_require__(34793);

var _xfindIndex =
/*#__PURE__*/
__webpack_require__(20834);
/**
 * Returns the index of the first element of the list which matches the
 * predicate, or `-1` if no element matches.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.1
 * @category List
 * @sig (a -> Boolean) -> [a] -> Number
 * @param {Function} fn The predicate function used to determine if the element is the
 * desired one.
 * @param {Array} list The array to consider.
 * @return {Number} The index of the element found, or `-1`.
 * @see R.transduce
 * @example
 *
 *      const xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
 *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
 */


var findIndex =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable([], _xfindIndex, function findIndex(fn, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (fn(list[idx])) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}));

module.exports = findIndex;

/***/ }),

/***/ 9134:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var curryN =
/*#__PURE__*/
__webpack_require__(2220);
/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      const mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */


var flip =
/*#__PURE__*/
_curry1(function flip(fn) {
  return curryN(fn.length, function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});

module.exports = flip;

/***/ }),

/***/ 69105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _identity =
/*#__PURE__*/
__webpack_require__(50339);
/**
 * A function that does nothing but return the parameter supplied to it. Good
 * as a default or placeholder function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> a
 * @param {*} x The value to return.
 * @return {*} The input value, `x`.
 * @example
 *
 *      R.identity(1); //=> 1
 *
 *      const obj = {};
 *      R.identity(obj) === obj; //=> true
 * @symb R.identity(a) = a
 */


var identity =
/*#__PURE__*/
_curry1(_identity);

module.exports = identity;

/***/ }),

/***/ 59270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 * Works also with strings.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.includes(3, [1, 2, 3]); //=> true
 *      R.includes(4, [1, 2, 3]); //=> false
 *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.includes([42], [[42]]); //=> true
 *      R.includes('ba', 'banana'); //=>true
 */


var includes =
/*#__PURE__*/
_curry2(_includes);

module.exports = includes;

/***/ }),

/***/ 8876:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _Set =
/*#__PURE__*/
function () {
  function _Set() {
    /* globals Set */
    this._nativeSet = typeof Set === 'function' ? new Set() : null;
    this._items = {};
  }

  // until we figure out why jsdoc chokes on this
  // @param item The item to add to the Set
  // @returns {boolean} true if the item did not exist prior, otherwise false
  //
  _Set.prototype.add = function (item) {
    return !hasOrAdd(item, true, this);
  }; //
  // @param item The item to check for existence in the Set
  // @returns {boolean} true if the item exists in the Set, otherwise false
  //


  _Set.prototype.has = function (item) {
    return hasOrAdd(item, false, this);
  }; //
  // Combines the logic for checking whether an item is a member of the set and
  // for adding a new item to the set.
  //
  // @param item       The item to check or add to the Set instance.
  // @param shouldAdd  If true, the item will be added to the set if it doesn't
  //                   already exist.
  // @param set        The set instance to check or add to.
  // @return {boolean} true if the item already existed, otherwise false.
  //


  return _Set;
}();

function hasOrAdd(item, shouldAdd, set) {
  var type = typeof item;
  var prevSize, newSize;

  switch (type) {
    case 'string':
    case 'number':
      // distinguish between +0 and -0
      if (item === 0 && 1 / item === -Infinity) {
        if (set._items['-0']) {
          return true;
        } else {
          if (shouldAdd) {
            set._items['-0'] = true;
          }

          return false;
        }
      } // these types can all utilise the native Set


      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = {};
            set._items[type][item] = true;
          }

          return false;
        } else if (item in set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][item] = true;
          }

          return false;
        }
      }

    case 'boolean':
      // set._items['boolean'] holds a two element array
      // representing [ falseExists, trueExists ]
      if (type in set._items) {
        var bIdx = item ? 1 : 0;

        if (set._items[type][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type][bIdx] = true;
          }

          return false;
        }
      } else {
        if (shouldAdd) {
          set._items[type] = item ? [false, true] : [true, false];
        }

        return false;
      }

    case 'function':
      // compare functions for reference equality
      if (set._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set._nativeSet.size;

          set._nativeSet.add(item);

          newSize = set._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set._nativeSet.has(item);
        }
      } else {
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }

          return false;
        }

        if (!_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }

          return false;
        }

        return true;
      }

    case 'undefined':
      if (set._items[type]) {
        return true;
      } else {
        if (shouldAdd) {
          set._items[type] = true;
        }

        return false;
      }

    case 'object':
      if (item === null) {
        if (!set._items['null']) {
          if (shouldAdd) {
            set._items['null'] = true;
          }

          return false;
        }

        return true;
      }

    /* falls through */

    default:
      // reduce the search size of heterogeneous sets by creating buckets
      // for each type.
      type = Object.prototype.toString.call(item);

      if (!(type in set._items)) {
        if (shouldAdd) {
          set._items[type] = [item];
        }

        return false;
      } // scan through all previously applied items


      if (!_includes(item, set._items[type])) {
        if (shouldAdd) {
          set._items[type].push(item);
        }

        return false;
      }

      return true;
  }
} // A simple Set type that honours R.equals semantics


module.exports = _Set;

/***/ }),

/***/ 7455:
/***/ ((module) => {

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

module.exports = _arity;

/***/ }),

/***/ 54118:
/***/ ((module) => {

function _arrayFromIterator(iter) {
  var list = [];
  var next;

  while (!(next = iter.next()).done) {
    list.push(next.value);
  }

  return list;
}

module.exports = _arrayFromIterator;

/***/ }),

/***/ 73542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);
/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */


function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;

    if (length === 0) {
      return fn();
    }

    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}

module.exports = _checkForMethod;

/***/ }),

/***/ 48770:
/***/ ((module) => {

function _complement(f) {
  return function () {
    return !f.apply(this, arguments);
  };
}

module.exports = _complement;

/***/ }),

/***/ 14011:
/***/ ((module) => {

/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];
  idx = 0;

  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }

  idx = 0;

  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }

  return result;
}

module.exports = _concat;

/***/ }),

/***/ 76224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

module.exports = _curry1;

/***/ }),

/***/ 79002:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;

      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

module.exports = _curry2;

/***/ }),

/***/ 16370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;

      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });

      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

module.exports = _curry3;

/***/ }),

/***/ 32738:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(36464);
/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;

    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;

      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }

      combined[combinedIdx] = result;

      if (!_isPlaceholder(result)) {
        left -= 1;
      }

      combinedIdx += 1;
    }

    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}

module.exports = _curryN;

/***/ }),

/***/ 34793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);

var _isTransformer =
/*#__PURE__*/
__webpack_require__(69082);
/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */


function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }

    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();

    if (!_isArray(obj)) {
      var idx = 0;

      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }

        idx += 1;
      }

      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }

    return fn.apply(this, arguments);
  };
}

module.exports = _dispatchable;

/***/ }),

/***/ 74023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arrayFromIterator =
/*#__PURE__*/
__webpack_require__(54118);

var _includesWith =
/*#__PURE__*/
__webpack_require__(82976);

var _functionName =
/*#__PURE__*/
__webpack_require__(4931);

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var _objectIs =
/*#__PURE__*/
__webpack_require__(21361);

var keys =
/*#__PURE__*/
__webpack_require__(90368);

var type =
/*#__PURE__*/
__webpack_require__(36433);
/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */


function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);

  var b = _arrayFromIterator(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  } // if *a* array contains any element that is not included in *b*


  return !_includesWith(function (b, aItem) {
    return !_includesWith(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (_objectIs(a, b)) {
    return true;
  }

  var typeA = type(a);

  if (typeA !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }

      break;

    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && _objectIs(a.valueOf(), b.valueOf()))) {
        return false;
      }

      break;

    case 'Date':
      if (!_objectIs(a.valueOf(), b.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return a.name === b.name && a.message === b.message;

    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }

      break;
  }

  var idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }

    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);

  if (keysA.length !== keys(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;

  while (idx >= 0) {
    var key = keysA[idx];

    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }

    idx -= 1;
  }

  return true;
}

module.exports = _equals;

/***/ }),

/***/ 34877:
/***/ ((module) => {

function _filter(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }

    idx += 1;
  }

  return result;
}

module.exports = _filter;

/***/ }),

/***/ 4931:
/***/ ((module) => {

function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}

module.exports = _functionName;

/***/ }),

/***/ 87684:
/***/ ((module) => {

function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = _has;

/***/ }),

/***/ 50339:
/***/ ((module) => {

function _identity(x) {
  return x;
}

module.exports = _identity;

/***/ }),

/***/ 87243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _indexOf =
/*#__PURE__*/
__webpack_require__(96069);

function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}

module.exports = _includes;

/***/ }),

/***/ 82976:
/***/ ((module) => {

function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }

    idx += 1;
  }

  return false;
}

module.exports = _includesWith;

/***/ }),

/***/ 96069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var equals =
/*#__PURE__*/
__webpack_require__(51481);

function _indexOf(list, a, idx) {
  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;

          while (idx < list.length) {
            item = list[idx];

            if (item === 0 && 1 / item === inf) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];

            if (typeof item === 'number' && item !== item) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } // non-zero numbers can utilise Set


        return list.indexOf(a, idx);
      // all these types can utilise Set

      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }

    }
  } // anything else not covered above, defer to R.equals


  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}

module.exports = _indexOf;

/***/ }),

/***/ 97587:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var toString = Object.prototype.toString;

var _isArguments =
/*#__PURE__*/
function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

module.exports = _isArguments;

/***/ }),

/***/ 20219:
/***/ ((module) => {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),

/***/ 3219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isArray =
/*#__PURE__*/
__webpack_require__(20219);

var _isString =
/*#__PURE__*/
__webpack_require__(20190);
/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */


var _isArrayLike =
/*#__PURE__*/
_curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }

  if (!x) {
    return false;
  }

  if (typeof x !== 'object') {
    return false;
  }

  if (_isString(x)) {
    return false;
  }

  if (x.nodeType === 1) {
    return !!x.length;
  }

  if (x.length === 0) {
    return true;
  }

  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }

  return false;
});

module.exports = _isArrayLike;

/***/ }),

/***/ 8291:
/***/ ((module) => {

function _isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
}

module.exports = _isObject;

/***/ }),

/***/ 36464:
/***/ ((module) => {

function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

module.exports = _isPlaceholder;

/***/ }),

/***/ 20190:
/***/ ((module) => {

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

module.exports = _isString;

/***/ }),

/***/ 69082:
/***/ ((module) => {

function _isTransformer(obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function';
}

module.exports = _isTransformer;

/***/ }),

/***/ 21361:
/***/ ((module) => {

// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function _objectIs(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
}

module.exports = typeof Object.is === 'function' ? Object.is : _objectIs;

/***/ }),

/***/ 56015:
/***/ ((module) => {

function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}

module.exports = _pipe;

/***/ }),

/***/ 39488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _isArrayLike =
/*#__PURE__*/
__webpack_require__(3219);

var _xwrap =
/*#__PURE__*/
__webpack_require__(39874);

var bind =
/*#__PURE__*/
__webpack_require__(63195);

function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    idx += 1;
  }

  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();

  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    step = iter.next();
  }

  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap(fn);
  }

  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }

  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }

  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }

  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }

  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

module.exports = _reduce;

/***/ }),

/***/ 22157:
/***/ ((module) => {

function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

module.exports = _reduced;

/***/ }),

/***/ 93714:
/***/ ((module) => {

module.exports = {
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
};

/***/ }),

/***/ 11383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFilter =
/*#__PURE__*/
function () {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }

  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;

  XFilter.prototype['@@transducer/step'] = function (result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return XFilter;
}();

var _xfilter =
/*#__PURE__*/
_curry2(function _xfilter(f, xf) {
  return new XFilter(f, xf);
});

module.exports = _xfilter;

/***/ }),

/***/ 47855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _reduced =
/*#__PURE__*/
__webpack_require__(22157);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFind =
/*#__PURE__*/
function () {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }

  XFind.prototype['@@transducer/init'] = _xfBase.init;

  XFind.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFind.prototype['@@transducer/step'] = function (result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }

    return result;
  };

  return XFind;
}();

var _xfind =
/*#__PURE__*/
_curry2(function _xfind(f, xf) {
  return new XFind(f, xf);
});

module.exports = _xfind;

/***/ }),

/***/ 20834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var _reduced =
/*#__PURE__*/
__webpack_require__(22157);

var _xfBase =
/*#__PURE__*/
__webpack_require__(93714);

var XFindIndex =
/*#__PURE__*/
function () {
  function XFindIndex(f, xf) {
    this.xf = xf;
    this.f = f;
    this.idx = -1;
    this.found = false;
  }

  XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

  XFindIndex.prototype['@@transducer/result'] = function (result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, -1);
    }

    return this.xf['@@transducer/result'](result);
  };

  XFindIndex.prototype['@@transducer/step'] = function (result, input) {
    this.idx += 1;

    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, this.idx));
    }

    return result;
  };

  return XFindIndex;
}();

var _xfindIndex =
/*#__PURE__*/
_curry2(function _xfindIndex(f, xf) {
  return new XFindIndex(f, xf);
});

module.exports = _xfindIndex;

/***/ }),

/***/ 39874:
/***/ ((module) => {

var XWrap =
/*#__PURE__*/
function () {
  function XWrap(fn) {
    this.f = fn;
  }

  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };

  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };

  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}

module.exports = _xwrap;

/***/ }),

/***/ 90368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _has =
/*#__PURE__*/
__webpack_require__(87684);

var _isArguments =
/*#__PURE__*/
__webpack_require__(97587); // cover IE < 9 keys issues


var hasEnumBug = !
/*#__PURE__*/
{
  toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

var hasArgsEnumBug =
/*#__PURE__*/
function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;

  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }

    idx += 1;
  }

  return false;
};
/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */


var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
/*#__PURE__*/
_curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) :
/*#__PURE__*/
_curry1(function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }

  var prop, nIdx;
  var ks = [];

  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }

  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;

    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];

      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }

      nIdx -= 1;
    }
  }

  return ks;
});
module.exports = keys;

/***/ }),

/***/ 57046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var mergeDeepWithKey =
/*#__PURE__*/
__webpack_require__(39036);
/**
 * Creates a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects:
 * - and both values are objects, the two values will be recursively merged
 * - otherwise the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig {a} -> {a} -> {a}
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
 * @example
 *
 *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
 *                       { age: 40, contact: { email: 'baa@example.com' }});
 *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
 */


var mergeDeepRight =
/*#__PURE__*/
_curry2(function mergeDeepRight(lObj, rObj) {
  return mergeDeepWithKey(function (k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});

module.exports = mergeDeepRight;

/***/ }),

/***/ 39036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _isObject =
/*#__PURE__*/
__webpack_require__(8291);

var mergeWithKey =
/*#__PURE__*/
__webpack_require__(56027);
/**
 * Creates a new object with the own properties of the two provided objects.
 * If a key exists in both objects:
 * - and both associated values are also objects then the values will be
 *   recursively merged.
 * - otherwise the provided function is applied to the key and associated values
 *   using the resulting value as the new value associated with the key.
 * If a key only exists in one object, the value will be associated with the key
 * of the resulting object.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} lObj
 * @param {Object} rObj
 * @return {Object}
 * @see R.mergeWithKey, R.mergeDeepWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeDeepWithKey(concatValues,
 *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
 *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
 *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
 */


var mergeDeepWithKey =
/*#__PURE__*/
_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
  return mergeWithKey(function (k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey(fn, lVal, rVal);
    } else {
      return fn(k, lVal, rVal);
    }
  }, lObj, rObj);
});

module.exports = mergeDeepWithKey;

/***/ }),

/***/ 56027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _has =
/*#__PURE__*/
__webpack_require__(87684);
/**
 * Creates a new object with the own properties of the two provided objects. If
 * a key exists in both objects, the provided function is applied to the key
 * and the values associated with the key in each object, with the result being
 * used as the value associated with the key in the returned object.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category Object
 * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
 * @param {Function} fn
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeDeepWithKey, R.merge, R.mergeWith
 * @example
 *
 *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
 *      R.mergeWithKey(concatValues,
 *                     { a: true, thing: 'foo', values: [10, 20] },
 *                     { b: true, thing: 'bar', values: [15, 35] });
 *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
 * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
 */


var mergeWithKey =
/*#__PURE__*/
_curry3(function mergeWithKey(fn, l, r) {
  var result = {};
  var k;

  for (k in l) {
    if (_has(k, l)) {
      result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
    }
  }

  for (k in r) {
    if (_has(k, r) && !_has(k, result)) {
      result[k] = r[k];
    }
  }

  return result;
});

module.exports = mergeWithKey;

/***/ }),

/***/ 4603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _arity =
/*#__PURE__*/
__webpack_require__(7455);

var _pipe =
/*#__PURE__*/
__webpack_require__(56015);

var reduce =
/*#__PURE__*/
__webpack_require__(20793);

var tail =
/*#__PURE__*/
__webpack_require__(43656);
/**
 * Performs left-to-right function composition. The first argument may have
 * any arity; the remaining arguments must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      const f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */


function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }

  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
}

module.exports = pipe;

/***/ }),

/***/ 18371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var equals =
/*#__PURE__*/
__webpack_require__(51481);
/**
 * Returns `true` if the specified object property is equal, in
 * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
 * You can test multiple properties with [`R.whereEq`](#whereEq).
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.whereEq, R.propSatisfies, R.equals
 * @example
 *
 *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      const kids = [abby, fred, rusty, alois];
 *      const hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */


var propEq =
/*#__PURE__*/
_curry3(function propEq(name, val, obj) {
  return equals(val, obj[name]);
});

module.exports = propEq;

/***/ }),

/***/ 20793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);

var _reduce =
/*#__PURE__*/
__webpack_require__(39488);
/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */


var reduce =
/*#__PURE__*/
_curry3(_reduce);

module.exports = reduce;

/***/ }),

/***/ 63266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _complement =
/*#__PURE__*/
__webpack_require__(48770);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var filter =
/*#__PURE__*/
__webpack_require__(51383);
/**
 * The complement of [`filter`](#filter).
 *
 * Acts as a transducer if a transformer is given in list position. Filterable
 * objects include plain objects or any object that has a filter method such
 * as `Array`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      const isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */


var reject =
/*#__PURE__*/
_curry2(function reject(pred, filterable) {
  return filter(_complement(pred), filterable);
});

module.exports = reject;

/***/ }),

/***/ 65814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var _isString =
/*#__PURE__*/
__webpack_require__(20190);
/**
 * Returns a new list or string with the elements or characters in reverse
 * order.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {Array|String} list
 * @return {Array|String}
 * @example
 *
 *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
 *      R.reverse([1, 2]);     //=> [2, 1]
 *      R.reverse([1]);        //=> [1]
 *      R.reverse([]);         //=> []
 *
 *      R.reverse('abc');      //=> 'cba'
 *      R.reverse('ab');       //=> 'ba'
 *      R.reverse('a');        //=> 'a'
 *      R.reverse('');         //=> ''
 */


var reverse =
/*#__PURE__*/
_curry1(function reverse(list) {
  return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
});

module.exports = reverse;

/***/ }),

/***/ 81753:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(73542);

var _curry3 =
/*#__PURE__*/
__webpack_require__(16370);
/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */


var slice =
/*#__PURE__*/
_curry3(
/*#__PURE__*/
_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

module.exports = slice;

/***/ }),

/***/ 59241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var slice =
/*#__PURE__*/
__webpack_require__(81753);
/**
 * Splits a collection into slices of the specified length.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig Number -> [a] -> [[a]]
 * @sig Number -> String -> [String]
 * @param {Number} n
 * @param {Array} list
 * @return {Array}
 * @example
 *
 *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
 *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
 */


var splitEvery =
/*#__PURE__*/
_curry2(function splitEvery(n, list) {
  if (n <= 0) {
    throw new Error('First argument to splitEvery must be a positive integer');
  }

  var result = [];
  var idx = 0;

  while (idx < list.length) {
    result.push(slice(idx, idx += n, list));
  }

  return result;
});

module.exports = splitEvery;

/***/ }),

/***/ 43656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(73542);

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);

var slice =
/*#__PURE__*/
__webpack_require__(81753);
/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */


var tail =
/*#__PURE__*/
_curry1(
/*#__PURE__*/
_checkForMethod('tail',
/*#__PURE__*/
slice(1, Infinity)));

module.exports = tail;

/***/ }),

/***/ 32250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Calls an input function `n` times, returning an array containing the results
 * of those function calls.
 *
 * `fn` is passed one argument: The current value of `n`, which begins at `0`
 * and is gradually incremented to `n - 1`.
 *
 * @func
 * @memberOf R
 * @since v0.2.3
 * @category List
 * @sig (Number -> a) -> Number -> [a]
 * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
 * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
 * @return {Array} An array containing the return values of all calls to `fn`.
 * @see R.repeat
 * @example
 *
 *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
 * @symb R.times(f, 0) = []
 * @symb R.times(f, 1) = [f(0)]
 * @symb R.times(f, 2) = [f(0), f(1)]
 */


var times =
/*#__PURE__*/
_curry2(function times(fn, n) {
  var len = Number(n);
  var idx = 0;
  var list;

  if (len < 0 || isNaN(len)) {
    throw new RangeError('n must be a non-negative number');
  }

  list = new Array(len);

  while (idx < len) {
    list[idx] = fn(idx);
    idx += 1;
  }

  return list;
});

module.exports = times;

/***/ }),

/***/ 36433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _curry1 =
/*#__PURE__*/
__webpack_require__(76224);
/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */


var type =
/*#__PURE__*/
_curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

module.exports = type;

/***/ }),

/***/ 30275:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _concat =
/*#__PURE__*/
__webpack_require__(14011);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var compose =
/*#__PURE__*/
__webpack_require__(50557);

var uniq =
/*#__PURE__*/
__webpack_require__(90086);
/**
 * Combines two lists into a set (i.e. no duplicates) composed of the elements
 * of each list.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig [*] -> [*] -> [*]
 * @param {Array} as The first list.
 * @param {Array} bs The second list.
 * @return {Array} The first and second lists concatenated, with
 *         duplicates removed.
 * @example
 *
 *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
 */


var union =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
compose(uniq, _concat));

module.exports = union;

/***/ }),

/***/ 90086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity =
/*#__PURE__*/
__webpack_require__(69105);

var uniqBy =
/*#__PURE__*/
__webpack_require__(54025);
/**
 * Returns a new list containing only one copy of each element in the original
 * list. [`R.equals`](#equals) is used to determine equality.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
 *      R.uniq([1, '1']);     //=> [1, '1']
 *      R.uniq([[42], [42]]); //=> [[42]]
 */


var uniq =
/*#__PURE__*/
uniqBy(identity);
module.exports = uniq;

/***/ }),

/***/ 54025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Set =
/*#__PURE__*/
__webpack_require__(8876);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);
/**
 * Returns a new list containing only one copy of each element in the original
 * list, based upon the value returned by applying the supplied function to
 * each list element. Prefers the first item if the supplied function produces
 * the same value on two items. [`R.equals`](#equals) is used for comparison.
 *
 * @func
 * @memberOf R
 * @since v0.16.0
 * @category List
 * @sig (a -> b) -> [a] -> [a]
 * @param {Function} fn A function used to produce a value to use during comparisons.
 * @param {Array} list The array to consider.
 * @return {Array} The list of unique items.
 * @example
 *
 *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
 */


var uniqBy =
/*#__PURE__*/
_curry2(function uniqBy(fn, list) {
  var set = new _Set();
  var result = [];
  var idx = 0;
  var appliedItem, item;

  while (idx < list.length) {
    item = list[idx];
    appliedItem = fn(item);

    if (set.add(appliedItem)) {
      result.push(item);
    }

    idx += 1;
  }

  return result;
});

module.exports = uniqBy;

/***/ }),

/***/ 76290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _includes =
/*#__PURE__*/
__webpack_require__(87243);

var _curry2 =
/*#__PURE__*/
__webpack_require__(79002);

var flip =
/*#__PURE__*/
__webpack_require__(9134);

var reject =
/*#__PURE__*/
__webpack_require__(63266);
/**
 * Returns a new list without values in the first argument.
 * [`R.equals`](#equals) is used to determine equality.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.19.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @param {Array} list1 The values to be removed from `list2`.
 * @param {Array} list2 The array to remove values from.
 * @return {Array} The new array without values in `list1`.
 * @see R.transduce, R.difference, R.remove
 * @example
 *
 *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
 */


var without =
/*#__PURE__*/
_curry2(function (xs, list) {
  return reject(flip(_includes)(xs), list);
});

module.exports = without;

/***/ }),

/***/ 67287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** @license React v0.24.0
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports = function $$$reconciler($$$hostConfig) {
'use strict';var aa=__webpack_require__(27418),ba=__webpack_require__(67294),m=__webpack_require__(60373);function n(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var q=ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
q.hasOwnProperty("ReactCurrentDispatcher")||(q.ReactCurrentDispatcher={current:null});q.hasOwnProperty("ReactCurrentBatchConfig")||(q.ReactCurrentBatchConfig={suspense:null});
var u="function"===typeof Symbol&&Symbol.for,ca=u?Symbol.for("react.element"):60103,da=u?Symbol.for("react.portal"):60106,ea=u?Symbol.for("react.fragment"):60107,fa=u?Symbol.for("react.strict_mode"):60108,ha=u?Symbol.for("react.profiler"):60114,ia=u?Symbol.for("react.provider"):60109,ja=u?Symbol.for("react.context"):60110,ka=u?Symbol.for("react.concurrent_mode"):60111,la=u?Symbol.for("react.forward_ref"):60112,ma=u?Symbol.for("react.suspense"):60113,na=u?Symbol.for("react.suspense_list"):60120,oa=
u?Symbol.for("react.memo"):60115,pa=u?Symbol.for("react.lazy"):60116;u&&Symbol.for("react.fundamental");u&&Symbol.for("react.responder");u&&Symbol.for("react.scope");var qa="function"===typeof Symbol&&Symbol.iterator;function ra(a){if(null===a||"object"!==typeof a)return null;a=qa&&a[qa]||a["@@iterator"];return"function"===typeof a?a:null}
function sa(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}
function ta(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ea:return"Fragment";case da:return"Portal";case ha:return"Profiler";case fa:return"StrictMode";case ma:return"Suspense";case na:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case ja:return"Context.Consumer";case ia:return"Context.Provider";case la:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
"ForwardRef");case oa:return ta(a.type);case pa:if(a=1===a._status?a._result:null)return ta(a)}return null}function ua(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function va(a){if(ua(a)!==a)throw Error(n(188));}
function wa(a){var b=a.alternate;if(!b){b=ua(a);if(null===b)throw Error(n(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return va(e),a;if(f===d)return va(e),b;f=f.sibling}throw Error(n(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,l=e.child;l;){if(l===c){g=!0;c=e;d=f;break}if(l===d){g=!0;d=e;c=f;break}l=l.sibling}if(!g){for(l=f.child;l;){if(l===
c){g=!0;c=f;d=e;break}if(l===d){g=!0;d=f;c=e;break}l=l.sibling}if(!g)throw Error(n(189));}}if(c.alternate!==d)throw Error(n(190));}if(3!==c.tag)throw Error(n(188));return c.stateNode.current===c?a:b}function xa(a){a=wa(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
function ya(a){a=wa(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
var za=$$$hostConfig.getPublicInstance,Aa=$$$hostConfig.getRootHostContext,Ba=$$$hostConfig.getChildHostContext,Ca=$$$hostConfig.prepareForCommit,Da=$$$hostConfig.resetAfterCommit,Ea=$$$hostConfig.createInstance,Fa=$$$hostConfig.appendInitialChild,Ga=$$$hostConfig.finalizeInitialChildren,Ia=$$$hostConfig.prepareUpdate,Ja=$$$hostConfig.shouldSetTextContent,Ka=$$$hostConfig.shouldDeprioritizeSubtree,La=$$$hostConfig.createTextInstance,Ma=$$$hostConfig.setTimeout,Na=$$$hostConfig.clearTimeout,Oa=$$$hostConfig.noTimeout,
Pa=$$$hostConfig.isPrimaryRenderer,Qa=$$$hostConfig.supportsMutation,Ra=$$$hostConfig.supportsPersistence,Sa=$$$hostConfig.supportsHydration,Ta=$$$hostConfig.appendChild,Ua=$$$hostConfig.appendChildToContainer,Va=$$$hostConfig.commitTextUpdate,Wa=$$$hostConfig.commitMount,Xa=$$$hostConfig.commitUpdate,Ya=$$$hostConfig.insertBefore,Za=$$$hostConfig.insertInContainerBefore,$a=$$$hostConfig.removeChild,ab=$$$hostConfig.removeChildFromContainer,bb=$$$hostConfig.resetTextContent,cb=$$$hostConfig.hideInstance,
db=$$$hostConfig.hideTextInstance,eb=$$$hostConfig.unhideInstance,fb=$$$hostConfig.unhideTextInstance,gb=$$$hostConfig.cloneInstance,hb=$$$hostConfig.createContainerChildSet,ib=$$$hostConfig.appendChildToContainerChildSet,kb=$$$hostConfig.finalizeContainerChildren,lb=$$$hostConfig.replaceContainerChildren,mb=$$$hostConfig.cloneHiddenInstance,nb=$$$hostConfig.cloneHiddenTextInstance,ob=$$$hostConfig.canHydrateInstance,pb=$$$hostConfig.canHydrateTextInstance,qb=$$$hostConfig.isSuspenseInstancePending,
rb=$$$hostConfig.isSuspenseInstanceFallback,sb=$$$hostConfig.getNextHydratableSibling,tb=$$$hostConfig.getFirstHydratableChild,ub=$$$hostConfig.hydrateInstance,vb=$$$hostConfig.hydrateTextInstance,wb=$$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,xb=$$$hostConfig.commitHydratedContainer,yb=$$$hostConfig.commitHydratedSuspenseInstance,zb=/^(.*)[\\\/]/;
function Ab(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=ta(a.type);c=null;d&&(c=ta(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(zb,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}new Set;var Bb=[],Cb=-1;function y(a){0>Cb||(a.current=Bb[Cb],Bb[Cb]=null,Cb--)}function z(a,b){Cb++;Bb[Cb]=a.current;a.current=b}
var Db={},A={current:Db},B={current:!1},Eb=Db;function Fb(a,b){var c=a.type.contextTypes;if(!c)return Db;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function C(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gb(a){y(B,a);y(A,a)}
function Hb(a){y(B,a);y(A,a)}function Ib(a,b,c){if(A.current!==Db)throw Error(n(168));z(A,b,a);z(B,c,a)}function Jb(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(n(108,ta(b)||"Unknown",e));return aa({},c,{},d)}function Kb(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||Db;Eb=A.current;z(A,b,a);z(B,B.current,a);return!0}
function Lb(a,b,c){var d=a.stateNode;if(!d)throw Error(n(169));c?(b=Jb(a,b,Eb),d.__reactInternalMemoizedMergedChildContext=b,y(B,a),y(A,a),z(A,b,a)):y(B,a);z(B,c,a)}
var Mb=m.unstable_runWithPriority,Nb=m.unstable_scheduleCallback,Ob=m.unstable_cancelCallback,Pb=m.unstable_shouldYield,Qb=m.unstable_requestPaint,Rb=m.unstable_now,Ub=m.unstable_getCurrentPriorityLevel,Vb=m.unstable_ImmediatePriority,Wb=m.unstable_UserBlockingPriority,Xb=m.unstable_NormalPriority,Yb=m.unstable_LowPriority,Zb=m.unstable_IdlePriority,$b={},ac=void 0!==Qb?Qb:function(){},bc=null,cc=null,dc=!1,ec=Rb(),E=1E4>ec?Rb:function(){return Rb()-ec};
function fc(){switch(Ub()){case Vb:return 99;case Wb:return 98;case Xb:return 97;case Yb:return 96;case Zb:return 95;default:throw Error(n(332));}}function gc(a){switch(a){case 99:return Vb;case 98:return Wb;case 97:return Xb;case 96:return Yb;case 95:return Zb;default:throw Error(n(332));}}function hc(a,b){a=gc(a);return Mb(a,b)}function ic(a,b,c){a=gc(a);return Nb(a,b,c)}function jc(a){null===bc?(bc=[a],cc=Nb(Vb,kc)):bc.push(a);return $b}function F(){if(null!==cc){var a=cc;cc=null;Ob(a)}kc()}
function kc(){if(!dc&&null!==bc){dc=!0;var a=0;try{var b=bc;hc(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});bc=null}catch(c){throw null!==bc&&(bc=bc.slice(a+1)),Nb(Vb,F),c;}finally{dc=!1}}}var lc=3;function mc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function nc(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var oc="function"===typeof Object.is?Object.is:nc,pc=Object.prototype.hasOwnProperty;
function qc(a,b){if(oc(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!pc.call(b,c[d])||!oc(a[c[d]],b[c[d]]))return!1;return!0}function rc(a,b){if(a&&a.defaultProps){b=aa({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}var sc={current:null},tc=null,uc=null,vc=null;function wc(){vc=uc=tc=null}
function xc(a,b){var c=a.type._context;Pa?(z(sc,c._currentValue,a),c._currentValue=b):(z(sc,c._currentValue2,a),c._currentValue2=b)}function yc(a){var b=sc.current;y(sc,a);a=a.type._context;Pa?a._currentValue=b:a._currentValue2=b}function zc(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}
function Ac(a,b){tc=a;vc=uc=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(Bc=!0),a.firstContext=null)}function Cc(a,b){if(vc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)vc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===uc){if(null===tc)throw Error(n(308));uc=b;tc.dependencies={expirationTime:0,firstContext:b,responders:null}}else uc=uc.next=b}return Pa?a._currentValue:a._currentValue2}var Dc=!1;
function Ec(a){return{baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function Fc(a){return{baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
function Gc(a,b){return{expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null,nextEffect:null}}function Hc(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b)}
function Ic(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=Ec(a.memoizedState))}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=Ec(a.memoizedState),e=c.updateQueue=Ec(c.memoizedState)):d=a.updateQueue=Fc(e):null===e&&(e=c.updateQueue=Fc(d));null===e||d===e?Hc(d,b):null===d.lastUpdate||null===e.lastUpdate?(Hc(d,b),Hc(e,b)):(Hc(d,b),e.lastUpdate=b)}
function Jc(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=Ec(a.memoizedState):Kc(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b)}function Kc(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=Fc(b));return b}
function Lc(a,b,c,d,e,f){switch(c.tag){case 1:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case 3:a.effectTag=a.effectTag&-4097|64;case 0:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return aa({},d,e);case 2:Dc=!0}return d}
function Nc(a,b,c,d,e){Dc=!1;b=Kc(a,b);for(var f=b.baseState,g=null,l=0,h=b.firstUpdate,k=f;null!==h;){var p=h.expirationTime;p<e?(null===g&&(g=h,f=k),l<p&&(l=p)):(Oc(p,h.suspenseConfig),k=Lc(a,b,h,k,c,d),null!==h.callback&&(a.effectTag|=32,h.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=h:(b.lastEffect.nextEffect=h,b.lastEffect=h)));h=h.next}p=null;for(h=b.firstCapturedUpdate;null!==h;){var D=h.expirationTime;D<e?(null===p&&(p=h,null===g&&(f=k)),l<D&&(l=D)):(k=Lc(a,b,h,k,c,d),null!==
h.callback&&(a.effectTag|=32,h.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=h:(b.lastCapturedEffect.nextEffect=h,b.lastCapturedEffect=h)));h=h.next}null===g&&(b.lastUpdate=null);null===p?b.lastCapturedUpdate=null:a.effectTag|=32;null===g&&null===p&&(f=k);b.baseState=f;b.firstUpdate=g;b.firstCapturedUpdate=p;Pc(l);a.expirationTime=l;a.memoizedState=k}
function Qc(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);Rc(b.firstEffect,c);b.firstEffect=b.lastEffect=null;Rc(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null}function Rc(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;if("function"!==typeof c)throw Error(n(191,c));c.call(d)}a=a.nextEffect}}
var Sc=q.ReactCurrentBatchConfig,Tc=(new ba.Component).refs;function Uc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:aa({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c)}
var Xc={isMounted:function(a){return(a=a._reactInternalFiber)?ua(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=G(),e=Sc.suspense;d=Vc(d,a,e);e=Gc(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Ic(a,e);Wc(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=G(),e=Sc.suspense;d=Vc(d,a,e);e=Gc(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Ic(a,e);Wc(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=G(),d=Sc.suspense;
c=Vc(c,a,d);d=Gc(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);Ic(a,d);Wc(a,c)}};function Yc(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!qc(c,d)||!qc(e,f):!0}
function Zc(a,b,c){var d=!1,e=Db;var f=b.contextType;"object"===typeof f&&null!==f?f=Cc(f):(e=C(b)?Eb:A.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Fb(a,e):Db);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Xc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function $c(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Xc.enqueueReplaceState(b,b.state,null)}
function ad(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Tc;var f=b.contextType;"object"===typeof f&&null!==f?e.context=Cc(f):(f=C(b)?Eb:A.current,e.context=Fb(a,f));f=a.updateQueue;null!==f&&(Nc(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(Uc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==
typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Xc.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(Nc(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var bd=Array.isArray;
function cd(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(n(309));var d=c.stateNode}if(!d)throw Error(n(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(b){var a=d.refs;a===Tc&&(a=d.refs={});null===b?delete a[e]:a[e]=b};b._stringRef=e;return b}if("string"!==typeof a)throw Error(n(284));if(!c._owner)throw Error(n(290,a));}return a}
function dd(a,b){if("textarea"!==a.type)throw Error(n(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
function ed(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(b,a){for(b=new Map;null!==a;)null!==a.key?b.set(a.key,a):b.set(a.index,a),a=a.sibling;return b}function e(b,a,c){b=fd(b,a,c);b.index=0;b.sibling=null;return b}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function l(b,a,c,d){if(null===a||6!==a.tag)return a=gd(c,b.mode,d),a.return=b,a;a=e(a,c,d);a.return=b;return a}function h(b,a,c,d){if(null!==a&&a.elementType===c.type)return d=e(a,c.props,d),d.ref=cd(b,a,c),d.return=b,d;d=hd(c.type,c.key,c.props,null,b.mode,d);d.ref=cd(b,a,c);d.return=b;return d}function k(b,a,c,d){if(null===a||4!==a.tag||a.stateNode.containerInfo!==c.containerInfo||a.stateNode.implementation!==
c.implementation)return a=id(c,b.mode,d),a.return=b,a;a=e(a,c.children||[],d);a.return=b;return a}function p(b,a,c,d,f){if(null===a||7!==a.tag)return a=jd(c,b.mode,d,f),a.return=b,a;a=e(a,c,d);a.return=b;return a}function D(b,a,c){if("string"===typeof a||"number"===typeof a)return a=gd(""+a,b.mode,c),a.return=b,a;if("object"===typeof a&&null!==a){switch(a.$$typeof){case ca:return c=hd(a.type,a.key,a.props,null,b.mode,c),c.ref=cd(b,null,a),c.return=b,c;case da:return a=id(a,b.mode,c),a.return=b,a}if(bd(a)||
ra(a))return a=jd(a,b.mode,c,null),a.return=b,a;dd(b,a)}return null}function x(b,a,c,d){var e=null!==a?a.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:l(b,a,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case ca:return c.key===e?c.type===ea?p(b,a,c.props.children,d,e):h(b,a,c,d):null;case da:return c.key===e?k(b,a,c,d):null}if(bd(c)||ra(c))return null!==e?null:p(b,a,c,d,null);dd(b,c)}return null}function K(b,a,c,d,e){if("string"===typeof d||"number"===typeof d)return b=
b.get(c)||null,l(a,b,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case ca:return b=b.get(null===d.key?c:d.key)||null,d.type===ea?p(a,b,d.props.children,e,d.key):h(a,b,d,e);case da:return b=b.get(null===d.key?c:d.key)||null,k(a,b,d,e)}if(bd(d)||ra(d))return b=b.get(c)||null,p(a,b,d,e,null);dd(a,d)}return null}function Ha(e,g,h,l){for(var k=null,w=null,t=g,r=g=0,p=null;null!==t&&r<h.length;r++){t.index>r?(p=t,t=null):p=t.sibling;var v=x(e,t,h[r],l);if(null===v){null===t&&(t=p);break}a&&
t&&null===v.alternate&&b(e,t);g=f(v,g,r);null===w?k=v:w.sibling=v;w=v;t=p}if(r===h.length)return c(e,t),k;if(null===t){for(;r<h.length;r++)t=D(e,h[r],l),null!==t&&(g=f(t,g,r),null===w?k=t:w.sibling=t,w=t);return k}for(t=d(e,t);r<h.length;r++)p=K(t,e,r,h[r],l),null!==p&&(a&&null!==p.alternate&&t.delete(null===p.key?r:p.key),g=f(p,g,r),null===w?k=p:w.sibling=p,w=p);a&&t.forEach(function(a){return b(e,a)});return k}function O(e,g,h,l){var k=ra(h);if("function"!==typeof k)throw Error(n(150));h=k.call(h);
if(null==h)throw Error(n(151));for(var t=k=null,r=g,w=g=0,p=null,v=h.next();null!==r&&!v.done;w++,v=h.next()){r.index>w?(p=r,r=null):p=r.sibling;var N=x(e,r,v.value,l);if(null===N){null===r&&(r=p);break}a&&r&&null===N.alternate&&b(e,r);g=f(N,g,w);null===t?k=N:t.sibling=N;t=N;r=p}if(v.done)return c(e,r),k;if(null===r){for(;!v.done;w++,v=h.next())v=D(e,v.value,l),null!==v&&(g=f(v,g,w),null===t?k=v:t.sibling=v,t=v);return k}for(r=d(e,r);!v.done;w++,v=h.next())v=K(r,e,w,v.value,l),null!==v&&(a&&null!==
v.alternate&&r.delete(null===v.key?w:v.key),g=f(v,g,w),null===t?k=v:t.sibling=v,t=v);a&&r.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ea&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case ca:a:{l=f.key;for(k=d;null!==k;){if(k.key===l)if(7===k.tag?f.type===ea:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===ea?f.props.children:f.props,h);d.ref=cd(a,k,f);d.return=a;a=d;break a}else{c(a,
k);break}else b(a,k);k=k.sibling}f.type===ea?(d=jd(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=hd(f.type,f.key,f.props,null,a.mode,h),h.ref=cd(a,d,f),h.return=a,a=h)}return g(a);case da:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=id(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===
typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h),d.return=a,a=d):(c(a,d),d=gd(f,a.mode,h),d.return=a,a=d),g(a);if(bd(f))return Ha(a,d,f,h);if(ra(f))return O(a,d,f,h);l&&dd(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(n(152,a.displayName||a.name||"Component"));}return c(a,d)}}var kd=ed(!0),ld=ed(!1),md={},H={current:md},nd={current:md},od={current:md};function pd(a){if(a===md)throw Error(n(174));return a}
function qd(a,b){z(od,b,a);z(nd,a,a);z(H,md,a);b=Aa(b);y(H,a);z(H,b,a)}function rd(a){y(H,a);y(nd,a);y(od,a)}function sd(a){var b=pd(od.current),c=pd(H.current);b=Ba(c,a.type,b);c!==b&&(z(nd,a,a),z(H,b,a))}function td(a){nd.current===a&&(y(H,a),y(nd,a))}var I={current:0};
function ud(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||qb(c)||rb(c)))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function vd(a,b){return{responder:a,props:b}}
var wd=q.ReactCurrentDispatcher,J=q.ReactCurrentBatchConfig,xd=0,yd=null,L=null,zd=null,Ad=null,M=null,Bd=null,Cd=0,Dd=null,Ed=0,Fd=!1,Gd=null,Hd=0;function P(){throw Error(n(321));}function Id(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!oc(a[c],b[c]))return!1;return!0}
function Jd(a,b,c,d,e,f){xd=f;yd=b;zd=null!==a?a.memoizedState:null;wd.current=null===zd?Kd:Ld;b=c(d,e);if(Fd){do Fd=!1,Hd+=1,zd=null!==a?a.memoizedState:null,Bd=Ad,Dd=M=L=null,wd.current=Ld,b=c(d,e);while(Fd);Gd=null;Hd=0}wd.current=Md;a=yd;a.memoizedState=Ad;a.expirationTime=Cd;a.updateQueue=Dd;a.effectTag|=Ed;a=null!==L&&null!==L.next;xd=0;Bd=M=Ad=zd=L=yd=null;Cd=0;Dd=null;Ed=0;if(a)throw Error(n(300));return b}
function Nd(){wd.current=Md;xd=0;Bd=M=Ad=zd=L=yd=null;Cd=0;Dd=null;Ed=0;Fd=!1;Gd=null;Hd=0}function Od(){var a={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};null===M?Ad=M=a:M=M.next=a;return M}function Pd(){if(null!==Bd)M=Bd,Bd=M.next,L=zd,zd=null!==L?L.next:null;else{if(null===zd)throw Error(n(310));L=zd;var a={memoizedState:L.memoizedState,baseState:L.baseState,queue:L.queue,baseUpdate:L.baseUpdate,next:null};M=null===M?Ad=a:M.next=a;zd=L.next}return M}
function Qd(a,b){return"function"===typeof b?b(a):b}
function Rd(a){var b=Pd(),c=b.queue;if(null===c)throw Error(n(311));c.lastRenderedReducer=a;if(0<Hd){var d=c.dispatch;if(null!==Gd){var e=Gd.get(c);if(void 0!==e){Gd.delete(c);var f=b.memoizedState;do f=a(f,e.action),e=e.next;while(null!==e);oc(f,b.memoizedState)||(Bc=!0);b.memoizedState=f;b.baseUpdate===c.last&&(b.baseState=f);c.lastRenderedState=f;return[f,d]}}return[b.memoizedState,d]}d=c.last;var g=b.baseUpdate;f=b.baseState;null!==g?(null!==d&&(d.next=null),d=g.next):d=null!==d?d.next:null;if(null!==
d){var l=e=null,h=d,k=!1;do{var p=h.expirationTime;p<xd?(k||(k=!0,l=g,e=f),p>Cd&&(Cd=p,Pc(Cd))):(Oc(p,h.suspenseConfig),f=h.eagerReducer===a?h.eagerState:a(f,h.action));g=h;h=h.next}while(null!==h&&h!==d);k||(l=g,e=f);oc(f,b.memoizedState)||(Bc=!0);b.memoizedState=f;b.baseUpdate=l;b.baseState=e;c.lastRenderedState=f}return[b.memoizedState,c.dispatch]}
function Sd(a){var b=Od();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={last:null,dispatch:null,lastRenderedReducer:Qd,lastRenderedState:a};a=a.dispatch=Td.bind(null,yd,a);return[b.memoizedState,a]}function Ud(a){return Rd(Qd,a)}function Vd(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};null===Dd?(Dd={lastEffect:null},Dd.lastEffect=a.next=a):(b=Dd.lastEffect,null===b?Dd.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,Dd.lastEffect=a));return a}
function Wd(a,b,c,d){var e=Od();Ed|=a;e.memoizedState=Vd(b,c,void 0,void 0===d?null:d)}function Xd(a,b,c,d){var e=Pd();d=void 0===d?null:d;var f=void 0;if(null!==L){var g=L.memoizedState;f=g.destroy;if(null!==d&&Id(d,g.deps)){Vd(0,c,f,d);return}}Ed|=a;e.memoizedState=Vd(b,c,f,d)}function Yd(a,b){return Wd(516,192,a,b)}function Zd(a,b){return Xd(516,192,a,b)}
function $d(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function ae(){}function be(a,b){Od().memoizedState=[a,void 0===b?null:b];return a}function ce(a,b){var c=Pd();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Id(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function Td(a,b,c){if(!(25>Hd))throw Error(n(301));var d=a.alternate;if(a===yd||null!==d&&d===yd)if(Fd=!0,a={expirationTime:xd,suspenseConfig:null,action:c,eagerReducer:null,eagerState:null,next:null},null===Gd&&(Gd=new Map),c=Gd.get(b),void 0===c)Gd.set(b,a);else{for(b=c;null!==b.next;)b=b.next;b.next=a}else{var e=G(),f=Sc.suspense;e=Vc(e,a,f);f={expirationTime:e,suspenseConfig:f,action:c,eagerReducer:null,eagerState:null,next:null};var g=b.last;if(null===g)f.next=f;else{var l=g.next;null!==l&&(f.next=
l);g.next=f}b.last=f;if(0===a.expirationTime&&(null===d||0===d.expirationTime)&&(d=b.lastRenderedReducer,null!==d))try{var h=b.lastRenderedState,k=d(h,c);f.eagerReducer=d;f.eagerState=k;if(oc(k,h))return}catch(p){}finally{}Wc(a,e)}}
var Md={readContext:Cc,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useResponder:P,useDeferredValue:P,useTransition:P},Kd={readContext:Cc,useCallback:be,useContext:Cc,useEffect:Yd,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Wd(4,36,$d.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Wd(4,36,a,b)},useMemo:function(a,b){var c=Od();b=void 0===b?null:b;a=a();c.memoizedState=
[a,b];return a},useReducer:function(a,b,c){var d=Od();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={last:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Td.bind(null,yd,a);return[d.memoizedState,a]},useRef:function(a){var b=Od();a={current:a};return b.memoizedState=a},useState:Sd,useDebugValue:ae,useResponder:vd,useDeferredValue:function(a,b){var c=Sd(a),d=c[0],e=c[1];Yd(function(){m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===b?null:b;try{e(a)}finally{J.suspense=
c}})},[a,b]);return d},useTransition:function(a){var b=Sd(!1),c=b[0],d=b[1];return[be(function(b){d(!0);m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===a?null:a;try{d(!1),b()}finally{J.suspense=c}})},[a,c]),c]}},Ld={readContext:Cc,useCallback:ce,useContext:Cc,useEffect:Zd,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Xd(4,36,$d.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Xd(4,36,a,b)},useMemo:function(a,b){var c=Pd();b=void 0===b?
null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Id(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a},useReducer:Rd,useRef:function(){return Pd().memoizedState},useState:Ud,useDebugValue:ae,useResponder:vd,useDeferredValue:function(a,b){var c=Ud(a),d=c[0],e=c[1];Zd(function(){m.unstable_next(function(){var c=J.suspense;J.suspense=void 0===b?null:b;try{e(a)}finally{J.suspense=c}})},[a,b]);return d},useTransition:function(a){var b=Ud(!1),c=b[0],d=b[1];return[ce(function(b){d(!0);m.unstable_next(function(){var c=
J.suspense;J.suspense=void 0===a?null:a;try{d(!1),b()}finally{J.suspense=c}})},[a,c]),c]}},de=null,ee=null,fe=!1;function ge(a,b){var c=he(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}
function ie(a,b){switch(a.tag){case 5:return b=ob(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=pb(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function je(a){if(fe){var b=ee;if(b){var c=b;if(!ie(a,b)){b=sb(c);if(!b||!ie(a,b)){a.effectTag=a.effectTag&-1025|2;fe=!1;de=a;return}ge(de,c)}de=a;ee=tb(b)}else a.effectTag=a.effectTag&-1025|2,fe=!1,de=a}}
function ke(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;de=a}function ne(a){if(!Sa||a!==de)return!1;if(!fe)return ke(a),fe=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Ja(b,a.memoizedProps))for(b=ee;b;)ge(a,b),b=sb(b);ke(a);if(13===a.tag){if(!Sa)throw Error(n(316));a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(n(317));ee=wb(a)}else ee=de?sb(a.stateNode):null;return!0}function oe(){Sa&&(ee=de=null,fe=!1)}var pe=q.ReactCurrentOwner,Bc=!1;
function Q(a,b,c,d){b.child=null===a?ld(b,null,c,d):kd(b,a.child,c,d)}function qe(a,b,c,d,e){c=c.render;var f=b.ref;Ac(b,e);d=Jd(a,b,c,d,f,e);if(null!==a&&!Bc)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),re(a,b,e);b.effectTag|=1;Q(a,b,d,e);return b.child}
function se(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!te(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ue(a,b,g,d,e,f);a=hd(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:qc,c(e,d)&&a.ref===b.ref))return re(a,b,f);b.effectTag|=1;a=fd(g,d,f);a.ref=b.ref;a.return=b;return b.child=a}
function ue(a,b,c,d,e,f){return null!==a&&qc(a.memoizedProps,d)&&a.ref===b.ref&&(Bc=!1,e<f)?re(a,b,f):ve(a,b,c,d,f)}function we(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function ve(a,b,c,d,e){var f=C(c)?Eb:A.current;f=Fb(b,f);Ac(b,e);c=Jd(a,b,c,d,f,e);if(null!==a&&!Bc)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),re(a,b,e);b.effectTag|=1;Q(a,b,c,e);return b.child}
function xe(a,b,c,d,e){if(C(c)){var f=!0;Kb(b)}else f=!1;Ac(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Zc(b,c,d,e),ad(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,l=b.memoizedProps;g.props=l;var h=g.context,k=c.contextType;"object"===typeof k&&null!==k?k=Cc(k):(k=C(c)?Eb:A.current,k=Fb(b,k));var p=c.getDerivedStateFromProps,D="function"===typeof p||"function"===typeof g.getSnapshotBeforeUpdate;D||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(l!==d||h!==k)&&$c(b,g,d,k);Dc=!1;var x=b.memoizedState;h=g.state=x;var K=b.updateQueue;null!==K&&(Nc(b,K,d,g,e),h=b.memoizedState);l!==d||x!==h||B.current||Dc?("function"===typeof p&&(Uc(b,c,p,d),h=b.memoizedState),(l=Dc||Yc(b,c,l,d,x,h,k))?(D||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&
g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=h),g.props=d,g.state=h,g.context=k,d=l):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,l=b.memoizedProps,g.props=b.type===b.elementType?l:rc(b.type,l),h=g.context,k=c.contextType,"object"===typeof k&&null!==k?k=Cc(k):(k=C(c)?Eb:A.current,k=Fb(b,k)),p=c.getDerivedStateFromProps,(D=
"function"===typeof p||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(l!==d||h!==k)&&$c(b,g,d,k),Dc=!1,h=b.memoizedState,x=g.state=h,K=b.updateQueue,null!==K&&(Nc(b,K,d,g,e),x=b.memoizedState),l!==d||h!==x||B.current||Dc?("function"===typeof p&&(Uc(b,c,p,d),x=b.memoizedState),(p=Dc||Yc(b,c,l,d,h,x,k))?(D||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||
("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,x,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=256),b.memoizedProps=
d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=p):("function"!==typeof g.componentDidUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||l===a.memoizedProps&&h===a.memoizedState||(b.effectTag|=256),d=!1);return ye(a,b,c,d,f,e)}
function ye(a,b,c,d,e,f){we(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Lb(b,c,!1),re(a,b,f);d=b.stateNode;pe.current=b;var l=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=kd(b,a.child,null,f),b.child=kd(b,null,l,f)):Q(a,b,l,f);b.memoizedState=d.state;e&&Lb(b,c,!0);return b.child}function ze(a){var b=a.stateNode;b.pendingContext?Ib(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ib(a,b.context,!1);qd(a,b.containerInfo)}
var Ae={dehydrated:null,retryTime:0};
function Be(a,b,c){var d=b.mode,e=b.pendingProps,f=I.current,g=!1,l;(l=0!==(b.effectTag&64))||(l=0!==(f&2)&&(null===a||null!==a.memoizedState));l?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);z(I,f&1,b);if(null===a){void 0!==e.fallback&&je(b);if(g){g=e.fallback;e=jd(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=jd(g,d,c,null);c.return=
b;e.sibling=c;b.memoizedState=Ae;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=ld(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=fd(a,a.pendingProps,0);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=fd(d,e,d.expirationTime);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Ae;b.child=c;return d}c=kd(b,a.child,e.children,c);b.memoizedState=
null;return b.child=c}a=a.child;if(g){g=e.fallback;e=jd(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=jd(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Ae;b.child=e;return c}b.memoizedState=null;return b.child=kd(b,a,e.children,c)}
function Ce(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);zc(a.return,b)}function De(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}
function Ee(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Q(a,b,d.children,c);d=I.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&Ce(a,c);else if(19===a.tag)Ce(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}z(I,d,b);if(0===(b.mode&2))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ud(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);De(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ud(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}De(b,!0,c,null,f,b.lastEffect);break;case "together":De(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}
function re(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Pc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(n(153));if(null!==b.child){a=b.child;c=fd(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=fd(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null}return b.child}function Fe(a){a.effectTag|=4}var Ge,He,Ie,Je;
if(Qa)Ge=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)Fa(a,c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}},He=function(){},Ie=function(a,b,c,d,e){a=a.memoizedProps;if(a!==d){var f=b.stateNode,g=pd(H.current);c=Ia(f,c,a,d,e,g);(b.updateQueue=c)&&Fe(b)}},Je=function(a,b,c,d){c!==d&&Fe(b)};else if(Ra){Ge=function(a,
b,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=mb(f,e.type,e.memoizedProps,e));Fa(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=nb(f,e.memoizedProps,e)),Fa(a,f);else if(4!==e.tag){if(13===e.tag&&0!==(e.effectTag&4)&&(f=null!==e.memoizedState)){var g=e.child;if(null!==g&&(null!==g.child&&(g.child.return=g,Ge(a,g,!0,f)),f=g.sibling,null!==f)){f.return=e;e=f;continue}}if(null!==e.child){e.child.return=e;e=e.child;continue}}if(e===b)break;for(;null===e.sibling;){if(null===
e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};var Ke=function(a,b,c,d){for(var e=b.child;null!==e;){if(5===e.tag){var f=e.stateNode;c&&d&&(f=mb(f,e.type,e.memoizedProps,e));ib(a,f)}else if(6===e.tag)f=e.stateNode,c&&d&&(f=nb(f,e.memoizedProps,e)),ib(a,f);else if(4!==e.tag){if(13===e.tag&&0!==(e.effectTag&4)&&(f=null!==e.memoizedState)){var g=e.child;if(null!==g&&(null!==g.child&&(g.child.return=g,Ke(a,g,!0,f)),f=g.sibling,null!==f)){f.return=e;e=f;continue}}if(null!==
e.child){e.child.return=e;e=e.child;continue}}if(e===b)break;for(;null===e.sibling;){if(null===e.return||e.return===b)return;e=e.return}e.sibling.return=e.return;e=e.sibling}};He=function(a){var b=a.stateNode;if(null!==a.firstEffect){var c=b.containerInfo,d=hb(c);Ke(d,a,!1,!1);b.pendingChildren=d;Fe(a);kb(c,d)}};Ie=function(a,b,c,d,e){var f=a.stateNode,g=a.memoizedProps;if((a=null===b.firstEffect)&&g===d)b.stateNode=f;else{var l=b.stateNode,h=pd(H.current),k=null;g!==d&&(k=Ia(l,c,g,d,e,h));a&&null===
k?b.stateNode=f:(f=gb(f,k,c,g,d,b,a,l),Ga(f,c,d,e,h)&&Fe(b),b.stateNode=f,a?Fe(b):Ge(f,b,!1,!1))}};Je=function(a,b,c,d){c!==d&&(a=pd(od.current),c=pd(H.current),b.stateNode=La(d,a,c,b),Fe(b))}}else He=function(){},Ie=function(){},Je=function(){};
function Le(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function Me(a){switch(a.tag){case 1:C(a.type)&&Gb(a);var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:rd(a);Hb(a);b=a.effectTag;if(0!==(b&64))throw Error(n(285));a.effectTag=b&-4097|64;return a;case 5:return td(a),null;case 13:return y(I,a),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return y(I,a),null;case 4:return rd(a),null;case 10:return yc(a),null;default:return null}}function Ne(a,b){return{value:a,source:b,stack:Ab(b)}}
var Oe="function"===typeof WeakSet?WeakSet:Set;function Pe(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Ab(c));null!==c&&ta(c.type);b=b.value;null!==a&&1===a.tag&&ta(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function Qe(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Re(a,c)}}function Se(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Re(a,c)}else b.current=null}
function Te(a,b){switch(b.tag){case 0:case 11:case 15:Ue(2,0,b);break;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:rc(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}break;case 3:case 5:case 6:case 4:case 17:break;default:throw Error(n(163));}}
function Ue(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if(0!==(d.tag&a)){var e=d.destroy;d.destroy=void 0;void 0!==e&&e()}0!==(d.tag&b)&&(e=d.create,d.destroy=e());d=d.next}while(d!==c)}}
function Ve(a,b,c){"function"===typeof We&&We(b);switch(b.tag){case 0:case 11:case 14:case 15:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;hc(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(l){Re(g,l)}}a=a.next}while(a!==d)})}break;case 1:Se(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Qe(b,c);break;case 5:Se(b);break;case 4:Qa?Xe(a,b,c):Ra&&Ye(b)}}
function Ze(a,b,c){for(var d=b;;)if(Ve(a,d,c),null===d.child||Qa&&4===d.tag){if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return}d.sibling.return=d.return;d=d.sibling}else d.child.return=d,d=d.child}function $e(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;null!==b&&$e(b)}
function Ye(a){if(Ra){a=a.stateNode.containerInfo;var b=hb(a);lb(a,b)}}function af(a){return 5===a.tag||3===a.tag||4===a.tag}
function bf(a){if(Qa){a:{for(var b=a.return;null!==b;){if(af(b)){var c=b;break a}b=b.return}throw Error(n(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(n(161));}c.effectTag&16&&(bb(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||af(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){var f=5===e.tag||6===e.tag;if(f)f=f?e.stateNode:e.stateNode.instance,c?d?Za(b,f,c):Ya(b,f,c):d?Ua(b,f):Ta(b,f);else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return}e.sibling.return=e.return;e=e.sibling}}}
function Xe(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(n(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag)Ze(a,d,c),g?ab(f,d.stateNode):$a(f,d.stateNode);else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ve(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;
for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}
function cf(a,b){if(Qa)switch(b.tag){case 0:case 11:case 14:case 15:Ue(4,8,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&Xa(c,f,e,a,d,b)}break;case 6:if(null===b.stateNode)throw Error(n(162));c=b.memoizedProps;Va(b.stateNode,null!==a?a.memoizedProps:c,c);break;case 3:Sa&&(b=b.stateNode,b.hydrate&&(b.hydrate=!1,xb(b.containerInfo)));break;case 12:break;case 13:df(b);ef(b);break;
case 19:ef(b);break;case 17:break;case 20:break;case 21:break;default:throw Error(n(163));}else{switch(b.tag){case 0:case 11:case 14:case 15:Ue(4,8,b);return;case 12:return;case 13:df(b);ef(b);return;case 19:ef(b);return;case 3:Sa&&(c=b.stateNode,c.hydrate&&(c.hydrate=!1,xb(c.containerInfo)))}a:if(Ra)switch(b.tag){case 1:case 5:case 6:case 20:break a;case 3:case 4:b=b.stateNode;lb(b.containerInfo,b.pendingChildren);break a;default:throw Error(n(163));}}}
function df(a){var b=a;if(null===a.memoizedState)var c=!1;else c=!0,b=a.child,ff=E();if(Qa&&null!==b)a:if(a=b,Qa)for(b=a;;){if(5===b.tag){var d=b.stateNode;c?cb(d):eb(b.stateNode,b.memoizedProps)}else if(6===b.tag)d=b.stateNode,c?db(d):fb(d,b.memoizedProps);else if(13===b.tag&&null!==b.memoizedState&&null===b.memoizedState.dehydrated){d=b.child.sibling;d.return=b;b=d;continue}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break a;for(;null===b.sibling;){if(null===b.return||b.return===
a)break a;b=b.return}b.sibling.return=b.return;b=b.sibling}}function ef(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Oe);b.forEach(function(b){var d=gf.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}var hf="function"===typeof WeakMap?WeakMap:Map;function jf(a,b,c){c=Gc(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){kf||(kf=!0,lf=d);Pe(a,b)};return c}
function mf(a,b,c){c=Gc(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Pe(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===nf?nf=new Set([this]):nf.add(this),Pe(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
var of=Math.ceil,pf=q.ReactCurrentDispatcher,qf=q.ReactCurrentOwner,R=0,rf=8,S=16,sf=32,tf=0,uf=1,vf=2,wf=3,xf=4,yf=5,T=R,U=null,V=null,W=0,X=tf,zf=null,Af=1073741823,Bf=1073741823,Cf=null,Df=0,Ef=!1,ff=0,Ff=500,Y=null,kf=!1,lf=null,nf=null,Gf=!1,Hf=null,If=90,Jf=null,Kf=0,Lf=null,Mf=0;function G(){return(T&(S|sf))!==R?1073741821-(E()/10|0):0!==Mf?Mf:Mf=1073741821-(E()/10|0)}
function Vc(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=fc();if(0===(b&4))return 99===d?1073741823:1073741822;if((T&S)!==R)return W;if(null!==c)a=mc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=mc(a,150,100);break;case 97:case 96:a=mc(a,5E3,250);break;case 95:a=2;break;default:throw Error(n(326));}null!==U&&a===W&&--a;return a}
function Wc(a,b){if(50<Kf)throw Kf=0,Lf=null,Error(n(185));a=Nf(a,b);if(null!==a){var c=fc();1073741823===b?(T&rf)!==R&&(T&(S|sf))===R?Of(a):(Z(a),T===R&&F()):Z(a);(T&4)===R||98!==c&&99!==c||(null===Jf?Jf=new Map([[a,b]]):(c=Jf.get(a),(void 0===c||c>b)&&Jf.set(a,b)))}}
function Nf(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(U===e&&(Pc(b),X===xf&&Pf(e,W)),Qf(e,b));return e}
function Rf(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Sf(a,b))return b;b=a.lastPingedTime;a=a.nextKnownPendingLevel;return b>a?b:a}
function Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=jc(Of.bind(null,a));else{var b=Rf(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=G();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==$b&&Ob(c)}a.callbackExpirationTime=
b;a.callbackPriority=d;b=1073741823===b?jc(Of.bind(null,a)):ic(d,Tf.bind(null,a),{timeout:10*(1073741821-b)-E()});a.callbackNode=b}}}
function Tf(a,b){Mf=0;if(b)return b=G(),Uf(a,b),Z(a),null;var c=Rf(a);if(0!==c){b=a.callbackNode;if((T&(S|sf))!==R)throw Error(n(327));Vf();a===U&&c===W||Wf(a,c);if(null!==V){var d=T;T|=S;var e=Xf(a);do try{Yf();break}catch(l){Zf(a,l)}while(1);wc();T=d;pf.current=e;if(X===uf)throw b=zf,Wf(a,c),Pf(a,c),Z(a),b;if(null===V)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=X,U=null,d){case tf:case uf:throw Error(n(345));case vf:Uf(a,2<c?2:c);break;case wf:Pf(a,c);d=a.lastSuspendedTime;
c===d&&(a.nextKnownPendingLevel=$f(e));if(1073741823===Af&&(e=ff+Ff-E(),10<e)){if(Ef){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Wf(a,c);break}}f=Rf(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Ma(ag.bind(null,a),e);break}ag(a);break;case xf:Pf(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=$f(e));if(Ef&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Wf(a,c);break}e=Rf(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
d;break}1073741823!==Bf?d=10*(1073741821-Bf)-E():1073741823===Af?d=0:(d=10*(1073741821-Af)-5E3,e=E(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*of(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Ma(ag.bind(null,a),d);break}ag(a);break;case yf:if(1073741823!==Af&&null!==Cf){f=Af;var g=Cf;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=E()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Pf(a,c);a.timeoutHandle=
Ma(ag.bind(null,a),d);break}}ag(a);break;default:throw Error(n(329));}Z(a);if(a.callbackNode===b)return Tf.bind(null,a)}}return null}
function Of(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if(a.finishedExpirationTime===b)ag(a);else{if((T&(S|sf))!==R)throw Error(n(327));Vf();a===U&&b===W||Wf(a,b);if(null!==V){var c=T;T|=S;var d=Xf(a);do try{bg();break}catch(e){Zf(a,e)}while(1);wc();T=c;pf.current=d;if(X===uf)throw c=zf,Wf(a,b),Pf(a,b),Z(a),c;if(null!==V)throw Error(n(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ag(a);Z(a)}}return null}function cg(a,b){Uf(a,b);Z(a);(T&(S|sf))===R&&F()}
function dg(){if(null!==Jf){var a=Jf;Jf=null;a.forEach(function(a,c){Uf(c,a);Z(c)});F()}}function eg(a,b){if((T&(S|sf))!==R)throw Error(n(187));var c=T;T|=1;try{return hc(99,a.bind(null,b))}finally{T=c,F()}}
function Wf(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;c!==Oa&&(a.timeoutHandle=Oa,Na(c));if(null!==V)for(c=V.return;null!==c;){var d=c;switch(d.tag){case 1:var e=d.type.childContextTypes;null!==e&&void 0!==e&&Gb(d);break;case 3:rd(d);Hb(d);break;case 5:td(d);break;case 4:rd(d);break;case 13:y(I,d);break;case 19:y(I,d);break;case 10:yc(d)}c=c.return}U=a;V=fd(a.current,null,b);W=b;X=tf;zf=null;Bf=Af=1073741823;Cf=null;Df=0;Ef=!1}
function Zf(a,b){do{try{wc();Nd();if(null===V||null===V.return)return X=uf,zf=b,null;a:{var c=a,d=V.return,e=V,f=b;b=W;e.effectTag|=2048;e.firstEffect=e.lastEffect=null;if(null!==f&&"object"===typeof f&&"function"===typeof f.then){var g=f,l=0!==(I.current&1),h=d;do{var k;if(k=13===h.tag){var p=h.memoizedState;if(null!==p)k=null!==p.dehydrated?!0:!1;else{var D=h.memoizedProps;k=void 0===D.fallback?!1:!0!==D.unstable_avoidThisFallback?!0:l?!1:!0}}if(k){var x=h.updateQueue;if(null===x){var K=new Set;
K.add(g);h.updateQueue=K}else x.add(g);if(0===(h.mode&2)){h.effectTag|=64;e.effectTag&=-2981;if(1===e.tag)if(null===e.alternate)e.tag=17;else{var Ha=Gc(1073741823,null);Ha.tag=2;Ic(e,Ha)}e.expirationTime=1073741823;break a}f=void 0;e=b;var O=c.pingCache;null===O?(O=c.pingCache=new hf,f=new Set,O.set(g,f)):(f=O.get(g),void 0===f&&(f=new Set,O.set(g,f)));if(!f.has(e)){f.add(e);var w=fg.bind(null,c,g,e);g.then(w,w)}h.effectTag|=4096;h.expirationTime=b;break a}h=h.return}while(null!==h);f=Error((ta(e.type)||
"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+Ab(e))}X!==yf&&(X=vf);f=Ne(f,e);h=d;do{switch(h.tag){case 3:g=f;h.effectTag|=4096;h.expirationTime=b;var r=jf(h,g,b);Jc(h,r);break a;case 1:g=f;var t=h.type,N=h.stateNode;if(0===(h.effectTag&64)&&("function"===typeof t.getDerivedStateFromError||null!==N&&"function"===typeof N.componentDidCatch&&
(null===nf||!nf.has(N)))){h.effectTag|=4096;h.expirationTime=b;var Mc=mf(h,g,b);Jc(h,Mc);break a}}h=h.return}while(null!==h)}V=gg(V)}catch(Sb){b=Sb;continue}break}while(1)}function Xf(){var a=pf.current;pf.current=Md;return null===a?Md:a}function Oc(a,b){a<Af&&2<a&&(Af=a);null!==b&&a<Bf&&2<a&&(Bf=a,Cf=b)}function Pc(a){a>Df&&(Df=a)}function bg(){for(;null!==V;)V=hg(V)}function Yf(){for(;null!==V&&!Pb();)V=hg(V)}
function hg(a){var b=ig(a.alternate,a,W);a.memoizedProps=a.pendingProps;null===b&&(b=gg(a));qf.current=null;return b}
function gg(a){V=a;do{var b=V.alternate;a=V.return;if(0===(V.effectTag&2048)){a:{var c=b;b=V;var d=W,e=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:C(b.type)&&Gb(b);break;case 3:rd(b);Hb(b);e=b.stateNode;e.pendingContext&&(e.context=e.pendingContext,e.pendingContext=null);(null===c||null===c.child)&&ne(b)&&Fe(b);He(b);break;case 5:td(b);var f=pd(od.current);d=b.type;if(null!==c&&null!=b.stateNode)Ie(c,b,d,e,f),c.ref!==b.ref&&(b.effectTag|=128);else if(e){c=pd(H.current);
if(ne(b)){e=b;if(!Sa)throw Error(n(175));c=ub(e.stateNode,e.type,e.memoizedProps,f,c,e);e.updateQueue=c;c=null!==c?!0:!1;c&&Fe(b)}else{var g=Ea(d,e,f,c,b);Ge(g,b,!1,!1);b.stateNode=g;Ga(g,d,e,f,c)&&Fe(b)}null!==b.ref&&(b.effectTag|=128)}else if(null===b.stateNode)throw Error(n(166));break;case 6:if(c&&null!=b.stateNode)Je(c,b,c.memoizedProps,e);else{if("string"!==typeof e&&null===b.stateNode)throw Error(n(166));c=pd(od.current);f=pd(H.current);if(ne(b)){c=b;if(!Sa)throw Error(n(176));(c=vb(c.stateNode,
c.memoizedProps,c))&&Fe(b)}else b.stateNode=La(e,c,f,b)}break;case 11:break;case 13:y(I,b);e=b.memoizedState;if(0!==(b.effectTag&64)){b.expirationTime=d;break a}e=null!==e;f=!1;null===c?void 0!==b.memoizedProps.fallback&&ne(b):(d=c.memoizedState,f=null!==d,e||null===d||(d=c.child.sibling,null!==d&&(g=b.firstEffect,null!==g?(b.firstEffect=d,d.nextEffect=g):(b.firstEffect=b.lastEffect=d,d.nextEffect=null),d.effectTag=8)));if(e&&!f&&0!==(b.mode&2))if(null===c&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(I.current&1))X===tf&&(X=wf);else{if(X===tf||X===wf)X=xf;0!==Df&&null!==U&&(Pf(U,W),Qf(U,Df))}Ra&&e&&(b.effectTag|=4);Qa&&(e||f)&&(b.effectTag|=4);break;case 7:break;case 8:break;case 12:break;case 4:rd(b);He(b);break;case 10:yc(b);break;case 9:break;case 14:break;case 17:C(b.type)&&Gb(b);break;case 19:y(I,b);e=b.memoizedState;if(null===e)break;f=0!==(b.effectTag&64);g=e.rendering;if(null===g)if(f)Le(e,!1);else{if(X!==tf||null!==c&&0!==(c.effectTag&64))for(c=b.child;null!==c;){g=ud(c);if(null!==
g){b.effectTag|=64;Le(e,!1);c=g.updateQueue;null!==c&&(b.updateQueue=c,b.effectTag|=4);null===e.lastEffect&&(b.firstEffect=null);b.lastEffect=e.lastEffect;c=d;for(e=b.child;null!==e;)f=e,d=c,f.effectTag&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childExpirationTime=0,f.expirationTime=d,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null):(f.childExpirationTime=g.childExpirationTime,f.expirationTime=g.expirationTime,
f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,d=g.dependencies,f.dependencies=null===d?null:{expirationTime:d.expirationTime,firstContext:d.firstContext,responders:d.responders}),e=e.sibling;z(I,I.current&1|2,b);b=b.child;break a}c=c.sibling}}else{if(!f)if(c=ud(g),null!==c){if(b.effectTag|=64,f=!0,c=c.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),Le(e,!0),null===e.tail&&"hidden"===e.tailMode&&!g.alternate){b=b.lastEffect=e.lastEffect;
null!==b&&(b.nextEffect=null);break}}else E()>e.tailExpiration&&1<d&&(b.effectTag|=64,f=!0,Le(e,!1),b.expirationTime=b.childExpirationTime=d-1);e.isBackwards?(g.sibling=b.child,b.child=g):(c=e.last,null!==c?c.sibling=g:b.child=g,e.last=g)}if(null!==e.tail){0===e.tailExpiration&&(e.tailExpiration=E()+500);c=e.tail;e.rendering=c;e.tail=c.sibling;e.lastEffect=b.lastEffect;c.sibling=null;e=I.current;e=f?e&1|2:e&1;z(I,e,b);b=c;break a}break;case 20:break;case 21:break;default:throw Error(n(156,b.tag));
}b=null}c=V;if(1===W||1!==c.childExpirationTime){e=0;for(f=c.child;null!==f;)d=f.expirationTime,g=f.childExpirationTime,d>e&&(e=d),g>e&&(e=g),f=f.sibling;c.childExpirationTime=e}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=V.firstEffect),null!==V.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=V.firstEffect),a.lastEffect=V.lastEffect),1<V.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=V:a.firstEffect=V,a.lastEffect=V))}else{b=Me(V,
W);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048)}b=V.sibling;if(null!==b)return b;V=a}while(null!==V);X===tf&&(X=yf);return null}function $f(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ag(a){var b=fc();hc(99,jg.bind(null,a,b));return null}
function jg(a,b){do Vf();while(null!==Hf);if((T&(S|sf))!==R)throw Error(n(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(n(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=$f(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(V=U=null,W=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=T;T|=sf;qf.current=null;Ca(a.containerInfo);Y=e;do try{kg()}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(var g=a,l=b;null!==Y;){var h=Y.effectTag;h&16&&Qa&&bb(Y.stateNode);if(h&128){var k=Y.alternate;if(null!==k){var p=
k.ref;null!==p&&("function"===typeof p?p(null):p.current=null)}}switch(h&1038){case 2:bf(Y);Y.effectTag&=-3;break;case 6:bf(Y);Y.effectTag&=-3;cf(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=-1025;cf(Y.alternate,Y);break;case 4:cf(Y.alternate,Y);break;case 8:var D=g,x=Y,K=l;Qa?Xe(D,x,K):Ze(D,x,K);$e(x)}Y=Y.nextEffect}}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Da(a.containerInfo);a.current=c;Y=e;do try{for(h=d;null!==Y;){var Ha=
Y.effectTag;if(Ha&36){var O=Y.alternate;k=Y;p=h;switch(k.tag){case 0:case 11:case 15:Ue(16,32,k);break;case 1:var w=k.stateNode;if(k.effectTag&4)if(null===O)w.componentDidMount();else{var r=k.elementType===k.type?O.memoizedProps:rc(k.type,O.memoizedProps);w.componentDidUpdate(r,O.memoizedState,w.__reactInternalSnapshotBeforeUpdate)}var t=k.updateQueue;null!==t&&Qc(k,t,w,p);break;case 3:var N=k.updateQueue;if(null!==N){g=null;if(null!==k.child)switch(k.child.tag){case 5:g=za(k.child.stateNode);break;
case 1:g=k.child.stateNode}Qc(k,N,g,p)}break;case 5:var Mc=k.stateNode;null===O&&k.effectTag&4&&Wa(Mc,k.type,k.memoizedProps,k);break;case 6:break;case 4:break;case 12:break;case 13:if(Sa&&null===k.memoizedState){var Sb=k.alternate;if(null!==Sb){var le=Sb.memoizedState;if(null!==le){var me=le.dehydrated;null!==me&&yb(me)}}}break;case 19:case 17:case 20:case 21:break;default:throw Error(n(163));}}if(Ha&128){k=void 0;var Tb=Y.ref;if(null!==Tb){var v=Y.stateNode;switch(Y.tag){case 5:k=za(v);break;default:k=
v}"function"===typeof Tb?Tb(k):Tb.current=k}}Y=Y.nextEffect}}catch(jb){if(null===Y)throw Error(n(330));Re(Y,jb);Y=Y.nextEffect}while(null!==Y);Y=null;ac();T=f}else a.current=c;if(Gf)Gf=!1,Hf=a,If=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(nf=null);1073741823===b?a===Lf?Kf++:(Kf=0,Lf=a):Kf=0;"function"===typeof lg&&lg(c.stateNode,d);Z(a);if(kf)throw kf=!1,a=lf,lf=null,a;if((T&rf)!==R)return null;F();return null}
function kg(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Te(Y.alternate,Y);0===(a&512)||Gf||(Gf=!0,ic(97,function(){Vf();return null}));Y=Y.nextEffect}}function Vf(){if(90!==If){var a=97<If?97:If;If=90;return hc(a,mg)}}
function mg(){if(null===Hf)return!1;var a=Hf;Hf=null;if((T&(S|sf))!==R)throw Error(n(331));var b=T;T|=sf;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:Ue(128,0,c),Ue(0,64,c)}}catch(d){if(null===a)throw Error(n(330));Re(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}T=b;F();return!0}function ng(a,b,c){b=Ne(c,b);b=jf(a,b,1073741823);Ic(a,b);a=Nf(a,1073741823);null!==a&&Z(a)}
function Re(a,b){if(3===a.tag)ng(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){ng(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===nf||!nf.has(d))){a=Ne(b,a);a=mf(c,a,1073741823);Ic(c,a);c=Nf(c,1073741823);null!==c&&Z(c);break}}c=c.return}}
function fg(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&W===c?X===xf||X===wf&&1073741823===Af&&E()-ff<Ff?Wf(a,W):Ef=!0:Sf(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,a.finishedExpirationTime===c&&(a.finishedExpirationTime=0,a.finishedWork=null),Z(a)))}function gf(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=G(),b=Vc(b,a,null));a=Nf(a,b);null!==a&&Z(a)}var ig;
ig=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||B.current)Bc=!0;else{if(d<c){Bc=!1;switch(b.tag){case 3:ze(b);oe();break;case 5:sd(b);if(b.mode&4&&1!==c&&Ka(b.type,e))return b.expirationTime=b.childExpirationTime=1,null;break;case 1:C(b.type)&&Kb(b);break;case 4:qd(b,b.stateNode.containerInfo);break;case 10:xc(b,b.memoizedProps.value);break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;if(0!==d&&d>=c)return Be(a,b,c);z(I,I.current&
1,b);b=re(a,b,c);return null!==b?b.sibling:null}z(I,I.current&1,b);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return Ee(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);z(I,I.current,b);if(!d)return null}return re(a,b,c)}Bc=!1}}else Bc=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Fb(b,A.current);Ac(b,c);e=Jd(null,b,d,a,e,c);b.effectTag|=1;if("object"===
typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;Nd();if(C(d)){var f=!0;Kb(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;var g=d.getDerivedStateFromProps;"function"===typeof g&&Uc(b,d,g,a);e.updater=Xc;b.stateNode=e;e._reactInternalFiber=b;ad(b,d,a,c);b=ye(null,b,d,!0,f,c)}else b.tag=0,Q(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;sa(e);if(1!==e._status)throw e._result;
e=e._result;b.type=e;f=b.tag=og(e);a=rc(e,a);switch(f){case 0:b=ve(null,b,e,a,c);break;case 1:b=xe(null,b,e,a,c);break;case 11:b=qe(null,b,e,a,c);break;case 14:b=se(null,b,e,rc(e.type,a),d,c);break;default:throw Error(n(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),ve(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),xe(a,b,d,e,c);case 3:ze(b);d=b.updateQueue;if(null===d)throw Error(n(282));e=b.memoizedState;e=null!==e?e.element:
null;Nc(b,d,b.pendingProps,null,c);d=b.memoizedState.element;if(d===e)oe(),b=re(a,b,c);else{if(e=b.stateNode.hydrate)Sa?(ee=tb(b.stateNode.containerInfo),de=b,e=fe=!0):e=!1;if(e)for(c=ld(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else Q(a,b,d,c),oe();b=b.child}return b;case 5:return sd(b),null===a&&je(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ja(d,e)?g=null:null!==f&&Ja(d,f)&&(b.effectTag|=16),we(a,b),b.mode&4&&1!==c&&Ka(d,e)?(b.expirationTime=
b.childExpirationTime=1,b=null):(Q(a,b,g,c),b=b.child),b;case 6:return null===a&&je(b),null;case 13:return Be(a,b,c);case 4:return qd(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=kd(b,null,d,c):Q(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),qe(a,b,d,e,c);case 7:return Q(a,b,b.pendingProps,c),b.child;case 8:return Q(a,b,b.pendingProps.children,c),b.child;case 12:return Q(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;
e=b.pendingProps;g=b.memoizedProps;f=e.value;xc(b,f);if(null!==g){var l=g.value;f=oc(l,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(l,f):1073741823)|0;if(0===f){if(g.children===e.children&&!B.current){b=re(a,b,c);break a}}else for(l=b.child,null!==l&&(l.return=b);null!==l;){var h=l.dependencies;if(null!==h){g=l.child;for(var k=h.firstContext;null!==k;){if(k.context===d&&0!==(k.observedBits&f)){1===l.tag&&(k=Gc(c,null),k.tag=2,Ic(l,k));l.expirationTime<c&&(l.expirationTime=
c);k=l.alternate;null!==k&&k.expirationTime<c&&(k.expirationTime=c);zc(l.return,c);h.expirationTime<c&&(h.expirationTime=c);break}k=k.next}}else g=10===l.tag?l.type===b.type?null:l.child:l.child;if(null!==g)g.return=l;else for(g=l;null!==g;){if(g===b){g=null;break}l=g.sibling;if(null!==l){l.return=g.return;g=l;break}g=g.return}l=g}}Q(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,Ac(b,c),e=Cc(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,Q(a,b,d,c),b.child;
case 14:return e=b.type,f=rc(e,b.pendingProps),f=rc(e.type,f),se(a,b,e,f,d,c);case 15:return ue(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:rc(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,C(d)?(a=!0,Kb(b)):a=!1,Ac(b,c),Zc(b,d,e,c),ad(b,d,e,c),ye(null,b,d,!0,a,c);case 19:return Ee(a,b,c)}throw Error(n(156,b.tag));};var lg=null,We=null;
function pg(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);lg=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};We=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}
function qg(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function he(a,b,c,d){return new qg(a,b,c,d)}
function te(a){a=a.prototype;return!(!a||!a.isReactComponent)}function og(a){if("function"===typeof a)return te(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===la)return 11;if(a===oa)return 14}return 2}
function fd(a,b){var c=a.alternate;null===c?(c=he(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function hd(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)te(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ea:return jd(c.children,e,f,b);case ka:g=8;e|=7;break;case fa:g=8;e|=1;break;case ha:return a=he(12,c,b,e|8),a.elementType=ha,a.type=ha,a.expirationTime=f,a;case ma:return a=he(13,c,b,e),a.type=ma,a.elementType=ma,a.expirationTime=f,a;case na:return a=he(19,c,b,e),a.elementType=na,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case ia:g=
10;break a;case ja:g=9;break a;case la:g=11;break a;case oa:g=14;break a;case pa:g=16;d=null;break a}throw Error(n(130,null==a?a:typeof a,""));}b=he(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function jd(a,b,c,d){a=he(7,a,d,b);a.expirationTime=c;return a}function gd(a,b,c){a=he(6,a,null,b);a.expirationTime=c;return a}
function id(a,b,c){b=he(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function rg(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=Oa;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}
function Sf(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Pf(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}
function Qf(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Uf(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function sg(a){var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(n(188));throw Error(n(268,Object.keys(a)));}a=xa(b);return null===a?null:a.stateNode}function tg(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function ug(a,b){tg(a,b);(a=a.alternate)&&tg(a,b)}
var vg={createContainer:function(a,b,c){a=new rg(a,b,c);b=he(3,null,null,2===b?7:1===b?3:0);a.current=b;return b.stateNode=a},updateContainer:function(a,b,c,d){var e=b.current,f=G(),g=Sc.suspense;f=Vc(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(ua(c)!==c||1!==c.tag)throw Error(n(170));var l=c;do{switch(l.tag){case 3:l=l.stateNode.context;break b;case 1:if(C(l.type)){l=l.stateNode.__reactInternalMemoizedMergedChildContext;break b}}l=l.return}while(null!==l);throw Error(n(171));}if(1===c.tag){var h=
c.type;if(C(h)){c=Jb(c,h,l);break a}}c=l}else c=Db;null===b.context?b.context=c:b.pendingContext=c;b=Gc(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);Ic(e,b);Wc(e,f);return f},batchedEventUpdates:function(a,b){var c=T;T|=2;try{return a(b)}finally{T=c,T===R&&F()}},batchedUpdates:function(a,b){var c=T;T|=1;try{return a(b)}finally{T=c,T===R&&F()}},unbatchedUpdates:function(a,b){var c=T;T&=-2;T|=rf;try{return a(b)}finally{T=c,T===R&&F()}},deferredUpdates:function(a){return hc(97,
a)},syncUpdates:function(a,b,c,d){return hc(99,a.bind(null,b,c,d))},discreteUpdates:function(a,b,c,d){var e=T;T|=4;try{return hc(98,a.bind(null,b,c,d))}finally{T=e,T===R&&F()}},flushDiscreteUpdates:function(){(T&(1|S|sf))===R&&(dg(),Vf())},flushControlled:function(a){var b=T;T|=1;try{hc(99,a)}finally{T=b,T===R&&F()}},flushSync:eg,flushPassiveEffects:Vf,IsThisRendererActing:{current:!1},getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return za(a.child.stateNode);
default:return a.child.stateNode}},attemptSynchronousHydration:function(a){switch(a.tag){case 3:var b=a.stateNode;b.hydrate&&cg(b,b.firstPendingTime);break;case 13:eg(function(){return Wc(a,1073741823)}),b=mc(G(),150,100),ug(a,b)}},attemptUserBlockingHydration:function(a){if(13===a.tag){var b=mc(G(),150,100);Wc(a,b);ug(a,b)}},attemptContinuousHydration:function(a){if(13===a.tag){G();var b=lc++;Wc(a,b);ug(a,b)}},attemptHydrationAtCurrentPriority:function(a){if(13===a.tag){var b=G();b=Vc(b,a,null);
Wc(a,b);ug(a,b)}},findHostInstance:sg,findHostInstanceWithWarning:function(a){return sg(a)},findHostInstanceWithNoPortals:function(a){a=ya(a);return null===a?null:20===a.tag?a.stateNode.instance:a.stateNode},shouldSuspend:function(){return!1},injectIntoDevTools:function(a){var b=a.findFiberByHostInstance;return pg(aa({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:q.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=xa(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))}};module.exports=vg.default||vg;

    var $$$renderer = module.exports;
    module.exports = $$$reconciler;
    return $$$renderer;
};


/***/ }),

/***/ 76525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(67287);
} else {}


/***/ }),

/***/ 52546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.18.0
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports, "__esModule", ({value:!0}));var f,g,h,k,l;
if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,
y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===
typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=Math.floor((c-1)/2),e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}
function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}
function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};
exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};exports.unstable_cancelCallback=function(a){a.callback=null};
exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_requestPaint=Z;exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};
exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_Profiling=null;


/***/ }),

/***/ 60373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(52546);
} else {}


/***/ }),

/***/ 72408:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var l=__webpack_require__(27418),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.13.1";


/***/ }),

/***/ 67294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(72408);
} else {}


/***/ }),

/***/ 23972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var rtlDetect = __webpack_require__(6730);

module.exports = {

    isRtlLang: rtlDetect.isRtlLang,

    getLangDir: rtlDetect.getLangDir

};


/***/ }),

/***/ 6730:
/***/ ((module) => {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */



var self;
var RtlDetectLib = self = {  // eslint-disable-line consistent-this
    // Private vars - star
    _regexEscape: /([\.\*\+\^\$\[\]\\\(\)\|\{\}\,\-\:\?])/g, // eslint-disable-line no-useless-escape
    _regexParseLocale: /^([a-zA-Z]*)([_\-a-zA-Z]*)$/,
    // Private vars - end

    // Private functions - star
    _escapeRegExpPattern: function (str) {
        if (typeof str !== 'string') {
            return str;
        }
        return str.replace(self._regexEscape, '\\$1');
    },

    _toLowerCase: function (str, reserveReturnValue) {
        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }
        return str.toLowerCase();
    },

    _toUpperCase: function (str, reserveReturnValue) {
        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }
        return str.toUpperCase();
    },

    _trim: function (str, delimiter, reserveReturnValue) {
        var patterns = [];
        var regexp;
        var addPatterns = function (pattern) {
            // Build trim RegExp pattern and push it to patterns array
            patterns.push('^' + pattern + '+|' + pattern + '+$');
        };

        // fix reserveReturnValue value
        if (typeof delimiter === 'boolean') {
            reserveReturnValue = delimiter;
            delimiter = null;
        }

        if (typeof str !== 'string') {
            return reserveReturnValue && str;
        }

        // Trim based on delimiter array values
        if (Array.isArray(delimiter)) {
            // Loop through delimiter array
            delimiter.map(function (item) {
                // Escape delimiter to be valid RegExp Pattern
                var pattern = self._escapeRegExpPattern(item);
                // Push pattern to patterns array
                addPatterns(pattern);
            });
        }

        // Trim based on delimiter string value
        if (typeof delimiter === 'string') {
            // Escape delimiter to be valid RegExp Pattern
            var patternDelimiter = self._escapeRegExpPattern(delimiter);
            // push pattern to patterns array
            addPatterns(patternDelimiter);
        }

        // If delimiter  is not defined, Trim white spaces
        if (!delimiter) {
            // Push white space pattern to patterns array
            addPatterns('\\s');
        }

        // Build RegExp pattern
        var pattern = '(' + patterns.join('|') + ')';
        // Build RegExp object
        regexp = new RegExp(pattern, 'g');

        // trim string for all patterns
        while (str.match(regexp)) {
            str = str.replace(regexp, '');
        }

        // Return trim string
        return str;
    },

    _parseLocale : function (strLocale) {
        var matches =  self._regexParseLocale.exec(strLocale); // exec regex
        var parsedLocale;
        var lang;
        var countryCode;

        if (!strLocale || !matches) {
            return;
        }

        // fix countryCode string by trimming '-' and '_'
        matches[2] = self._trim(matches[2], ['-', '_']);

        lang = self._toLowerCase(matches[1]);
        countryCode = self._toUpperCase(matches[2]) || countryCode;

        // object with lang, countryCode properties
        parsedLocale = {
            lang: lang,
            countryCode: countryCode
        };

        // return parsed locale object
        return parsedLocale;
    },
    // Private functions - End

    // Public functions - star
    isRtlLang: function (strLocale) {
        var objLocale = self._parseLocale(strLocale);
        if (!objLocale) {
            return;
        }
        // return true if the intel string lang exists in the BID RTL LANGS array else return false
        return (self._BIDI_RTL_LANGS.indexOf(objLocale.lang) >= 0);
    },

    getLangDir: function (strLocale) {
        // return 'rtl' if the intel string lang exists in the BID RTL LANGS array else return 'ltr'
        return self.isRtlLang(strLocale) ? 'rtl' : 'ltr';
    }

    // Public functions - End
};

// Const BIDI_RTL_LANGS Array
// BIDI_RTL_LANGS ref: http://en.wikipedia.org/wiki/Right-to-left
// Table of scripts in Unicode: https://en.wikipedia.org/wiki/Script_(Unicode)
Object.defineProperty(self, '_BIDI_RTL_LANGS', {
    value: [
        'ae',	/* Avestan */
        'ar',   /* 'العربية', Arabic */
        'arc',  /* Aramaic */
        'bcc',  /* 'بلوچی مکرانی', Southern Balochi */
        'bqi',  /* 'بختياري', Bakthiari */
        'ckb',  /* 'Soranî / کوردی', Sorani */
        'dv',   /* Dhivehi */
        'fa',   /* 'فارسی', Persian */
        'glk',  /* 'گیلکی', Gilaki */
        'he',   /* 'עברית', Hebrew */
        'ku',   /* 'Kurdî / كوردی', Kurdish */
        'mzn',  /* 'مازِرونی', Mazanderani */
        'nqo',  /* N'Ko */
        'pnb',  /* 'پنجابی', Western Punjabi */
        'ps',   /* 'پښتو', Pashto, */
        'sd',   /* 'سنڌي', Sindhi */
        'ug',   /* 'Uyghurche / ئۇيغۇرچە', Uyghur */
        'ur',    /* 'اردو', Urdu */
        'yi'    /* 'ייִדיש', Yiddish */
    ],
    writable: false,
    enumerable: true,
    configurable: false
});


module.exports = RtlDetectLib;


/***/ }),

/***/ 89509:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(48764)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 42830:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = (__webpack_require__(17187).EventEmitter);
var inherits = __webpack_require__(35717);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(56577);
Stream.Writable = __webpack_require__(20323);
Stream.Duplex = __webpack_require__(68656);
Stream.Transform = __webpack_require__(94473);
Stream.PassThrough = __webpack_require__(2366);
Stream.finished = __webpack_require__(81086)
Stream.pipeline = __webpack_require__(56472)

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ 58106:
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.q = codes;


/***/ }),

/***/ 68656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(56577);

var Writable = __webpack_require__(20323);

__webpack_require__(35717)(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ 2366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(94473);

__webpack_require__(35717)(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ 56577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(17187).EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(83194);
/*</replacement>*/


var Buffer = (__webpack_require__(48764).Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(40964);

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(39686);

var destroyImpl = __webpack_require__(71029);

var _require = __webpack_require__(30094),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(35717)(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(68656);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(32553)/* .StringDecoder */ .s);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(68656);
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(32553)/* .StringDecoder */ .s);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(20828);
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(31265);
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ 94473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(68656);

__webpack_require__(35717)(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ 20323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(94927)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(83194);
/*</replacement>*/


var Buffer = (__webpack_require__(48764).Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(71029);

var _require = __webpack_require__(30094),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(35717)(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(68656);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(68656); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ 20828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = __webpack_require__(81086);

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ 39686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = __webpack_require__(48764),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(69862),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ 71029:
/***/ ((module) => {

"use strict";
 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ 81086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(58106)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ 31265:
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),

/***/ 56472:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(58106)/* .codes */ .q),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(81086);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ 30094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(58106)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ 83194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(17187).EventEmitter;


/***/ }),

/***/ 32553:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(89509).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ 94927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ 91496:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ 20384:
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 89539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(__webpack_require__.g.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(20384);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(91496);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),

/***/ 25752:
/***/ (() => {



/***/ }),

/***/ 14290:
/***/ (() => {



/***/ }),

/***/ 62052:
/***/ (() => {



/***/ }),

/***/ 89592:
/***/ (() => {



/***/ }),

/***/ 60197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/modal_hide-2341f.ogg";

/***/ }),

/***/ 99373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/release-7c974.ogg";

/***/ }),

/***/ 43464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/snes_pop-7a6d3.ogg";

/***/ }),

/***/ 53603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Acquire Hardware-11613.jpg";

/***/ }),

/***/ 73217:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Adventuring Time-70f23.jpg";

/***/ }),

/***/ 18376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Ahoy-1bdfb.jpg";

/***/ }),

/***/ 43218:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Alternative Fuel-9fa05.jpg";

/***/ }),

/***/ 67464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Archer-9f669.jpg";

/***/ }),

/***/ 827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Artificial Selection-ecbd8.jpg";

/***/ }),

/***/ 52133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Atlantis-c690d.jpg";

/***/ }),

/***/ 41988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bake Bread-46004.jpg";

/***/ }),

/***/ 81346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Beaconator-9fcb5.jpg";

/***/ }),

/***/ 811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Beam Me Up-4de6a.jpg";

/***/ }),

/***/ 67982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bee Our Guest-eea44.jpg";

/***/ }),

/***/ 19119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Benchmaking-81738.jpg";

/***/ }),

/***/ 69501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Body Guard-d2b59.jpg";

/***/ }),

/***/ 68592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Bullseye-7f384.jpg";

/***/ }),

/***/ 47461:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Buy Low Sell High-6e453.jpg";

/***/ }),

/***/ 33732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Camouflage-fdac2.jpg";

/***/ }),

/***/ 77563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Castaway-87c1e.jpg";

/***/ }),

/***/ 86795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cheating Death-962c3.jpg";

/***/ }),

/***/ 9071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Chestful of Cobblestone-cfa59.jpg";

/***/ }),

/***/ 72844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cover Me in Debris-1c2af.jpg";

/***/ }),

/***/ 3139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Cow Tipper-101c0.jpg";

/***/ }),

/***/ 8348:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/DIAMONDS-747fe.jpg";

/***/ }),

/***/ 67607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Delicious Fish-31f5d.jpg";

/***/ }),

/***/ 48677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Diamonds To You-0d1f9.jpg";

/***/ }),

/***/ 33231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Disenchanted-198d2.jpg";

/***/ }),

/***/ 18905:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Dispense With This-73ccf.jpg";

/***/ }),

/***/ 57098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Do a Barrel Roll-7b2c5.jpg";

/***/ }),

/***/ 76844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Dry Spell-5b906.jpg";

/***/ }),

/***/ 27149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Echolocation-2379f.jpg";

/***/ }),

/***/ 16996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Enchanter-24e86.jpg";

/***/ }),

/***/ 55671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Feeling ill-45cc9.jpg";

/***/ }),

/***/ 84115:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Free Diver-58756.jpg";

/***/ }),

/***/ 6454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Freight Station-17c07.jpg";

/***/ }),

/***/ 28110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Fruit on the Loom-48969.jpg";

/***/ }),

/***/ 90796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Getting Wood-27bf3.jpg";

/***/ }),

/***/ 94267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Getting an Upgrade-48f3f.jpg";

/***/ }),

/***/ 29655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Great View From Up Here-1af43.jpg";

/***/ }),

/***/ 57185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Have a Shearful Day-d56db.jpg";

/***/ }),

/***/ 29199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Hot Topic-5e947.jpg";

/***/ }),

/***/ 65975:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Hot Tourist Destination-05e2d.jpg";

/***/ }),

/***/ 32236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Inception-a30bb.jpg";

/***/ }),

/***/ 92857:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Into Fire-282b4.jpg";

/***/ }),

/***/ 72312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Into the Nether-97882.jpg";

/***/ }),

/***/ 32261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Iron Belly-4bfd0.jpg";

/***/ }),

/***/ 66893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Iron Man-28f8f.jpg";

/***/ }),

/***/ 36719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Its a sign-955a5.jpg";

/***/ }),

/***/ 72127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Ive Got a Bad Feeling About This-3b4bb.jpg";

/***/ }),

/***/ 91731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Kill the Beast-bbbe7.jpg";

/***/ }),

/***/ 7850:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Leader Of The Pack-05612.jpg";

/***/ }),

/***/ 55112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Let it Go-e5f7f.jpg";

/***/ }),

/***/ 37:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Librarian-ffc9f.jpg";

/***/ }),

/***/ 93457:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Lion Hunter-4baac.jpg";

/***/ }),

/***/ 28556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Local Brewery-cf73b.jpg";

/***/ }),

/***/ 71507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/MOAR_Tools-f858a.jpg";

/***/ }),

/***/ 7424:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Map Room-12963.jpg";

/***/ }),

/***/ 61851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Marine Biologist-905e5.jpg";

/***/ }),

/***/ 24273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Master Trader-31d3e.jpg";

/***/ }),

/***/ 50459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Me Gold-c1d48.jpg";

/***/ }),

/***/ 95541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Missing Content-acdf5.jpg";

/***/ }),

/***/ 45981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Monster Hunter-06656.jpg";

/***/ }),

/***/ 15168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Moskstraumen-41d9e.jpg";

/***/ }),

/***/ 39216:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/On a Rail-b2aef.jpg";

/***/ }),

/***/ 81568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/One Pickle Two Pickle Sea Pickle Four-2321c.jpg";

/***/ }),

/***/ 92011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Oooh Shiny-cdce6.jpg";

/***/ }),

/***/ 75394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Organizational Wizard-9595e.jpg";

/***/ }),

/***/ 96121:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Overkill-6fded.jpg";

/***/ }),

/***/ 91330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Overpowered-63911.jpg";

/***/ }),

/***/ 49678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Passing The Time-b1578.jpg";

/***/ }),

/***/ 66862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Plethora of Cats-6cb9c.jpg";

/***/ }),

/***/ 3664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Pork Chop-8a9b2.jpg";

/***/ }),

/***/ 45459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Pot Planter-6fbb2.jpg";

/***/ }),

/***/ 16013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Rabbit Season-50e3f.jpg";

/***/ }),

/***/ 73682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Rainbow Collection-f3be4.jpg";

/***/ }),

/***/ 72486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Renewable Energy-dc525.jpg";

/***/ }),

/***/ 48853:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Repopulation-1512c.jpg";

/***/ }),

/***/ 38735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Return to Sender-27efb.jpg";

/***/ }),

/***/ 10068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Saddle Up-648bf.jpg";

/***/ }),

/***/ 90261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sail the 7 Seas-f35c0.jpg";

/***/ }),

/***/ 8003:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sleep With The Fishes-14e33.jpg";

/***/ }),

/***/ 46175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Smelt Everything-bb2bf.jpg";

/***/ }),

/***/ 38537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sniper Duel-9112f.jpg";

/***/ }),

/***/ 96350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/So I Got That Going for Me-27680.jpg";

/***/ }),

/***/ 34924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sound the Alarm-4774c.jpg";

/***/ }),

/***/ 57213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Stayin Frosty-7d731.jpg";

/***/ }),

/***/ 8072:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Sticky Situation-38e18.jpg";

/***/ }),

/***/ 18460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Super Fuel-f0ebd.jpg";

/***/ }),

/***/ 10988:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Super Sonic-1fdf2.jpg";

/***/ }),

/***/ 66570:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Taking Inventory-96cd8.jpg";

/***/ }),

/***/ 786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Taste of Your Own Medicine-fcfb1.jpg";

/***/ }),

/***/ 90678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Beginning.-06a1b.jpg";

/***/ }),

/***/ 661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Beginning_-756c9.jpg";

/***/ }),

/***/ 78965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Deep End-1e509.jpg";

/***/ }),

/***/ 81023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End... Again...-2210a.jpg";

/***/ }),

/***/ 56377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End-b4e77.jpg";

/***/ }),

/***/ 68956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The End_-0d7cd.jpg";

/***/ }),

/***/ 47419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Haggler-34004.jpg";

/***/ }),

/***/ 42539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/The Lie-73ed5.jpg";

/***/ }),

/***/ 32539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Tie Dye Outfit-a8a7d.jpg";

/***/ }),

/***/ 59906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time For Stew-cee86.jpg";

/***/ }),

/***/ 43450:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Farm-b9d4e.jpg";

/***/ }),

/***/ 70040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Mine-1e5c7.jpg";

/***/ }),

/***/ 50611:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Time to Strike-60cb6.jpg";

/***/ }),

/***/ 93870:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Top of the World-b9b5b.jpg";

/***/ }),

/***/ 30280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Total Beelocation-325f5.jpg";

/***/ }),

/***/ 29553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Trampoline-c6bf4.jpg";

/***/ }),

/***/ 90104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Treasure Hunter-44301.jpg";

/***/ }),

/***/ 13921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Were being attacked-832ac.jpg";

/***/ }),

/***/ 93624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/When Pigs Fly-bd98b.jpg";

/***/ }),

/***/ 18324:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Where Have You Been-61295.jpg";

/***/ }),

/***/ 41395:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/You Need A Mint-28c41.jpg";

/***/ }),

/***/ 87126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Zombie Doctor-159ee.jpg";

/***/ }),

/***/ 94239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/Zoologist-0f99d.jpg";

/***/ }),

/***/ 76243:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/placeholder1-55454.jpg";

/***/ }),

/***/ 54705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/placeholder2-b6c97.jpg";

/***/ }),

/***/ 40949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/hat_fisherman_thumbnail_0-90aea.png";

/***/ }),

/***/ 36577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/skin_slime_thumbnail_0-3af42.png";

/***/ }),

/***/ 59001:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/toothpick_wheat_thumbnail_0-b93d5.png";

/***/ }),

/***/ 84984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/animation-074ed.gif";

/***/ }),

/***/ 69862:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 40964:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/hbui/";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// extracted by mini-css-extract-plugin
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ({});
})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
// React tries to run `element instanceof win.HTMLIFrameElement`
// and crashes, because HTMLIFrameElement is undefined in HB
// see: https://github.com/facebook/react/blame/c954efa70f44a44be9c33c60c57f87bea6f40a10/packages/react-dom/src/client/ReactInputSelection.js#L46
window.HTMLIFrameElement = window.HTMLIFrameElement || function () {};
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(67294);
// EXTERNAL MODULE: ./packages/react-facet/src/index.ts
var react_facet_src = __webpack_require__(57811);
// EXTERNAL MODULE: ./node_modules/@react-facet/core/dist/index.js
var dist = __webpack_require__(88572);
;// CONCATENATED MODULE: ./packages/react-router-ish/src/context.tsx


const DEFAULT_ROUTING_STATE = {
  length: 1,
  action: 'PUSH',
  list: [{
    pathname: '',
    search: '',
    hash: '',
    state: ''
  }]
};
const DEFAULT_ROUTING_API = {
  push: () => {},
  replace: () => {},
  goBack: () => {}
};
const context_stateContext = (0,react.createContext)((0,dist.createStaticFacet)(DEFAULT_ROUTING_STATE));
const apiContext = (0,react.createContext)(DEFAULT_ROUTING_API);
const isActiveContext = (0,react.createContext)((0,dist.createStaticFacet)(false));
const context_isInBackgroundContext = (0,react.createContext)((0,dist.createStaticFacet)(false));
const paramsContext = (0,react.createContext)((0,dist.createStaticFacet)({}));
const transitionsEnabledContext = (0,react.createContext)((0,dist.createStaticFacet)(true));
;// CONCATENATED MODULE: ./node_modules/@ungap/url-search-params/esm/index.js
/*! (c) Andrea Giammarchi - ISC */
var esm_self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26' ||
      new URLSearchParams({q: '%zx'}).toString() !== 'q=%25zx'
    )
      throw URLSearchParams;
    esm_self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var findPercentSign = /%(?![0-9a-fA-F]{2})/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    esm_self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }

    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }

    function decode(str) {
      return decodeURIComponent(str.replace(findPercentSign, '%25').replace(plus, ' '));
    }

    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    /* istanbul ignore next */
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === void 0, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(esm_self.URLSearchParams.prototype, Object));
/* harmony default export */ const esm = (esm_self.URLSearchParams);

;// CONCATENATED MODULE: ./packages/react-router-ish/src/hooks.ts




const hooks_useRouterAPI = () => {
  const routerAPI = (0,react.useContext)(apiContext); // Error for dev/release environments if we don't have a provider

  if (false) {}

  return routerAPI;
};
/**
 * @returns if the current route is active
 */

const hooks_useRouteIsActive = () => (0,react.useContext)(isActiveContext);
/**
 * @returns if the current route was active at one point and its now in the background in history
 */

const useRouteIsInBackground = () => useContext(isInBackgroundContext);
const hooks_useRouteParams = () => (0,react.useContext)(paramsContext);
const useRoutePathname = () => (0,dist.useFacetMap)(({
  list
}) => list[list.length - 1].pathname, [], [(0,react.useContext)(context_stateContext)]);
const useRouteHash = () => useFacetMap(({
  list
}) => list[list.length - 1].hash, [], [useContext(stateContext)]);
const useRouteQuery = () => (0,dist.useFacetMap)(search => new esm(search), [], // Uses two maps so that we get equality checks on the search changing
[(0,dist.useFacetMap)(({
  list
}) => list[list.length - 1].search, [], [(0,react.useContext)(context_stateContext)])]);
;// CONCATENATED MODULE: ./node_modules/path-to-regexp/dist.es2015/index.js
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./packages/react-router-ish/src/Redirect.tsx



const Redirect = ({
  to,
  match
}) => {
  const api = hooks_useRouterAPI(); // Compiling the matching function can be expensive, so we only do it when needed

  const matchFunction = (0,react.useMemo)(() => compile(to), [to]);
  (0,react.useEffect)(() => {
    if (!match) return;
    const destination = matchFunction(match.params);
    api.replace(destination);
  }, [matchFunction, match, api]);
  return null;
};
;// CONCATENATED MODULE: ./packages/react-router-ish/src/Switch.tsx



 // eslint-disable-next-line

const isRoute = x => {
  const props = Boolean(x.props) ? x.props : {};
  return Boolean(props.route) && Boolean(props.component);
};

const isRedirect = x => {
  const props = Boolean(x.props) ? x.props : {};
  return Boolean(props.from);
};

const pathnameOnlyEqualityCheck = () => {
  let previousPathname;
  return ({
    pathname: newPathname
  }) => {
    if (newPathname != previousPathname) {
      previousPathname = newPathname;
      return false;
    }

    return true;
  };
};
/**
 * Switch component that controls which Route, Redirect to render.
 *
 * - It considers a match only the first Route/Redirect that it matches.
 * - It also prevents rendering any of its children if nothing is matched.
 */


function Switch({
  children,
  onNotFound
}) {
  // We unwrap both pathname and action in a single state, as both information are important to routes.
  // However, we only consider a change if the pathname changes.
  const pathnameAndAction = (0,dist.useFacetUnwrap)((0,dist.useFacetMemo)(state => ({
    pathname: state.list[state.list.length - 1].pathname,
    action: state.action
  }), [], [(0,react.useContext)(context_stateContext)], pathnameOnlyEqualityCheck));
  const getCachedMatchFunction = useGetCachedMatchFunction();
  let hasPrevMatch = false;
  let shouldRender = false;

  if (pathnameAndAction != dist.NO_VALUE) {
    const {
      pathname
    } = pathnameAndAction;
    /**
     * This is to calculate if we should render anything at all so OreUI screens don't overlap on JSON UI screens
     *
     * We need to do this initial loop ahead of the `map` below so that we know if any of the children did match,
     * since we can have other elements being children of a Switch that would still need to not be rendered.
     */

    react.Children.forEach(children, child => {
      if (shouldRender === true) return;
      if (!(0,react.isValidElement)(child)) return;

      if (isRoute(child) && getCachedMatchFunction(child.props.route)(pathname) != false) {
        shouldRender = true;
        return;
      }

      if (isRedirect(child) && getCachedMatchFunction(child.props.from)(pathname) != false) {
        shouldRender = true;
        return;
      }
    });
  }

  const childrenWithMatch = pathnameAndAction === dist.NO_VALUE ? [] : react.Children.map(children, child => {
    if (!(0,react.isValidElement)(child)) {
      return shouldRender ? child : null;
    }

    if (isRoute(child)) {
      const match = hasPrevMatch ? false : getCachedMatchFunction(child.props.route)(pathnameAndAction.pathname);
      hasPrevMatch = hasPrevMatch || match != false;
      return react.cloneElement(child, {
        match: match == false ? undefined : match,
        action: pathnameAndAction.action
      });
    }

    if (isRedirect(child)) {
      const match = hasPrevMatch ? false : getCachedMatchFunction(child.props.from)(pathnameAndAction.pathname);
      hasPrevMatch = hasPrevMatch || match != false;
      return react.cloneElement(child, {
        match: match == false ? undefined : match
      });
    }

    if (shouldRender) {
      return child;
    }

    return null;
  });
  const notFound = pathnameAndAction != dist.NO_VALUE && !hasPrevMatch;
  /**
   * This effects needs to be at the end, after we defined the value of `hasPrevMatch`
   */

  (0,react.useEffect)(() => {
    if (notFound && onNotFound != null) {
      onNotFound();
    }
  }, [notFound, onNotFound]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, childrenWithMatch);
}
/**
 * Caches compiling the matching function based on the route string definition
 */

const useGetCachedMatchFunction = () => {
  const matchFunctionCacheRef = (0,react.useRef)(new Map());
  return (0,react.useCallback)(route => {
    const matchFunction = matchFunctionCacheRef.current.get(route);
    if (matchFunction) return matchFunction;
    const newMatchFunction = match(route);
    matchFunctionCacheRef.current.set(route, newMatchFunction);
    return newMatchFunction;
  }, []);
};
;// CONCATENATED MODULE: ./packages/react-router-ish/src/index.ts








;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/urlFocusedId.tsx
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * TODO: There is currently a bug with the router facet (on the back-end) which
 * doesn't behave correctly with hash URL fragments, so we will enforce using
 * query strings until it is fixed
 */

const isHashBugFixed = false;
const useHashForFocusState = isHashBugFixed && "gameface" === 'gameface';
function getFocusedIdFromLocation(location, useHash = useHashForFocusState) {
  const params = new esm(useHash ? location.hash : location.search);
  const alias = params.get('alias');
  if (typeof alias === 'string' && alias.length !== 0) return alias;
  const nodeId = params.get('nodeId');
  if (nodeId == null) return undefined;
  return parseInt(nodeId, 10);
}

function parseUrlHashParams(hash) {
  return hash.substr(1).split('&').reduce((res, item) => {
    const parts = item.split('=');
    res.set(parts[0], parts[1]);
    return res;
  }, new Map());
}

function encodeUrlHashParams(hashParams) {
  return Array.from(hashParams.entries()).filter(item => item[1] != null).map(([key, value]) => `${key}=${value}`).join('&');
}

function getURLWithFocusedId(location, newFocusedId, useHash = useHashForFocusState) {
  const hashParams = parseUrlHashParams(location.hash);
  hashParams.delete('nodeId');
  hashParams.delete('alias');
  const searchParams = new URLSearchParams(location.search);
  searchParams.delete('nodeId');
  searchParams.delete('alias');
  const params = useHash ? hashParams : searchParams;

  if (typeof newFocusedId === 'string') {
    params.set('alias', newFocusedId);
  } else if (typeof newFocusedId === 'number') {
    params.set('nodeId', newFocusedId.toString());
  }

  const hashString = encodeUrlHashParams(hashParams);
  const searchString = searchParams.toString();
  return _objectSpread(_objectSpread({}, location), {}, {
    search: searchString.length ? `?${searchString}` : '',
    hash: hashString.length ? `#${hashString}` : ''
  });
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/types.ts
let ScreenType;

(function (ScreenType) {
  ScreenType[ScreenType["TV_SCREEN_TYPE"] = 0] = "TV_SCREEN_TYPE";
  ScreenType[ScreenType["DESKTOP_SCREEN_TYPE"] = 1] = "DESKTOP_SCREEN_TYPE";
  ScreenType[ScreenType["HANDHELD_SCREEN_TYPE"] = 2] = "HANDHELD_SCREEN_TYPE";
  ScreenType[ScreenType["VR_SCREEN_TYPE"] = 3] = "VR_SCREEN_TYPE";
})(ScreenType || (ScreenType = {}));

let HandheldDeviceType;

(function (HandheldDeviceType) {
  HandheldDeviceType[HandheldDeviceType["PHONE"] = 0] = "PHONE";
  HandheldDeviceType[HandheldDeviceType["TABLET"] = 1] = "TABLET";
})(HandheldDeviceType || (HandheldDeviceType = {}));

let types_InputMethod;

(function (InputMethod) {
  InputMethod[InputMethod["GAMEPAD"] = 0] = "GAMEPAD";
  InputMethod[InputMethod["TOUCH"] = 1] = "TOUCH";
  InputMethod[InputMethod["MOUSE"] = 2] = "MOUSE";
  InputMethod[InputMethod["MOTION"] = 3] = "MOTION";
  InputMethod[InputMethod["KEYBOARD"] = 4] = "KEYBOARD";
})(types_InputMethod || (types_InputMethod = {}));

let ARVRPlatform;

(function (ARVRPlatform) {
  ARVRPlatform[ARVRPlatform["ARVR_None"] = 0] = "ARVR_None";
  ARVRPlatform[ARVRPlatform["ARVR_Rift"] = 1] = "ARVR_Rift";
  ARVRPlatform[ARVRPlatform["ARVR_Holographic"] = 2] = "ARVR_Holographic";
  ARVRPlatform[ARVRPlatform["ARVR_WindowsMR"] = 3] = "ARVR_WindowsMR";
  ARVRPlatform[ARVRPlatform["ARVR_PSVR"] = 4] = "ARVR_PSVR";
  ARVRPlatform[ARVRPlatform["ARVR_GearVR"] = 5] = "ARVR_GearVR";
  ARVRPlatform[ARVRPlatform["ARVR_DesktopXR"] = 6] = "ARVR_DesktopXR";
})(ARVRPlatform || (ARVRPlatform = {}));

let Platform;

(function (Platform) {
  Platform[Platform["IOS"] = 0] = "IOS";
  Platform[Platform["GOOGLE"] = 1] = "GOOGLE";
  Platform[Platform["AMAZON_HANDHELD"] = 2] = "AMAZON_HANDHELD";
  Platform[Platform["UWP"] = 3] = "UWP";
  Platform[Platform["XBOX"] = 4] = "XBOX";
  Platform[Platform["NX_HANDHELD"] = 5] = "NX_HANDHELD";
  Platform[Platform["PS4"] = 6] = "PS4";
  Platform[Platform["GEARVR"] = 7] = "GEARVR";
  Platform[Platform["WIN32"] = 8] = "WIN32";
  Platform[Platform["MACOS"] = 9] = "MACOS";
  Platform[Platform["AMAZON_TV"] = 10] = "AMAZON_TV";
  Platform[Platform["NX_TV"] = 11] = "NX_TV";
  Platform[Platform["PS5"] = 12] = "PS5";
})(Platform || (Platform = {}));

let Scale;

(function (Scale) {
  Scale[Scale["SCALE_100_PERCENT"] = 4] = "SCALE_100_PERCENT";
  Scale[Scale["SCALE_125_PERCENT"] = 5] = "SCALE_125_PERCENT";
  Scale[Scale["SCALE_150_PERCENT"] = 6] = "SCALE_150_PERCENT";
  Scale[Scale["SCALE_175_PERCENT"] = 7] = "SCALE_175_PERCENT";
  Scale[Scale["SCALE_200_PERCENT"] = 8] = "SCALE_200_PERCENT";
})(Scale || (Scale = {}));

let Controller;

(function (Controller) {
  Controller[Controller["XBOX"] = 0] = "XBOX";
  Controller[Controller["PS"] = 1] = "PS";
  Controller[Controller["STEAM"] = 2] = "STEAM";
  Controller[Controller["SWITCH"] = 3] = "SWITCH";
  Controller[Controller["QUEST"] = 4] = "QUEST";
})(Controller || (Controller = {}));
;// CONCATENATED MODULE: ./packages/react-device-information/src/context.tsx



const InputMethodsContext = (0,react.createContext)({
  isPointerInputMouse: (0,react_facet_src.createStaticFacet)(false),
  isPointerInputTouch: (0,react_facet_src.createStaticFacet)(false),
  isPointerInputAvailable: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputGamepad: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputKeyboard: (0,react_facet_src.createStaticFacet)(false),
  isFocusInputAvailable: (0,react_facet_src.createStaticFacet)(false),
  isLastInputMouse: (0,react_facet_src.createStaticFacet)(false),
  isLastInputTouch: (0,react_facet_src.createStaticFacet)(false),
  isLastInputGamepad: (0,react_facet_src.createStaticFacet)(false),
  isLastInputKeyboard: (0,react_facet_src.createStaticFacet)(false),
  isLastInputPointer: (0,react_facet_src.createStaticFacet)(false),
  isLastInputFocus: (0,react_facet_src.createStaticFacet)(false),
  isGamepadSupported: (0,react_facet_src.createStaticFacet)(false),
  isKeyboardSupported: (0,react_facet_src.createStaticFacet)(false),
  isMouseSupported: (0,react_facet_src.createStaticFacet)(false),
  isTouchSupported: (0,react_facet_src.createStaticFacet)(false),
  isPointerSupported: (0,react_facet_src.createStaticFacet)(false),
  isFocusSupported: (0,react_facet_src.createStaticFacet)(false)
});
const platformContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(Platform.XBOX));
const VRPlatformContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(ARVRPlatform.ARVR_None));
const screenTypeContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(ScreenType.TV_SCREEN_TYPE));
const controllerContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(Controller.XBOX)); // Hooks for last used pointer input method (mouse or touch)

const useIsPointerInputMouse = () => (0,react.useContext)(InputMethodsContext).isPointerInputMouse;
const useIsPointerInputTouch = () => (0,react.useContext)(InputMethodsContext).isPointerInputTouch;
const useIsPointerInputAvailable = () => useContext(InputMethodsContext).isPointerInputAvailable; // Hooks for last used focus input method (keyboard or gamepad)

const useIsFocusInputGamepad = () => (0,react.useContext)(InputMethodsContext).isFocusInputGamepad;
const useIsFocusInputKeyboard = () => (0,react.useContext)(InputMethodsContext).isFocusInputKeyboard;
const useIsFocusInputAvailable = () => (0,react.useContext)(InputMethodsContext).isFocusInputAvailable; // Hooks for last used input method of any type

const useIsLastInputMouse = () => (0,react.useContext)(InputMethodsContext).isLastInputMouse;
const useIsLastInputTouch = () => (0,react.useContext)(InputMethodsContext).isLastInputTouch;
const useIsLastInputGamepad = () => (0,react.useContext)(InputMethodsContext).isLastInputGamepad;
const useIsLastInputKeyboard = () => (0,react.useContext)(InputMethodsContext).isLastInputKeyboard;
const context_useIsLastInputPointer = () => (0,react.useContext)(InputMethodsContext).isLastInputPointer;
const useIsLastInputFocus = () => (0,react.useContext)(InputMethodsContext).isLastInputFocus; // Hooks for what input methods are supported by the platform

const useIsGamepadSupported = () => useContext(InputMethodsContext).isGamepadSupported;
const useIsKeyboardSupported = () => useContext(InputMethodsContext).isKeyboardSupported;
const useIsMouseSupported = () => useContext(InputMethodsContext).isMouseSupported;
const useIsTouchSupported = () => useContext(InputMethodsContext).isTouchSupported;
const useIsPointerSupported = () => (0,react.useContext)(InputMethodsContext).isPointerSupported;
const useIsFocusSupported = () => useContext(InputMethodsContext).isFocusSupported;
const usePlatformSelected = () => (0,react.useContext)(platformContext);
const useVRPlatform = () => (0,react.useContext)(VRPlatformContext);
const useDeviceScreenType = () => (0,react.useContext)(screenTypeContext);
const useControllerSelected = () => (0,react.useContext)(controllerContext);
// EXTERNAL MODULE: ./node_modules/ramda/src/without.js
var without = __webpack_require__(76290);
var without_default = /*#__PURE__*/__webpack_require__.n(without);
// EXTERNAL MODULE: ./node_modules/ramda/src/union.js
var union = __webpack_require__(30275);
var union_default = /*#__PURE__*/__webpack_require__.n(union);
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/types.ts
// TODO Create a interface for the button_map with backend
let ButtonType;

(function (ButtonType) {
  ButtonType["A"] = "A";
  ButtonType["B"] = "B";
  ButtonType["X"] = "X";
  ButtonType["Y"] = "Y";
  ButtonType["START"] = "START";
  ButtonType["SELECT"] = "SELECT";
  ButtonType["XBOX"] = "XBOX";
  ButtonType["RIGHT_TRIGGER"] = "RT";
  ButtonType["LEFT_TRIGGER"] = "LT";
  ButtonType["LEFT_BUMPER"] = "LB";
  ButtonType["RIGHT_BUMPER"] = "RB";
  ButtonType["L3"] = "L3";
  ButtonType["R3"] = "R3";
  ButtonType["LEFT"] = "LEFT";
  ButtonType["RIGHT"] = "RIGHT";
  ButtonType["UP"] = "UP";
  ButtonType["DOWN"] = "DOWN";
  ButtonType["NEXT"] = "NEXT";
  ButtonType["PREV"] = "PREV";
  ButtonType["LEFT_ANALOG_LEFT"] = "L_LEFT";
  ButtonType["LEFT_ANALOG_RIGHT"] = "L_RIGHT";
  ButtonType["LEFT_ANALOG_UP"] = "L_UP";
  ButtonType["LEFT_ANALOG_DOWN"] = "L_DOWN";
  ButtonType["RIGHT_ANALOG_LEFT"] = "R_LEFT";
  ButtonType["RIGHT_ANALOG_RIGHT"] = "R_RIGHT";
  ButtonType["RIGHT_ANALOG_UP"] = "R_UP";
  ButtonType["RIGHT_ANALOG_DOWN"] = "R_DOWN";
  ButtonType[ButtonType["LEFT_HORIZONTAL_AXIS"] = 0] = "LEFT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["LEFT_VERTICAL_AXIS"] = 1] = "LEFT_VERTICAL_AXIS";
  ButtonType[ButtonType["RIGHT_HORIZONTAL_AXIS"] = 2] = "RIGHT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["RIGHT_VERTICAL_AXIS"] = 3] = "RIGHT_VERTICAL_AXIS";
  ButtonType["PSEUDO_BUTTON_1"] = "PSEUDO_BUTTON_1";
  ButtonType["PSEUDO_BUTTON_2"] = "PSEUDO_BUTTON_2";
  ButtonType["PSEUDO_BUTTON_3"] = "PSEUDO_BUTTON_3";
  ButtonType["PSEUDO_BUTTON_4"] = "PSEUDO_BUTTON_4";
  ButtonType["PSEUDO_BUTTON_5"] = "PSEUDO_BUTTON_5";
  ButtonType["PSEUDO_BUTTON_6"] = "PSEUDO_BUTTON_6";
  ButtonType["PSEUDO_BUTTON_7"] = "PSEUDO_BUTTON_7";
  ButtonType["PSEUDO_BUTTON_8"] = "PSEUDO_BUTTON_8";
  ButtonType["PSEUDO_BUTTON_9"] = "PSEUDO_BUTTON_9";
  ButtonType["PSEUDO_BUTTON_10"] = "PSEUDO_BUTTON_10";
})(ButtonType || (ButtonType = {}));

const AXIS_MAP = [[ButtonType.LEFT_ANALOG_LEFT, ButtonType.LEFT_ANALOG_RIGHT], [ButtonType.LEFT_ANALOG_UP, ButtonType.LEFT_ANALOG_DOWN], [ButtonType.RIGHT_ANALOG_LEFT, ButtonType.RIGHT_ANALOG_RIGHT], [ButtonType.RIGHT_ANALOG_UP, ButtonType.RIGHT_ANALOG_DOWN]];
/**
 * Type for buttons which can be mapped to a keyboard key
 */

const KEYBOARD_MAPPABLE_BUTTON = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.XBOX, ButtonType.RIGHT_TRIGGER, ButtonType.LEFT_TRIGGER, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.L3, ButtonType.R3, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN, ButtonType.PSEUDO_BUTTON_1, ButtonType.PSEUDO_BUTTON_2, ButtonType.PSEUDO_BUTTON_3, ButtonType.PSEUDO_BUTTON_4, ButtonType.PSEUDO_BUTTON_5, ButtonType.PSEUDO_BUTTON_6, ButtonType.PSEUDO_BUTTON_7, ButtonType.PSEUDO_BUTTON_8, ButtonType.PSEUDO_BUTTON_9, ButtonType.PSEUDO_BUTTON_10];
/**
 * Type for buttons which can be displayed on input legends
 */

const INPUT_LEGEND_BUTTONS = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN, ButtonType.L3, ButtonType.R3, ButtonType.LEFT_ANALOG_LEFT, ButtonType.RIGHT_ANALOG_LEFT, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER];
const ACTION_BUTTONS = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.START, ButtonType.SELECT, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER, ButtonType.R3, ButtonType.L3];
const BUTTON_MAP = [ButtonType.A, ButtonType.B, ButtonType.X, ButtonType.Y, ButtonType.LEFT_BUMPER, ButtonType.RIGHT_BUMPER, ButtonType.LEFT_TRIGGER, ButtonType.RIGHT_TRIGGER, ButtonType.SELECT, ButtonType.START, ButtonType.L3, ButtonType.R3, ButtonType.UP, ButtonType.DOWN, ButtonType.LEFT, ButtonType.RIGHT, ButtonType.XBOX];
const DIRECTIONAL_BUTTONS = [ButtonType.LEFT, ButtonType.RIGHT, ButtonType.UP, ButtonType.DOWN];
const ACTION_BUTTONS_INDEX = ACTION_BUTTONS.map(string => BUTTON_MAP.indexOf(string));
const DIRECTIONAL_BUTTONS_INDEX = DIRECTIONAL_BUTTONS.map(string => BUTTON_MAP.indexOf(string));
let KeyboardKey;

(function (KeyboardKey) {
  KeyboardKey[KeyboardKey["BACKSPACE"] = 8] = "BACKSPACE";
  KeyboardKey[KeyboardKey["TAB"] = 9] = "TAB";
  KeyboardKey[KeyboardKey["ENTER"] = 13] = "ENTER";
  KeyboardKey[KeyboardKey["SHIFT"] = 16] = "SHIFT";
  KeyboardKey[KeyboardKey["CTRL"] = 17] = "CTRL";
  KeyboardKey[KeyboardKey["ALT"] = 18] = "ALT";
  KeyboardKey[KeyboardKey["CAPS_LOCK"] = 20] = "CAPS_LOCK";
  KeyboardKey[KeyboardKey["ESCAPE"] = 27] = "ESCAPE";
  KeyboardKey[KeyboardKey["SPACE"] = 32] = "SPACE";
  KeyboardKey[KeyboardKey["PG_UP"] = 33] = "PG_UP";
  KeyboardKey[KeyboardKey["PG_DOWN"] = 34] = "PG_DOWN";
  KeyboardKey[KeyboardKey["END"] = 35] = "END";
  KeyboardKey[KeyboardKey["LEFT"] = 37] = "LEFT";
  KeyboardKey[KeyboardKey["UP"] = 38] = "UP";
  KeyboardKey[KeyboardKey["RIGHT"] = 39] = "RIGHT";
  KeyboardKey[KeyboardKey["DOWN"] = 40] = "DOWN";
  KeyboardKey[KeyboardKey["INSERT"] = 45] = "INSERT";
  KeyboardKey[KeyboardKey["DELETE"] = 46] = "DELETE";
  KeyboardKey[KeyboardKey["KEY_0"] = 48] = "KEY_0";
  KeyboardKey[KeyboardKey["KEY_1"] = 49] = "KEY_1";
  KeyboardKey[KeyboardKey["KEY_2"] = 50] = "KEY_2";
  KeyboardKey[KeyboardKey["KEY_3"] = 51] = "KEY_3";
  KeyboardKey[KeyboardKey["KEY_4"] = 52] = "KEY_4";
  KeyboardKey[KeyboardKey["KEY_5"] = 53] = "KEY_5";
  KeyboardKey[KeyboardKey["KEY_6"] = 54] = "KEY_6";
  KeyboardKey[KeyboardKey["KEY_7"] = 55] = "KEY_7";
  KeyboardKey[KeyboardKey["KEY_8"] = 56] = "KEY_8";
  KeyboardKey[KeyboardKey["KEY_9"] = 57] = "KEY_9";
  KeyboardKey[KeyboardKey["SEMICOLON"] = 59] = "SEMICOLON";
  KeyboardKey[KeyboardKey["EQUALS"] = 61] = "EQUALS";
  KeyboardKey[KeyboardKey["KEY_A"] = 65] = "KEY_A";
  KeyboardKey[KeyboardKey["KEY_B"] = 66] = "KEY_B";
  KeyboardKey[KeyboardKey["KEY_C"] = 67] = "KEY_C";
  KeyboardKey[KeyboardKey["KEY_D"] = 68] = "KEY_D";
  KeyboardKey[KeyboardKey["KEY_E"] = 69] = "KEY_E";
  KeyboardKey[KeyboardKey["KEY_F"] = 70] = "KEY_F";
  KeyboardKey[KeyboardKey["KEY_G"] = 71] = "KEY_G";
  KeyboardKey[KeyboardKey["KEY_H"] = 72] = "KEY_H";
  KeyboardKey[KeyboardKey["KEY_I"] = 73] = "KEY_I";
  KeyboardKey[KeyboardKey["KEY_J"] = 74] = "KEY_J";
  KeyboardKey[KeyboardKey["KEY_K"] = 75] = "KEY_K";
  KeyboardKey[KeyboardKey["KEY_L"] = 76] = "KEY_L";
  KeyboardKey[KeyboardKey["KEY_M"] = 77] = "KEY_M";
  KeyboardKey[KeyboardKey["KEY_N"] = 78] = "KEY_N";
  KeyboardKey[KeyboardKey["KEY_O"] = 79] = "KEY_O";
  KeyboardKey[KeyboardKey["KEY_P"] = 80] = "KEY_P";
  KeyboardKey[KeyboardKey["KEY_Q"] = 81] = "KEY_Q";
  KeyboardKey[KeyboardKey["KEY_R"] = 82] = "KEY_R";
  KeyboardKey[KeyboardKey["KEY_S"] = 83] = "KEY_S";
  KeyboardKey[KeyboardKey["KEY_T"] = 84] = "KEY_T";
  KeyboardKey[KeyboardKey["KEY_U"] = 85] = "KEY_U";
  KeyboardKey[KeyboardKey["KEY_V"] = 86] = "KEY_V";
  KeyboardKey[KeyboardKey["KEY_W"] = 87] = "KEY_W";
  KeyboardKey[KeyboardKey["KEY_X"] = 88] = "KEY_X";
  KeyboardKey[KeyboardKey["KEY_Y"] = 89] = "KEY_Y";
  KeyboardKey[KeyboardKey["KEY_Z"] = 90] = "KEY_Z";
  KeyboardKey[KeyboardKey["NUMPAD_0"] = 96] = "NUMPAD_0";
  KeyboardKey[KeyboardKey["NUMPAD_1"] = 97] = "NUMPAD_1";
  KeyboardKey[KeyboardKey["NUMPAD_2"] = 98] = "NUMPAD_2";
  KeyboardKey[KeyboardKey["NUMPAD_3"] = 99] = "NUMPAD_3";
  KeyboardKey[KeyboardKey["NUMPAD_4"] = 100] = "NUMPAD_4";
  KeyboardKey[KeyboardKey["NUMPAD_5"] = 101] = "NUMPAD_5";
  KeyboardKey[KeyboardKey["NUMPAD_6"] = 102] = "NUMPAD_6";
  KeyboardKey[KeyboardKey["NUMPAD_7"] = 103] = "NUMPAD_7";
  KeyboardKey[KeyboardKey["NUMPAD_8"] = 104] = "NUMPAD_8";
  KeyboardKey[KeyboardKey["NUMPAD_9"] = 105] = "NUMPAD_9";
  KeyboardKey[KeyboardKey["MINUS"] = 109] = "MINUS";
  KeyboardKey[KeyboardKey["F1"] = 112] = "F1";
  KeyboardKey[KeyboardKey["F2"] = 113] = "F2";
  KeyboardKey[KeyboardKey["F3"] = 114] = "F3";
  KeyboardKey[KeyboardKey["F4"] = 115] = "F4";
  KeyboardKey[KeyboardKey["F5"] = 116] = "F5";
  KeyboardKey[KeyboardKey["F6"] = 117] = "F6";
  KeyboardKey[KeyboardKey["F7"] = 118] = "F7";
  KeyboardKey[KeyboardKey["F8"] = 119] = "F8";
  KeyboardKey[KeyboardKey["F9"] = 120] = "F9";
  KeyboardKey[KeyboardKey["F10"] = 121] = "F10";
  KeyboardKey[KeyboardKey["F11"] = 122] = "F11";
  KeyboardKey[KeyboardKey["F12"] = 123] = "F12";
  KeyboardKey[KeyboardKey["COMMA"] = 188] = "COMMA";
  KeyboardKey[KeyboardKey["PERIOD"] = 190] = "PERIOD";
  KeyboardKey[KeyboardKey["SLASH"] = 191] = "SLASH";
  KeyboardKey[KeyboardKey["GRAVE"] = 192] = "GRAVE";
  KeyboardKey[KeyboardKey["MOUSE_MOVEMENT"] = 195] = "MOUSE_MOVEMENT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_LEFT"] = 196] = "MOUSE_BUTTON_LEFT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_MIDDLE"] = 197] = "MOUSE_BUTTON_MIDDLE";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_RIGHT"] = 198] = "MOUSE_BUTTON_RIGHT";
  KeyboardKey[KeyboardKey["MOUSE_WHEEL"] = 199] = "MOUSE_WHEEL";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_1"] = 201] = "PSEUDO_KEY_1";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_2"] = 202] = "PSEUDO_KEY_2";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_3"] = 203] = "PSEUDO_KEY_3";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_4"] = 204] = "PSEUDO_KEY_4";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_5"] = 205] = "PSEUDO_KEY_5";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_6"] = 206] = "PSEUDO_KEY_6";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_7"] = 207] = "PSEUDO_KEY_7";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_8"] = 208] = "PSEUDO_KEY_8";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_9"] = 209] = "PSEUDO_KEY_9";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_10"] = 210] = "PSEUDO_KEY_10";
  KeyboardKey[KeyboardKey["BRACKET_OPEN"] = 219] = "BRACKET_OPEN";
  KeyboardKey[KeyboardKey["BACKSLASH"] = 220] = "BACKSLASH";
  KeyboardKey[KeyboardKey["BRACKET_CLOSE"] = 221] = "BRACKET_CLOSE";
  KeyboardKey[KeyboardKey["APOSTROPHE"] = 222] = "APOSTROPHE";
})(KeyboardKey || (KeyboardKey = {}));

let MouseButton;

(function (MouseButton) {
  MouseButton[MouseButton["Left"] = 0] = "Left";
  MouseButton[MouseButton["Middle"] = 1] = "Middle";
  MouseButton[MouseButton["Right"] = 2] = "Right";
  MouseButton[MouseButton["Back"] = 3] = "Back";
  MouseButton[MouseButton["Forward"] = 4] = "Forward";
})(MouseButton || (MouseButton = {}));
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/types.ts
/**
 * Custom alias provided by the user to identify a node in the focus tree
 * ie: "batata-frita"
 */

/**
 * This is the internal id of a node within the focus tree
 * ie: 2
 */

/**
 * This is the id set by the user to signal which node should be focused
 */
let FocusOrigin;

(function (FocusOrigin) {
  FocusOrigin[FocusOrigin["Unknown"] = -1] = "Unknown";
  FocusOrigin[FocusOrigin["Initial"] = 0] = "Initial";
  FocusOrigin[FocusOrigin["FocusInput"] = 1] = "FocusInput";
  FocusOrigin[FocusOrigin["PointerInput"] = 2] = "PointerInput";
  FocusOrigin[FocusOrigin["FocusTreeMutation"] = 3] = "FocusTreeMutation";
  FocusOrigin[FocusOrigin["URL"] = 4] = "URL";
  FocusOrigin[FocusOrigin["DebugTool"] = 5] = "DebugTool";
  FocusOrigin[FocusOrigin["ImperativeSetFocus"] = 6] = "ImperativeSetFocus";
})(FocusOrigin || (FocusOrigin = {}));

let types_ButtonType;

(function (ButtonType) {
  ButtonType["A"] = "A";
  ButtonType["B"] = "B";
  ButtonType["X"] = "X";
  ButtonType["Y"] = "Y";
  ButtonType["START"] = "START";
  ButtonType["SELECT"] = "SELECT";
  ButtonType["XBOX"] = "XBOX";
  ButtonType["RIGHT_TRIGGER"] = "RT";
  ButtonType["LEFT_TRIGGER"] = "LT";
  ButtonType["LEFT_BUMPER"] = "LB";
  ButtonType["RIGHT_BUMPER"] = "RB";
  ButtonType["L3"] = "L3";
  ButtonType["R3"] = "R3";
  ButtonType["LEFT"] = "LEFT";
  ButtonType["RIGHT"] = "RIGHT";
  ButtonType["UP"] = "UP";
  ButtonType["DOWN"] = "DOWN";
  ButtonType["NEXT"] = "NEXT";
  ButtonType["PREV"] = "PREV";
  ButtonType["LEFT_ANALOG_LEFT"] = "L_LEFT";
  ButtonType["LEFT_ANALOG_RIGHT"] = "L_RIGHT";
  ButtonType["LEFT_ANALOG_UP"] = "L_UP";
  ButtonType["LEFT_ANALOG_DOWN"] = "L_DOWN";
  ButtonType["RIGHT_ANALOG_LEFT"] = "R_LEFT";
  ButtonType["RIGHT_ANALOG_RIGHT"] = "R_RIGHT";
  ButtonType["RIGHT_ANALOG_UP"] = "R_UP";
  ButtonType["RIGHT_ANALOG_DOWN"] = "R_DOWN";
  ButtonType[ButtonType["LEFT_HORIZONTAL_AXIS"] = 0] = "LEFT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["LEFT_VERTICAL_AXIS"] = 1] = "LEFT_VERTICAL_AXIS";
  ButtonType[ButtonType["RIGHT_HORIZONTAL_AXIS"] = 2] = "RIGHT_HORIZONTAL_AXIS";
  ButtonType[ButtonType["RIGHT_VERTICAL_AXIS"] = 3] = "RIGHT_VERTICAL_AXIS";
  ButtonType["PSEUDO_BUTTON_1"] = "PSEUDO_BUTTON_1";
  ButtonType["PSEUDO_BUTTON_2"] = "PSEUDO_BUTTON_2";
  ButtonType["PSEUDO_BUTTON_3"] = "PSEUDO_BUTTON_3";
  ButtonType["PSEUDO_BUTTON_4"] = "PSEUDO_BUTTON_4";
  ButtonType["PSEUDO_BUTTON_5"] = "PSEUDO_BUTTON_5";
  ButtonType["PSEUDO_BUTTON_6"] = "PSEUDO_BUTTON_6";
  ButtonType["PSEUDO_BUTTON_7"] = "PSEUDO_BUTTON_7";
  ButtonType["PSEUDO_BUTTON_8"] = "PSEUDO_BUTTON_8";
  ButtonType["PSEUDO_BUTTON_9"] = "PSEUDO_BUTTON_9";
  ButtonType["PSEUDO_BUTTON_10"] = "PSEUDO_BUTTON_10";
})(types_ButtonType || (types_ButtonType = {}));

const DATA_LANDMARK_ID = 'data-landmark-id';
const types_DATA_FOCUSABLE_ID = 'data-focusable-id';
const DATA_FOCUSABLE_DEBUG_ID = 'data-focusable-debug-id';
let types_FocusTreeNodeType;

(function (FocusTreeNodeType) {
  FocusTreeNodeType[FocusTreeNodeType["ITEM"] = 0] = "ITEM";
  FocusTreeNodeType[FocusTreeNodeType["FOCUS_GROUP"] = 1] = "FOCUS_GROUP";
  FocusTreeNodeType[FocusTreeNodeType["LANDMARK"] = 2] = "LANDMARK";
  FocusTreeNodeType[FocusTreeNodeType["ROOT"] = 3] = "ROOT";
})(types_FocusTreeNodeType || (types_FocusTreeNodeType = {}));

let Axis;

(function (Axis) {
  Axis[Axis["HORIZONTAL"] = 0] = "HORIZONTAL";
  Axis[Axis["VERTICAL"] = 1] = "VERTICAL";
})(Axis || (Axis = {}));

let ScrollAxis;

(function (ScrollAxis) {
  ScrollAxis[ScrollAxis["HORIZONTAL"] = 0] = "HORIZONTAL";
  ScrollAxis[ScrollAxis["VERTICAL"] = 1] = "VERTICAL";
})(ScrollAxis || (ScrollAxis = {}));

const DEFAULT_ACTIONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.LEFT, types_ButtonType.DOWN, types_ButtonType.RIGHT, types_ButtonType.UP];
let Arrows;

(function (Arrows) {
  Arrows[Arrows["UP"] = 0] = "UP";
  Arrows[Arrows["RIGHT"] = 1] = "RIGHT";
  Arrows[Arrows["DOWN"] = 2] = "DOWN";
  Arrows[Arrows["LEFT"] = 3] = "LEFT";
})(Arrows || (Arrows = {}));

const mapButtonToArrow = {
  [types_ButtonType.LEFT_ANALOG_UP]: Arrows.UP,
  [types_ButtonType.UP]: Arrows.UP,
  [types_ButtonType.LEFT_ANALOG_DOWN]: Arrows.DOWN,
  [types_ButtonType.DOWN]: Arrows.DOWN,
  [types_ButtonType.LEFT_ANALOG_LEFT]: Arrows.LEFT,
  [types_ButtonType.LEFT]: Arrows.LEFT,
  [types_ButtonType.LEFT_ANALOG_RIGHT]: Arrows.RIGHT,
  [types_ButtonType.RIGHT]: Arrows.RIGHT
};
const mapMouseButtonToButtonType = {
  3: types_ButtonType.B
};
let Direction;

(function (Direction) {
  Direction[Direction["NEXT"] = -1] = "NEXT";
  Direction[Direction["PREVIOUS"] = 1] = "PREVIOUS";
})(Direction || (Direction = {}));

let NewFocusSuggestionReason;

(function (NewFocusSuggestionReason) {
  NewFocusSuggestionReason[NewFocusSuggestionReason["DefaultDelegation"] = 0] = "DefaultDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["FirstFoundDelegation"] = 1] = "FirstFoundDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["AliasDelegation"] = 2] = "AliasDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["MemoryDelegation"] = 3] = "MemoryDelegation";
  NewFocusSuggestionReason[NewFocusSuggestionReason["FocusableAliasMutation"] = 4] = "FocusableAliasMutation";
})(NewFocusSuggestionReason || (NewFocusSuggestionReason = {}));

const types_isFocusable = element => element.type === types_FocusTreeNodeType.ITEM || element.type === types_FocusTreeNodeType.LANDMARK && element.focusControlDisabled !== true || element.type === types_FocusTreeNodeType.ROOT;
const isAvailableFocusable = element => types_isFocusable(element) && !element.disabled && !element.hidden && element.ref != null;
const isFocusTreeNodeEnabled = element => !element.disabled && !element.hidden;
const isAvailableFocusableOrEnabledNonFocusable = element => types_isFocusable(element) ? isAvailableFocusable(element) : isFocusTreeNodeEnabled(element);
const isRoot = focusable => focusable != null && focusable.type === types_FocusTreeNodeType.ROOT;
const types_isDelegatingLandmark = focusable => focusable != null && focusable.type === types_FocusTreeNodeType.LANDMARK && focusable.focusControlDisabled !== true && 'getDelegatedFocus' in focusable;
const isBindingLandmark = element => types_isDelegatingLandmark(element) && 'shouldBindFocus' in element && element.shouldBindFocus === true;
const isFocusTreeNodeBecomingDisabled = (previousNode, currentNode) => previousNode.disabled === false && currentNode.disabled === true || previousNode.hidden === false && currentNode.hidden === true;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/focusTree.tsx



function getFreshTree() {
  return {
    focusableCount: 0,
    parentShortcutCount: 0,
    metadata: new Map(),
    focusableChildren: new Map(),
    containerChildren: new Map(),
    shortcutChildren: new Map(),
    parents: new Map(),
    aliases: new Map(),
    globalShortcuts: []
  };
}

function updateCount(focusTree, node, increment) {
  if (node.type === 'focusable') {
    focusTree.focusableCount += increment;
  }

  if (node.type === 'shortcut' && node.scope === 'parent') {
    focusTree.parentShortcutCount += increment;
  }
}

function hasInteractiveNode(focusTree) {
  return focusTree.focusableCount > 0 || focusTree.parentShortcutCount > 0 || focusTree.globalShortcuts.length > 0;
}
/**
 *
 * @returns true if was added
 */

function addOrUpdateNode(focusTree, node) {
  const previousNode = getNode(focusTree, node.id);

  if (previousNode) {
    if (node.type === 'focusable') {
      const originalAlias = getAlias(focusTree, node.id);
      const newAlias = node.alias;

      if (originalAlias !== newAlias) {
        // remove old alias
        if (originalAlias != null) {
          focusTree.aliases.delete(originalAlias);
        } // new alias


        if (newAlias != null) {
          focusTree.aliases.set(newAlias, node.id);
        }
      }
    }

    focusTree.metadata.set(node.id, node);
    return false;
  } else {
    if (false) {}

    focusTree.metadata.set(node.id, node);
    updateCount(focusTree, node, 1);

    if (node.type === 'focusable' && node.alias != null) {
      focusTree.aliases.set(node.alias, node.id);
    }

    if (node.type === 'shortcut' && node.scope === 'global') {
      focusTree.globalShortcuts = union_default()([node.id], focusTree.globalShortcuts);
      return true;
    }

    node.path.forEach((id, index) => {
      const childrenGroup = index < node.path.length - 1 ? 'containerChildren' : node.type === 'focusable' ? 'focusableChildren' : node.type === 'shortcut' ? 'shortcutChildren' : 'containerChildren';
      const children = focusTree[childrenGroup].get(id) || [];
      const nextChild = index === node.path.length - 1 ? node.id : node.path[index + 1];
      focusTree[childrenGroup].set(id, union_default()(children, [nextChild]));
      focusTree.parents.set(nextChild, id);
    });
    return true;
  }
}

const logErrorOnDuplicatedAlias = (focusTree, alias) => {
  for (const entry of focusTree.metadata) {
    if (entry[1].type === 'focusable' && entry[1].alias === alias) {
      console.warn(`The gamepad focus alias ${alias} is duplicated. Duplicated aliases might causes issues with focus and gamepad navigation.`);
    }
  }
};

function removeNode(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);
  if (!node) return;
  updateCount(focusTree, node, -1);
  const parent = getParentId(focusTree, nodeId);

  if (node.type === 'focusable' && node.alias != null) {
    focusTree.aliases.delete(node.alias);
  }

  if (node.type === 'shortcut' && node.scope === 'global') {
    focusTree.globalShortcuts = without_default()([nodeId], focusTree.globalShortcuts);
  } else if (parent != null) {
    if (node.type === 'shortcut' && node.scope === 'parent') {
      const parentChildren = focusTree.shortcutChildren.get(parent);

      if (parentChildren) {
        focusTree.shortcutChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    } else if (node.type === 'focusable') {
      const parentChildren = focusTree.focusableChildren.get(parent);

      if (parentChildren) {
        focusTree.focusableChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    } else {
      const parentChildren = focusTree.containerChildren.get(parent);

      if (parentChildren) {
        focusTree.containerChildren.set(parent, without_default()([nodeId], parentChildren));
      }
    }
  }

  focusTree.parents.delete(nodeId);
  focusTree.metadata.delete(nodeId);
}
function getAlias(focusTree, nodeId) {
  const focusable = getFocusable(focusTree, nodeId);
  if (focusable) return focusable.alias;
}
/**
 * Given a focusedId, it uses the alias information to find the NodeId of what should be considered focused
 */

function findNodeIdFromFocusedId(focusTree, focusedId) {
  if (focusedId == null) {
    return undefined;
  } // convert from an alias (if provided)


  const nodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId; // check if the node exists, and if it is enabled

  if (nodeId != null && isNodeEnabled(focusTree, nodeId)) return nodeId;
  return undefined;
}
/**
 * Finds a fallback NodeId that can hold focus
 *
 * To be used when a provided focusedId doesn't resolve in a valid NodeID
 * which could cause the UI to be stuck.
 *
 * Having a fallback NodeId allows the user to navigate if something goes wrong
 */

function findFallbackNodeId(focusTree) {
  const anythingElse = find(focusTree.metadata, (node, id) => {
    return node.type === 'focusable' && isNodeEnabled(focusTree, id);
  });

  if (anythingElse) {
    return anythingElse.id;
  }
}

function find(map, predicate) {
  for (const [key, value] of map) {
    if (predicate(value, key)) return value;
  }
}

function findClickableFocusableAtPoint(focusTree, x, y) {
  return findNode(focusTree, metadata => {
    if (metadata.type !== 'focusable' || metadata.disabled || !metadata.onClick || !metadata.ref || !metadata.ref.current) return false;
    const rect = metadata.ref.current.getBoundingClientRect();
    return x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height;
  });
}
function isNodeEnabled(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);
  if (node == null) return false;
  if (node.disabled) return false;
  const ancestors = getAncestorIds(focusTree, nodeId);

  for (let i = 0; i < ancestors.length; i++) {
    const node = getNode(focusTree, ancestors[i]);

    if (node == null || !!node.disabled) {
      return false;
    }
  }

  return true;
}
function getNode(focusTree, nodeId) {
  return focusTree.metadata.get(nodeId);
}
function getFocusable(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);

  if (node && node.type === 'focusable') {
    return node;
  }
}
const containerTypes = ['column', 'row'];
function isContainer(node) {
  return containerTypes.includes(node.type);
}
function getShortcut(focusTree, nodeId) {
  const node = getNode(focusTree, nodeId);

  if (node && node.type === 'shortcut') {
    return node;
  }
}
function getParentId(focusTree, nodeId) {
  return focusTree.parents.get(nodeId);
}
function getAncestorIds(focusTree, nodeId) {
  const parent = getParentId(focusTree, nodeId);

  if (parent == null) {
    return [];
  }

  return [parent, ...getAncestorIds(focusTree, parent)];
}
function getAncestorNodes(focusTree, nodeId) {
  return getAncestorIds(focusTree, nodeId).map(id => getNode(focusTree, id)).filter(node => node != null);
}
function getChildrenIds(focusTree, nodeId) {
  return [...(focusTree.containerChildren.get(nodeId) || []), ...(focusTree.focusableChildren.get(nodeId) || [])];
}
function getLeafIds(focusTree, nodeId) {
  const children = getChildrenIds(focusTree, nodeId);
  if (children.length === 0) return [nodeId];
  return children.map(childId => getLeafIds(focusTree, childId)).reduce((leaves, all) => [...leaves, ...all], []);
}
function findNode(focusTree, predicate) {
  return find(focusTree.metadata, predicate);
}
/**
 * Find shortcuts as well as the current focused node
 * to be displayed as hints in the InputLegend.
 *
 * Note that the nodes without an inputLegend are not included in the output.
 */

function findInputLegends(focusTree, nodeId) {
  const focusable = nodeId != null ? getFocusable(focusTree, nodeId) : undefined;
  const result = {};

  for (const buttonType of INPUT_LEGEND_BUTTONS) {
    var _findInputLegendNode$, _findInputLegendNode;

    result[buttonType] = (_findInputLegendNode$ = (_findInputLegendNode = findInputLegendNode(focusTree, nodeId, buttonType)) === null || _findInputLegendNode === void 0 ? void 0 : _findInputLegendNode.inputLegend) !== null && _findInputLegendNode$ !== void 0 ? _findInputLegendNode$ : buttonType === types_ButtonType.A ? focusable === null || focusable === void 0 ? void 0 : focusable.inputLegend : undefined;
  }

  return result;
}
function findInputLegendNode(focusTree, nodeId, button) {
  const predicate = node => node.shortcut === button && node.inputLegend != null && !node.disabled;

  const shortcutId = findShortcutId(focusTree, nodeId, predicate);
  if (shortcutId == null) return;
  const shortcut = getNode(focusTree, shortcutId);
  if (shortcut == null || !('shortcut' in shortcut) || shortcut.inputLegend == null) return;
  return shortcut;
}
function findShortcut(focusTree, nodeId, button) {
  const predicate = node => node.shortcut === button && !node.disabled;

  const shortcutId = findShortcutId(focusTree, nodeId, predicate);
  if (shortcutId == null) return;
  const shortcut = getNode(focusTree, shortcutId);
  if (shortcut == null || !('shortcut' in shortcut)) return;
  return shortcut;
}
function findShortcutId(focusTree, nodeId, predicate) {
  const parentShortcutId = nodeId != null ? findParentShortcutId(focusTree, nodeId, predicate) : undefined;
  return parentShortcutId !== null && parentShortcutId !== void 0 ? parentShortcutId : findGlobalShortcutId(focusTree, predicate);
}

function findParentShortcutId(focusTree, nodeId, predicate) {
  const parentId = getParentId(focusTree, nodeId);
  if (parentId == null) return undefined;
  const shortcutChildren = focusTree.shortcutChildren.get(parentId);
  if (shortcutChildren == null) return findParentShortcutId(focusTree, parentId, predicate);
  const shortcutId = shortcutChildren.find(id => {
    const shortcut = getShortcut(focusTree, id);
    return shortcut ? predicate(shortcut) : undefined;
  });
  return shortcutId != null ? shortcutId : findParentShortcutId(focusTree, parentId, predicate);
}

function findGlobalShortcutId(focusTree, predicate) {
  return focusTree.globalShortcuts.find(id => {
    const shortcut = getNode(focusTree, id);
    return shortcut != null ? predicate(shortcut) : undefined;
  });
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/apiContext.tsx


const logWarning = () => {
  if (false) {}
};

const GamepadAPIContext = (0,react.createContext)({
  runAddNodeEffect: () => {},
  isFocusableFocused: () => {
    logWarning();
    return false;
  },
  addOrUpdateNode: logWarning,
  removeNode: logWarning,
  requestAutofocus: logWarning,
  requestFocus: logWarning,
  addAnalogListener: () => {
    logWarning();
    return () => {};
  },
  addDigitalListener: () => {
    logWarning();
    return () => {};
  },
  clickFocusableAtPoint: logWarning,
  focusFocusableAtPoint: logWarning,
  getCurrentFocusable: () => undefined
});
const {
  Provider,
  Consumer
} = GamepadAPIContext;
const GamepadAPIProvider = Provider;
const GamepadAPIConsumer = (/* unused pure expression or super */ null && (Consumer));
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/types.ts
// TODO Create a interface for the button_map with backend

const types_AXIS_MAP = [[types_ButtonType.LEFT_ANALOG_LEFT, types_ButtonType.LEFT_ANALOG_RIGHT], [types_ButtonType.LEFT_ANALOG_UP, types_ButtonType.LEFT_ANALOG_DOWN], [types_ButtonType.RIGHT_ANALOG_LEFT, types_ButtonType.RIGHT_ANALOG_RIGHT], [types_ButtonType.RIGHT_ANALOG_UP, types_ButtonType.RIGHT_ANALOG_DOWN]];
/**
 * Type for buttons which can be mapped to a keyboard key
 */

const types_KEYBOARD_MAPPABLE_BUTTON = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.XBOX, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.PSEUDO_BUTTON_1, types_ButtonType.PSEUDO_BUTTON_2, types_ButtonType.PSEUDO_BUTTON_3, types_ButtonType.PSEUDO_BUTTON_4, types_ButtonType.PSEUDO_BUTTON_5, types_ButtonType.PSEUDO_BUTTON_6, types_ButtonType.PSEUDO_BUTTON_7, types_ButtonType.PSEUDO_BUTTON_8, types_ButtonType.PSEUDO_BUTTON_9, types_ButtonType.PSEUDO_BUTTON_10];
/**
 * Type for buttons which can be displayed on input legends
 */

const types_INPUT_LEGEND_BUTTONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.LEFT_ANALOG_LEFT, types_ButtonType.RIGHT_ANALOG_LEFT, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER];
const types_ACTION_BUTTONS = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.START, types_ButtonType.SELECT, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.R3, types_ButtonType.L3];
const types_BUTTON_MAP = [types_ButtonType.A, types_ButtonType.B, types_ButtonType.X, types_ButtonType.Y, types_ButtonType.LEFT_BUMPER, types_ButtonType.RIGHT_BUMPER, types_ButtonType.LEFT_TRIGGER, types_ButtonType.RIGHT_TRIGGER, types_ButtonType.SELECT, types_ButtonType.START, types_ButtonType.L3, types_ButtonType.R3, types_ButtonType.UP, types_ButtonType.DOWN, types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.XBOX];
const types_DIRECTIONAL_BUTTONS = [types_ButtonType.LEFT, types_ButtonType.RIGHT, types_ButtonType.UP, types_ButtonType.DOWN];
const types_ACTION_BUTTONS_INDEX = types_ACTION_BUTTONS.map(string => types_BUTTON_MAP.indexOf(string));
const types_DIRECTIONAL_BUTTONS_INDEX = types_DIRECTIONAL_BUTTONS.map(string => types_BUTTON_MAP.indexOf(string));
let types_KeyboardKey;

(function (KeyboardKey) {
  KeyboardKey[KeyboardKey["BACKSPACE"] = 8] = "BACKSPACE";
  KeyboardKey[KeyboardKey["TAB"] = 9] = "TAB";
  KeyboardKey[KeyboardKey["ENTER"] = 13] = "ENTER";
  KeyboardKey[KeyboardKey["SHIFT"] = 16] = "SHIFT";
  KeyboardKey[KeyboardKey["CTRL"] = 17] = "CTRL";
  KeyboardKey[KeyboardKey["ALT"] = 18] = "ALT";
  KeyboardKey[KeyboardKey["CAPS_LOCK"] = 20] = "CAPS_LOCK";
  KeyboardKey[KeyboardKey["ESCAPE"] = 27] = "ESCAPE";
  KeyboardKey[KeyboardKey["SPACE"] = 32] = "SPACE";
  KeyboardKey[KeyboardKey["PG_UP"] = 33] = "PG_UP";
  KeyboardKey[KeyboardKey["PG_DOWN"] = 34] = "PG_DOWN";
  KeyboardKey[KeyboardKey["END"] = 35] = "END";
  KeyboardKey[KeyboardKey["LEFT"] = 37] = "LEFT";
  KeyboardKey[KeyboardKey["UP"] = 38] = "UP";
  KeyboardKey[KeyboardKey["RIGHT"] = 39] = "RIGHT";
  KeyboardKey[KeyboardKey["DOWN"] = 40] = "DOWN";
  KeyboardKey[KeyboardKey["INSERT"] = 45] = "INSERT";
  KeyboardKey[KeyboardKey["DELETE"] = 46] = "DELETE";
  KeyboardKey[KeyboardKey["KEY_0"] = 48] = "KEY_0";
  KeyboardKey[KeyboardKey["KEY_1"] = 49] = "KEY_1";
  KeyboardKey[KeyboardKey["KEY_2"] = 50] = "KEY_2";
  KeyboardKey[KeyboardKey["KEY_3"] = 51] = "KEY_3";
  KeyboardKey[KeyboardKey["KEY_4"] = 52] = "KEY_4";
  KeyboardKey[KeyboardKey["KEY_5"] = 53] = "KEY_5";
  KeyboardKey[KeyboardKey["KEY_6"] = 54] = "KEY_6";
  KeyboardKey[KeyboardKey["KEY_7"] = 55] = "KEY_7";
  KeyboardKey[KeyboardKey["KEY_8"] = 56] = "KEY_8";
  KeyboardKey[KeyboardKey["KEY_9"] = 57] = "KEY_9";
  KeyboardKey[KeyboardKey["SEMICOLON"] = 59] = "SEMICOLON";
  KeyboardKey[KeyboardKey["EQUALS"] = 61] = "EQUALS";
  KeyboardKey[KeyboardKey["KEY_A"] = 65] = "KEY_A";
  KeyboardKey[KeyboardKey["KEY_B"] = 66] = "KEY_B";
  KeyboardKey[KeyboardKey["KEY_C"] = 67] = "KEY_C";
  KeyboardKey[KeyboardKey["KEY_D"] = 68] = "KEY_D";
  KeyboardKey[KeyboardKey["KEY_E"] = 69] = "KEY_E";
  KeyboardKey[KeyboardKey["KEY_F"] = 70] = "KEY_F";
  KeyboardKey[KeyboardKey["KEY_G"] = 71] = "KEY_G";
  KeyboardKey[KeyboardKey["KEY_H"] = 72] = "KEY_H";
  KeyboardKey[KeyboardKey["KEY_I"] = 73] = "KEY_I";
  KeyboardKey[KeyboardKey["KEY_J"] = 74] = "KEY_J";
  KeyboardKey[KeyboardKey["KEY_K"] = 75] = "KEY_K";
  KeyboardKey[KeyboardKey["KEY_L"] = 76] = "KEY_L";
  KeyboardKey[KeyboardKey["KEY_M"] = 77] = "KEY_M";
  KeyboardKey[KeyboardKey["KEY_N"] = 78] = "KEY_N";
  KeyboardKey[KeyboardKey["KEY_O"] = 79] = "KEY_O";
  KeyboardKey[KeyboardKey["KEY_P"] = 80] = "KEY_P";
  KeyboardKey[KeyboardKey["KEY_Q"] = 81] = "KEY_Q";
  KeyboardKey[KeyboardKey["KEY_R"] = 82] = "KEY_R";
  KeyboardKey[KeyboardKey["KEY_S"] = 83] = "KEY_S";
  KeyboardKey[KeyboardKey["KEY_T"] = 84] = "KEY_T";
  KeyboardKey[KeyboardKey["KEY_U"] = 85] = "KEY_U";
  KeyboardKey[KeyboardKey["KEY_V"] = 86] = "KEY_V";
  KeyboardKey[KeyboardKey["KEY_W"] = 87] = "KEY_W";
  KeyboardKey[KeyboardKey["KEY_X"] = 88] = "KEY_X";
  KeyboardKey[KeyboardKey["KEY_Y"] = 89] = "KEY_Y";
  KeyboardKey[KeyboardKey["KEY_Z"] = 90] = "KEY_Z";
  KeyboardKey[KeyboardKey["NUMPAD_0"] = 96] = "NUMPAD_0";
  KeyboardKey[KeyboardKey["NUMPAD_1"] = 97] = "NUMPAD_1";
  KeyboardKey[KeyboardKey["NUMPAD_2"] = 98] = "NUMPAD_2";
  KeyboardKey[KeyboardKey["NUMPAD_3"] = 99] = "NUMPAD_3";
  KeyboardKey[KeyboardKey["NUMPAD_4"] = 100] = "NUMPAD_4";
  KeyboardKey[KeyboardKey["NUMPAD_5"] = 101] = "NUMPAD_5";
  KeyboardKey[KeyboardKey["NUMPAD_6"] = 102] = "NUMPAD_6";
  KeyboardKey[KeyboardKey["NUMPAD_7"] = 103] = "NUMPAD_7";
  KeyboardKey[KeyboardKey["NUMPAD_8"] = 104] = "NUMPAD_8";
  KeyboardKey[KeyboardKey["NUMPAD_9"] = 105] = "NUMPAD_9";
  KeyboardKey[KeyboardKey["MINUS"] = 109] = "MINUS";
  KeyboardKey[KeyboardKey["F1"] = 112] = "F1";
  KeyboardKey[KeyboardKey["F2"] = 113] = "F2";
  KeyboardKey[KeyboardKey["F3"] = 114] = "F3";
  KeyboardKey[KeyboardKey["F4"] = 115] = "F4";
  KeyboardKey[KeyboardKey["F5"] = 116] = "F5";
  KeyboardKey[KeyboardKey["F6"] = 117] = "F6";
  KeyboardKey[KeyboardKey["F7"] = 118] = "F7";
  KeyboardKey[KeyboardKey["F8"] = 119] = "F8";
  KeyboardKey[KeyboardKey["F9"] = 120] = "F9";
  KeyboardKey[KeyboardKey["F10"] = 121] = "F10";
  KeyboardKey[KeyboardKey["F11"] = 122] = "F11";
  KeyboardKey[KeyboardKey["F12"] = 123] = "F12";
  KeyboardKey[KeyboardKey["COMMA"] = 188] = "COMMA";
  KeyboardKey[KeyboardKey["PERIOD"] = 190] = "PERIOD";
  KeyboardKey[KeyboardKey["SLASH"] = 191] = "SLASH";
  KeyboardKey[KeyboardKey["GRAVE"] = 192] = "GRAVE";
  KeyboardKey[KeyboardKey["MOUSE_MOVEMENT"] = 195] = "MOUSE_MOVEMENT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_LEFT"] = 196] = "MOUSE_BUTTON_LEFT";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_MIDDLE"] = 197] = "MOUSE_BUTTON_MIDDLE";
  KeyboardKey[KeyboardKey["MOUSE_BUTTON_RIGHT"] = 198] = "MOUSE_BUTTON_RIGHT";
  KeyboardKey[KeyboardKey["MOUSE_WHEEL"] = 199] = "MOUSE_WHEEL";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_1"] = 201] = "PSEUDO_KEY_1";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_2"] = 202] = "PSEUDO_KEY_2";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_3"] = 203] = "PSEUDO_KEY_3";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_4"] = 204] = "PSEUDO_KEY_4";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_5"] = 205] = "PSEUDO_KEY_5";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_6"] = 206] = "PSEUDO_KEY_6";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_7"] = 207] = "PSEUDO_KEY_7";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_8"] = 208] = "PSEUDO_KEY_8";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_9"] = 209] = "PSEUDO_KEY_9";
  KeyboardKey[KeyboardKey["PSEUDO_KEY_10"] = 210] = "PSEUDO_KEY_10";
  KeyboardKey[KeyboardKey["BRACKET_OPEN"] = 219] = "BRACKET_OPEN";
  KeyboardKey[KeyboardKey["BACKSLASH"] = 220] = "BACKSLASH";
  KeyboardKey[KeyboardKey["BRACKET_CLOSE"] = 221] = "BRACKET_CLOSE";
  KeyboardKey[KeyboardKey["APOSTROPHE"] = 222] = "APOSTROPHE";
})(types_KeyboardKey || (types_KeyboardKey = {}));

let types_MouseButton;

(function (MouseButton) {
  MouseButton[MouseButton["Left"] = 0] = "Left";
  MouseButton[MouseButton["Middle"] = 1] = "Middle";
  MouseButton[MouseButton["Right"] = 2] = "Right";
  MouseButton[MouseButton["Back"] = 3] = "Back";
  MouseButton[MouseButton["Forward"] = 4] = "Forward";
})(types_MouseButton || (types_MouseButton = {}));
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/keyboardGamepadMap.ts




/*
 * Default mapping of keyboard keys to gamepad buttons
 */

const DEFAULT_KEYBOARD_GAMEPAD_MAP = {
  [types_ButtonType.UP]: [types_KeyboardKey.UP],
  [types_ButtonType.DOWN]: [types_KeyboardKey.DOWN],
  [types_ButtonType.LEFT]: [types_KeyboardKey.LEFT],
  [types_ButtonType.RIGHT]: [types_KeyboardKey.RIGHT],
  [types_ButtonType.X]: [types_KeyboardKey.KEY_X],
  [types_ButtonType.Y]: [types_KeyboardKey.KEY_Y],
  [types_ButtonType.A]: [types_KeyboardKey.ENTER, types_KeyboardKey.SPACE],
  [types_ButtonType.B]: [types_KeyboardKey.ESCAPE, types_KeyboardKey.BACKSPACE],
  [types_ButtonType.LEFT_TRIGGER]: [types_KeyboardKey.KEY_Q],
  [types_ButtonType.RIGHT_TRIGGER]: [types_KeyboardKey.KEY_Z],
  [types_ButtonType.LEFT_BUMPER]: [types_KeyboardKey.BRACKET_OPEN],
  [types_ButtonType.RIGHT_BUMPER]: [types_KeyboardKey.BRACKET_CLOSE],
  // TODO: Consolidate how to display joystick input legend without adding
  //       the joystick left movement to the KeyboardMappableButton list. and once that's done remove LEFT_ANALOG_LEFT and RIGHT_ANALOG_RIGHT.
  [types_ButtonType.LEFT_ANALOG_LEFT]: [types_KeyboardKey.KEY_9],
  [types_ButtonType.RIGHT_ANALOG_LEFT]: [types_KeyboardKey.KEY_0],
  [types_ButtonType.START]: [types_KeyboardKey.F10],
  [types_ButtonType.SELECT]: [types_KeyboardKey.F11],
  [types_ButtonType.XBOX]: [types_KeyboardKey.F1],
  [types_ButtonType.L3]: [types_KeyboardKey.F2],
  [types_ButtonType.R3]: [types_KeyboardKey.F3],
  [types_ButtonType.PSEUDO_BUTTON_1]: [types_KeyboardKey.PSEUDO_KEY_1],
  [types_ButtonType.PSEUDO_BUTTON_2]: [types_KeyboardKey.PSEUDO_KEY_2],
  [types_ButtonType.PSEUDO_BUTTON_3]: [types_KeyboardKey.PSEUDO_KEY_3],
  [types_ButtonType.PSEUDO_BUTTON_4]: [types_KeyboardKey.PSEUDO_KEY_4],
  [types_ButtonType.PSEUDO_BUTTON_5]: [types_KeyboardKey.PSEUDO_KEY_5],
  [types_ButtonType.PSEUDO_BUTTON_6]: [types_KeyboardKey.PSEUDO_KEY_6],
  [types_ButtonType.PSEUDO_BUTTON_7]: [types_KeyboardKey.PSEUDO_KEY_7],
  [types_ButtonType.PSEUDO_BUTTON_8]: [types_KeyboardKey.PSEUDO_KEY_8],
  [types_ButtonType.PSEUDO_BUTTON_9]: [types_KeyboardKey.PSEUDO_KEY_9],
  [types_ButtonType.PSEUDO_BUTTON_10]: [types_KeyboardKey.PSEUDO_KEY_10]
};
const defaultFacet = (0,react_facet_src.createStaticFacet)(DEFAULT_KEYBOARD_GAMEPAD_MAP);
const keyboardGamepadMapContext = (0,react.createContext)([defaultFacet, () => {}]);
const useKeyboardGamepadMap = () => (0,react.useContext)(keyboardGamepadMapContext);
/**
 * Hook that sets up a new keyboardGamepadMap.
 * This hook will update the keyboardGamepadMap on mount, so any changes
 * to the keyboardGamepadMap after the component is mounted will be ignored.
 *
 * @param keyboardGamepadMap the new keyboardGamepadMap
 */

const useSetKeyboardGamepadMap = (keyboardGamepadMap, hidden) => {
  const [, setKeyboardGamepadMap] = useKeyboardGamepadMap();
  useFacetEffect(hidden => {
    if (hidden !== true) {
      // This is an example of how a particular Screen can override the
      // keyboardGamepadMap set in the Application. The hook will update
      // the keyboardGamepadMap when this component is mounted.
      setKeyboardGamepadMap(keyboardGamepadMap);
    } // We disable the exhaustive-deps linting rule because we do not want to set
    // the keyboardGamepadMap again if it changes. We only want to set it on mount
    // or when being shown
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [setKeyboardGamepadMap, keyboardGamepadMap], [hidden]);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/buttonMap.ts


const Context = (0,react.createContext)((0,react_facet_src.createStaticFacet)({
  swapABButtons: false,
  swapXYButtons: false
}));
const useButtonMap = () => (0,react.useContext)(Context);
const ButtonMapProvider = Context.Provider;
const ButtonMapConsumer = Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/availableInputLegends.tsx


const availableInputLegendsContext = (0,react_facet_src.createFacetContext)({});
const useAvailableInputLegends = () => (0,react.useContext)(availableInputLegendsContext);
const AvailableInputLegendsProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(availableInputLegendsContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/invokeCurrentCallback.tsx

const invokeCurrentCallbackContext = (0,react.createContext)(undefined);
const useInputLegendCallback = () => (0,react.useContext)(invokeCurrentCallbackContext);
const InvokeCurrentCallbackProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(invokeCurrentCallbackContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useSetFocusedId.tsx


const setFocusedIdContext = (0,react.createContext)(() => () => {});
/**
 * Hook that allows access to a function to imperatively set the focused id
 * On setting a focusedId, it returns a "restore" function that can be called to restore the focus to a previous state
 */

const useSetFocusedId_useSetFocusedId = () => (0,react.useContext)(setFocusedIdContext);

/**
 * Provider to be used internally in the GamepadProvider
 * (not a public API)
 */
const SetFocusedIdProvider = ({
  onFocusedIdChange,
  children,
  focusedId
}) => {
  const setFocusedId = (0,react_facet_src.useFacetCallback)(oldFocusedId => newFocusedId => {
    onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange(newFocusedId);
    return () => onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange(oldFocusedId);
  }, [onFocusedIdChange], [focusedId]);
  return /*#__PURE__*/react.createElement(setFocusedIdContext.Provider, {
    value: setFocusedId
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInputLegends.ts



/**
 * Hook that keeps the logic to re-calculate the "input legends" given the currently focused node
 *
 * Because the "input legends" can also change if the "focus tree" changes, this also keeps track lastKnownTreeUpdate
 */
function useInputLegends(providerState, focusedId, lastKnownTreeUpdate) {
  return (0,react_facet_src.useFacetMemo)(focusedId => {
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    return findInputLegends(providerState.focusTree, focusedNodeId);
  }, [providerState], // listen for the lastKnownTreeUpdate so we can recalculate the input legends when a component gets mounted, for example
  [focusedId, lastKnownTreeUpdate], equalInputLegends);
}
/**
 * Purposefully made comparison function done for performance reasons
 */

const equalInputLegends = () => {
  /**
   * We need to set the initial value as uninitialized otherwise the equalityCheck will prevent the
   * initial value of the input legends facet (everything with undefined) to be propagated.
   */
  let A = '---uninitialized---';
  let B = '---uninitialized---';
  let START = '---uninitialized---';
  let X = '---uninitialized---';
  let Y = '---uninitialized---';
  return current => {
    if (current.A === A && current.B === B && current.START === START && current.X === X && current.Y === Y) return true;
    A = current.A;
    B = current.B;
    START = current.START;
    X = current.X;
    Y = current.Y;
    return false;
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInvokeCurrentCallback.ts


function useInvokeCurrentCallback(providerState, focusedId) {
  return (0,react_facet_src.useFacetCallback)(focusedId => actionButton => {
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    const node = findShortcut(providerState.focusTree, focusedNodeId, actionButton);
    node === null || node === void 0 ? void 0 : node.onClick();
  }, [providerState], [focusedId]);
}
// EXTERNAL MODULE: ./node_modules/ramda/src/findIndex.js
var findIndex = __webpack_require__(53523);
var findIndex_default = /*#__PURE__*/__webpack_require__.n(findIndex);
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/navigate.tsx



function canNavigate(type, direction) {
  if (type === 'column' && (direction === 'right' || direction === 'left')) {
    return false;
  }

  if (type === 'row' && (direction === 'up' || direction === 'down')) {
    return false;
  }

  return true;
}

function isStartDirection(direction) {
  return direction === 'left' || direction === 'up' || direction === 'prev';
}

function getDirectionOffset(direction) {
  return isStartDirection(direction) ? -1 : 1;
}

function searchForNextNodeInDirection(currentNodeId, indexableChildren, direction) {
  const focusedIndex = findIndex_default()(node => node.id === currentNodeId, indexableChildren);

  const siblingIndex = focusedIndex + getDirectionOffset(direction);
  return indexableChildren[siblingIndex];
}

const searchForNextNodeByFocusChildBehavior = (parentId, focusState, focusTree, siblings, gridIndex, direction) => {
  const container = getNode(focusTree, parentId);
  const defaultFocusedChildBehavior = container.defaultFocusedChildBehavior;
  const defaultFocusedChildAlias = container.defaultFocusedChildAlias; // When the defaultFocusedChildBehavior is set to remember we're potentially
  // taking a shortcut to a focusable further down in the tree. We need to make
  // sure that the part of the tree that the focusable resides in haven't been
  // disabled since the last time we visited it.

  if (defaultFocusedChildBehavior === 'remember') {
    const cachedNodeId = focusState.get(parentId);

    if (cachedNodeId != null) {
      let isInDisabledBranch = false;
      let nextAncestorId = getParentId(focusTree, cachedNodeId);

      while (nextAncestorId != null && !isInDisabledBranch) {
        const parentNode = getNode(focusTree, nextAncestorId);
        isInDisabledBranch = !!(parentNode !== null && parentNode !== void 0 && parentNode.disabled);
        nextAncestorId = getParentId(focusTree, nextAncestorId);
      }

      if (!isInDisabledBranch) {
        return getNode(focusTree, cachedNodeId);
      }
    }
  }

  if (defaultFocusedChildAlias != null) {
    return siblings.find(sibling => sibling.type === 'focusable' && sibling.alias != null && sibling.alias !== '' && sibling.alias === defaultFocusedChildAlias);
  }

  if (defaultFocusedChildBehavior === 'grid') {
    return siblings.find(sibling => sibling.index === gridIndex);
  }

  if (defaultFocusedChildBehavior === 'last') {
    return siblings[siblings.length - 1];
  }

  if (defaultFocusedChildBehavior === 'first') {
    return siblings[0];
  } // If we didn't match any of the previous behavior, it means it should be sequential.
  // NOTE: The behavior "remember" will also use this as a fallback.


  const siblingIndex = isStartDirection(direction) ? siblings.length - 1 : 0;
  return siblings[siblingIndex];
};

function depthFirstSearch({
  focusTree,
  parentId,
  shouldFindDefaultFocusedChild,
  direction,
  currentNodeId,
  focusState,
  gridIndex,
  stack = [],
  visisted = {}
}) {
  var _nextItem, _nextItem$id, _nextItem3;

  // Get all the indexable nodes from the parent container and sort them based
  // on their sequential index.
  const indexableChildren = getChildrenIds(focusTree, parentId).map(id => getNode(focusTree, id)).filter(node => (node === null || node === void 0 ? void 0 : node.type) != 'shortcut' && !(node !== null && node !== void 0 && node.disabled)).sort((a, b) => a.index - b.index); // If we're searching based on focus child behavior it means that we've found
  // a branch in the correct direction to explore.

  let nextItem;

  if (shouldFindDefaultFocusedChild) {
    nextItem = searchForNextNodeByFocusChildBehavior(parentId, focusState, focusTree, indexableChildren, gridIndex, direction);
  }

  if (nextItem == null) {
    nextItem = searchForNextNodeInDirection(currentNodeId, indexableChildren, direction);
  } // If the nextItem is a focusable we've found what we were looking for and
  // can end the recursion.


  if (((_nextItem = nextItem) === null || _nextItem === void 0 ? void 0 : _nextItem.type) === 'focusable') {
    return nextItem.id;
  } // If the nextItem is a container we'll add its siblings to the stack of
  // nodes that we'll potentially have to explore.


  if (nextItem != null && isContainer(nextItem)) {
    var _getChildrenIds$filte, _getChildrenIds;

    const nextItemSiblings = (_getChildrenIds$filte = (_getChildrenIds = getChildrenIds(focusTree, parentId)) === null || _getChildrenIds === void 0 ? void 0 : _getChildrenIds.filter(id => {
      var _nextItem2;

      return id != ((_nextItem2 = nextItem) === null || _nextItem2 === void 0 ? void 0 : _nextItem2.id);
    })) !== null && _getChildrenIds$filte !== void 0 ? _getChildrenIds$filte : [];
    stack.push(...nextItemSiblings);
  } // All the children (if there were any) are now in the stack. Therefore,
  // we'll mark this branch as having been visisted.


  visisted[parentId] = true; // If the nextItem is a container we'll drill down. If it's undefined we'll
  // pick the next branch to explore from the stack of nodes.

  const nextBranchToSearch = (_nextItem$id = (_nextItem3 = nextItem) === null || _nextItem3 === void 0 ? void 0 : _nextItem3.id) !== null && _nextItem$id !== void 0 ? _nextItem$id : stack.filter(id => !visisted[id]).pop();
  return nextBranchToSearch != null ? depthFirstSearch({
    focusTree,
    parentId: nextBranchToSearch,
    shouldFindDefaultFocusedChild: true,
    direction,
    currentNodeId,
    focusState,
    gridIndex,
    stack,
    visisted
  }) : undefined;
}

function navigateToDirection(focusTree, nodeId, focusState, direction) {
  // This gets the path all the way down to the node we're currently focused on.
  const ancestryPath = [nodeId, ...getAncestorIds(focusTree, nodeId)]; // This gets the sequential index of the currently focused node within its container.

  const sequentialIndex = getNode(focusTree, nodeId).index;
  let nextNodeToFocus; // We'll walk up the ancestryPath to try and find the next focusable to move
  // to. We don't have to explore the root node because it won't have a parent
  // or siblings (hence the "< length - 1").

  for (let i = 0; i < ancestryPath.length - 1; i++) {
    const currentId = ancestryPath[i];
    const currentNode = getNode(focusTree, currentId); // Bounded means that the focus is trapped within a certain container. It
    // could, for example, be a modal and we don't want the user to be able to
    // move the focus outside of it.

    if (isContainer(currentNode) && !!currentNode.bounded) {
      break;
    }

    const parentId = ancestryPath[i + 1];
    const parentNode = getNode(focusTree, parentId); // Lets say our closest parent is a row inside of a column. If we press
    // down our nearest parent (the row) wont be able to find a focusable in
    // that direction - rows only supports left/right movement. Therefore,
    // we'll continue the loop. In the next iteration the parentNode will be
    // the column (our parents parent) and we'll get to explore that node to
    // see if our closest parent had any siblings below.

    if (!canNavigate(parentNode.type, direction)) {
      continue;
    } // If we reach this point it means that we've found an ancestor that
    // supports navigation in the direction we want (and the focus isn't
    // bound). We can then explore this ancestor to try and find the next node
    // to focus.


    nextNodeToFocus = depthFirstSearch({
      focusTree,
      parentId,
      // The first node in the *ancestryPath* is the focusable we're currently
      // standing on. Let's say it's node B in the example below.
      //            +-------+  +-------+  +-------+
      // ROW1 ----->|   A   |  |   B   |  |   C   |
      //            +-------+  +-------+  +-------+
      //            +-------+  +-------+
      // ROW2 ----->|   D   |  |   E   |
      //            +-------+  +-------+
      // We'll never want to find the defaultFocusChild for ROW1 (which is the
      // first ancestor of node B). We want the next node in the correct
      // direction. Now let's say that we pressed UP. Rows does not support
      // navigation in that direction so we'll have to climb up the tree until
      // we find an ancestor of type *column*. When we've found that ancestor
      // we don't want to find it's default focus child either. What if its set
      // to last? In that case we could end up at a focusable below us even
      // though we pressed UP. We'll always do direction based navigation
      // first. When we have chosen a node in the correct direction -- and that
      // node is a container -- we'll drill down further by performing
      // recursive calls in the *depthFirstSearch* function where we take the
      // default focus child behavior into consideration.
      shouldFindDefaultFocusedChild: false,
      direction,
      currentNodeId: currentId,
      focusState,
      gridIndex: sequentialIndex,
      // The property below looks a little strange. You usually don't have to
      // keep track of any visisted nodes while traversing trees. Instead, it's
      // a common way to avoid infinite loops while doing DFS or BFS in a
      // cyclical graph. In this case it's needed though because we're
      // traversing the tree bottoms up, and then drilling down using a DFS.
      visisted: {
        [currentId]: true
      },
      stack: []
    });

    if (nextNodeToFocus != null) {
      return nextNodeToFocus;
    }
  } // If we weren't able to find a node to focus we're probably trying to move
  // outside the bounds of a container. In that case we want to keep the focus
  // where it is.


  return nodeId;
} // This function is used by scroll views where we have a loading state and want
// to autofocus something once the loading is completed. We'll then drill down
// into that scroll view to find the first focusable.

function findFirstFocusableChildNode(id, focusTree, focusState) {
  const parentId = getParentId(focusTree, id);
  const gridIndex = getNode(focusTree, id).index;

  if (parentId == null) {
    return;
  }

  const currentNodeId = depthFirstSearch({
    focusTree,
    parentId,
    shouldFindDefaultFocusedChild: true,
    direction: 'next',
    currentNodeId: id,
    focusState,
    gridIndex
  });
  return currentNodeId;
}
;// CONCATENATED MODULE: ./node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

;// CONCATENATED MODULE: ./packages/scrolling-animation/src/index.ts

const ease = cubicOut;
function createScrollingManager({
  disabledTransition = false,
  speedFactor = 1,
  align = 'center',
  scrollOffset = 0,
  axis = 'y'
} = {}) {
  let currentElement;
  let currentScrollElement;
  let initialScrollPosition;
  let deltaPixels;
  let animationStart;
  const animationDuration = 500 / speedFactor;

  const animate = () => {
    if (!currentScrollElement) return;
    const currentTime = Date.now() - animationStart;
    const t = currentTime / animationDuration;
    const shouldStop = currentTime > animationDuration || disabledTransition;
    currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'] = Math.round(initialScrollPosition + ease(shouldStop ? 1 : t) * deltaPixels);
    if (shouldStop) return;
    window.requestAnimationFrame(animate);
  };

  return {
    scrollIntoView(scrollElement, element) {
      currentScrollElement = scrollElement;
      currentElement = element;
      const scrollElementRect = currentScrollElement.getBoundingClientRect();
      const scrollSize = scrollElementRect[axis === 'x' ? 'width' : 'height'];
      const rect = currentElement.getBoundingClientRect();
      const padding = align === 'center' ? scrollSize / 2 : 0;
      deltaPixels = (axis === 'x' ? rect.left : rect.top) - (axis === 'x' ? scrollElementRect.left : scrollElementRect.top) + (align === 'center' ? rect[axis === 'x' ? 'width' : 'height'] / 2 : 0) - padding + scrollOffset;
      initialScrollPosition = currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
      animationStart = Date.now();

      if (Math.abs(deltaPixels) < 5) {
        // animation would be too small, just ignore
        return;
      }

      window.requestAnimationFrame(animate);
    },

    scrollTo(scrollElement, scrollValue) {
      currentScrollElement = scrollElement;
      initialScrollPosition = currentScrollElement[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
      deltaPixels = scrollValue - initialScrollPosition;
      animationStart = Date.now();
      window.requestAnimationFrame(animate);
    },

    stopScrolling() {
      currentScrollElement = null;
      currentElement = null;
    }

  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/setupScrollIntoView.tsx


/**
 * Setups the scrollIntoView function
 * It keeps a local state of previous running animations so that it cancel between scroll requests
 */
function setupScrollIntoView() {
  const runningAnimations = new Map();
  /**
   * Implementation that takes a list with a focusable and its ancestors and triggers animations
   * It supports:
   * - multiple levels of nesting (column inside a row, for example)
   * - animations to continue when switching between different sections of the focus tree
   *
   * Returns a cleanup function that can be used to stop all previously running animations
   */

  return (focusable, ancestors, disabledTransition) => {
    ancestors.forEach(containerNode => {
      var _ref, _focusable$scrollSpee, _container$scrollInto, _focusable$scrollOffs;

      const container = containerNode;

      if (!container.scrollIntoView || focusable.disableScrollIntoView) {
        return;
      }

      if (!focusable.ref || !focusable.ref.current) {
        if (false) {}

        return;
      }

      if (!container.ref || !container.ref.current) {
        if (false) {}

        return;
      }

      const existingStop = runningAnimations.get(container.id);

      if (existingStop) {
        existingStop();
        runningAnimations.delete(container.id);
      }

      const {
        scrollIntoView,
        stopScrolling
      } = createScrollingManager({
        disabledTransition,
        speedFactor: (_ref = (_focusable$scrollSpee = focusable.scrollSpeedFactor) !== null && _focusable$scrollSpee !== void 0 ? _focusable$scrollSpee : container.scrollIntoViewSpeedFactor) !== null && _ref !== void 0 ? _ref : 1,
        align: (focusable.scrollAlign ? focusable.scrollAlign : container.scrollIntoViewAlign) || 'center',
        scrollOffset: ((_container$scrollInto = container.scrollIntoViewOffset) !== null && _container$scrollInto !== void 0 ? _container$scrollInto : 0) + ((_focusable$scrollOffs = focusable.scrollOffset) !== null && _focusable$scrollOffs !== void 0 ? _focusable$scrollOffs : 0),
        axis: container.type === 'row' ? 'x' : 'y'
      });
      scrollIntoView(container.ref.current, focusable.ref.current);
      runningAnimations.set(container.id, stopScrolling);
    });
    /**
     * Cleanup function that stops all running animations
     */

    return () => {
      for (const stopScrolling of runningAnimations.values()) {
        stopScrolling();
      }

      runningAnimations.clear();
    };
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useInput.ts






const scrollIntoView = setupScrollIntoView();
/**
 * Hook that listens for user input (gamepad and keyboard) to trigger navigation and other events
 */

function useInput(providerState, focusedId, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, disabledTransition, keyboardGamepadMap, driver) {
  const [isInputEnabled, setInputEnabled] = (0,react.useState)(false);
  const focusedIdRef = (0,react_facet_src.useFacetRef)(focusedId);
  const disabledNavigationRef = (0,react_facet_src.useFacetRef)(providerState.disabledNavigation);
  const ANALOG_SCROLL_MAX_SPEED = 20;
  const cancelScrollRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)((focusedId, disabledNavigation) => {
    if (disabledNavigation) return;
    if (focusedId == null) return;
    const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedId);
    if (focusedNodeId == null) return;
    const focusable = getFocusable(providerState.focusTree, focusedNodeId);
    if (!focusable) return;
    const ancestors = getAncestorNodes(providerState.focusTree, focusedNodeId);
    cancelScrollRef.current = scrollIntoView(focusable, ancestors, disabledTransition);
  }, [providerState, disabledTransition], [focusedId, providerState.disabledNavigation]);
  (0,react.useLayoutEffect)(() => {
    const handleClick = () => {
      if (disabledNavigationRef.current === true) return;
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current === react_facet_src.NO_VALUE ? undefined : focusedIdRef.current);
      if (focusedNodeId == null) return;
      const focusable = getFocusable(providerState.focusTree, focusedNodeId);

      if (focusable != null && focusable.onClick) {
        focusable.onClick();
      }
    };

    const handleShortcut = (button, focusedNodeId) => {
      // TODO unify this and the useInvokeCurrentCallback
      // if (providerState.disabledShortcuts) return fals
      const shortcut = findShortcut(providerState.focusTree, focusedNodeId, button);

      if ((shortcut === null || shortcut === void 0 ? void 0 : shortcut.onClick) != null) {
        shortcut.onClick();
        return true;
      }

      return false;
    };

    const handleDirection = (direction, focusedNodeId) => {
      var _getAlias2;

      // if (disabledNavigationRef.current === true) return
      // If the provided focusedId didn't resolve into any Node, we need to try to find
      // a fallback nodeId so that the UI doesn't get stuck
      if (focusedNodeId == null) {
        var _getAlias;

        const fallbackNodeId = findFallbackNodeId(providerState.focusTree);
        const fallbackAliasOrNodeId = fallbackNodeId != null ? (_getAlias = getAlias(providerState.focusTree, fallbackNodeId)) !== null && _getAlias !== void 0 ? _getAlias : fallbackNodeId : undefined;

        if (fallbackAliasOrNodeId != null) {
          var _providerState$onFocu;

          (_providerState$onFocu = providerState.onFocusedIdChange) === null || _providerState$onFocu === void 0 ? void 0 : _providerState$onFocu.call(providerState, fallbackAliasOrNodeId);
        }

        return;
      }

      const focusedNode = getFocusable(providerState.focusTree, focusedNodeId);

      if (focusedNode) {
        switch (direction) {
          case 'left':
            if (focusedNode.onLeft) {
              if (focusedNode.onLeft()) return;
            }

            break;

          case 'right':
            if (focusedNode.onRight) {
              if (focusedNode.onRight()) return;
            }

            break;

          case 'up':
            if (focusedNode.onUp) {
              if (focusedNode.onUp()) return;
            }

            break;

          case 'down':
            if (focusedNode.onDown) {
              if (focusedNode.onDown()) return;
            }

        }
      }

      const newFocusedId = navigateToDirection(providerState.focusTree, focusedNodeId, providerState.focusState, direction);
      const newAliasOrNodeId = (_getAlias2 = getAlias(providerState.focusTree, newFocusedId)) !== null && _getAlias2 !== void 0 ? _getAlias2 : newFocusedId;

      if (focusedIdRef.current !== newAliasOrNodeId) {
        var _providerState$onFocu2;

        (_providerState$onFocu2 = providerState.onFocusedIdChange) === null || _providerState$onFocu2 === void 0 ? void 0 : _providerState$onFocu2.call(providerState, newAliasOrNodeId);
      } else {
        var _providerState$onFocu3;

        (_providerState$onFocu3 = providerState.onFocusedIdChangeFail) === null || _providerState$onFocu3 === void 0 ? void 0 : _providerState$onFocu3.call(providerState);
      }
    };

    const handleAnalog = axes => {
      if (disabledNavigationRef.current === true) return;
      providerState.analogListeners.forEach(analogListener => analogListener(axes));
      if (focusedIdRef.current == react_facet_src.NO_VALUE || focusedIdRef.current == null) return;
      const verticalValue = axes[types_ButtonType.RIGHT_VERTICAL_AXIS];
      const horizontalValue = axes[types_ButtonType.RIGHT_HORIZONTAL_AXIS];
      if (verticalValue === 0 && horizontalValue === 0) return;
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current);
      if (focusedNodeId == null) return;
      const nodes = getAncestorNodes(providerState.focusTree, focusedNodeId);
      const parents = nodes.filter(node => node.scrollWithAnalog);
      if (parents.length === 0) return;
      if (cancelScrollRef.current) cancelScrollRef.current();
      parents.forEach(parent => {
        const value = parent.type === 'row' ? horizontalValue : verticalValue;
        const scrollProperty = parent.type === 'row' ? 'scrollLeft' : 'scrollTop';
        if (!parent.ref || !parent.ref.current) return;
        parent.ref.current[scrollProperty] += value * ANALOG_SCROLL_MAX_SPEED;
      });
    };

    const handleDigital = button => {
      providerState.digitalListeners.forEach(digitalListener => digitalListener(button));
      const focusedNodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current === react_facet_src.NO_VALUE ? undefined : focusedIdRef.current);
      if (handleShortcut(button, focusedNodeId)) return;

      switch (button) {
        case types_ButtonType.A:
          return handleClick();

        case types_ButtonType.LEFT_ANALOG_UP:
        case types_ButtonType.UP:
          return handleDirection('up', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_DOWN:
        case types_ButtonType.DOWN:
          return handleDirection('down', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_LEFT:
        case types_ButtonType.LEFT:
          return handleDirection('left', focusedNodeId);

        case types_ButtonType.LEFT_ANALOG_RIGHT:
        case types_ButtonType.RIGHT:
          return handleDirection('right', focusedNodeId);

        case types_ButtonType.NEXT:
          return handleDirection('next', focusedNodeId);

        case types_ButtonType.PREV:
          return handleDirection('prev', focusedNodeId);
      }
    };

    return isInputEnabled ? driver(handleDigital, handleAnalog, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyboardGamepadMap) : undefined;
  }, [isInputEnabled, providerState, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyboardGamepadMap, focusedIdRef, disabledNavigationRef, driver]);
  return setInputEnabled;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useRerenderNodes.ts




/**
 * Allows us to notify specific nodes in the tree to change their focus state
 * without using a value in a React's context API (which would cause everything to re-render).
 */
function useRerenderNodes(providerState, newFocusedId) {
  const previousNodeIdRef = (0,react.useRef)();
  const previousFocusedIdRef = (0,react.useRef)();
  (0,react_facet_src.useFacetEffect)(newFocusedId => {
    /**
     * Delays checking re-rendering nodes until the end of the current frame so that React has time to apply reconciliation changes
     * before this Facet effect gets executed.
     */
    const timerId = setTimeout(() => {
      // Get previous values
      const previousFocusedId = previousFocusedIdRef.current;
      const previousNodeId = previousNodeIdRef.current;
      const focusTree = providerState.focusTree;
      const refreshedPreviousNodeId = findNodeIdFromFocusedId(focusTree, previousFocusedId);
      const refreshedPreviousNode = refreshedPreviousNodeId != null ? getFocusable(focusTree, refreshedPreviousNodeId) : null;

      if (previousNodeId !== refreshedPreviousNodeId) {
        const previousNode = previousNodeId != null ? getFocusable(focusTree, previousNodeId) : null;

        if (previousNode) {
          previousNode.onFocusedChange(false);
        }
      }

      const newNodeId = findNodeIdFromFocusedId(focusTree, newFocusedId);
      const newNode = newNodeId != null ? getFocusable(focusTree, newNodeId) : null;

      if (refreshedPreviousNode && refreshedPreviousNode !== newNode) {
        refreshedPreviousNode.onFocusedChange(false);
      }

      if (newNode) {
        newNode.onFocusedChange(true);
      } // Store current values as the next previous values


      previousFocusedIdRef.current = newFocusedId;
      previousNodeIdRef.current = newNodeId;
    }, 0);
    return () => {
      clearTimeout(timerId);
    };
  }, [providerState], [newFocusedId]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useApi.ts





/**
 * Hook that setups the API passed down to React components that construct the focus tree (focusable, row, column, shortcut)
 */
function useApi(providerState, setInputEnabled, focusedId, setLastKnownTreeUpdate) {
  const focusedIdRef = (0,react_facet_src.useFacetRef)(focusedId);
  /**
   * Debounce to batch a bunch of updates in a single timestamp.
   */

  const debounceSetLastKnownTreeUpdate = (0,react.useMemo)(() => debounce(setLastKnownTreeUpdate), [setLastKnownTreeUpdate]);
  return (0,react.useMemo)(() => {
    const updateInputEnabled = () => {
      setInputEnabled(hasInteractiveNode(providerState.focusTree));
    };

    return {
      // The force flag is used when we move focus with VR
      requestFocus(nodeId, force = false) {
        const alias = getAlias(providerState.focusTree, nodeId);

        if (force || alias !== focusedIdRef.current) {
          var _providerState$onFocu;

          (_providerState$onFocu = providerState.onFocusedIdChange) === null || _providerState$onFocu === void 0 ? void 0 : _providerState$onFocu.call(providerState, alias !== null && alias !== void 0 ? alias : nodeId);
        }
      },

      requestAutofocus(nodeId) {
        const isFocusedIdSet = typeof focusedIdRef.current === 'number' || typeof focusedIdRef.current === 'string';
        const focusedIdNodeId = isFocusedIdSet ? findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current) : null; // Don't trigger autofocus if something is already focused

        if (focusedIdNodeId != null && isNodeEnabled(providerState.focusTree, focusedIdNodeId)) return; // Don't focus the given node if it isn't enabled

        if (!isNodeEnabled(providerState.focusTree, nodeId)) return;
        const alias = getAlias(providerState.focusTree, nodeId);

        if (alias != null && alias !== focusedIdRef.current || nodeId !== focusedIdRef.current) {
          var _providerState$onFocu2;

          (_providerState$onFocu2 = providerState.onFocusedIdChange) === null || _providerState$onFocu2 === void 0 ? void 0 : _providerState$onFocu2.call(providerState, alias !== null && alias !== void 0 ? alias : nodeId);
        }
      },

      runAddNodeEffect() {
        updateInputEnabled();
      },

      addOrUpdateNode(metadata) {
        addOrUpdateNode(providerState.focusTree, metadata);
        debounceSetLastKnownTreeUpdate(Date.now());
      },

      removeNode(nodeId) {
        removeNode(providerState.focusTree, nodeId);
        updateInputEnabled();
      },

      isFocusableFocused(nodeId, alias) {
        return nodeId === focusedIdRef.current || alias != null && alias === focusedIdRef.current;
      },

      addAnalogListener: analogListener => {
        providerState.analogListeners = [...providerState.analogListeners, analogListener];
        return () => {
          providerState.analogListeners = without_default()([analogListener], providerState.analogListeners);
        };
      },
      addDigitalListener: digitalListener => {
        providerState.digitalListeners = [...providerState.digitalListeners, digitalListener];
        return () => {
          providerState.digitalListeners = without_default()([digitalListener], providerState.digitalListeners);
        };
      },
      clickFocusableAtPoint: (x, y) => {
        const focusable = findClickableFocusableAtPoint(providerState.focusTree, x, y);

        if (focusable && focusable.onClick) {
          focusable.onClick();
        }
      },
      focusFocusableAtPoint: (x, y) => {
        const focusable = findClickableFocusableAtPoint(providerState.focusTree, x, y);
        const {
          onFocusedIdChange
        } = providerState;
        const focusedId = focusedIdRef.current; // If the focus has changed, a clickable focusable has been found, and there is nothing currently focused
        // _or_ the clickable focusable is different then the currently focused node
        // --> Give focus to the clickable focusable
        // If the focus has changed, a node was previously focused and there was no clickable focusable found
        // --> Give focus to undefined (meaning a sane default)

        if (focusable && (focusedId == null || !(focusable.id === focusedId || focusable.alias === focusedId))) {
          var _focusable$alias;

          onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange((_focusable$alias = focusable.alias) !== null && _focusable$alias !== void 0 ? _focusable$alias : focusable.id);
        } else if (!focusable && focusedId != null) {
          onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange(undefined);
        }
      },
      getCurrentFocusable: () => {
        if (focusedIdRef.current === react_facet_src.NO_VALUE) {
          return undefined;
        }

        const nodeId = findNodeIdFromFocusedId(providerState.focusTree, focusedIdRef.current);

        if (nodeId == null) {
          return undefined;
        }

        return getFocusable(providerState.focusTree, nodeId);
      }
    };
  }, [focusedIdRef, providerState, setInputEnabled, debounceSetLastKnownTreeUpdate]);
}
/**
 * Simple debounce function that works just for numbers.
 */

const debounce = (fn, timeout = 100) => {
  let id;
  return value => {
    clearTimeout(id);
    id = setTimeout(() => fn(value), timeout);
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/hooks/useUpdateFocusState.ts



/**
 * It takes the parent of the current focused node, and updates the information in the focusState that it is now focused.
 */
function useUpdateFocusState(providerState, focusedId) {
  (0,react_facet_src.useFacetEffect)(focusedId => {
    const focusTree = providerState.focusTree;
    const focusState = providerState.focusState;
    const focusedNodeId = findNodeIdFromFocusedId(focusTree, focusedId);
    if (focusedNodeId == null) return;
    let currentParentId = getParentId(focusTree, focusedNodeId);

    while (currentParentId != null) {
      focusState.set(currentParentId, focusedNodeId);
      currentParentId = getParentId(focusTree, currentParentId);
    }
  }, [providerState], [focusedId]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useFocusProvider.tsx

const context = (0,react.createContext)(undefined);
const FocusProvider = ({
  value,
  children
}) => {
  return /*#__PURE__*/react.createElement(context.Provider, {
    value: value
  }, children);
};
function useGamepadAPI() {
  return (0,react.useContext)(context);
}
;// CONCATENATED MODULE: ./packages/gamepad-polyfill/src/index.ts
const getGamepadsPolyfill = () => {
  if (navigator == null) {
    return [];
  }

  const navigatorGamepads = navigator.getGamepads();

  if (Array.isArray(navigatorGamepads)) {
    return navigatorGamepads;
  }

  return Array.from(navigatorGamepads);
};

const isFirefox = () => {
  var _navigator$userAgent$, _navigator, _navigator$userAgent;

  return  false && 0;
};

let gamepads = [];
const getGamepads = () => {
  if (false) {}

  return gamepads;
};
/* navigator.getGamepads() is a relatively expensive call and should be avoided to be called each frame.
 * The ideal solution is to always use the gamepadconnected and gamepaddisconnected events to update the gamepad list.
 * However, Chrome behaves differently than other environments (eg. Gameface and Firefox) and doesn't update the
 * reference to the gamepad that is passed to the gamepadconnected and gamepaddisconnected events on each frame.
 * That is the reason why we fallback to polling for all environments that except Gameface and Firefox
 *
 * Read this for more info regarding how Chrome behaves differently:
 * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API#using_button_information
 */

const noop = () => undefined;

let cleanupHandler = noop;

const cleanup = () => {
  gamepads = [];
  cleanupHandler();
  cleanupHandler = noop;
};

const initialize = () => {
  if (isInitialized()) return cleanup;

  if (true) {
    if (true) {
      // Get initial state of gamepads. We don't want to make this call when running tests since the
      // navigator.getGamepads API is not available in that environment.
      gamepads = getGamepadsPolyfill();
    }

    const handleGamepadConnected = event => {
      if (event.gamepad.index >= gamepads.length) {
        const updatedGamepads = [...gamepads];
        const inBetweenIndexCount = gamepads.length - event.gamepad.index;

        for (let i = 0; i < inBetweenIndexCount; i++) {
          updatedGamepads.push(null);
        }

        updatedGamepads.push(event.gamepad);
        gamepads = updatedGamepads;
      } else if (event.gamepad.index >= 0) {
        const updatedGamepads = [...gamepads];
        updatedGamepads[event.gamepad.index] = event.gamepad;
        gamepads = updatedGamepads;
      }
    };

    const handleGamepadDisconnected = event => {
      if (gamepads.length - 1 >= event.gamepad.index) {
        const updatedGamepads = [...gamepads];
        updatedGamepads[event.gamepad.index] = null;
        gamepads = updatedGamepads;
      }
    };

    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

    cleanupHandler = () => {
      window.removeEventListener('gamepadconnected', handleGamepadConnected);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnected);
    };
  } else {}

  return cleanup;
};
const isInitialized = () => cleanupHandler !== noop;
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/throttleByName.ts

const FIRST_THROTTLE_DELAY = 400;
const MEDIUM_THROTTLE_RATE = 100;
const FAST_THROTTLE_RATE = 40;
/**
 * How many presses we should have triggered before going to fast speed
 */

const FAST_REPETITION_COUNT_WAIT = 16;
function throttleByName(fn) {
  const timestamps = initMetrics();
  const pressCounts = initMetrics(); // @TODO: Rewrite without gamepadIndex

  return (buttonType, pressed, gamepadIndex) => {
    if (!pressed) {
      timestamps[gamepadIndex][buttonType] = 0;
      pressCounts[gamepadIndex][buttonType] = 0;
    } else {
      const now = Date.now();
      const timestamp = timestamps[gamepadIndex][buttonType] || 0;
      const pressCount = pressCounts[gamepadIndex][buttonType] || 0;
      const delta = now - timestamp;

      if (pressCount === 0) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 1;
        return fn(buttonType);
      }

      if (pressCount === 1 && delta > FIRST_THROTTLE_DELAY) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 2;
        return fn(buttonType);
      }

      if (pressCount > 1 && pressCount < FAST_REPETITION_COUNT_WAIT && delta > MEDIUM_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return fn(buttonType);
      }

      if (pressCount > FAST_REPETITION_COUNT_WAIT - 1 && delta > FAST_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return fn(buttonType);
      }
    }
  };
}

const initMetrics = () => {
  const metrics = {
    0: initButtons(),
    1: initButtons(),
    2: initButtons(),
    3: initButtons()
  };
  return metrics;
};

const initButtons = () => {
  return {
    [ButtonType.A]: 0,
    [ButtonType.B]: 0,
    [ButtonType.X]: 0,
    [ButtonType.Y]: 0,
    [ButtonType.START]: 0,
    [ButtonType.SELECT]: 0,
    [ButtonType.XBOX]: 0,
    [ButtonType.RIGHT_TRIGGER]: 0,
    [ButtonType.LEFT_TRIGGER]: 0,
    [ButtonType.LEFT_BUMPER]: 0,
    [ButtonType.RIGHT_BUMPER]: 0,
    [ButtonType.L3]: 0,
    [ButtonType.R3]: 0,
    [ButtonType.LEFT]: 0,
    [ButtonType.RIGHT]: 0,
    [ButtonType.UP]: 0,
    [ButtonType.DOWN]: 0,
    [ButtonType.NEXT]: 0,
    [ButtonType.PREV]: 0,
    [ButtonType.LEFT_ANALOG_LEFT]: 0,
    [ButtonType.LEFT_ANALOG_RIGHT]: 0,
    [ButtonType.LEFT_ANALOG_UP]: 0,
    [ButtonType.LEFT_ANALOG_DOWN]: 0,
    [ButtonType.RIGHT_ANALOG_LEFT]: 0,
    [ButtonType.RIGHT_ANALOG_RIGHT]: 0,
    [ButtonType.RIGHT_ANALOG_UP]: 0,
    [ButtonType.RIGHT_ANALOG_DOWN]: 0,
    [ButtonType.LEFT_HORIZONTAL_AXIS]: 0,
    [ButtonType.LEFT_VERTICAL_AXIS]: 0,
    [ButtonType.RIGHT_HORIZONTAL_AXIS]: 0,
    [ButtonType.RIGHT_VERTICAL_AXIS]: 0,
    [ButtonType.PSEUDO_BUTTON_1]: 0,
    [ButtonType.PSEUDO_BUTTON_2]: 0,
    [ButtonType.PSEUDO_BUTTON_3]: 0,
    [ButtonType.PSEUDO_BUTTON_4]: 0,
    [ButtonType.PSEUDO_BUTTON_5]: 0,
    [ButtonType.PSEUDO_BUTTON_6]: 0,
    [ButtonType.PSEUDO_BUTTON_7]: 0,
    [ButtonType.PSEUDO_BUTTON_8]: 0,
    [ButtonType.PSEUDO_BUTTON_9]: 0,
    [ButtonType.PSEUDO_BUTTON_10]: 0
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupGamepads.ts



/**
 * Setup pooling for the gamepad button states.
 *
 * This code is extremely performance sensitive, so be mindful of any changes and measure the performance
 * on a performance sensitive device (ex: Xbox One)
 */

function setupGamepads(handleDigitalInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons) {
  const throttledCb = throttleByName(handleDigitalInput);
  const toggleCb = toggleByName(handleDigitalInput);
  const actionButtonsIndex = ACTION_BUTTONS.map(name => BUTTON_MAP.indexOf(name));
  const mappedActionButtonsIndex = ACTION_BUTTONS.map(name => BUTTON_MAP.indexOf(mapButton(name, swapABButtons, swapXYButtons)));
  const directionalButtonsIndex = DIRECTIONAL_BUTTONS.map(name => BUTTON_MAP.indexOf(name));
  /**
   * Check an individual gamepad for its presses states and axes values and fire the
   * throttled or toggles callbacks
   */

  function checkGamepad(gamepad) {
    const buttons = gamepad.buttons;
    const gamepadIndex = gamepad.index;

    for (let index = 0; index < actionButtonsIndex.length; index++) {
      toggleCb(BUTTON_MAP[mappedActionButtonsIndex[index]], buttons[actionButtonsIndex[index]].pressed, gamepadIndex);
    }

    for (let index = 0; index < directionalButtonsIndex.length; index++) {
      const buttonIndex = directionalButtonsIndex[index];
      throttledCb(BUTTON_MAP[buttonIndex], buttons[buttonIndex].pressed, gamepadIndex);
    }

    const axes = gamepad.axes.map((value, index) => {
      if (value > -0.16 && value < 0.16) {
        return 0;
      }

      const map = AXIS_MAP[index];
      throttledCb(map[0], value < -AXIS_TRIGGER_LIMIT, gamepadIndex);
      throttledCb(map[1], value > AXIS_TRIGGER_LIMIT, gamepadIndex);
      return value;
    });
    handleAnalogInput(axes);
  }
  /**
   * Tick that runs every frame and can either be
   * - Accepting input from all controllers
   * - Accept input from one specific controller
   */


  const tick = acceptInputFromAllControllers ? function () {
    try {
      const gamepads = getGamepads();
      const first = gamepads[0];
      const second = gamepads[1];
      const third = gamepads[2];
      const fourth = gamepads[3];
      if (first != null) checkGamepad(first);
      if (second != null) checkGamepad(second);
      if (third != null) checkGamepad(third);
      if (fourth != null) checkGamepad(fourth);
      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  } : function () {
    try {
      // We use a regular for loop here instead of a for of loop
      // since it's measurably faster. More context here:
      // https://github.com/Mojang/minecraft-ui/pull/2155
      const gamepads = getGamepads();

      for (let i = 0; i < gamepads.length; i++) {
        const gamepad = gamepads[i];

        if (gamepad != null && controllerId === gamepad.id) {
          checkGamepad(gamepad);
          break;
        }
      }

      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  };
  let handler = requestAnimationFrame(tick);
  return () => {
    cancelAnimationFrame(handler);
  };
}
const AXIS_TRIGGER_LIMIT = 0.5;

const toggleByName = fn => {
  const pressStates = {
    0: {},
    1: {},
    2: {},
    3: {}
  };
  return (name, pressed, index) => {
    const wasPressed = pressStates[index][name];

    if (pressed === wasPressed) {
      return;
    }

    if (pressed) {
      pressStates[index][name] = true;

      if (wasPressed != null) {
        fn(name);
      }
    } else {
      pressStates[index][name] = false;
    }
  };
};

const mapButton = (button, swapABButtons, swapXYButtons) => {
  if (button === ButtonType.Y && swapXYButtons) return ButtonType.X;
  if (button === ButtonType.X && swapXYButtons) return ButtonType.Y;
  if (button === ButtonType.A && swapABButtons) return ButtonType.B;
  if (button === ButtonType.B && swapABButtons) return ButtonType.A;
  return button;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupKeyboard.ts

function setupKeyboard(handleDigitalInput, keyToGamepad) {
  const handler = event => {
    if (false) {} // If an element in the DOM is focused, stop navigation from the keyboard input


    if (document.activeElement !== document.body || keyToGamepad == null) return; // Gameface does not support the new standard `key`, so we read the `keyCode` instead

    const key = event.keyCode;

    if (false) {}

    const buttonType = keyToGamepad[key];

    if (buttonType) {
      if (false) {}

      event.preventDefault();
      return handleDigitalInput(buttonType);
    } // Support for using the "tab" key to navigate the focus.
    // Key is being fired as a string on Jest.


    if (key === KeyboardKey.TAB) {
      event.preventDefault();
      return handleDigitalInput(event.shiftKey ? ButtonType.PREV : ButtonType.NEXT);
    }
  };

  document.addEventListener('keydown', handler);
  return () => {
    document.removeEventListener('keydown', handler);
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/setupMouse.ts

const MOUSE_BACK_BUTTON = 3;
/**
 * Maps the mouse "back button" to the B button
 */

function setupMouse(handleDigitalInput) {
  const handleEvent = event => {
    if (event.button === MOUSE_BACK_BUTTON) {
      handleDigitalInput(ButtonType.B);
    }
  };

  document.addEventListener('mouseup', handleEvent);
  return () => {
    document.removeEventListener('mouseup', handleEvent);
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-driver/src/driver.ts




const driver_driver = (handleDigitalInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepad) => {
  const handleDigitalFocusInput = button => handleDigitalInput(button, FocusOrigin.FocusInput);

  const handleDigitalPointerInput = button => handleDigitalInput(button, FocusOrigin.PointerInput);

  const disposeGamepads = setupGamepads(handleDigitalFocusInput, handleAnalogInput, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons);
  const disposeKeyboard = setupKeyboard(handleDigitalFocusInput, keyToGamepad.current);
  const disposeMouse =  true ? setupMouse(handleDigitalPointerInput) : 0;
  return () => {
    disposeKeyboard();
    disposeGamepads();
    disposeMouse();
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GamepadProvider/GamepadProvider.tsx










// Hook that take a FacetProp and returns a Facet where changes to the value have been delayed by a frame.
const useDelayedFacetState = prop => {
  const propAsFacet = (0,react_facet_src.useFacetWrap)(prop);
  const [delayedState, setDelayedState] = (0,react_facet_src.useFacetState)(propAsFacet.get());
  (0,react_facet_src.useFacetEffect)(value => {
    let requestId = requestAnimationFrame(() => {
      setDelayedState(value);
      requestId = 0;
    });
    return () => {
      if (requestId !== 0) {
        cancelAnimationFrame(requestId);
      }
    };
  }, [setDelayedState], [propAsFacet]);
  return delayedState;
}; // We want to delay changes to the disabled state by a frame in order to make sure
// that all other effects in the GamepadProvider has been run before committing
// to the change, eg setup of the Driver.

const useDisabledNavigation = disabledNavigationFacetProp => {
  return useDelayedFacetState(typeof disabledNavigationFacetProp === 'undefined' ? false : disabledNavigationFacetProp);
};
/**
 * Provider that enables the gamepad focus capability around a React component tree.
 */


function GamepadProvider({
  children,
  focusedId: focusedIdFacetProp,
  onFocusedIdChange,
  onFocusedIdChangeFail,
  gameControllerId = (0,react_facet_src.createStaticFacet)('0'),
  acceptInputFromAllControllers = (0,react_facet_src.createStaticFacet)(false),
  swapABButtons = (0,react_facet_src.createStaticFacet)(false),
  swapXYButtons = (0,react_facet_src.createStaticFacet)(false),
  disabledNavigation: disabledNavigationFacetProp,
  disabledTransition = (0,react_facet_src.createStaticFacet)(false),
  isInputLegendClickable = false,
  isRtl = false,
  keyboardGamepadMap,
  driver = driver_driver,
  mostRecentlyFocusedId = focusedIdFacetProp
}) {
  const disabledTransitionUnwrapped = (0,react_facet_src.useFacetUnwrap)(disabledTransition);
  const disabledTransitionValue = disabledTransitionUnwrapped === react_facet_src.NO_VALUE ? false : disabledTransitionUnwrapped;
  const gameControllerIdUnwrapped = (0,react_facet_src.useFacetUnwrap)(gameControllerId);
  const gameControllerIdValue = gameControllerIdUnwrapped === react_facet_src.NO_VALUE ? '' : gameControllerIdUnwrapped;
  const acceptInputFromAllControllersUnwrapped = (0,react_facet_src.useFacetUnwrap)(acceptInputFromAllControllers);
  const acceptInputFromAllControllersValue = acceptInputFromAllControllersUnwrapped === react_facet_src.NO_VALUE ? false : acceptInputFromAllControllersUnwrapped;
  const swapABButtonsUnwrapped = (0,react_facet_src.useFacetUnwrap)(swapABButtons);
  const swapABButtonsValue = swapABButtonsUnwrapped === react_facet_src.NO_VALUE ? false : swapABButtonsUnwrapped;
  const swapXYButtonsUnwrapped = (0,react_facet_src.useFacetUnwrap)(swapXYButtons);
  const swapXYButtonsValue = swapXYButtonsUnwrapped === react_facet_src.NO_VALUE ? false : swapXYButtonsUnwrapped;
  const disabledNavigation = useDisabledNavigation(disabledNavigationFacetProp);
  const focusedId = (0,react_facet_src.useFacetWrap)(focusedIdFacetProp);
  const keyToGamepadFacet = (0,react_facet_src.useFacetMap)(keyboardGamepadMap => {
    const keyboardGamepadEntries = Object.entries(keyboardGamepadMap);
    const keyToGamepad = {};

    for (let i = 0; i < keyboardGamepadEntries.length; i++) {
      const entry = keyboardGamepadEntries[i];
      const buttonType = entry[0];
      const buttonValues = entry[1];

      for (let j = 0; j < buttonValues.length; j++) {
        keyToGamepad[buttonValues[j]] = buttonType;
      }
    }

    return keyToGamepad;
  }, [], [(0,react_facet_src.useFacetWrap)(keyboardGamepadMap)]);
  const keyToGamepadRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)(keyToGamepad => {
    keyToGamepadRef.current = keyToGamepad;
  }, [], [keyToGamepadFacet]);
  /**
   * Stores a timestamp of the last time the Focus Tree was updated.
   * Useful to recalculate Input Legends after components have been mounted.
   */

  const [lastKnownTreeUpdate, setLastKnownTreeUpdate] = (0,react_facet_src.useFacetState)(0);
  const defaultProviderState = (0,react.useMemo)(() => ({
    disabledNavigation,
    focusedId,
    onFocusedIdChange,
    focusState: new Map(),
    //
    focusTree: getFreshTree(),
    analogListeners: [],
    digitalListeners: [],
    isRtl
  }),
  /**
   * We useMemo here to call the expensive functions (getFreshTree, new Map) only once at the boot of GamepadProvider
   */
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const providerStateRef = (0,react.useRef)(defaultProviderState);
  providerStateRef.current.disabledNavigation = disabledNavigation;
  providerStateRef.current.onFocusedIdChange = onFocusedIdChange;
  providerStateRef.current.onFocusedIdChangeFail = onFocusedIdChangeFail;
  providerStateRef.current.isRtl = isRtl;
  const inputLegends = useInputLegends(providerStateRef.current, focusedId, lastKnownTreeUpdate);
  const invokeCurrentCallback = useInvokeCurrentCallback(providerStateRef.current, focusedId);
  const setInputEnabled = useInput(providerStateRef.current, focusedId, gameControllerIdValue, acceptInputFromAllControllersValue, swapABButtonsValue, swapXYButtonsValue, disabledTransitionValue, keyToGamepadRef, driver);
  useRerenderNodes(providerStateRef.current, (0,react_facet_src.useFacetWrap)(mostRecentlyFocusedId));
  const api = useApi(providerStateRef.current, setInputEnabled, focusedId, setLastKnownTreeUpdate);
  useUpdateFocusState(providerStateRef.current, focusedId); // Prevent buttonMap to be created on every render by using useMemo,
  // which would trigger an update on any consumer of the ButtonMapProvider context provider below

  const buttonMap = (0,react_facet_src.useFacetMap)((swapABButtons, swapXYButtons) => ({
    swapABButtons,
    swapXYButtons
  }), [], [swapABButtons, swapXYButtons]);

  const navigateToDefaultFocusChild = parentId => {
    const node = getNode(providerStateRef.current.focusTree, parentId);

    if ((node === null || node === void 0 ? void 0 : node.type) === 'focusable') {
      var _getAlias, _providerStateRef$cur, _providerStateRef$cur2;

      const focusId = (_getAlias = getAlias(providerStateRef.current.focusTree, parentId)) !== null && _getAlias !== void 0 ? _getAlias : parentId;
      return (_providerStateRef$cur = (_providerStateRef$cur2 = providerStateRef.current).onFocusedIdChange) === null || _providerStateRef$cur === void 0 ? void 0 : _providerStateRef$cur.call(_providerStateRef$cur2, focusId);
    }

    const childId = findFirstFocusableChildNode(parentId, providerStateRef.current.focusTree, providerStateRef.current.focusState);

    if (childId != null) {
      var _getAlias2, _providerStateRef$cur3, _providerStateRef$cur4;

      const newAliasOrNodeId = (_getAlias2 = getAlias(providerStateRef.current.focusTree, childId)) !== null && _getAlias2 !== void 0 ? _getAlias2 : childId;
      (_providerStateRef$cur3 = (_providerStateRef$cur4 = providerStateRef.current).onFocusedIdChange) === null || _providerStateRef$cur3 === void 0 ? void 0 : _providerStateRef$cur3.call(_providerStateRef$cur4, newAliasOrNodeId);
    }
  };

  const clearRememberCache = nodeId => {
    const node = getNode(providerStateRef.current.focusTree, nodeId);

    if (node != null && isContainer(node) && node.defaultFocusedChildBehavior === 'remember') {
      providerStateRef.current.focusState.delete(nodeId);
    }
  }; // We know that the keyboardGamepadMap is set "statically" as a prop, and if it changes it will be by having a new instance
  // So for this implementation of the GamepadProvider that is soon to be replaced by the visual implementation, we can safelly
  // do a strictEqualityCheck assuming the data to be immutable.
  // This is an optimization to prevent unnecessary updates to the context.


  const keyboardGamepadMap_ = (0,react_facet_src.useFacetWrap)(keyboardGamepadMap, immutableStrictEqualityCheck);
  const value = (0,react.useMemo)(() => [keyboardGamepadMap_, () => {}], [keyboardGamepadMap_]);
  return (
    /*#__PURE__*/
    // We pass keyboardGamepadMap as a read-only Facet, with a fake setter, just to match the new API
    // of the keyboardGamepadMapContext in the visual package (which we are using here)
    react.createElement(keyboardGamepadMapContext.Provider, {
      value: value
    }, /*#__PURE__*/react.createElement(SetFocusedIdProvider, {
      onFocusedIdChange: onFocusedIdChange,
      focusedId: focusedId
    }, /*#__PURE__*/react.createElement(ButtonMapProvider, {
      value: buttonMap
    }, /*#__PURE__*/react.createElement(GamepadAPIProvider, {
      value: api
    }, /*#__PURE__*/react.createElement(AvailableInputLegendsProvider, {
      value: inputLegends
    }, /*#__PURE__*/react.createElement(InvokeCurrentCallbackProvider, {
      value: isInputLegendClickable ? invokeCurrentCallback : undefined
    }, /*#__PURE__*/react.createElement(FocusProvider, {
      value: {
        focusedId,
        navigate: navigateToDefaultFocusChild,
        clearRememberCache
      }
    }, children)))))))
  );
}

function immutableStrictEqualityCheck() {
  let previous = react_facet_src.NO_VALUE;
  return current => {
    if (previous !== current) {
      previous = current;
      return false;
    }

    return true;
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/path.tsx

const path_Context = (0,react.createContext)([]);
const {
  Provider: path_Provider,
  Consumer: path_Consumer
} = path_Context;

const PathContext = path_Context;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/setFocusedId.ts

const setFocusedId_setFocusedIdContext = (0,react.createContext)(() => () => {});
/**
 * Hook that allows access to a function to imperatively set the focused id
 * On setting a focusedId, it returns a "restore" function that can be called to restore the focus to a previous state
 */

const setFocusedId_useSetFocusedId = () => (0,react.useContext)(setFocusedId_setFocusedIdContext);
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/lastFocusOriginContext.tsx



const lastFocusOriginContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(FocusOrigin.Initial));
const useLastFocusOrigin = () => (0,react.useContext)(lastFocusOriginContext);
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/focusTreeAPI.tsx


const focusTreeAPI_logWarning = () => {
  if (false) {}
};

const focusTreeAPI_FocusTreeAPIContext = (0,react.createContext)({
  current: {
    press: () => undefined,
    isFocused: () => {
      focusTreeAPI_logWarning();
      return false;
    },
    isFocusable: () => {
      focusTreeAPI_logWarning();
      return false;
    },
    putNode: focusTreeAPI_logWarning,
    putShortcut: focusTreeAPI_logWarning,
    removeNode: focusTreeAPI_logWarning,
    removeShortcut: focusTreeAPI_logWarning,
    getElement: () => {
      focusTreeAPI_logWarning();
      return undefined;
    },
    isAncestorOf: () => {
      focusTreeAPI_logWarning();
      return false;
    },
    getDynasty: () => {
      focusTreeAPI_logWarning();
      return undefined;
    },
    getEnabledBindingLandmarkDescendant: () => {
      focusTreeAPI_logWarning();
      return undefined;
    }
  }
});
const {
  Provider: focusTreeAPI_Provider,
  Consumer: focusTreeAPI_Consumer
} = focusTreeAPI_FocusTreeAPIContext;
const FocusTreeAPIProvider = focusTreeAPI_Provider;
const FocusTreeAPIConsumer = (/* unused pure expression or super */ null && (focusTreeAPI_Consumer));
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/cursorAPI.tsx

const CursorAPIContext = (0,react.createContext)({
  addAnalogListener: () => () => {},
  addDigitalListener: () => () => {},
  clickAtPoint: () => {},
  focusAtPoint: () => {}
});
const {
  Provider: cursorAPI_Provider,
  Consumer: cursorAPI_Consumer
} = CursorAPIContext;
const CursorAPIProvider = cursorAPI_Provider;
const CursorAPIConsumer = (/* unused pure expression or super */ null && (cursorAPI_Consumer));
// EXTERNAL MODULE: ./node_modules/ramda/src/includes.js
var includes = __webpack_require__(59270);
var includes_default = /*#__PURE__*/__webpack_require__.n(includes);
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/treeQueries.tsx



function treeQueries_getAlias(focusTree, focusableId) {
  const element = focusTree.elements.get(focusableId);

  if (element == null || !types_isFocusable(element)) {
    return;
  }

  return element === null || element === void 0 ? void 0 : element.alias;
}
function containerHasEnabledItems(tree, landmark) {
  var _tree$children$get;

  const childIds = (_tree$children$get = tree.children.get(landmark.id)) !== null && _tree$children$get !== void 0 ? _tree$children$get : [];

  for (const childId of childIds) {
    const child = tree.elements.get(childId);

    if (!child) {
      continue;
    }

    switch (child.type) {
      case types_FocusTreeNodeType.LANDMARK:
        {
          if (!isAvailableFocusable(child)) {
            continue;
          }

          const enabled = containerHasEnabledItems(tree, child);

          if (enabled) {
            return true;
          }

          break;
        }

      case types_FocusTreeNodeType.FOCUS_GROUP:
        {
          if (child.disabled || child.hidden) {
            continue;
          }

          const enabled = containerHasEnabledItems(tree, child);

          if (enabled) {
            return true;
          }

          break;
        }

      case types_FocusTreeNodeType.ITEM:
        {
          if (isAvailableFocusable(child)) {
            return true;
          }

          break;
        }

      case types_FocusTreeNodeType.ROOT:
        {
          if (false) {}

          break;
        }
    }
  }

  return false;
}
function getIdFromAliasOrId(focusTree, aliasOrId) {
  if (typeof aliasOrId === 'string') {
    return focusTree.aliases.get(aliasOrId);
  }

  if (aliasOrId != null && focusTree.elements.has(aliasOrId)) {
    return aliasOrId;
  }

  return undefined;
}
function getElement(focusTree, aliasOrId) {
  const id = getIdFromAliasOrId(focusTree, aliasOrId);
  if (id == null) return;
  const element = focusTree.elements.get(id);
  return element;
}
function treeQueries_getAncestorIds(focusTree, elementId) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return [];
  }

  return [parentId, ...treeQueries_getAncestorIds(focusTree, parentId)];
}
function isAncestorOf(focusTree, parentId, elementId) {
  const parentElementId = focusTree.parents.get(elementId);

  if (parentElementId === parentId) {
    return true;
  }

  if (parentElementId == null) {
    return false;
  }

  return isAncestorOf(focusTree, parentId, parentElementId);
}
function getClosestDelegatingAncestor(focusTree, elementId) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return null;
  }

  const parentElement = focusTree.elements.get(parentId);

  if (parentElement == null) {
    return null;
  }

  if (types_isDelegatingLandmark(parentElement) || isRoot(parentElement)) {
    return parentElement;
  }

  return getClosestDelegatingAncestor(focusTree, parentId);
}
function doesDynastyHaveAnyEnabledItems(focusTree, dynasty) {
  for (const id of dynasty) {
    const element = focusTree.elements.get(id);

    if (!element) {
      continue;
    }

    if (types_isDelegatingLandmark(element) && treeQueries_isNodeEnabled(focusTree, id)) {
      return true;
    }

    if (element.type === types_FocusTreeNodeType.ITEM && treeQueries_isNodeEnabled(focusTree, id)) {
      return true;
    }
  }

  return false;
}
function getDirectParent(focusTree, elementId) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return null;
  }

  const parentElement = focusTree.elements.get(parentId);

  if (parentElement == null) {
    return null;
  }

  return parentElement;
}
function getClosestAncestor(focusTree, elementId, test) {
  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return null;
  }

  const parentElement = focusTree.elements.get(parentId);

  if (parentElement == null) {
    return null;
  }

  if (test(parentElement)) {
    return parentElement;
  }

  return getClosestDelegatingAncestor(focusTree, parentId);
}
const getRootNodes = focusTree => {
  const rootNodes = [];

  for (const [id] of focusTree.elements) {
    if (!focusTree.parents.has(id)) {
      rootNodes.push(id);
    }
  }

  return rootNodes;
};
const getClosestAncestorIdGetter = test => {
  const getClosestParentId = (tree, elementId) => {
    const parentId = tree.parents.get(elementId);

    if (parentId == null) {
      return null;
    }

    const parent = tree.elements.get(parentId);

    if (parent == null) {
      return null;
    }

    if (test(parent)) {
      return parentId;
    }

    return getClosestParentId(tree, parentId);
  };

  return getClosestParentId;
};
const doesAnyNonSharedAncestorDelegateFocus = (tree, candidateElementId, currentFocusedElementID) => {
  const pathForCurrentFocusedElement = treeQueries_getAncestorIds(tree, currentFocusedElementID);
  const testResult = getClosestAncestorIdGetter(element => types_isDelegatingLandmark(element) && !includes_default()(element.id, pathForCurrentFocusedElement))(tree, candidateElementId);
  return testResult != null;
};
const getDisabledAncestor = getClosestAncestorIdGetter(parent => parent.disabled || parent.hidden);
const treeQueries_isAnyAncestorDisabled = (tree, elementId) => getDisabledAncestor(tree, elementId) != null;
const getBindingAncestorId = getClosestAncestorIdGetter(isBindingLandmark);
const getScrollableAncestorId = getClosestAncestorIdGetter(parent => parent.type === types_FocusTreeNodeType.LANDMARK && parent.scrollAxis != null);
const hasAnyAncestorWithId = (tree, elementId, targetParentId) => {
  const parentId = tree.parents.get(elementId);

  if (parentId == null) {
    return false;
  }

  if (parentId === targetParentId) {
    return true;
  }

  return hasAnyAncestorWithId(tree, parentId, targetParentId);
};
const getEnabledBindingLandmarkDescendant = (focusTree, elementId) => {
  const enabledBindingLandmarksDescendantIds = getEnabledBindingLandmarkDescendantIds(focusTree, elementId);

  if (enabledBindingLandmarksDescendantIds != null && enabledBindingLandmarksDescendantIds.length > 0) {
    const enabledBindingLandmarksDescendantId = enabledBindingLandmarksDescendantIds[0];
    const enabledBindingLandmarksDescendant = getElement(focusTree, enabledBindingLandmarksDescendantId);
    return enabledBindingLandmarksDescendant != null && isBindingLandmark(enabledBindingLandmarksDescendant) ? enabledBindingLandmarksDescendant : undefined;
  }
};
const getEnabledBindingLandmarkDescendantIds = (focusTree, elementId) => {
  const bindingLandmarkDescendants = focusTree.bindingLandmarkDescendants.get(elementId);

  if (bindingLandmarkDescendants == null) {
    return;
  }

  const enabledBindingLandmarkDescendants = [];

  for (const itemId of bindingLandmarkDescendants) {
    if (treeQueries_isNodeEnabled(focusTree, itemId)) {
      enabledBindingLandmarkDescendants.push(itemId);
    }
  }

  if (false) {}

  return enabledBindingLandmarkDescendants;
};
function treeQueries_isNodeEnabled(focusTree, elementId) {
  const node = getElement(focusTree, elementId);
  if (node == null) return false;
  if (node.type === types_FocusTreeNodeType.ROOT) return true;
  if (!isAvailableFocusableOrEnabledNonFocusable(node)) return false;
  const ancestorIds = treeQueries_getAncestorIds(focusTree, node.id);

  for (const id of ancestorIds) {
    const node = getElement(focusTree, id);
    if (node == null) return false;
    if (node.type === types_FocusTreeNodeType.ROOT) return true;
    if (!isAvailableFocusableOrEnabledNonFocusable(node)) return false;
  }

  return true;
}
const getDelegatedFocusFromAncestor = (focusTree, elementId) => {
  const id = getIdFromAliasOrId(focusTree, elementId);

  if (id == null) {
    return undefined;
  }

  const element = focusTree.elements.get(id);

  if (element == null) {
    return undefined;
  }

  if (element.type === types_FocusTreeNodeType.ROOT || types_isDelegatingLandmark(element) && treeQueries_isNodeEnabled(focusTree, id)) {
    const delegatedFocus = element.getDelegatedFocus();
    return delegatedFocus != react_facet_src.NO_VALUE ? delegatedFocus : undefined;
  }

  return getDelegatedFocusFromAncestor(focusTree, focusTree.parents.get(id));
};
function getShortcutsFor(focusTree, aliasOrId) {
  const elementId = getIdFromAliasOrId(focusTree, aliasOrId);

  if (elementId == null) {
    return;
  }

  return focusTree.shortcuts.get(elementId);
}
function treeQueries_getShortcut(focusTree, elementId, buttonType) {
  const focusable = focusTree.elements.get(elementId);

  if (!focusable) {
    return;
  }

  if (treeQueries_isNodeEnabled(focusTree, elementId)) {
    var _focusTree$shortcuts$;

    const shortcut = (_focusTree$shortcuts$ = focusTree.shortcuts.get(elementId)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : _focusTree$shortcuts$.get(buttonType);

    if (shortcut != null) {
      return shortcut;
    }
  }

  const parentId = focusTree.parents.get(elementId);

  if (parentId == null) {
    return;
  }

  return treeQueries_getShortcut(focusTree, parentId, buttonType);
}
function getShortcutHandler(focusTree, elementId, actionButton) {
  var _getShortcut;

  return (_getShortcut = treeQueries_getShortcut(focusTree, elementId, actionButton)) === null || _getShortcut === void 0 ? void 0 : _getShortcut.callback;
}
function getFocusableAncestorNodes(focusTree, elementId) {
  const ancestors = [];
  const ancestorIds = treeQueries_getAncestorIds(focusTree, elementId);

  for (const id of ancestorIds) {
    const ancestor = getElement(focusTree, id);
    if (ancestor == null) return ancestors;

    if (ancestor.type !== types_FocusTreeNodeType.ITEM && types_isFocusable(ancestor)) {
      ancestors.push(ancestor);
    }
  }

  return ancestors;
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/treeInitialization.ts



const ROOT_NODE_ID = 1;

const createIsElementAncestorOf = (focusTree, id) => element => {
  var _element$getAttribute;

  const idAttribute = (_element$getAttribute = element.getAttribute(types_DATA_FOCUSABLE_ID)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : element.getAttribute(DATA_LANDMARK_ID);
  if (idAttribute == null) return false;
  const elementId = parseInt(idAttribute, 10);
  return id === elementId || isAncestorOf(focusTree, id, elementId);
};

const createGetDelegatedFocus = (focusTree, id) => () => {
  var _window$document$body;

  const enabledBindingLandmarkDescendant = getEnabledBindingLandmarkDescendant(focusTree, id); // We start by looking at enabled binding landmark descendants.
  // Binding landmarks take priority over any other behavior

  if (enabledBindingLandmarkDescendant != null) {
    const delegatedFocus = enabledBindingLandmarkDescendant.getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      return delegatedFocus;
    }
  }

  const defaultDelegatedFocus = {
    id,
    reason: NewFocusSuggestionReason.DefaultDelegation
  };
  const dynasty = focusTree.dynasty.get(id);
  const elements = Array.from((_window$document$body = window.document.body.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}], [${DATA_LANDMARK_ID}]`)) !== null && _window$document$body !== void 0 ? _window$document$body : []);

  if (elements.length === 0) {
    return defaultDelegatedFocus;
  }

  for (let i = 0; i < elements.length; i++) {
    const landmarkIdAttribute = elements[i].getAttribute(DATA_LANDMARK_ID);
    const focusableIdAttribute = elements[i].getAttribute(types_DATA_FOCUSABLE_ID);

    if (landmarkIdAttribute != null) {
      const landmarkId = parseInt(landmarkIdAttribute, 10);

      if (!(dynasty !== null && dynasty !== void 0 && dynasty.has(landmarkId))) {
        continue;
      }

      const landmarkElement = getElement(focusTree, landmarkId);

      if (!types_isDelegatingLandmark(landmarkElement)) {
        continue;
      }

      if (!treeQueries_isNodeEnabled(focusTree, landmarkId)) {
        continue;
      }

      const isElementAncestorOfLandmark = createIsElementAncestorOf(focusTree, landmarkId);
      const landmarkDecedentElements = elements.filter(isElementAncestorOfLandmark);
      const delegatedFocus = landmarkElement.getDelegatedFocus(landmarkDecedentElements);

      if (delegatedFocus != react_facet_src.NO_VALUE && delegatedFocus != null) {
        return delegatedFocus;
      }
    } else if (focusableIdAttribute != null) {
      const focusableId = parseInt(focusableIdAttribute, 10);

      if (dynasty !== null && dynasty !== void 0 && dynasty.has(focusableId) && treeQueries_isNodeEnabled(focusTree, focusableId)) {
        return {
          id: focusableId,
          reason: NewFocusSuggestionReason.FirstFoundDelegation
        };
      }
    }
  }

  return defaultDelegatedFocus;
};

const treeInitialization_getFreshTree = () => {
  const focusTree = {
    elements: new Map(),
    candidates: new Set(),
    children: new Map(),
    parents: new Map(),
    aliases: new Map(),
    shortcuts: new Map(),
    history: [],
    bindingLandmarkStack: [],
    dynasty: new Map(),
    grids: new Map(),
    bindingLandmarkDescendants: new Map()
  };
  const rootElement = {
    type: types_FocusTreeNodeType.ROOT,
    id: ROOT_NODE_ID,
    alias: undefined,
    disabled: false,
    hidden: false,
    ref: null,
    scrollAxis: null,
    onDown: undefined,
    onUp: undefined,
    onRight: undefined,
    onLeft: undefined,
    onBlur: undefined,
    onFocus: undefined,
    disableScrollIntoView: undefined,
    getDelegatedFocus: createGetDelegatedFocus(focusTree, ROOT_NODE_ID)
  };
  focusTree.elements.set(ROOT_NODE_ID, rootElement);
  return focusTree;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/geometry.ts

const mapArrowToDirection = {
  [Arrows.UP]: Direction.PREVIOUS,
  [Arrows.DOWN]: Direction.NEXT,
  [Arrows.LEFT]: Direction.PREVIOUS,
  [Arrows.RIGHT]: Direction.NEXT
};
const mapArrowToOppositeArrow = {
  [Arrows.UP]: Arrows.DOWN,
  [Arrows.DOWN]: Arrows.UP,
  [Arrows.LEFT]: Arrows.RIGHT,
  [Arrows.RIGHT]: Arrows.LEFT
};
const arrowToAxis = {
  [Arrows.UP]: Axis.VERTICAL,
  [Arrows.DOWN]: Axis.VERTICAL,
  [Arrows.LEFT]: Axis.HORIZONTAL,
  [Arrows.RIGHT]: Axis.HORIZONTAL
};
const perpendicularAxis = {
  [Axis.VERTICAL]: Axis.HORIZONTAL,
  [Axis.HORIZONTAL]: Axis.VERTICAL
};
const getEdgeCoordinate = (position, arrow) => {
  switch (arrow) {
    case Arrows.DOWN:
      {
        return position.top + position.height;
      }

    case Arrows.UP:
      {
        return position.top;
      }

    case Arrows.RIGHT:
      {
        return position.left + position.width;
      }

    case Arrows.LEFT:
      {
        return position.left;
      }
  }
};
const isSameAxis = (oldArrow, newArrow) => {
  switch (oldArrow) {
    case Arrows.DOWN:
    case Arrows.UP:
      {
        return newArrow === Arrows.UP || newArrow === Arrows.DOWN;
      }

    case Arrows.RIGHT:
    case Arrows.LEFT:
      {
        return newArrow === Arrows.LEFT || newArrow === Arrows.RIGHT;
      }
  }
};
const getTheCenterOfPostion = position => {
  const horizontal = position.left + position.width / 2;
  const vertical = position.top + position.height / 2;
  return [horizontal, vertical];
};
const getProjectionOverlap = (startingDimensions, targetDimensions, axis) => {
  switch (axis) {
    case Axis.HORIZONTAL:
      {
        const startingDimensionsBottom = startingDimensions.top + startingDimensions.height;
        const targetDimensionsBottom = targetDimensions.top + targetDimensions.height;
        const topHandSideDiff = Math.max(targetDimensions.top - startingDimensions.top, 0);
        const bottomHandSideDiff = Math.max(startingDimensionsBottom - targetDimensionsBottom, 0);
        const difference = topHandSideDiff + bottomHandSideDiff;
        const overlapInPixels = Math.max(startingDimensions.height - difference, 0);
        return overlapInPixels / startingDimensions.height;
      }

    case Axis.VERTICAL:
      {
        const startingDimensionsRight = startingDimensions.left + startingDimensions.width;
        const targetDimensionsRight = targetDimensions.left + targetDimensions.width;
        const leftHandSideDiff = Math.max(targetDimensions.left - startingDimensions.left, 0);
        const rightHandSideDiff = Math.max(startingDimensionsRight - targetDimensionsRight, 0);
        const difference = leftHandSideDiff + rightHandSideDiff;
        const overlapInPixels = Math.max(startingDimensions.width - difference, 0);
        return overlapInPixels / startingDimensions.width;
      }
  }
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/visualQueries.tsx



function getBoundingClientRectById(focusTree, id) {
  var _element$ref;

  const element = focusTree.elements.get(id);

  if (element == null || !types_isFocusable(element)) {
    return;
  }

  return element === null || element === void 0 ? void 0 : (_element$ref = element.ref) === null || _element$ref === void 0 ? void 0 : _element$ref.getBoundingClientRect();
}
function visualQueries_findClickableFocusableAtPoint(focusTree, x, y) {
  for (const entry of focusTree.elements) {
    var _focusTree$shortcuts$, _focusTree$shortcuts$2;

    const element = entry[1];
    if (element.type !== types_FocusTreeNodeType.ITEM || !isAvailableFocusable(element) || ((_focusTree$shortcuts$ = focusTree.shortcuts.get(element.id)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : (_focusTree$shortcuts$2 = _focusTree$shortcuts$.get(types_ButtonType.A)) === null || _focusTree$shortcuts$2 === void 0 ? void 0 : _focusTree$shortcuts$2.callback) == null) continue;
    const rect = element.ref.getBoundingClientRect();

    if (x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height) {
      return element;
    }
  }
}
const getTopLeftElementId = tree => {
  let bestCandidateId = null;
  let bestCandidateCoordinates = [Infinity, Infinity];

  for (const [id, element] of tree.elements) {
    var _element$ref2;

    if (!types_isFocusable(element)) {
      continue;
    }

    const position = (_element$ref2 = element.ref) === null || _element$ref2 === void 0 ? void 0 : _element$ref2.getBoundingClientRect();

    if (position == null) {
      continue;
    }

    if (element.type !== types_FocusTreeNodeType.ITEM) {
      continue;
    }

    if (treeQueries_isAnyAncestorDisabled(tree, element.id)) {
      continue;
    }

    const center = getTheCenterOfPostion(position);
    const candidateMoreTop = center[0] < bestCandidateCoordinates[0];
    const candidateSameTopButMoreLeft = center[0] === bestCandidateCoordinates[0] && center[1] < bestCandidateCoordinates[1];

    if (candidateMoreTop || candidateSameTopButMoreLeft) {
      bestCandidateId = id;
      bestCandidateCoordinates = center;
    }
  }

  return bestCandidateId;
};
const getCurrentDomElementIndex = (currentDomElement, allElements) => {
  for (let i = 0; i < allElements.length; i++) {
    if (currentDomElement === allElements[i]) {
      return i;
    }
  }

  return null;
};
const getFocusedIdFromDomElement = currentDomElement => {
  const stringElementId = currentDomElement.getAttribute(types_DATA_FOCUSABLE_ID);

  if (stringElementId != null) {
    return parseInt(stringElementId);
  }

  return;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/operations.ts



const clickFocusableAtPoint = (focusTree, x, y) => {
  const focusable = visualQueries_findClickableFocusableAtPoint(focusTree, x, y);

  if (focusable != null && focusable.type === types_FocusTreeNodeType.ITEM) {
    var _shortcuts$get;

    const shortcuts = focusTree.shortcuts.get(focusable.id);
    shortcuts === null || shortcuts === void 0 ? void 0 : (_shortcuts$get = shortcuts.get(types_ButtonType.A)) === null || _shortcuts$get === void 0 ? void 0 : _shortcuts$get.callback();
  }
};
const notifyAncestorsOfDecedentFocus = (focusTree, focusedId, origin) => {
  const focusedNumberId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNumberId == null) return;
  let lastDelegatingAncestorId = undefined;

  for (let ancestorId = focusTree.parents.get(focusedNumberId); ancestorId != null; ancestorId = focusTree.parents.get(ancestorId)) {
    const ancestorElement = focusTree.elements.get(ancestorId);

    if (!types_isDelegatingLandmark(ancestorElement)) {
      continue;
    }

    if (lastDelegatingAncestorId == null) {
      ancestorElement.onFocusableOfDynastyFocused(focusedId, origin); // Use focusedId here since we want to pass the alias if there is one
    } else {
      const lastDelegatingAncestorElement = focusTree.elements.get(lastDelegatingAncestorId);
      const lastDelegatingAncestorAlias = lastDelegatingAncestorElement != null && types_isFocusable(lastDelegatingAncestorElement) ? lastDelegatingAncestorElement === null || lastDelegatingAncestorElement === void 0 ? void 0 : lastDelegatingAncestorElement.alias : undefined;
      ancestorElement.onFocusableOfDynastyFocused( // Prefer passing the alias over the number id
      lastDelegatingAncestorAlias !== null && lastDelegatingAncestorAlias !== void 0 ? lastDelegatingAncestorAlias : lastDelegatingAncestorId, origin);
    }

    lastDelegatingAncestorId = ancestorId;
  }
};
const nofifyNodesOfBlurAndFocus = (focusTree, previousElementId, focusedId) => {
  const newNodeId = getIdFromAliasOrId(focusTree, focusedId);
  const previousNode = previousElementId != null ? focusTree.elements.get(previousElementId) : undefined;
  if (previousNode == null || !types_isFocusable(previousNode)) return;

  if (previousNode != null && previousElementId !== newNodeId && previousElementId != null) {
    var _previousNode$onBlur;

    (_previousNode$onBlur = previousNode.onBlur) === null || _previousNode$onBlur === void 0 ? void 0 : _previousNode$onBlur.call(previousNode);
  }

  if (focusedId == null || newNodeId == null) return;
  const newNode = focusTree.elements.get(newNodeId);
  if (newNode == null || !types_isFocusable(newNode)) return;

  if (previousNode != null && previousNode !== newNode) {
    var _previousNode$onBlur2;

    (_previousNode$onBlur2 = previousNode.onBlur) === null || _previousNode$onBlur2 === void 0 ? void 0 : _previousNode$onBlur2.call(previousNode);
  }

  if (newNode != null) {
    var _newNode$onFocus;

    (_newNode$onFocus = newNode.onFocus) === null || _newNode$onFocus === void 0 ? void 0 : _newNode$onFocus.call(newNode);
  }
};
const click = (focusTree, focusedId) => {
  if (focusedId == null) return undefined;
  const focusable = focusTree.elements.get(focusedId);

  if (focusable != null && focusable.type === types_FocusTreeNodeType.ITEM) {
    var _focusTree$shortcuts$, _focusTree$shortcuts$2;

    (_focusTree$shortcuts$ = focusTree.shortcuts.get(focusedId)) === null || _focusTree$shortcuts$ === void 0 ? void 0 : (_focusTree$shortcuts$2 = _focusTree$shortcuts$.get(types_ButtonType.A)) === null || _focusTree$shortcuts$2 === void 0 ? void 0 : _focusTree$shortcuts$2.callback();
  }

  return;
};
const fireShortcut = (focusTree, focusedId, button) => {
  const focusedNodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId;
  if (focusedNodeId == null) return false;
  const handler = getShortcutHandler(focusTree, focusedNodeId, button);

  if (handler != null) {
    handler();
    return true;
  }

  return false;
};
const fireHandler = (focusTree, focusedId, arrow) => {
  const focusedNodeId = typeof focusedId === 'string' ? focusTree.aliases.get(focusedId) : focusedId;
  if (focusedNodeId == null) return false;
  const focusedNode = focusTree.elements.get(focusedNodeId);
  if (focusedNode == null || !types_isFocusable(focusedNode)) return false;

  switch (arrow) {
    case Arrows.LEFT:
      if (focusedNode.onLeft) {
        if (focusedNode.onLeft()) return true;
      }

      break;

    case Arrows.RIGHT:
      if (focusedNode.onRight) {
        if (focusedNode.onRight()) return true;
      }

      break;

    case Arrows.UP:
      if (focusedNode.onUp) {
        if (focusedNode.onUp()) return true;
      }

      break;

    case Arrows.DOWN:
      if (focusedNode.onDown) {
        if (focusedNode.onDown()) return true;
      }

  }

  return false;
};
const wiggleScrollables = (focusTree, focusedId, axes, analogScrollMaxSpeed) => {
  if (focusedId == null) return false;
  const verticalValue = axes[types_ButtonType.RIGHT_VERTICAL_AXIS];
  const horizontalValue = axes[types_ButtonType.RIGHT_HORIZONTAL_AXIS];
  if (verticalValue === 0 && horizontalValue === 0) return false;
  const focusedNodeId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNodeId == null) return false;
  const nodes = getFocusableAncestorNodes(focusTree, focusedNodeId);
  const parents = nodes.filter(node => node.scrollAxis != null);
  if (parents.length === 0) return false;
  parents.forEach(parent => {
    const value = parent.scrollAxis === ScrollAxis.HORIZONTAL ? horizontalValue : verticalValue;
    const scrollProperty = parent.scrollAxis === ScrollAxis.HORIZONTAL ? 'scrollLeft' : 'scrollTop';
    if (parent.ref == null) return;
    parent.ref[scrollProperty] += value * analogScrollMaxSpeed;
  });
  return true;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/delegation/delegateBinding.ts




const delegateToBindingLandmark = (focusTree, maybeBindingLandmark) => {
  if (!isBindingLandmark(maybeBindingLandmark)) return;
  focusTree.bindingLandmarkStack.push(maybeBindingLandmark.id);
  const delegatedFocus = maybeBindingLandmark.getDelegatedFocus(); // Not getting a `delegatedId` in this case should be impossible.
  // `getDelegatedFocus` should be implemented so that, if no other child
  // is available, the delegating Landmark will return its own id.

  return delegatedFocus === react_facet_src.NO_VALUE ? undefined : delegatedFocus;
};

function getTopBindingLandmarkDelegatedFocus(tree, focusedNumberId, discardedStack) {
  if (focusedNumberId != null) {
    for (const discardedId of discardedStack) {
      if (isAncestorOf(tree, discardedId, focusedNumberId) && tree.bindingLandmarkStack.length > 0) {
        const topOfStack = getElement(tree, tree.bindingLandmarkStack[tree.bindingLandmarkStack.length - 1]);

        if (topOfStack != null && isBindingLandmark(topOfStack)) {
          const delegatedFocus = topOfStack.getDelegatedFocus();

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        }
      }
    }
  }
}

function processLandmarkStack(tree, incomingFocusableId) {
  const newStack = [];
  const discardedStack = new Set();
  tree.bindingLandmarkStack.forEach(elementId => {
    if (isAncestorOf(tree, incomingFocusableId, elementId) || incomingFocusableId === elementId) {
      discardedStack.add(elementId);
    } else {
      newStack.push(elementId);
    }
  });
  return {
    newStack,
    discardedStack
  };
}

function shouldConsiderDelegatedFocus(tree, currentFocusedNumberId, incomingFocusableId) {
  if (currentFocusedNumberId == null) {
    return false;
  }

  const isIncomingFocusableCurrentFocusedId = currentFocusedNumberId === incomingFocusableId;
  return isAncestorOf(tree, incomingFocusableId, currentFocusedNumberId) || isIncomingFocusableCurrentFocusedId;
}

function delegateFocusOnBindingLandmark(tree, incomingFocusable) {
  return delegateToBindingLandmark(tree, incomingFocusable) || delegateToFirstEnabledDescendant(tree, incomingFocusable) || null;
}

function delegateToFirstEnabledDescendant(tree, incomingFocusable) {
  const enabledBindingLandmarkDescendants = getEnabledBindingLandmarkDescendantIds(tree, incomingFocusable.id);

  if (enabledBindingLandmarkDescendants != null && enabledBindingLandmarkDescendants.length > 0) {
    const enabledBindingLandmarkId = enabledBindingLandmarkDescendants[0];
    const enabledBindingLandmark = getElement(tree, enabledBindingLandmarkId);

    if (enabledBindingLandmark != null && types_isFocusable(enabledBindingLandmark)) {
      return delegateToBindingLandmark(tree, enabledBindingLandmark);
    }
  }

  return null;
}

function updateFocusOnBindingLandmarkEnabling(tree, incomingFocusable, shouldSuggestNewFocus, isLandmarkBecomingEnabled, isLandmarkBeingAddedEnabled) {
  if (!shouldSuggestNewFocus) return null;

  if (isLandmarkBecomingEnabled || isLandmarkBeingAddedEnabled) {
    return delegateFocusOnBindingLandmark(tree, incomingFocusable);
  }

  return null;
}
function updateFocusOnBindingLandmarkDisabling(tree, incomingFocusable, currentFocusedNumberId, shouldSuggestNewFocus, isLandmarkBecomingDisabled) {
  if (!isLandmarkBecomingDisabled) return null;
  const {
    newStack,
    discardedStack
  } = processLandmarkStack(tree, incomingFocusable.id);
  tree.bindingLandmarkStack = newStack;

  if (shouldSuggestNewFocus) {
    const topBindingDelegatedFocus = getTopBindingLandmarkDelegatedFocus(tree, currentFocusedNumberId, discardedStack);
    if (topBindingDelegatedFocus) return topBindingDelegatedFocus;

    if (shouldConsiderDelegatedFocus(tree, currentFocusedNumberId, incomingFocusable.id)) {
      return getDelegatedFocusFromAncestor(tree, incomingFocusable.id);
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/mutationQueries.ts


function getFocusableEnabledStatus(tree, treeNode, previousFocusable, parentId) {
  const isFocusableEnabled = isAvailableFocusableOrEnabledNonFocusable(treeNode) && treeQueries_isNodeEnabled(tree, parentId);
  const isFocusableBecomingEnabled = previousFocusable != null && isFocusableEnabled && !isAvailableFocusableOrEnabledNonFocusable(previousFocusable);
  const isFocusableBeingAddedEnabled = previousFocusable == null && isFocusableEnabled;
  return {
    isFocusableEnabled,
    isFocusableBecomingEnabled,
    isFocusableBeingAddedEnabled
  };
} // TODO: Let's try to eliminate this function by
// inserting the item early into the tree in the main function L:232, and into the dynasty properly
// Then we should call getclosestDelegatingAncestor directly without any heuristics.
// function getClosestDelegatingAncestorToFocusTreeNode(
// 	tree: FocusTree,
// 	treeNode: FocusTreeNode,
// ): DelegatingLandmark | Root | null {
// 	return getClosestDelegatingAncestor(tree, treeNode.id)
// }

function getClosestDelegatingAncestorToFocusTreeNode(tree, treeNode, previousFocusable, parentFocusable) {
  if (previousFocusable == null && parentFocusable != null && (types_isDelegatingLandmark(parentFocusable) || isRoot(parentFocusable))) {
    return parentFocusable;
  } else {
    const startingElementId = previousFocusable == null && (parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id) != null ? parentFocusable.id : treeNode.id;
    return getClosestDelegatingAncestor(tree, startingElementId);
  }
}
function getClosestDelegatingLandmark(tree, treeNode, previousFocusable, parentFocusable) {
  const closestDelegatingAncestor = getClosestDelegatingAncestorToFocusTreeNode(tree, treeNode, previousFocusable, parentFocusable);
  return isDelegatingLandmark(closestDelegatingAncestor) ? closestDelegatingAncestor : undefined;
}
function getAncestorInfo(tree, treeNode, previousFocusable, parentFocusable) {
  const closestDelegatingAncestor = getClosestDelegatingAncestorToFocusTreeNode(tree, treeNode, previousFocusable, parentFocusable);
  const maybeDynasty = closestDelegatingAncestor != null ? tree.dynasty.get(closestDelegatingAncestor.id) : undefined;
  const closestDelegatingAncestorDynastyHasNoEnabledItems = maybeDynasty == null || !doesDynastyHaveAnyEnabledItems(tree, maybeDynasty);
  const closestDelegatingLandmark = types_isDelegatingLandmark(closestDelegatingAncestor) ? closestDelegatingAncestor : undefined;
  return {
    closestDelegatingAncestor,
    maybeDynasty,
    closestDelegatingAncestorDynastyHasNoEnabledItems,
    closestDelegatingLandmark
  };
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/delegation/delegate.ts





const getDelegateCandidate = delgatingAncestor => {
  const delegatedFocus = delgatingAncestor.getDelegatedFocus();

  if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
    return delegatedFocus;
  }
};
function getRedelegatedFocusIfFocusedAndAliasChanged(shouldSuggestNewFocus, focusTreeNode, currentFocusedNumberId, updatedIdAfterAliasMutation) {
  const isIncomingFocusableCurrentFocusedId = currentFocusedNumberId === focusTreeNode.id;

  if (shouldSuggestNewFocus && isIncomingFocusableCurrentFocusedId && updatedIdAfterAliasMutation != null) {
    return {
      id: updatedIdAfterAliasMutation,
      reason: NewFocusSuggestionReason.FocusableAliasMutation
    };
  }
}
function getDelegatedFocusOnRemovalIfFocusWithin(tree, focusable, focused, parentId) {
  const focusedId = focused.id;
  const focusedNumberId = getIdFromAliasOrId(tree, focusedId);
  const wasFocusableAncestorOfFocusedId = focusedNumberId != null && isAncestorOf(tree, focusable.id, focusedNumberId);
  const wasSameAsFocusedId = focusedNumberId === focusable.id;

  if (parentId != null && (wasFocusableAncestorOfFocusedId || wasSameAsFocusedId)) {
    const delegatedId = getDelegatedFocusFromAncestor(tree, parentId);

    if (delegatedId != null) {
      return delegatedId;
    }
  }
}
function getDelegatedFocusForNextBindingLandmark(maybeNextBindingLandmarkInStack) {
  if (maybeNextBindingLandmarkInStack != null && isBindingLandmark(maybeNextBindingLandmarkInStack)) {
    const delegatedFocus = maybeNextBindingLandmarkInStack.getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      return delegatedFocus;
    }
  }
}
function getPutFocusableDelegationFunctions(tree, incomingFocusable, incomingFocusablePreviousState, parentFocusable, closestDelegatingAncestor, maybeDynasty, currentFocusedNumberId, currentFocus, shouldSuggestNewFocus) {
  const {
    isFocusableEnabled,
    isFocusableBecomingEnabled,
    isFocusableBeingAddedEnabled
  } = getFocusableEnabledStatus(tree, incomingFocusable, incomingFocusablePreviousState, parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id); // Has to be calculated before we update dynasty of closestDelgatingAncestor in putNodeIntoTree

  const closestDelegatingAncestorDynastyHasNoEnabledItems = maybeDynasty == null || !doesDynastyHaveAnyEnabledItems(tree, maybeDynasty);
  /**
   * Landmark binding case includes current focusable being a binding landmark being inserted, enabled or being disabled
   */

  function delegateFocusOnBindingLandmarkCase() {
    const isFocusableEnabled = isAvailableFocusableOrEnabledNonFocusable(incomingFocusable) && treeQueries_isNodeEnabled(tree, parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id);
    const isLandmarkBeingAddedEnabled = incomingFocusablePreviousState == null && isFocusableEnabled;
    const isLandmarkBecomingEnabled = isAvailableFocusableOrEnabledNonFocusable(incomingFocusable) && treeQueries_isNodeEnabled(tree, parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id);
    const isLandmarkBecomingDisabled = incomingFocusablePreviousState != null && !isAvailableFocusable(incomingFocusable) && isAvailableFocusable(incomingFocusablePreviousState);
    const updatedFocusOnLandmarkDisabling = updateFocusOnBindingLandmarkDisabling(tree, incomingFocusable, currentFocusedNumberId, shouldSuggestNewFocus, isLandmarkBecomingDisabled);
    if (updatedFocusOnLandmarkDisabling != null) return updatedFocusOnLandmarkDisabling;
    const updatedFocusOnLandmarkChange = updateFocusOnBindingLandmarkEnabling(tree, incomingFocusable, shouldSuggestNewFocus, isLandmarkBecomingEnabled, isLandmarkBeingAddedEnabled);
    if (updatedFocusOnLandmarkChange) return updatedFocusOnLandmarkChange;
  }
  /**
   * Landmark Identity change includes mutating `delegateByAlias` or `landmarkKey`
   */


  function delegateFocusOnLandmarkIdentityChanged() {
    // Re-delegate focus of a Landmark if:
    // 1a) Alias for delegation changed and focused origin is from a tree mutation
    // 1b) OR landmark key changed
    // 2a) The Landmark itself is focused
    // 2b) OR a decedent item of the Landmark is currently focused and is the previous alias
    const shouldSuggestNewFocusForDelegatingLandamrk = shouldSuggestNewFocus && currentFocusedNumberId != null && incomingFocusablePreviousState != null && types_isDelegatingLandmark(incomingFocusable) && types_isDelegatingLandmark(incomingFocusablePreviousState);
    const isIncomingFocusableCurrentFocusedId = currentFocusedNumberId === incomingFocusable.id;

    if (shouldSuggestNewFocusForDelegatingLandamrk) {
      const focusedOriginIsFromTreeMutation = currentFocus.origin === FocusOrigin.FocusTreeMutation;
      const aliasForDelegationDidChange = incomingFocusablePreviousState.delegateFocusByAlias !== incomingFocusable.delegateFocusByAlias;
      const landmarkKeyDidChange = incomingFocusable.landmarkKey !== incomingFocusablePreviousState.landmarkKey;
      const aliasForDelegationChangedWithoutUserInput = aliasForDelegationDidChange && focusedOriginIsFromTreeMutation;

      if (aliasForDelegationChangedWithoutUserInput || landmarkKeyDidChange) {
        if (isIncomingFocusableCurrentFocusedId || isAncestorOf(tree, incomingFocusable.id, currentFocusedNumberId)) {
          const delegatedFocus = incomingFocusable.getDelegatedFocus();

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        }
      }
    }
  }
  /**
   * This case includes incomingFocusable being of any focusable type and changing it's alias while
   * it has a delegating ancestor that delegates by alias or by memory
   */


  function delegateFocusIfFocusableAliasChanged() {
    /**  We want to eliminate ROOT as a delegating ancestor in this constant
     */
    const closestDelegatingLandmark = types_isDelegatingLandmark(closestDelegatingAncestor) ? closestDelegatingAncestor : undefined; // Re-delegate if alias for an focusable changes and if:
    // 1) Current focused originates from a tree mutation
    // 2) The focusable is a decendant of the closest ancestor Landmark
    // 3) The closest delegating Landmark is delegating by alias or delegating by memory (memory stores aliases)
    // 4a) The closest delegating Landmark is focused
    // 4b) OR the focused id is a decedent of the closest delegating Landmark

    if ((incomingFocusablePreviousState == null || types_isFocusable(incomingFocusablePreviousState)) && shouldSuggestNewFocus && isFocusableEnabled && currentFocus.origin === FocusOrigin.FocusTreeMutation && currentFocusedNumberId != null && types_isFocusable(incomingFocusable)) {
      const hasAliasChanged = incomingFocusablePreviousState == null || incomingFocusablePreviousState.alias !== incomingFocusable.alias;

      if ((hasAliasChanged || isFocusableBecomingEnabled || isFocusableBeingAddedEnabled) && closestDelegatingLandmark != null && (closestDelegatingLandmark.delegateFocusByAlias != null || closestDelegatingLandmark.delegationMemoryStack != null)) {
        if (closestDelegatingLandmark.id === currentFocusedNumberId || isAncestorOf(tree, closestDelegatingLandmark.id, currentFocusedNumberId)) {
          const delegatedFocus = closestDelegatingLandmark.getDelegatedFocus();

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        }
      }
    }
  }
  /**
   * IncomingFocusable is enabled and it's closest delegating ancestor is focused with no enabled children
   */


  function delegateFocusOnDelegatingAncestorHasNoEnabledChildren() {
    const hasNoEnabledChildren = shouldSuggestNewFocus && (isFocusableBecomingEnabled || isFocusableBeingAddedEnabled) && closestDelegatingAncestorDynastyHasNoEnabledItems && closestDelegatingAncestor != null && currentFocusedNumberId != null && closestDelegatingAncestor.id === currentFocusedNumberId;

    if (hasNoEnabledChildren) {
      return getDelegateCandidate(closestDelegatingAncestor);
    }
  }

  return {
    delegateFocusOnBindingLandmarkCase,
    delegateFocusOnLandmarkIdentityChanged,
    delegateFocusIfFocusableAliasChanged,
    delegateFocusOnDelegatingAncestorHasNoEnabledChildren
  };
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/dom.ts

function writeDOMData(incomingFocusable) {
  var _incomingFocusable$re, _incomingFocusable$re2;

  const stringId = incomingFocusable.id.toString(); // Note that if the `ref` is ever updated, we are not setting these again.
  // This could be a problem, but as far as we know, there is nowhere in the
  // current minecraft-ui code a mechanism to listen to changes in the ref
  // object. That is something that we should address more generally: potentially
  // adding a callback to the `ref` prop when putting it into a `<div />`, for
  // example, instead of using a `useRef`

  const isLandmark = incomingFocusable.type === types_FocusTreeNodeType.LANDMARK;
  (_incomingFocusable$re = incomingFocusable.ref) === null || _incomingFocusable$re === void 0 ? void 0 : _incomingFocusable$re.removeAttribute(isLandmark ? types_DATA_FOCUSABLE_ID : DATA_LANDMARK_ID);
  (_incomingFocusable$re2 = incomingFocusable.ref) === null || _incomingFocusable$re2 === void 0 ? void 0 : _incomingFocusable$re2.setAttribute(isLandmark ? DATA_LANDMARK_ID : types_DATA_FOCUSABLE_ID, stringId);

  if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ != null) {
    var _incomingFocusable$re3;

    (_incomingFocusable$re3 = incomingFocusable.ref) === null || _incomingFocusable$re3 === void 0 ? void 0 : _incomingFocusable$re3.setAttribute(DATA_FOCUSABLE_DEBUG_ID, stringId);
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/utility.ts
/**
 * Mutates the parameter array by trimming undefined or null from the end of it
 */
function trimArrayEnd(arr) {
  for (let i = arr.length - 1; i >= 0; i--) {
    const element = arr[i];

    if (element == null) {
      arr.pop();
    } else {
      return;
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/grid.ts


function addItemToGridInTree(tree, incomingFocusable, parentFocusable) {
  // Grid optimization
  if ((parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id) != null && (parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.type) === types_FocusTreeNodeType.LANDMARK && !!parentFocusable.isGrid) {
    const currentElementGridIndex = incomingFocusable.gridIndex;

    if (currentElementGridIndex != null) {
      var _tree$grids$get;

      const parentGrid = (_tree$grids$get = tree.grids.get(parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id)) !== null && _tree$grids$get !== void 0 ? _tree$grids$get : [];

      if (parentGrid[currentElementGridIndex] !== incomingFocusable.id) {
        parentGrid[currentElementGridIndex] = incomingFocusable.id;
        tree.grids.set(parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id, parentGrid);
      }
    }
  }
}
function removeItemFromGridInTree(tree, focusableToRemove, parentFocusable) {
  // Grid optimization
  // If a direct descendant of a grid landmark is removed, remove it from the grid matrix
  if ((parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.type) === types_FocusTreeNodeType.LANDMARK && parentFocusable.isGrid && focusableToRemove.type === types_FocusTreeNodeType.ITEM) {
    const currentElementGridIndex = focusableToRemove.gridIndex;

    if (currentElementGridIndex != null) {
      var _tree$grids$get2;

      const parentGrid = (_tree$grids$get2 = tree.grids.get(parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id)) !== null && _tree$grids$get2 !== void 0 ? _tree$grids$get2 : [];

      if (parentGrid[currentElementGridIndex] === focusableToRemove.id) {
        // We want to keep the index empty, if the grid is being shuffled it will be
        // occupied at a later stage by another sibling
        delete parentGrid[currentElementGridIndex];

        if (currentElementGridIndex === parentGrid.length - 1) {
          // Mutates the array
          trimArrayEnd(parentGrid);
        }

        tree.grids.set(parentFocusable === null || parentFocusable === void 0 ? void 0 : parentFocusable.id, parentGrid);
      }
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/treeStateErrorHandlers.ts


function handleTreeStateErrors(focusTreeNode, focusTree) {
  if (false) {}
}
function handleMissingRefErrors(focusTreeNode) {
  if (isFocusable(focusTreeNode) && focusTreeNode.type !== FocusTreeNodeType.ROOT && focusTreeNode.ref == null) {
    console.log(focusTreeNode);
    console.error(`${focusTreeNodeToIdString(focusTreeNode)} doesn't have a ref, provide one to it and link the ref to a real DOM element to fix this`);
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/putNodeIntoTree/addNode.ts


function addNode(focusTreeNode, focusTree, parentId, closestDelegatingAncestor, maybeDynasty, isLandmark) {
  handleTreeStateErrors(focusTreeNode, focusTree);
  focusTree.elements.set(focusTreeNode.id, focusTreeNode);

  if (types_isFocusable(focusTreeNode) && focusTreeNode.alias != null) {
    focusTree.aliases.set(focusTreeNode.alias, focusTreeNode.id);
  }

  if (parentId != null) {
    var _focusTree$children$g;

    // Update parent's children
    const siblings = (_focusTree$children$g = focusTree.children.get(parentId)) !== null && _focusTree$children$g !== void 0 ? _focusTree$children$g : new Set();
    siblings.add(focusTreeNode.id);
    focusTree.children.set(parentId, siblings); // Update parents

    focusTree.parents.set(focusTreeNode.id, parentId); // Update dynasty

    updateDynasty(closestDelegatingAncestor, focusTreeNode, maybeDynasty, focusTree); // Update binding landmark descendants

    updateBindingLandmarkDescendants(focusTreeNode, parentId, focusTree);
  } // If a delegating landmark is added after its children, we update its dynasty.


  if (isLandmark && types_isDelegatingLandmark(focusTreeNode)) {
    const landmarkChildren = focusTree.children.get(focusTreeNode.id);

    if (landmarkChildren != null) {
      var _focusTree$dynasty$ge;

      const dynasty = (_focusTree$dynasty$ge = focusTree.dynasty.get(focusTreeNode.id)) !== null && _focusTree$dynasty$ge !== void 0 ? _focusTree$dynasty$ge : new Set();

      const updateDynastyRecursively = children => {
        if (children == null) return;

        for (const childId of children) {
          if (!dynasty.has(childId)) {
            dynasty.add(childId);
          }

          const child = focusTree.elements.get(childId);

          if (!types_isDelegatingLandmark(child)) {
            const grandChildren = focusTree.children.get(childId);
            updateDynastyRecursively(grandChildren);
          }
        }
      };

      updateDynastyRecursively(landmarkChildren);
      focusTree.dynasty.set(focusTreeNode.id, dynasty);
    }
  }
}

function updateDynasty(closestDelegatingAncestor, focusTreeNode, maybeDynasty, focusTree) {
  if (closestDelegatingAncestor != null && types_isFocusable(focusTreeNode)) {
    const dynasty = maybeDynasty !== null && maybeDynasty !== void 0 ? maybeDynasty : new Set();
    dynasty.add(focusTreeNode.id);
    focusTree.dynasty.set(closestDelegatingAncestor.id, dynasty);
  }
}

function updateBindingLandmarkDescendants(focusTreeNode, parentId, focusTree) {
  if (isBindingLandmark(focusTreeNode)) {
    for (let currentId = parentId; currentId != null; currentId = focusTree.parents.get(currentId)) {
      var _focusTree$bindingLan;

      const current = focusTree.elements.get(currentId);

      if (current == null) {
        break;
      }

      const descendants = (_focusTree$bindingLan = focusTree.bindingLandmarkDescendants.get(current.id)) !== null && _focusTree$bindingLan !== void 0 ? _focusTree$bindingLan : new Set();
      descendants.add(focusTreeNode.id);
      focusTree.bindingLandmarkDescendants.set(current.id, descendants);

      if (isBindingLandmark(current)) {
        break;
      }
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/putNodeIntoTree/putNode.ts



 // TODO: split this code into putFocusable and putNonFocusable

function putNodeIntoTree(previousFocusable, focusTree, focusTreeNode, isLandmark, parentId, closestDelegatingAncestor, maybeDynasty) {
  let updatedIdAfterAliasMutation = undefined;

  if (previousFocusable) {
    updatedIdAfterAliasMutation = putNode(focusTree, focusTreeNode, updatedIdAfterAliasMutation, isLandmark, previousFocusable);
  } else {
    // Error handling of faulty tree states on insertion only in browser developent environment as to not
    // add too much cost in performance
    addNode(focusTreeNode, focusTree, parentId, closestDelegatingAncestor, maybeDynasty, isLandmark);
  }

  return updatedIdAfterAliasMutation;
}

function putNode(focusTree, focusTreeNode, updatedIdAfterAliasMutation, isLandmark, previousFocusable) {
  updatedIdAfterAliasMutation = putAliasForNode(focusTree, focusTreeNode, updatedIdAfterAliasMutation); // Error handling of faulty tree states on insertion only in browser developent environment as to not
  // add too much cost in performance

  handleTreeStateErrors(focusTreeNode, focusTree); // If we check for empty refs on first time insertion of a node, often it doesn't have a ref yet and it gets it on the next update.
  // However this isn't guaranteed to detect if a landmark has a null ref, because if the ref isnt updated the landmark isn't updated in tree either.
  // TODO: find a better way to check for landmarks that have truly faulty refs and not just temporarily have null ref that will be filled next update.

  if (false) {}

  focusTree.elements.set(focusTreeNode.id, focusTreeNode); // If a landmark turns to a delegating one after it wasn't, we update its dynasty.

  updateDynastyForLandmark(isLandmark, previousFocusable, focusTreeNode, focusTree); // If a landmark turns to a non-delegating one after it was a delegating one, we remove its dynasty.

  if (isLandmark && types_isDelegatingLandmark(previousFocusable) && !types_isDelegatingLandmark(focusTreeNode)) {
    focusTree.dynasty.delete(focusTreeNode.id);
  }

  return updatedIdAfterAliasMutation;
}

function updateDynastyForLandmark(isLandmark, previousFocusable, focusTreeNode, focusTree) {
  if (isLandmark && !types_isDelegatingLandmark(previousFocusable) && types_isDelegatingLandmark(focusTreeNode)) {
    const landmarkChildren = focusTree.children.get(focusTreeNode.id);

    if (landmarkChildren != null) {
      var _focusTree$dynasty$ge;

      const dynasty = (_focusTree$dynasty$ge = focusTree.dynasty.get(focusTreeNode.id)) !== null && _focusTree$dynasty$ge !== void 0 ? _focusTree$dynasty$ge : new Set();

      const updateDynastyRecursively = children => {
        if (children == null) return;

        for (const childId of children) {
          if (!dynasty.has(childId)) {
            dynasty.add(childId);
          }

          const child = focusTree.elements.get(childId);

          if (!types_isDelegatingLandmark(child)) {
            const grandChildren = focusTree.children.get(childId);
            updateDynastyRecursively(grandChildren);
          }
        }
      };

      updateDynastyRecursively(landmarkChildren);
      focusTree.dynasty.set(focusTreeNode.id, dynasty);
    }
  }
}

function putAliasForNode(focusTree, focusTreeNode, updatedIdAfterAliasMutation) {
  const originalAlias = treeQueries_getAlias(focusTree, focusTreeNode.id);
  const newAlias = types_isFocusable(focusTreeNode) ? focusTreeNode.alias : undefined;

  if (originalAlias !== newAlias) {
    if (originalAlias != null) {
      focusTree.aliases.delete(originalAlias);
    }

    const isNewAliasDefined = newAlias != null;

    if (isNewAliasDefined) {
      focusTree.aliases.set(newAlias, focusTreeNode.id);
    }

    updatedIdAfterAliasMutation = isNewAliasDefined ? newAlias : focusTreeNode.id; // NOTE: We are deliberately not updating the delegation memory stack of the
    // closest delegating landmark here. The reason is that we might change alias on
    // an item when the landmark key changes, i.e. the items is considered to be a
    // new item. We therefore want to keep the old alias in memory and not add the
    // the new one to memory.
  }

  return updatedIdAfterAliasMutation;
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/removeNodeFromTree/removeNode.ts


function removeFromClosestDelegatingAncestors(tree, focusable) {
  const closestDelegatingAncestor = getClosestDelegatingAncestor(tree, focusable.id);

  if (closestDelegatingAncestor != null) {
    const coDescendants = tree.dynasty.get(closestDelegatingAncestor.id);

    if (coDescendants != null) {
      coDescendants.delete(focusable.id);
    }
  } // Update delegation memory of closest delegating landmark
  // NOTE: if ths focusable has been stored as an alias in the
  // closest delegating landmark's memory stack, we are deliberately
  // not removing that. The reason is that we might want to remember
  // the alias if a new focus item gets mounted with that alias, eg.
  // when going back and forth between tabs having the same landmark,
  // but with different landmark keys. An example of this is the mount
  // tabs in badger's character select screen.


  if (closestDelegatingAncestor != null && closestDelegatingAncestor.type !== types_FocusTreeNodeType.ROOT && closestDelegatingAncestor.delegationMemoryStack != null) {
    closestDelegatingAncestor.delegationMemoryStack.forEach(memoryStack => {
      const indexInStack = memoryStack.indexOf(focusable.id);
      memoryStack.splice(indexInStack, 1);
    });
  }
}
function removeFromBindingListInTree(tree, focusable) {
  // Update binding landmark descendants
  tree.bindingLandmarkDescendants.delete(focusable.id);

  if (isBindingLandmark(focusable)) {
    for (const [_, bindingLandmarkDescendants] of tree.bindingLandmarkDescendants) {
      bindingLandmarkDescendants.delete(focusable.id);
    }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/mutate/mutations.ts








function resetNavigationDirection(tree) {
  tree.lastDirectionChange = undefined;
}
function putShortcut(tree, elementId, actionButton, shortcut) {
  var _shortcuts$get;

  const {
    shortcuts
  } = tree;

  if (!shortcuts.get(elementId)) {
    shortcuts.set(elementId, new Map());
  }

  (_shortcuts$get = shortcuts.get(elementId)) === null || _shortcuts$get === void 0 ? void 0 : _shortcuts$get.set(actionButton, shortcut);
}

function putFocusable(tree, incomingFocusable, parentId, currentFocus, shouldSuggestNewFocus) {
  const incomingFocusablePreviousState = getElement(tree, incomingFocusable.id); // Gets current element's state from FocusTree

  const currentFocusedNumberId = getIdFromAliasOrId(tree, currentFocus.id);
  const parentFocusable = getElement(tree, parentId);
  const {
    closestDelegatingAncestor,
    maybeDynasty
  } = getAncestorInfo(tree, incomingFocusable, incomingFocusablePreviousState, parentFocusable);
  const {
    delegateFocusOnLandmarkIdentityChanged,
    delegateFocusOnBindingLandmarkCase,
    delegateFocusIfFocusableAliasChanged,
    delegateFocusOnDelegatingAncestorHasNoEnabledChildren
  } = getPutFocusableDelegationFunctions(tree, incomingFocusable, incomingFocusablePreviousState, parentFocusable, closestDelegatingAncestor, maybeDynasty, currentFocusedNumberId, currentFocus, shouldSuggestNewFocus);
  let updatedIdAfterAliasMutation;

  switch (incomingFocusable.type) {
    case types_FocusTreeNodeType.LANDMARK:
      {
        updatedIdAfterAliasMutation = putNodeIntoTree(incomingFocusablePreviousState, tree, incomingFocusable, true, parentId, closestDelegatingAncestor, maybeDynasty);
        writeDOMData(incomingFocusable);
        const updatedFocusOnLandarkIdentityChange = delegateFocusOnLandmarkIdentityChanged();
        if (updatedFocusOnLandarkIdentityChange != null) return updatedFocusOnLandarkIdentityChange;
        const updatedFocusOnBindingLandmarkCase = delegateFocusOnBindingLandmarkCase();
        if (updatedFocusOnBindingLandmarkCase != null) return updatedFocusOnBindingLandmarkCase;
        break;
      }

    case types_FocusTreeNodeType.ITEM:
      {
        writeDOMData(incomingFocusable);
        updatedIdAfterAliasMutation = putNodeIntoTree(incomingFocusablePreviousState, tree, incomingFocusable, false, parentId, closestDelegatingAncestor, maybeDynasty);
        addItemToGridInTree(tree, incomingFocusable, parentFocusable);
        break;
      }
  }

  const redelegatedFocus = delegateFocusIfFocusableAliasChanged();
  if (redelegatedFocus) return redelegatedFocus;
  const delegatedFocus = delegateFocusOnDelegatingAncestorHasNoEnabledChildren();
  if (delegatedFocus) return delegatedFocus;
  const redelegatedFocusFromAliasChange = getRedelegatedFocusIfFocusedAndAliasChanged(shouldSuggestNewFocus, incomingFocusable, currentFocusedNumberId, updatedIdAfterAliasMutation);

  if (redelegatedFocusFromAliasChange != null) {
    return redelegatedFocusFromAliasChange;
  }
}

function putNonFocusable(tree, incomingNonFocusable, parentId, currentFocus, shouldSuggestNewFocus) {
  // @TODO maybe inline those calculations
  const currentFocusedNumberId = getIdFromAliasOrId(tree, currentFocus.id);
  const incomingFocusablePreviousState = getElement(tree, incomingNonFocusable.id); // Gets current element's state from FocusTree

  const parentFocusable = getElement(tree, parentId);
  const {
    closestDelegatingAncestor,
    maybeDynasty
  } = getAncestorInfo(tree, incomingNonFocusable, incomingFocusablePreviousState, parentFocusable);
  const isNonFocusableBecomingDisabled = incomingFocusablePreviousState != null && isFocusTreeNodeBecomingDisabled(incomingFocusablePreviousState, incomingNonFocusable); // Delegation logic:

  const isNonFocusableAncestorOfFocusedId = currentFocusedNumberId != null && isAncestorOf(tree, incomingNonFocusable.id, currentFocusedNumberId);
  putNodeIntoTree(incomingFocusablePreviousState, tree, incomingNonFocusable, false, parentId, closestDelegatingAncestor, maybeDynasty);
  const isNonFocusableGettingDisabledWithCurrentFocusedWithinIt = shouldSuggestNewFocus && isNonFocusableBecomingDisabled && isNonFocusableAncestorOfFocusedId && closestDelegatingAncestor != null; // Re-delegate focus of a landmark if:
  // Non Focusable (FocusTreeNode) is getting disabled and current focused Item is within it

  if (isNonFocusableGettingDisabledWithCurrentFocusedWithinIt) {
    // Reset deelegation from nearest ancestor
    return getDelegateCandidate(closestDelegatingAncestor);
  }
}

function putFocusTreeNode(tree, treeNode, parentId, focused, shouldSuggestNewFocus) {
  if (types_isFocusable(treeNode)) {
    return putFocusable(tree, treeNode, parentId, focused, shouldSuggestNewFocus);
  } else {
    return putNonFocusable(tree, treeNode, parentId, focused, shouldSuggestNewFocus);
  }
}
function removeShortcut(tree, elementId, actionButton) {
  const shortcuts = tree.shortcuts.get(elementId);

  if (!shortcuts) {
    return;
  }

  shortcuts.delete(actionButton);

  if (shortcuts.size === 0) {
    tree.shortcuts.delete(elementId);
  }
}
function removeFocusTreeNode(tree, focusableId, focused) {
  const focusable = tree.elements.get(focusableId);
  if (!focusable) return;
  const parentId = tree.parents.get(focusableId);
  const parentFocusable = parentId != null ? tree.elements.get(parentId) : undefined;

  if (types_isFocusable(focusable) && focusable.alias != null) {
    tree.aliases.delete(focusable.alias);
  }

  if (parentId != null) {
    // Update the children of the parent
    const siblings = tree.children.get(parentId);

    if (siblings != null) {
      siblings.delete(focusableId);
    } // Update parents


    tree.parents.delete(focusableId);
    removeItemFromGridInTree(tree, focusable, parentFocusable); // If the grid landmark is removed, remove it's corresponding grid matrix

    if ((focusable === null || focusable === void 0 ? void 0 : focusable.type) === types_FocusTreeNodeType.LANDMARK && focusable.isGrid) {
      tree.grids.delete(parentId);
    } // Update dynasties and memory stacks


    removeFromClosestDelegatingAncestors(tree, focusable); // Update binding landmark descendants

    if (focusable.type === types_FocusTreeNodeType.LANDMARK) {
      removeFromBindingListInTree(tree, focusable);
    }
  }

  tree.parents.delete(focusableId);
  tree.elements.delete(focusableId);
  tree.shortcuts.delete(focusableId);

  if (isBindingLandmark(focusable)) {
    const indexInStack = tree.bindingLandmarkStack.indexOf(focusable.id);

    if (indexInStack !== -1) {
      const wasTopOfStack = indexInStack === tree.bindingLandmarkStack.length - 1;
      tree.bindingLandmarkStack.splice(indexInStack);

      if (wasTopOfStack && tree.bindingLandmarkStack.length > 0) {
        const nextBindingLandmarkInStack = getElement(tree, tree.bindingLandmarkStack[tree.bindingLandmarkStack.length - 1]);
        const focusFromNextBindingLandmark = getDelegatedFocusForNextBindingLandmark(nextBindingLandmarkInStack);
        if (focusFromNextBindingLandmark != null) return focusFromNextBindingLandmark;
      }
    }
  }

  const redelegatedFocusFromClosestAncestor = getDelegatedFocusOnRemovalIfFocusWithin(tree, focusable, focused, parentId);
  if (redelegatedFocusFromClosestAncestor != null) return redelegatedFocusFromClosestAncestor;
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/navigate-grid.ts


function navigateInGrid(tree, focusedId, arrow, skip = 0) {
  const directParent = getDirectParent(tree, focusedId);

  if (directParent != null && directParent.type === types_FocusTreeNodeType.LANDMARK && directParent.isGrid) {
    // const gridMaxRows = Math.trunc(directParent.gridContainerHeight / directParent.gridItemHeight)
    const gridMaxColumns = Math.trunc(directParent.gridContainerWidth / directParent.gridItemWidth);
    const parentGrid = tree.grids.get(directParent.id);

    if (parentGrid != null) {
      const nextElementGridIndex = nextGridIndexItem(parentGrid, focusedId, gridMaxColumns, arrow, skip);

      if (nextElementGridIndex != null) {
        const nextElementFocusId = parentGrid[nextElementGridIndex];
        const nextElement = getElement(tree, nextElementFocusId);

        if (nextElement != null && isAvailableFocusable(nextElement)) {
          return nextElementFocusId;
        } else {
          // skipping unavailable element
          // recurse
          return navigateInGrid(tree, focusedId, arrow, skip + 1);
        }
      } else {
        // break out of the optimization
        return undefined;
      }
    }
  }

  return undefined;
}
function nextGridIndexItem(parentGrid, focusedId, // gridMaxRows: number,
gridMaxColumns, arrow, skip) {
  const currentElementGridIndex = parentGrid.indexOf(focusedId);
  const currentElementGridColumn = currentElementGridIndex % gridMaxColumns; // const currentElementGridRow = Math.trunc(currentElementGridIndex / gridMaxColumns)

  switch (arrow) {
    case Arrows.DOWN:
      {
        const nextIndex = currentElementGridIndex + gridMaxColumns * (skip + 1);

        if (nextIndex > parentGrid.length - 1) {
          return undefined;
        }

        return nextIndex;
      }

    case Arrows.UP:
      {
        const nextIndex = currentElementGridIndex - gridMaxColumns * (skip + 1);

        if (nextIndex < 0) {
          return undefined;
        }

        return nextIndex;
      }

    case Arrows.RIGHT:
      {
        const nextIndex = currentElementGridIndex + 1 + skip;

        if (nextIndex % gridMaxColumns < currentElementGridColumn) {
          return undefined;
        }

        return nextIndex;
      }

    case Arrows.LEFT:
      {
        const nextIndex = currentElementGridIndex - 1 - skip;

        if (nextIndex < 0 || nextIndex % gridMaxColumns > currentElementGridColumn) {
          return undefined;
        }

        return nextIndex;
      }
  }
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/logit.ts
/**
 * logit.
 *
 * 	- Non-linear, continuous, and differentiable logistic function. Inverse of sigmoid
 *
 * https://en.wikipedia.org/wiki/Logit
 *
 * @param number z
 */
function logit(z) {
  return Math.log(z / (1 - z));
}
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/weights.ts


const weights = {
  matchScrollableDirectionWeight: 0.000001,
  noWeight: 1,
  mainAxisProjectionOverlapWeightMax: 10000,
  crossAxisProjectionOverlapWeightMax: 7500
};
const getScrollableAncestorMultiplier = (tree, scrollableAncestorId, currentCandidateId, navigationAxis) => {
  if (scrollableAncestorId == null) {
    return weights.noWeight;
  }

  const scrollableAncestor = tree.elements.get(scrollableAncestorId);

  if (scrollableAncestor == null || scrollableAncestor.type !== types_FocusTreeNodeType.LANDMARK) {
    return weights.noWeight;
  }

  if (hasAnyAncestorWithId(tree, currentCandidateId, scrollableAncestorId) && scrollableAncestor.scrollAxis == navigationAxis) {
    return weights.matchScrollableDirectionWeight;
  }

  return weights.noWeight;
};
;// CONCATENATED MODULE: ./packages/navigation-focus-tree/src/navigate/navigate.ts









const SEVENTY_FIVE_DEGREES_IN_RADIANS = 5 * (Math.PI / 12); // TODO: Find closest landmark instead of parent to fully implement this function

function navigateToAdjacentElement(focusTree, focusedId, reverse = false) {
  const parentId = focusTree.parents.get(focusedId);

  if (parentId == null) {
    return null;
  }

  const parent = focusTree.elements.get(parentId);
  const focusedElement = focusTree.elements.get(focusedId);

  if (parent == null || !isFocusable(parent) || parent.ref == null || focusedElement == null || // TODO: should we do this?
  !isFocusable(focusedElement)) {
    return null;
  }

  const htmlElements = parent.ref.querySelectorAll(`[${DATA_FOCUSABLE_ID}]`);

  for (let i = 0; i < htmlElements.length; i++) {
    const element = htmlElements[i];

    if (element === focusedElement.ref) {
      var _htmlElements$nextInd;

      let nextIndex = i + (reverse ? -1 : 1);

      if (nextIndex < 0) {
        nextIndex = htmlElements.length - 1;
      } else if (nextIndex >= htmlElements.length) {
        nextIndex = 0;
      }

      const adjacentElementId = (_htmlElements$nextInd = htmlElements[nextIndex]) === null || _htmlElements$nextInd === void 0 ? void 0 : _htmlElements$nextInd.getAttribute(DATA_FOCUSABLE_ID);

      if (adjacentElementId == null) {
        return null;
      }

      const adjacentElement = focusTree.elements.get(parseInt(adjacentElementId));

      if (adjacentElement == null) {
        return null;
      }

      if (isAnyAncestorDisabled(focusTree, adjacentElement.id)) {
        continue;
      }

      return adjacentElement.id;
    }
  }

  return null;
}
function legacyNavigateToAdjacentElement(focusTree, focusedId, reverse = false) {
  if (focusedId == null) return undefined;
  const htmlElements = document.body.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}]`);
  const currentDomElement = document.body.querySelector(`[${types_DATA_FOCUSABLE_ID}='${focusedId}']`);

  if (currentDomElement == null) {
    const focusedId = getFocusedIdFromDomElement(htmlElements[0]);

    if (focusedId == null) {
      return undefined;
    }

    if (treeQueries_isAnyAncestorDisabled(focusTree, focusedId)) {
      return undefined;
    }

    return focusedId;
  }

  const currentDomElementIndex = getCurrentDomElementIndex(currentDomElement, htmlElements);

  if (currentDomElementIndex == null) {
    return getFocusedIdFromDomElement(htmlElements[0]);
  }

  let startingIndex = reverse ? currentDomElementIndex - 1 : currentDomElementIndex + 1;

  while (currentDomElementIndex !== startingIndex) {
    if (startingIndex < 0) {
      startingIndex = htmlElements.length - 1;
    }

    if (startingIndex > htmlElements.length - 1) {
      startingIndex = 0;
    }

    const focusedId = getFocusedIdFromDomElement(htmlElements[startingIndex]);

    if (focusedId != null) {
      const element = focusTree.elements.get(focusedId);

      if (element != null && !treeQueries_isAnyAncestorDisabled(focusTree, focusedId)) {
        if (element.type !== types_FocusTreeNodeType.LANDMARK && element.disabled !== true && element.hidden !== true) {
          return focusedId;
        }
      }
    }

    if (reverse) {
      startingIndex--;
    } else {
      startingIndex++;
    }
  }

  return;
}
/**
 * Ideally is supposed to be a minimizing score function where distance can infinitely increase your score
 * (which makes you a worse candidate) and angle should exponentially increase your score the higher it is
 * to favor smaller angles more in relation to closeness + bad angle.
 *
 * Projection overlap (that is, if the target box is facing the current focusable from the side where the
 * motion is going to) also is taken into account. If there is overlap, then the score is improved to
 * account for the intuitive perception that overlapping targets should be preferred.
 *
 * @param tree
 * @param focusedId
 * @param arrow
 * @returns
 */

const navigate_navigateToDirection = (tree, focusedId, arrow) => {
  var _startingElement$ref;

  if (focusedId == null) {
    var _getTopLeftElementId;

    return (_getTopLeftElementId = getTopLeftElementId(tree)) !== null && _getTopLeftElementId !== void 0 ? _getTopLeftElementId : ROOT_NODE_ID;
  }

  const startingElement = tree.elements.get(focusedId); // If starting element isn't a focusable reset focus, this shouldn't happen

  if (startingElement == null || !types_isFocusable(startingElement)) {
    var _getTopLeftElementId2;

    if (false) {}

    return (_getTopLeftElementId2 = getTopLeftElementId(tree)) !== null && _getTopLeftElementId2 !== void 0 ? _getTopLeftElementId2 : ROOT_NODE_ID;
  }

  const startingElementPosition = startingElement === null || startingElement === void 0 ? void 0 : (_startingElement$ref = startingElement.ref) === null || _startingElement$ref === void 0 ? void 0 : _startingElement$ref.getBoundingClientRect();

  if (startingElementPosition == null) {
    var _getTopLeftElementId3;

    return (_getTopLeftElementId3 = getTopLeftElementId(tree)) !== null && _getTopLeftElementId3 !== void 0 ? _getTopLeftElementId3 : focusedId;
  }

  const startingElementCenter = getTheCenterOfPostion(startingElementPosition);
  let bestCandidateId = focusedId;
  let bestCandidateScore = Infinity;
  const mainAxis = arrowToAxis[arrow];
  const navigationAxis = arrow === Arrows.LEFT || arrow === Arrows.RIGHT ? ScrollAxis.HORIZONTAL : ScrollAxis.VERTICAL;
  const crossAxis = perpendicularAxis[mainAxis];
  const bindingAncestorId = getBindingAncestorId(tree, focusedId);
  const scrollableAncestorId = getScrollableAncestorId(tree, focusedId);

  if (tree.lastDirectionChange == null || !isSameAxis(tree.lastDirectionChange[0], arrow) && focusedId != null) {
    tree.lastDirectionChange = [arrow, focusedId];
  } // TODO: Check if navigating within a grid (not into or out of) and shortcut out of looping through candidates by checking grid position co-ordinates and returning the elment that corresponds to that co-ordinate
  // NOTE: Landmark with grid flag elements should be the same size for this to work, otherwise no one should turn on the flag.
  // Grid Optimization
  // TODO: retrieve the parent's grid matrix, locate the curent element
  // then jump to the next element depending on direction of movement
  // if no element in that direction continue normal navigation
  // if there's element, return it as best candidate early


  const gridBestCandidate = navigateInGrid(tree, focusedId, arrow);
  if (gridBestCandidate != null) return gridBestCandidate;

  for (const [id, element] of tree.elements) {
    var _element$ref, _getBoundingClientRec;

    if (id === focusedId) {
      continue;
    } // We do not want non focusables


    if (!isAvailableFocusable(element)) {
      continue;
    }

    if (element.type === types_FocusTreeNodeType.LANDMARK && !types_isDelegatingLandmark(element)) {
      continue;
    }

    if (element.type === types_FocusTreeNodeType.LANDMARK && isAncestorOf(tree, id, focusedId)) {
      continue;
    }

    if (treeQueries_isAnyAncestorDisabled(tree, id)) {
      continue;
    }

    if (doesAnyNonSharedAncestorDelegateFocus(tree, id, focusedId)) {
      continue;
    } // If the delegating landmark doesn't have a valid target within it, skip it.


    if (element.type === types_FocusTreeNodeType.LANDMARK && types_isDelegatingLandmark(element) && !containerHasEnabledItems(tree, element)) {
      continue;
    }

    const currentElementPosition = (_element$ref = element.ref) === null || _element$ref === void 0 ? void 0 : _element$ref.getBoundingClientRect();

    if (currentElementPosition == null) {
      continue;
    }

    const positionOfLastDirectionChange = (_getBoundingClientRec = getBoundingClientRectById(tree, tree.lastDirectionChange[1])) !== null && _getBoundingClientRec !== void 0 ? _getBoundingClientRec : getBoundingClientRectById(tree, focusedId);

    if (positionOfLastDirectionChange == null) {
      continue;
    }

    const centerOfLastDirectionChange = getTheCenterOfPostion(positionOfLastDirectionChange);
    const currentElementCenter = getTheCenterOfPostion(currentElementPosition);
    const differenceMainAxisCenters = (startingElementCenter[mainAxis] - currentElementCenter[mainAxis]) * mapArrowToDirection[arrow];
    const differenceMainAxisFacingEdges = (getEdgeCoordinate(startingElementPosition, arrow) - getEdgeCoordinate(currentElementPosition, mapArrowToOppositeArrow[arrow])) * mapArrowToDirection[arrow];
    const differenceMainAxisEndEdges = (getEdgeCoordinate(startingElementPosition, arrow) - getEdgeCoordinate(currentElementPosition, arrow)) * mapArrowToDirection[arrow];
    const virtualDistanceInMainAxisCoordinate = differenceMainAxisFacingEdges < 0 && differenceMainAxisCenters > 0 ? 0 : differenceMainAxisFacingEdges;

    if (virtualDistanceInMainAxisCoordinate < 0) {
      continue;
    }

    const differenceCrossAxisCentersLastDirectionChange = centerOfLastDirectionChange[crossAxis] - currentElementCenter[crossAxis];
    const differenceCrossAxisCentersFocusedElement = startingElementCenter[crossAxis] - currentElementCenter[crossAxis];

    if (bindingAncestorId != null && !hasAnyAncestorWithId(tree, id, bindingAncestorId)) {
      continue;
    }

    const distanceMainAxisEdges = Math.max(virtualDistanceInMainAxisCoordinate, 1);
    const distanceMainAxisCenter = Math.abs(differenceMainAxisCenters); // unsignedTangentEdge is used as an exponential penalty depending on how wide the angle is for
    // navigating to the candidate element from current element, the idea is if a candidate has 0 angle
    // it should be way more preferred than a candidate with 10

    const unsignedTangentLastDirectionChangeEdge = Math.abs(differenceCrossAxisCentersLastDirectionChange / (virtualDistanceInMainAxisCoordinate === 0 ? 1 : virtualDistanceInMainAxisCoordinate));
    const radianAngleLastDirectionChangeEdge = Math.atan(unsignedTangentLastDirectionChangeEdge); // Projection overlap: it's how much of the candidate box overlaps when you draw a projection of the
    // current box along the direction of motion, it's a value from 0 to 1 which is later inverted
    // for calculation purposes
    // In the end it's passed through a logit function
    // You can read about the logit function on Wikipedia https://en.wikipedia.org/wiki/Logit,
    // which exponentially adds a penalty depending on how much overlap you have, with total overlap adding
    // 0 penalty and no overlap capped at 10,000 penalty, in the end the magic number 10,000 doesn't matter so much
    // since in the situation where all candidates have 0 overlap, they all get the same penalty so it self-equalizes
    // and the number 10,000 was used because it's guaranteed to be above distance + unsignedTangent is supposed
    // to be in most cases

    const projectionOverlap = getProjectionOverlap(startingElementPosition, currentElementPosition, mainAxis);
    const invertedProjectionOverlap = 1 - projectionOverlap;
    const lowOrNoProjectionOverlapPenalty = Math.min(logit(invertedProjectionOverlap / 2 + 0.5), weights.mainAxisProjectionOverlapWeightMax);
    const crossAxisProjectionOverlap = getProjectionOverlap(startingElementPosition, currentElementPosition, crossAxis);
    const crossAxisProjectionOverlapPenalty = Math.min(logit(crossAxisProjectionOverlap / 2 + 0.5), weights.crossAxisProjectionOverlapWeightMax); // We need the radian penalty to matter very little if the cross axis overlap is less than half, but matter exponentially over half

    const crossAxisRadianPenalty = SEVENTY_FIVE_DEGREES_IN_RADIANS * crossAxisProjectionOverlap ** 3; // WeightedTangent is unsignedTangent but with ties to overlap, so we apply a heuristic so that if a candidate has total overlap
    // then we treat it as if it's at angle 0, because we don't want to delve into the complications of
    // calculating the precise closest points between the two candidates to calculate a proper angle.

    const weightedTangentLastDirectionChange = unsignedTangentLastDirectionChangeEdge * invertedProjectionOverlap;
    const weightedRadianAngleLastDirectionChange = (radianAngleLastDirectionChangeEdge + crossAxisRadianPenalty) * invertedProjectionOverlap; // We also need the angle as measured from the center of both components, instead of the edge,
    // to cover the special case when the target box is very close along main axis (distance ~1)
    // but to the side, without cross axis overlap, and it is also very large. In that case,
    // the angle as measured from the edge will be very, very wide (>89 degrees) but we don't
    // want to cut it out of the calculation if the center is not also at a very wide angle,
    // because a big enough box should intuitively get focus even if the edge angle is wide.

    const unsignedTangentCenterFocusedElement = Math.abs(differenceCrossAxisCentersFocusedElement / distanceMainAxisCenter);
    const unsignedTangentEndEdgesFocusedElement = Math.abs(differenceCrossAxisCentersFocusedElement / (differenceMainAxisEndEdges === 0 ? 1 : differenceMainAxisEndEdges));
    const radianAngleCenterFocusedElement = Math.atan(unsignedTangentCenterFocusedElement);
    const weightedRadianAngleCenterFocusedElement = radianAngleCenterFocusedElement + crossAxisRadianPenalty;
    const radianAngleEndEdgesFocusedElement = Math.atan(unsignedTangentEndEdgesFocusedElement); // Checks if all of the following is true to eliminate the candidate from consideration:
    // - the angle between the center of the two end edges of the boxes (nonfacing edges) along main axis
    // are more than 75 degrees OR the distance between them is negative (so target end edge is behind starting element end edge)
    // - they have no projection overlap

    const edgeToEdgeCutOff = (differenceMainAxisEndEdges < 0 || radianAngleEndEdgesFocusedElement >= SEVENTY_FIVE_DEGREES_IN_RADIANS) && projectionOverlap === 0; // console.log(focusedId, {
    // 	id,
    // 	projectionOverlap,
    // 	differenceMainAxisEndEdges,
    // 	unsignedTangentEndEdgesFocusedElement,
    // 	radianAngleEndEdgesFocusedElement,
    // 	degrees: (radianAngleEndEdgesFocusedElement * 180) / Math.PI,
    // 	edgeToEdgeCutOff,
    // 	crossAxisProjectionOverlap,
    // 	crossAxisProjectionOverlapPenalty,
    // 	crossAxisRadianPenalty,
    // 	weightedTangentLastDirectionChange,
    // 	weightedRadianAngleLastDirectionChange,
    // 	weightedRadianAngleCenterFocusedElement,
    // 	SEVENTY_FIVE_DEGREES_IN_RADIANS,
    // })
    // If the angle from edge to edge, accounting for cross axis distance of last
    // direction change center is still higher than 75 degrees
    // after the projection overlap buff is applied, then we want to skip this element.
    // The angle is just too wide and it's not an intuitive target.
    //
    // The only exception is if the angle from the center of current focused to the
    // center of the target element is less than 75 degrees. The reason is that for this
    // angle to be shallow while the other angle is very wide, it means that the
    // target box is very large, large enough for its center to be far away enough
    // for the angle to be shallower than 75 degrees. In that case, we intuitively
    // expect focus to still be able to flow there.
    //
    // ## Weighted angles
    // We also increase the angle up in relation cross axis overlap, if the target overlaps 100%
    // In cross axis the angle will be increased with 75 degrees, if there's no overlap there's no angle increase
    // This is to avoid navigating to items that are completely adjacent to us unless there's also a main axis overlap
    // which would mean the target and the current element are overlapping,
    // in which case the main axis overlap reduces the angle with a multiplier from 0 to 1
    // while the cross axis increases the angle with an additional angle between 0 and 75 degrees

    if (weightedRadianAngleLastDirectionChange >= SEVENTY_FIVE_DEGREES_IN_RADIANS && (weightedRadianAngleCenterFocusedElement >= SEVENTY_FIVE_DEGREES_IN_RADIANS || edgeToEdgeCutOff)) {
      continue;
    }

    const scrollableAncestorMultiplier = getScrollableAncestorMultiplier(tree, scrollableAncestorId, id, navigationAxis); // The score is basically a bunch of penalties you get depending on distnace, unsignedTangent, projection overlap
    // and whether or not you're inside the same scrollable parent

    const currentCandidateScore = (distanceMainAxisEdges + weightedTangentLastDirectionChange + lowOrNoProjectionOverlapPenalty + crossAxisProjectionOverlapPenalty) * scrollableAncestorMultiplier;

    if (bestCandidateScore > currentCandidateScore) {
      bestCandidateScore = currentCandidateScore;
      bestCandidateId = id;
    }
  }

  const bestCandidate = tree.elements.get(bestCandidateId);

  if (types_isDelegatingLandmark(bestCandidate)) {
    const delegatedFocus = bestCandidate.getDelegatedFocus();

    if (delegatedFocus !== react_facet_src.NO_VALUE && delegatedFocus != null) {
      // Make sure the delegated id exists in the focus tree before trying to navigate there.
      // A landmark can delegate for example to an alias that is not yet present in the tree,
      // similar to a deep link via URL.
      const delegatedId = getIdFromAliasOrId(tree, delegatedFocus.id);

      if (delegatedId != null) {
        return delegatedId;
      }
    }
  }

  return bestCandidateId;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/setupInput/throttleByName.ts

const throttleByName_FIRST_THROTTLE_DELAY = 400;
const throttleByName_MEDIUM_THROTTLE_RATE = 100;
const throttleByName_FAST_THROTTLE_RATE = 40;
/**
 * How many presses we should have triggered before going to fast speed
 */

const throttleByName_FAST_REPETITION_COUNT_WAIT = 16;
function constructThrottleByName() {
  const timestamps = throttleByName_initMetrics();
  const pressCounts = throttleByName_initMetrics();
  return (buttonType, pressed, gamepadIndex) => {
    if (!pressed) {
      timestamps[gamepadIndex][buttonType] = 0;
      pressCounts[gamepadIndex][buttonType] = 0;
    } else {
      const now = Date.now();
      const timestamp = timestamps[gamepadIndex][buttonType] || 0;
      const pressCount = pressCounts[gamepadIndex][buttonType] || 0;
      const delta = now - timestamp;

      if (pressCount === 0) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 1;
        return buttonType;
      }

      if (pressCount === 1 && delta > throttleByName_FIRST_THROTTLE_DELAY) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = 2;
        return buttonType;
      }

      if (pressCount > 1 && pressCount < throttleByName_FAST_REPETITION_COUNT_WAIT && delta > throttleByName_MEDIUM_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return buttonType;
      }

      if (pressCount > throttleByName_FAST_REPETITION_COUNT_WAIT - 1 && delta > throttleByName_FAST_THROTTLE_RATE) {
        timestamps[gamepadIndex][buttonType] = now;
        pressCounts[gamepadIndex][buttonType] = pressCount + 1;
        return buttonType;
      }
    }
  };
}

const throttleByName_initMetrics = () => {
  const metrics = {
    0: throttleByName_initButtons(),
    1: throttleByName_initButtons(),
    2: throttleByName_initButtons(),
    3: throttleByName_initButtons()
  };
  return metrics;
};

const throttleByName_initButtons = () => {
  return {
    [types_ButtonType.A]: 0,
    [types_ButtonType.B]: 0,
    [types_ButtonType.X]: 0,
    [types_ButtonType.Y]: 0,
    [types_ButtonType.START]: 0,
    [types_ButtonType.SELECT]: 0,
    [types_ButtonType.XBOX]: 0,
    [types_ButtonType.RIGHT_TRIGGER]: 0,
    [types_ButtonType.LEFT_TRIGGER]: 0,
    [types_ButtonType.LEFT_BUMPER]: 0,
    [types_ButtonType.RIGHT_BUMPER]: 0,
    [types_ButtonType.L3]: 0,
    [types_ButtonType.R3]: 0,
    [types_ButtonType.LEFT]: 0,
    [types_ButtonType.RIGHT]: 0,
    [types_ButtonType.UP]: 0,
    [types_ButtonType.DOWN]: 0,
    [types_ButtonType.NEXT]: 0,
    [types_ButtonType.PREV]: 0,
    [types_ButtonType.LEFT_ANALOG_LEFT]: 0,
    [types_ButtonType.LEFT_ANALOG_RIGHT]: 0,
    [types_ButtonType.LEFT_ANALOG_UP]: 0,
    [types_ButtonType.LEFT_ANALOG_DOWN]: 0,
    [types_ButtonType.RIGHT_ANALOG_LEFT]: 0,
    [types_ButtonType.RIGHT_ANALOG_RIGHT]: 0,
    [types_ButtonType.RIGHT_ANALOG_UP]: 0,
    [types_ButtonType.RIGHT_ANALOG_DOWN]: 0,
    [types_ButtonType.LEFT_HORIZONTAL_AXIS]: 0,
    [types_ButtonType.LEFT_VERTICAL_AXIS]: 0,
    [types_ButtonType.RIGHT_HORIZONTAL_AXIS]: 0,
    [types_ButtonType.RIGHT_VERTICAL_AXIS]: 0,
    [types_ButtonType.PSEUDO_BUTTON_1]: 0,
    [types_ButtonType.PSEUDO_BUTTON_2]: 0,
    [types_ButtonType.PSEUDO_BUTTON_3]: 0,
    [types_ButtonType.PSEUDO_BUTTON_4]: 0,
    [types_ButtonType.PSEUDO_BUTTON_5]: 0,
    [types_ButtonType.PSEUDO_BUTTON_6]: 0,
    [types_ButtonType.PSEUDO_BUTTON_7]: 0,
    [types_ButtonType.PSEUDO_BUTTON_8]: 0,
    [types_ButtonType.PSEUDO_BUTTON_9]: 0,
    [types_ButtonType.PSEUDO_BUTTON_10]: 0
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/setupInput/setupGamepads.ts




const setupGamepads_ACTION_BUTTONS_INDEX = types_ACTION_BUTTONS.map(name => types_BUTTON_MAP.indexOf(name));
const setupGamepads_DIRECTIONAL_BUTTONS_INDEX = types_DIRECTIONAL_BUTTONS.map(name => types_BUTTON_MAP.indexOf(name));
/**
 * Setup pooling for the gamepad button states.
 *
 * This code is extremely performance sensitive, so be mindful of any changes and measure the performance
 * on a performance sensitive device (ex: Xbox One)
 */

function setupGamepads_setupGamepads(onPress, onWiggle, controllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons) {
  const throttleByName = constructThrottleByName();
  const toggleByName = constructToggleByName();
  const mappedActionButtonsIndex = types_ACTION_BUTTONS.map(name => types_BUTTON_MAP.indexOf(setupGamepads_mapButton(name, swapABButtons, swapXYButtons)));
  const checkGamepad = constructCheckGamepad(toggleByName, throttleByName, mappedActionButtonsIndex, onWiggle, onPress);
  return constructTick(acceptInputFromAllControllers, checkGamepad, controllerId);
}
/**
 * Tick that runs every frame and can either be
 * - Accepting input from all controllers
 * - Accept input from one specific controller
 */

const constructTick = (acceptInputFromAllControllers, checkGamepad, controllerId) => {
  let handler;

  const tick = () => {
    try {
      const gamepads = getGamepads();

      if (acceptInputFromAllControllers) {
        const first = gamepads[0];
        const second = gamepads[1];
        const third = gamepads[2];
        const fourth = gamepads[3];
        if (first != null) checkGamepad(first);
        if (second != null) checkGamepad(second);
        if (third != null) checkGamepad(third);
        if (fourth != null) checkGamepad(fourth);
      } else {
        // We use a regular for loop here instead of a for of loop
        // since it's measurably faster. More context here:
        // https://github.com/Mojang/minecraft-ui/pull/2155
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];

          if (gamepad != null && controllerId === gamepad.id) {
            checkGamepad(gamepad);
            break;
          }
        }
      }

      handler = requestAnimationFrame(tick);
    } catch (e) {
      console.log('Error handling gamepad input', e);
    }
  };

  handler = requestAnimationFrame(tick);
  return () => {
    cancelAnimationFrame(handler);
  };
};
/**
 * Check an individual gamepad for its presses states and axes values and fire the
 * throttled or toggles callbacks
 */


const constructCheckGamepad = (toggleByName, throttleByName, mappedActionButtonsIndex, onWiggle, onPress) => gamepad => {
  const buttons = gamepad.buttons;
  const gamepadIndex = gamepad.index;

  for (let index = 0; index < setupGamepads_ACTION_BUTTONS_INDEX.length; index++) {
    const name = toggleByName(types_BUTTON_MAP[mappedActionButtonsIndex[index]], buttons[setupGamepads_ACTION_BUTTONS_INDEX[index]].pressed, gamepadIndex);

    if (name != null) {
      onPress(name, FocusOrigin.FocusInput);
    }
  }

  for (let index = 0; index < setupGamepads_DIRECTIONAL_BUTTONS_INDEX.length; index++) {
    const buttonIndex = setupGamepads_DIRECTIONAL_BUTTONS_INDEX[index];
    const name = throttleByName(types_BUTTON_MAP[buttonIndex], buttons[buttonIndex].pressed, gamepadIndex);

    if (name != null) {
      onPress(name, FocusOrigin.FocusInput);
    }
  }

  const axes = [];
  const length = gamepad.axes.length;

  for (let index = 0; index < length; index++) {
    const value = gamepad.axes[index];

    if (value > -0.16 && value < 0.16) {
      axes.push(0);
      continue;
    }

    const map = types_AXIS_MAP[index];
    const name1 = throttleByName(map[0], value < -setupGamepads_AXIS_TRIGGER_LIMIT, gamepadIndex);

    if (name1 != null) {
      onPress(name1, FocusOrigin.FocusInput);
    }

    const name2 = throttleByName(map[1], value > setupGamepads_AXIS_TRIGGER_LIMIT, gamepadIndex);

    if (name2 != null) {
      onPress(name2, FocusOrigin.FocusInput);
    }

    axes.push(value);
  }

  onWiggle(axes);
};

const setupGamepads_AXIS_TRIGGER_LIMIT = 0.5;

const constructToggleByName = () => {
  const pressStates = {
    0: {},
    1: {},
    2: {},
    3: {}
  };
  return (name, pressed, index) => {
    const wasPressed = pressStates[index][name];

    if (pressed === wasPressed) {
      return;
    }

    if (pressed) {
      pressStates[index][name] = true;

      if (wasPressed != null) {
        return name;
      }
    } else {
      pressStates[index][name] = false;
    }
  };
};

const setupGamepads_mapButton = (button, swapABButtons, swapXYButtons) => {
  if (button === types_ButtonType.Y && swapXYButtons) return types_ButtonType.X;
  if (button === types_ButtonType.X && swapXYButtons) return types_ButtonType.Y;
  if (button === types_ButtonType.A && swapABButtons) return types_ButtonType.B;
  if (button === types_ButtonType.B && swapABButtons) return types_ButtonType.A;
  return button;
};
;// CONCATENATED MODULE: ./packages/react-gamepad-driver-visual/src/driver.ts



const src_driver_driver = (onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepad) => {
  const disposeGamepads = setupGamepads_setupGamepads(onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons);

  const keyboardEventHandler = event => {
    var _keyToGamepad$current;

    // If an element in the DOM is focused, stop navigation from the keyboard input
    if (document.activeElement !== document.body || keyToGamepad == null) return; // console.log('Driver:Key: ', event)
    // Gameface does not support the new standard `key`, so we read the `keyCode` instead

    const buttonType = (_keyToGamepad$current = keyToGamepad.current) === null || _keyToGamepad$current === void 0 ? void 0 : _keyToGamepad$current[event.keyCode];

    if (buttonType != null) {
      // console.log('Driver:buttonType', buttonType)
      event.preventDefault();
      onPress(buttonType, FocusOrigin.FocusInput); // Don't fall through to the explicit handling of tab key below.
      // If the tab key is mapped to a gamepad button it will clash.

      return;
    } // Support for using the "tab" key to navigate the focus.
    // Key is being fired as a string on Jest.


    if (event.keyCode === types_KeyboardKey.TAB) {
      event.preventDefault();
      onPress(event.shiftKey ? types_ButtonType.PREV : types_ButtonType.NEXT, FocusOrigin.FocusInput);
      return;
    }
  }; // NOTE: this one could benefit from calling the requestFocusIdUpdate, since it should reset the navigation direction information


  const mouseEventHandler = event => {
    const button = mapMouseButtonToButtonType[event.button];

    if (button != null) {
      onPress(button, FocusOrigin.PointerInput);
    }
  };

  document.addEventListener('keydown', keyboardEventHandler);
   true && document.addEventListener('mousedown', mouseEventHandler);
  return () => {
    document.removeEventListener('keydown', keyboardEventHandler);
    disposeGamepads();
     true && document.removeEventListener('mousedown', mouseEventHandler);
  };
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/setupScrollIntoView.tsx


/**
 * Setups the scrollIntoView function
 * It keeps a local state of previous running animations so that it cancel between scroll requests
 */

function setupScrollIntoView_setupScrollIntoView() {
  const runningAnimations = new Map();
  /**
   * Implementation that takes a list with a focusable and its ancestors and triggers animations
   * It supports:
   * - multiple levels of nesting (column inside a row, for example)
   * - animations to continue when switching between different sections of the focus tree
   *
   * Returns a cleanup function that can be used to stop all previously running animations
   */

  return (focusable, ancestors, disabledTransition) => {
    ancestors.forEach(containerNode => {
      var _ref, _focusable$scrollSpee, _container$scrollInto, _focusable$scrollOffs;

      const container = containerNode;

      if (container.type === types_FocusTreeNodeType.ROOT) {
        return;
      }

      if (container.scrollAxis == null || focusable.disableScrollIntoView === true) {
        return;
      }

      if (focusable.ref == null) {
        if (false) {}

        return;
      }

      if (container.ref == null) {
        if (false) {}

        return;
      }

      const existingStop = runningAnimations.get(container.id);

      if (existingStop) {
        existingStop();
        runningAnimations.delete(container.id);
      }

      const {
        scrollIntoView,
        stopScrolling
      } = createScrollingManager({
        disabledTransition,
        speedFactor: (_ref = (_focusable$scrollSpee = focusable.scrollSpeedFactor) !== null && _focusable$scrollSpee !== void 0 ? _focusable$scrollSpee : container.scrollIntoViewSpeedFactor) !== null && _ref !== void 0 ? _ref : 1,
        align: (focusable.scrollAlign ? focusable.scrollAlign : container.scrollIntoViewAlign) || 'center',
        scrollOffset: ((_container$scrollInto = container.scrollIntoViewOffset) !== null && _container$scrollInto !== void 0 ? _container$scrollInto : 0) + ((_focusable$scrollOffs = focusable.scrollOffset) !== null && _focusable$scrollOffs !== void 0 ? _focusable$scrollOffs : 0),
        axis: container.scrollAxis === ScrollAxis.HORIZONTAL ? 'x' : 'y'
      });
      scrollIntoView(container.ref, focusable.ref);
      runningAnimations.set(container.id, stopScrolling);
    });
    /**
     * Cleanup function that stops all running animations
     */

    return () => {
      for (const stopScrolling of runningAnimations.values()) {
        stopScrolling();
      }

      runningAnimations.clear();
    };
  };
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/temporaryHelpers.ts


const temporaryHelpers_scrollIntoView = setupScrollIntoView_setupScrollIntoView();
const scrollIntoFocused = (focusTree, focusedId, disabledTransition) => {
  if (focusedId == null) return;
  const focusedNodeId = getIdFromAliasOrId(focusTree, focusedId);
  if (focusedNodeId == null) return;
  const focusable = focusTree.elements.get(focusedNodeId);
  if (!focusable || focusable.type == types_FocusTreeNodeType.ROOT || !types_isFocusable(focusable)) return;
  const ancestors = getFocusableAncestorNodes(focusTree, focusedNodeId);
  return temporaryHelpers_scrollIntoView(focusable, ancestors, disabledTransition);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/focusTree/localQueries.ts


function localQueries_findInputLegends(focusTree, focusedId) {
  const result = {};
  const elementId = getIdFromAliasOrId(focusTree, focusedId);

  if (elementId == null) {
    return result;
  }

  for (const actionButton of types_INPUT_LEGEND_BUTTONS) {
    var _getShortcut;

    const inputLegend = (_getShortcut = treeQueries_getShortcut(focusTree, elementId, actionButton)) === null || _getShortcut === void 0 ? void 0 : _getShortcut.inputLegend;

    if (inputLegend != null) {
      result[actionButton] = inputLegend;
    }
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/isNavigationDisabled.tsx


const isNavigationDisabledContext = (0,react.createContext)([(0,react_facet_src.createStaticFacet)(true), () => {}]);
const useDisableNavigation = () => useContext(isNavigationDisabledContext);
const ToggleNavigationProvider = ({
  isNavigationDisabledFacet,
  setIsNavigationDisabled,
  children
}) => {
  const value = (0,react.useMemo)(() => [isNavigationDisabledFacet, setIsNavigationDisabled], [isNavigationDisabledFacet, setIsNavigationDisabled]);
  return /*#__PURE__*/react.createElement(isNavigationDisabledContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/hooks/useGetFocusedId.tsx




const focusedIdContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)(ROOT_NODE_ID));
const FocusedIdProvider = focusedIdContext.Provider;
/**
 * Returns currently focusedId (if an element has an alias, that will be returned always)
 */

const useGetFocusedId_useGetFocusedId = () => {
  const focusedIdFacet = useContext(focusedIdContext);
  const focusTreeAPIRef = useContext(FocusTreeAPIContext);
  return useFacetCallback(focusedId => () => {
    const element = focusTreeAPIRef.current.getElement(focusedId);
    if (element == null) return undefined;
    /**
     * The focusedId stored in the focusedIdContext is not guaranteed to hold the alias
     * so, we need to make sure we make it available if one is defined
     *
     * TODO: make sure that focusedIdContext holds an alias if one is defined
     * This worked is tracked in UserStory 1132048
     */

    if (isFocusable(element)) {
      var _element$alias;

      return (_element$alias = element.alias) !== null && _element$alias !== void 0 ? _element$alias : element.id;
    }

    return element.id;
  }, [focusTreeAPIRef], [focusedIdFacet], undefined);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/GamepadProvider/GamepadProvider.tsx


function GamepadProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function GamepadProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GamepadProvider_ownKeys(Object(source), true).forEach(function (key) { GamepadProvider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GamepadProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GamepadProvider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











const ANALOG_SCROLL_MAX_SPEED = 20;
const INITIAL_PATH = [ROOT_NODE_ID];

/**
 * Provider that enables the gamepad focus capability around a React component tree.
 */
function GamepadProvider_GamepadProvider({
  children,
  driver = src_driver_driver,
  initialFocusTree,
  initialFocusedId,
  notifyFocusRequest,
  onFocusedIdChange,
  onFocusedIdChangeFail,
  gameControllerId: gameControllerIdFacet = (0,react_facet_src.createStaticFacet)('0'),
  acceptInputFromAllControllers: acceptInputFromAllControllersFacet = (0,react_facet_src.createStaticFacet)(false),
  swapABButtons: swapABButtonsFacet = (0,react_facet_src.createStaticFacet)(false),
  swapXYButtons: swapXYButtonsFacet = (0,react_facet_src.createStaticFacet)(false),
  disabledTransition = (0,react_facet_src.createStaticFacet)(false),
  keyboardGamepadMap
}) {
  const [isNavigationDisabledFacet, setIsNavigationDisabled] = (0,react_facet_src.useFacetState)(false);
  const actualInitialFocusedId = {
    id: initialFocusedId != null ? initialFocusedId : ROOT_NODE_ID,
    origin: FocusOrigin.Initial
  };
  const [focusedFacet, setFocusedFacet] = (0,react_facet_src.useFacetState)(actualInitialFocusedId);
  const focusedRef = (0,react.useRef)(actualInitialFocusedId);
  const setFocusedId = (0,react.useCallback)((newFocusedId, origin) => {
    const newValue = {
      id: newFocusedId,
      origin
    };
    focusedRef.current = newValue;
    setFocusedFacet(newValue);
  }, [focusedRef, setFocusedFacet]);
  const lastFocusOriginFacet = (0,react_facet_src.useFacetMap)(focused => focused.origin, [], [focusedFacet]);
  const focusTree = (0,react.useMemo)(() => initialFocusTree == null ? treeInitialization_getFreshTree() : initialFocusTree, [initialFocusTree]);
  const [debugFocusTreeFacet, setDebugFocusTreeFacet] = (0,react_facet_src.useFacetState)(focusTree);
  const [inputLegends, setInputLegends] = (0,react_facet_src.useFacetState)(localQueries_findInputLegends(focusTree, initialFocusedId));
  const inputLegendsRef = (0,react_facet_src.useFacetRef)(inputLegends);
  const [keyboardGamepadMapFacet, setKeyboardGamepadMap] = (0,react_facet_src.useFacetState)(keyboardGamepadMap);
  const keyToGamepadFacet = (0,react_facet_src.useFacetMap)(keyboardGamepadMap => Object.entries(keyboardGamepadMap).reduce((acc, [buttonType, buttonValues]) => {
    const keys = buttonValues.reduce((acc, buttonValue) => GamepadProvider_objectSpread(GamepadProvider_objectSpread({}, acc), {}, {
      [buttonValue]: buttonType
    }), {});
    return GamepadProvider_objectSpread(GamepadProvider_objectSpread({}, acc), keys);
  }, {}), [], [keyboardGamepadMapFacet]);
  const keyToGamepadRef = (0,react.useRef)(undefined);
  (0,react_facet_src.useFacetEffect)(keyToGamepad => {
    keyToGamepadRef.current = keyToGamepad;
  }, [], [keyToGamepadFacet]); // useFacetEffect(
  // 	(focusedFacet) => {
  // 		console.log('focusedFacet', focusedFacet)
  // 	},
  // 	[],
  // 	[focusedFacet],
  // )

  const isLastInputFocus = useIsLastInputFocus(); // Central place to handle updates of the focus to a new focused id

  const handleFocusedChange = (0,react_facet_src.useFacetCallback)((isLastInputFocus, disabledTransition) => (newFocusedId, newFocusedOrigin) => {
    if (newFocusedId != null && focusedRef.current.id !== newFocusedId) {
      const previousId = getIdFromAliasOrId(focusTree, focusedRef.current.id); // Update local record of the focused id

      setFocusedId(newFocusedId, newFocusedOrigin); // Notify external listeners of the focused id change, for example
      // for updating the URL

      onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange(newFocusedId); // Notify the ancestors of this element that its child was focused

      notifyAncestorsOfDecedentFocus(focusTree, newFocusedId, newFocusedOrigin); // Notify the nodes of onFocus and onBlur, and
      // store current values as the next previous values

      nofifyNodesOfBlurAndFocus(focusTree, previousId, newFocusedId); // Update the input legends according to the ones calculated for the new
      // focused id
      // TODO: Don't trigger the setInputLegends if InputLegend is Disabled
      // If there are no input legends don't trigger the setter

      const inputLegends = localQueries_findInputLegends(focusTree, newFocusedId);

      if (inputLegendsRef.current === react_facet_src.NO_VALUE || !areObjectsEqualShallow(inputLegends, inputLegendsRef.current)) {
        setInputLegends(inputLegends);
        inputLegendsRef.current = inputLegends;
      } // If necessary, request the scroll to move to center the current focused element.
      // We keep a reference to the canceling operation to be able to cancel if
      // another event starts scrolling before the animated transition is over


      if (isLastInputFocus) {
        cancelScrollRef.current = scrollIntoFocused(focusTree, newFocusedId, disabledTransition);
      }
    }
  }, [setFocusedId, onFocusedIdChange, focusTree, setInputLegends, focusedRef, inputLegendsRef], [isLastInputFocus, disabledTransition]);
  const requestFocusIdUpdate = (0,react_facet_src.useFacetCallback)(oldFocusedId => (newFocusedId, origin, isDefault) => {
    resetNavigationDirection(focusTree);

    if (isDefault) {
      const oldElement = getElement(focusTree, oldFocusedId.id);

      if (oldElement != null && types_isFocusable(oldElement) && treeQueries_isNodeEnabled(focusTree, oldFocusedId.id)) {
        return () => {};
      }
    }

    handleFocusedChange(newFocusedId, origin);
    return () => {
      resetNavigationDirection(focusTree);
      const oldElement = getElement(focusTree, oldFocusedId.id);

      if (oldElement != null && types_isFocusable(oldElement) && treeQueries_isNodeEnabled(focusTree, oldFocusedId.id)) {
        handleFocusedChange(oldFocusedId.id, oldFocusedId.origin);
      }
    };
  }, [handleFocusedChange, focusTree], [focusedFacet]);
  const imperativeSetFocusedId = (0,react.useCallback)((newFocusedId, isDefault, origin = FocusOrigin.ImperativeSetFocus) => {
    // Focusing something disabled
    // is always a bug. We might avoid some bugs by preventing focused to
    // be (probably manually) moved to a disabled item.
    const element = getElement(focusTree, newFocusedId);

    if (element != null && !types_isFocusable(element) || !treeQueries_isNodeEnabled(focusTree, newFocusedId)) {
      if (false) {}

      return () => {};
    }

    return requestFocusIdUpdate(newFocusedId, origin, isDefault);
  }, [requestFocusIdUpdate, focusTree, focusedRef]);
  const focusTreeAPI = (0,react.useMemo)(() => {
    return {
      press(button, origin) {
        const focusedId = getIdFromAliasOrId(focusTree, focusedRef.current.id);

        if (focusedId != null) {
          const didFireShortcut = fireShortcut(focusTree, focusedId, button);
          if (didFireShortcut) return;
        }

        if (button in mapButtonToArrow) {
          const arrow = mapButtonToArrow[button];

          if (arrow != null) {
            var _getAlias;

            if (focusedId != null) {
              const didFireHandler = fireHandler(focusTree, focusedId, arrow);
              if (didFireHandler) return;
            }

            const newFocusedId = navigate_navigateToDirection(focusTree, focusedId, arrow);

            if (newFocusedId === focusedId && onFocusedIdChangeFail != null) {
              onFocusedIdChangeFail();
            }

            handleFocusedChange((_getAlias = treeQueries_getAlias(focusTree, newFocusedId)) !== null && _getAlias !== void 0 ? _getAlias : newFocusedId, origin);
          }

          return;
        }

        switch (button) {
          case types_ButtonType.A:
            // go deeper
            click(focusTree, focusedId);
            return;

          case types_ButtonType.B:
            // go to parent
            return;

          case types_ButtonType.NEXT:
            {
              const nextId = legacyNavigateToAdjacentElement(focusTree, focusedId, false);

              if (nextId != null) {
                handleFocusedChange(nextId, FocusOrigin.FocusInput);
              }

              return;
            }

          case types_ButtonType.PREV:
            {
              const nextId = legacyNavigateToAdjacentElement(focusTree, focusedId, true);

              if (nextId != null) {
                handleFocusedChange(nextId, FocusOrigin.FocusInput);
              }

              return;
            }
        }
      },

      putNode(element, parentId) {
        const focused = focusedRef.current; // We don't want to change the focus id via tree mutation if 1) the focused
        // id is from a deep link (from URL or set as the initial id)
        // and 2) the id has not been added to the focus tree yet.

        const isFromDeepLink = focused.id != null && focused.id != ROOT_NODE_ID && (focused.origin === FocusOrigin.URL || focused.origin === FocusOrigin.Initial);
        const shouldSuggestNewId = !isFromDeepLink || focused.id != null;
        const newFocusSuggestion = putFocusTreeNode(focusTree, element, parentId, focusedRef.current, shouldSuggestNewId);

        if (newFocusSuggestion != null) {
          handleFocusedChange(newFocusSuggestion.id, FocusOrigin.FocusTreeMutation);
        }

        setDebugFocusTreeFacet(focusTree);
      },

      putShortcut(elementId, actionButton, shortcut) {
        putShortcut(focusTree, elementId, actionButton, shortcut);
        setDebugFocusTreeFacet(focusTree);
      },

      removeNode(elementId) {
        const newFocusSuggestion = removeFocusTreeNode(focusTree, elementId, focusedRef.current);

        if (newFocusSuggestion != null) {
          handleFocusedChange(newFocusSuggestion.id, FocusOrigin.FocusTreeMutation);
        }

        setDebugFocusTreeFacet(focusTree);
      },

      removeShortcut(elementId, actionButton) {
        removeShortcut(focusTree, elementId, actionButton);
        setDebugFocusTreeFacet(focusTree);
      },

      isFocused(elementId, alias) {
        return elementId === focusedRef.current.id || alias != null && alias === focusedRef.current.id;
      },

      isFocusable: focusableId => {
        // TODO: Need to consolidate the checks from `navigateToDirection()` into here as well. We need to understand which should be shared.
        const element = getElement(focusTree, focusableId);
        return element != null && types_isFocusable(element) && treeQueries_isNodeEnabled(focusTree, focusableId);
      },
      getElement: elementId => getElement(focusTree, getIdFromAliasOrId(focusTree, elementId)),
      isAncestorOf: (parentId, elementId) => isAncestorOf(focusTree, parentId, elementId),
      getDynasty: elementId => focusTree.dynasty.get(elementId),
      getEnabledBindingLandmarkDescendant: elementId => {
        return getEnabledBindingLandmarkDescendant(focusTree, elementId);
      }
    };
  }, [focusedRef, focusTree, handleFocusedChange, setDebugFocusTreeFacet, onFocusedIdChangeFail]);
  const focusTreeAPIRef = (0,react.useRef)(focusTreeAPI); // TODO: figure out how to do debugging without impacting performance all the time in test builds
  // One way could be to only trigger the following 6 lines if you're in browser

  const focusedIdFacet = (0,react_facet_src.useFacetMap)(focused => focused.id, [], [focusedFacet]);
  const setFocusFromDebugTool = (0,react.useCallback)(id => handleFocusedChange(id, FocusOrigin.DebugTool), [handleFocusedChange]); // This acts like a define in C++ to remove the enclosed piece of code in non-browser environments during transpilation

  if (false) {}

  const analogListenersRef = (0,react.useRef)([]);
  const digitalListenersRef = (0,react.useRef)([]);
  const invokeCurrentCallback = (0,react.useCallback)(actionButton => {
    const focused = focusedRef.current;
    const focusedNumberId = getIdFromAliasOrId(focusTree, focused.id);
    if (focusedNumberId == null) return;
    const handler = getShortcutHandler(focusTree, focusedNumberId, actionButton);
    handler === null || handler === void 0 ? void 0 : handler();
  }, [focusTree]);
  const cancelScrollRef = (0,react.useRef)(undefined);
  const onPress = (0,react.useCallback)((button, origin = FocusOrigin.Unknown) => {
    digitalListenersRef.current.forEach(digitalListener => digitalListener(button));
    focusTreeAPI.press(button, origin);
  }, [focusTreeAPI]);
  const onWiggle = (0,react.useCallback)(axes => {
    analogListenersRef.current.forEach(analogListener => analogListener(axes));
    const didWiggleCauseScroll = wiggleScrollables(focusTree, focusedRef.current.id, axes, ANALOG_SCROLL_MAX_SPEED);
    if (didWiggleCauseScroll && cancelScrollRef.current) cancelScrollRef.current();
  }, [focusTree, analogListenersRef, focusedRef]);
  (0,react_facet_src.useFacetLayoutEffect)((isNavigationDisabled, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons) => {
    // NOTE: If we in the future would disable / enable navigation based on shared input facet state
    // then we might end up in a race condition between registering the driver and determining initial
    // focus state. In case that happens it can be solved by waiting a frame (using requestAnimationFrame)
    // before initializing the driver below.
    return !isNavigationDisabled ? driver(onPress, onWiggle, gameControllerId, acceptInputFromAllControllers, swapABButtons, swapXYButtons, keyToGamepadRef) : undefined;
  }, [gameControllerIdFacet, driver, onWiggle, onPress, acceptInputFromAllControllersFacet, swapABButtonsFacet, swapXYButtonsFacet, keyToGamepadRef], [isNavigationDisabledFacet, gameControllerIdFacet, acceptInputFromAllControllersFacet, swapABButtonsFacet, swapXYButtonsFacet]);
  const cursorAPI = (0,react.useMemo)(() => {
    const cursorAPI = {
      addAnalogListener: analogListener => {
        analogListenersRef.current = [...analogListenersRef.current, analogListener];
        return () => {
          analogListenersRef.current = without_default()([analogListener], analogListenersRef.current);
        };
      },
      addDigitalListener: digitalListener => {
        digitalListenersRef.current = [...digitalListenersRef.current, digitalListener];
        return () => {
          digitalListenersRef.current = without_default()([digitalListener], digitalListenersRef.current);
        };
      },
      clickAtPoint: (x, y) => {
        clickFocusableAtPoint(focusTree, x, y);
      },
      focusAtPoint: (x, y) => {
        var _focusable$alias;

        const focusable = visualQueries_findClickableFocusableAtPoint(focusTree, x, y);
        const focusableId = (_focusable$alias = focusable === null || focusable === void 0 ? void 0 : focusable.alias) !== null && _focusable$alias !== void 0 ? _focusable$alias : focusable === null || focusable === void 0 ? void 0 : focusable.id;

        if (focusableId != null) {
          requestFocusIdUpdate(focusableId, FocusOrigin.PointerInput);
        }
      }
    };
    return cursorAPI;
  }, [requestFocusIdUpdate, focusTree]); // Prevent buttonMap to be created on every render by using useMemo,
  // which would trigger an update on any consumer of the ButtonMapProvider context provider below

  const buttonMap = (0,react_facet_src.useFacetMap)((swapABButtons, swapXYButtons) => ({
    swapABButtons,
    swapXYButtons
  }), [], [swapABButtonsFacet, swapXYButtonsFacet]);
  const keyboardGamepadMapValue = (0,react.useMemo)(() => [keyboardGamepadMapFacet, setKeyboardGamepadMap], [keyboardGamepadMapFacet, setKeyboardGamepadMap]); // Using a layout effect since we want this to run before we render components further down
  // in the tree that will mutate the focus tree. Can't use a useMemo since then requestFocusIdUpdate
  // isn't initialized yet (by useFacetCallback)

  (0,react.useLayoutEffect)(() => {
    if (notifyFocusRequest == null) return () => {}; // Note that we are using requestFocusIdUpdate here instead of imperativeSetFocusedId since we want to
    // be able to be able to deep link to a particular focused id from the URL. However, at that point we don't
    // know if the full tree is constructed yet or not, so we just set the focused id regardless if it is in the
    // tree, disabled etc.

    return notifyFocusRequest(newFocusedId => requestFocusIdUpdate(newFocusedId, FocusOrigin.URL));
  }, [requestFocusIdUpdate, notifyFocusRequest]);
  return /*#__PURE__*/react.createElement(ToggleNavigationProvider, {
    isNavigationDisabledFacet: isNavigationDisabledFacet,
    setIsNavigationDisabled: setIsNavigationDisabled
  }, /*#__PURE__*/react.createElement(PathContext.Provider, {
    value: INITIAL_PATH
  }, /*#__PURE__*/react.createElement(keyboardGamepadMapContext.Provider, {
    value: keyboardGamepadMapValue
  }, /*#__PURE__*/react.createElement(setFocusedId_setFocusedIdContext.Provider, {
    value: imperativeSetFocusedId
  }, /*#__PURE__*/react.createElement(lastFocusOriginContext.Provider, {
    value: lastFocusOriginFacet
  }, /*#__PURE__*/react.createElement(ButtonMapProvider, {
    value: buttonMap
  }, /*#__PURE__*/react.createElement(FocusTreeAPIProvider, {
    value: focusTreeAPIRef
  }, /*#__PURE__*/react.createElement(CursorAPIProvider, {
    value: cursorAPI
  }, /*#__PURE__*/react.createElement(AvailableInputLegendsProvider, {
    value: inputLegends
  }, /*#__PURE__*/react.createElement(InvokeCurrentCallbackProvider, {
    value: invokeCurrentCallback
  }, /*#__PURE__*/react.createElement(FocusedIdProvider, {
    value: focusedIdFacet
  }, children)))))))))));
}

function areObjectsEqualShallow(a, b) {
  for (const key in a) {
    if (!(key in b) || a[key] !== b[key]) {
      return false;
    }
  }

  for (const key in b) {
    if (!(key in a) || a[key] !== b[key]) {
      return false;
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/gamepadAdapterContext.tsx

let GamepadAdapterVersion;

(function (GamepadAdapterVersion) {
  GamepadAdapterVersion[GamepadAdapterVersion["LEGACY"] = 0] = "LEGACY";
  GamepadAdapterVersion[GamepadAdapterVersion["VISUAL"] = 1] = "VISUAL";
})(GamepadAdapterVersion || (GamepadAdapterVersion = {}));

const gamepadAdapterContext = (0,react.createContext)({
  version: GamepadAdapterVersion.LEGACY,
  setVersion: () => {}
});
const useGamepadAdapter = () => (0,react.useContext)(gamepadAdapterContext);
const GamepadAdapterProvider = ({
  children,
  version: defaultVersion
}) => {
  const [version, setVersion] = (0,react.useState)(defaultVersion);
  const value = (0,react.useMemo)(() => ({
    version,
    setVersion
  }), [version, setVersion]);
  return /*#__PURE__*/react.createElement(gamepadAdapterContext.Provider, {
    value: value
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadProvider.tsx
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }






// Static facet holding a false value
const falseFacet = (0,react_facet_src.createStaticFacet)(false);
function src_GamepadProvider_GamepadProvider(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();
  const [focusedIdFacet, setFocusedId] = (0,react_facet_src.useFacetState)(undefined);
  const {
    disabledNavigation,
    notifyFocusRequest,
    onFocusedIdChange
  } = props;
  const mappedFocusedIdFacet = (0,react_facet_src.useFacetMap)((disabledNavigation, focusedId) => disabledNavigation !== true ? focusedId : undefined, [], [(0,react_facet_src.useFacetWrap)(disabledNavigation !== null && disabledNavigation !== void 0 ? disabledNavigation : falseFacet), focusedIdFacet]);
  (0,react.useEffect)(() => {
    if (notifyFocusRequest == null) return () => {};
    const cleanup = notifyFocusRequest(focusedId => {
      setFocusedId(focusedId);
    });
    return cleanup;
  }, [notifyFocusRequest, setFocusedId]);
  const legacyOnFocusedIdChange = (0,react.useCallback)(newFocusedId => {
    setFocusedId(newFocusedId);
    onFocusedIdChange === null || onFocusedIdChange === void 0 ? void 0 : onFocusedIdChange(newFocusedId);
  }, [setFocusedId, onFocusedIdChange]);

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadProvider, _extends({
      focusedId: mappedFocusedIdFacet
    }, props, {
      onFocusedIdChange: legacyOnFocusedIdChange,
      mostRecentlyFocusedId: focusedIdFacet
    }));
  }

  return /*#__PURE__*/react.createElement(GamepadProvider_GamepadProvider, props);
}
// EXTERNAL MODULE: ./node_modules/rtl-detect/index.js
var rtl_detect = __webpack_require__(23972);
var rtl_detect_default = /*#__PURE__*/__webpack_require__.n(rtl_detect);
;// CONCATENATED MODULE: ./packages/react-localization/src/LocalizationProvider.tsx



const noopTranslate = key => key;

const noopFormatDate = timestamp => `${timestamp}`;

const LocalizationContext = (0,react.createContext)({
  translationPrefix: 'hbui',
  translate: noopTranslate,
  formatDate: noopFormatDate,
  locale: 'en-US',
  isRtl: false
});
function LocalizationProvider({
  translationPrefix,
  translate,
  formatDate,
  children,
  locale
}) {
  const isRtl = (0,react.useMemo)(() =>  true ? rtl_detect_default().getLangDir(locale) === 'rtl' : 0, [locale]);
  const value = (0,react.useMemo)(() => ({
    translationPrefix,
    translate,
    formatDate,
    locale,
    isRtl
  }), [translationPrefix, translate, formatDate, locale, isRtl]);
  return /*#__PURE__*/react.createElement(LocalizationContext.Provider, {
    value: value
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-localization/src/useIsLocaleRtl.tsx


const useIsLocaleRtl = () => {
  return (0,react.useContext)(LocalizationContext).isRtl;
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/inputFacet.ts

const inputFacet_INPUT_FACET = 'core.input';
/**
 * React Hook that requests the facet
 */

const inputFacet_inputFacet = (0,react_facet_src.sharedFacet)(inputFacet_INPUT_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/animationFacet.ts

const ANIMATION_FACET = 'core.animation';
const animationFacet = (0,react_facet_src.sharedFacet)(ANIMATION_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/splitScreenFacet.ts

let SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(SplitScreenDirection || (SplitScreenDirection = {}));

const SPLIT_SCREEN_FACET = 'core.splitScreen';
/**
 * React Hook that requests the facet
 */

const splitScreenFacet = (0,react_facet_src.sharedFacet)(SPLIT_SCREEN_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/GamepadEngineProvider.tsx









/**
 * Provider that setups the Gamepad to be used by the RouterEngineProvider
 * differently than other "engine provider", this has some required props that are to be used by another provider
 *
 * It should not be moved outside of this folder
 */
function GamepadEngineProvider({
  notifyFocusRequest,
  onFocusedIdChange,
  onFocusedIdChangeFail,
  children,
  keyboardGamepadMap,
  isInputLegendClickable
}) {
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const splitScreen = (0,react_facet_src.useSharedFacet)(splitScreenFacet);
  const isRtl = useIsLocaleRtl();
  const acceptInputFromAllControllers = (0,react_facet_src.useFacetMap)(input => input.acceptInputFromAllControllers, [], [(0,react_facet_src.useSharedFacet)(inputFacet_inputFacet)]);
  const gameControllerId = (0,react_facet_src.useFacetMap)(input => input.gameControllerId, [], [(0,react_facet_src.useSharedFacet)(inputFacet_inputFacet)]);
  const swapABButtons = (0,react_facet_src.useFacetMap)(input => input.swapABButtons, [], [(0,react_facet_src.useSharedFacet)(inputFacet_inputFacet)]);
  const swapXYButtons = (0,react_facet_src.useFacetMap)(input => input.swapXYButtons, [], [(0,react_facet_src.useSharedFacet)(inputFacet_inputFacet)]);
  const disabledNavigation = (0,react_facet_src.useFacetMap)(isLastInputFocus => !isLastInputFocus, [], [useIsLastInputFocus()]); // Performance while running the game in split screen is degraded,
  // so we disable animations to a more snappy UI

  const disabledTransition = (0,react_facet_src.useFacetMap)((animation, splitScreen) => !animation.screenAnimationEnabled || splitScreen.numActivePlayers > 1, [], [animation, splitScreen]);
  return /*#__PURE__*/react.createElement(src_GamepadProvider_GamepadProvider, {
    notifyFocusRequest: notifyFocusRequest,
    onFocusedIdChange: onFocusedIdChange,
    onFocusedIdChangeFail: onFocusedIdChangeFail,
    disabledNavigation: disabledNavigation,
    acceptInputFromAllControllers: acceptInputFromAllControllers,
    gameControllerId: gameControllerId,
    swapABButtons: swapABButtons,
    swapXYButtons: swapXYButtons,
    disabledTransition: disabledTransition,
    isRtl: isRtl,
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/context.ts

const context_context = (0,react.createContext)(() => () => {});
const {
  Provider: context_Provider,
  Consumer: context_Consumer
} = context_context;

const usePlay = () => (0,react.useContext)(context_context);
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/constants.ts
const NO_SOUND = 'react-sound-effect.NoSound';
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/useSoundEffectTrigger.ts



function useSoundEffectTrigger() {
  const play = usePlay();
  const triggerSoundEffect = (0,react.useCallback)((eventName, delay = 0, volume = 1, pitch = 1) => {
    if (eventName === NO_SOUND || !eventName) return;
    play(eventName, delay, volume, pitch);
  }, [play]);
  return triggerSoundEffect;
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationEnabled.ts

const narrationEnabledContext = (0,react.createContext)(true);
const NarrationEnabledProvider = narrationEnabledContext.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrationEnabled.ts


const useNarrationEnabled = () => (0,react.useContext)(narrationEnabledContext);
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/constants.ts
const DEFAULT_ROLE = 'neutral';
const NEUTRAL_ROLES = [DEFAULT_ROLE, 'neutral20', 'neutral50', 'neutral60', 'neutral80', 'neutral100'];
const SEMANTIC_ROLES = ['primary', 'primaryTint', 'secondary', 'tertiary', 'success', 'successTint', 'destructive', 'destructiveTint', 'informative', 'informativeTint', 'notice', 'noticeTint'];
const DATA_VISUALIZATION_ROLES = ['dataViz01', 'dataViz02', 'dataViz03', 'dataViz04', 'dataViz05', 'dataViz06', 'dataViz07', 'dataVizLine'];
const PAPER_ROLE = 'paper';
const ROLES = [...NEUTRAL_ROLES, ...SEMANTIC_ROLES, ...DATA_VISUALIZATION_ROLES, PAPER_ROLE]; // Variant

const DEFAULT_FOREGROUND_VARIANT = 'regular';
const EFFECT_VARIANT = 'reversed';
const FOREGROUND_VARIANTS = ['dimmest', 'dimmer', 'stronger', 'strongest'];
const NONE_DEFAULT_VARIANTS = [...FOREGROUND_VARIANTS, EFFECT_VARIANT];
const VARIANTS = [DEFAULT_FOREGROUND_VARIANT, ...NONE_DEFAULT_VARIANTS]; // Element

const FOREGROUND_ELEMENTS = ['text', 'icon', 'border', 'caret'];
const LIGHTING_EFFECT_ELEMENTS = ['specular', 'bevel'];
const HIGHLIGHT_ELEMENT = 'highlight';
const BASE_ELEMENTS = ['background', 'shadow', 'outline', 'overlay', 'dropShadow'];
const ELEMENTS = [...FOREGROUND_ELEMENTS, ...BASE_ELEMENTS, ...LIGHTING_EFFECT_ELEMENTS, HIGHLIGHT_ELEMENT]; // Modifier

const DEFAULT_MODIFIER = 'default';
const HOVERED = 'hovered';
const PRESSED = 'pressed';
const DISABLED = 'disabled';
const SELECTED = 'selected';
const FOCUSED = 'focused';
const INTERACTIVE_MODIFIERS = [SELECTED, FOCUSED, HOVERED, PRESSED, DISABLED];
const MODIFIERS = ['default', ...INTERACTIVE_MODIFIERS]; // Pseudo

const BASE = 'base';
const HOVER = 'hover';
const PRESS = 'press';
const DISABLE = 'disable';
const SELECT = 'select';
const FOCUS = 'focus';
const INTERACTIVE = 'interactive';
const PSEUDO_SELECTORS_EXCLUDE_INTERACTIVE = [HOVER, PRESS, DISABLE, SELECT, FOCUS, BASE];
const PSEUDO_SELECTORS = [...PSEUDO_SELECTORS_EXCLUDE_INTERACTIVE, INTERACTIVE]; // Pseudo & Modifier

const MODIFIER_TO_PSEUDO_SELECTOR = {
  [DEFAULT_MODIFIER]: BASE,
  [HOVERED]: HOVER,
  [PRESSED]: PRESS,
  [FOCUSED]: FOCUS,
  [SELECTED]: SELECT,
  [DISABLED]: DISABLE
};
const PSEUDO_SELECTOR_TO_MODIFIER = {
  [BASE]: DEFAULT_MODIFIER,
  [HOVER]: HOVERED,
  [PRESS]: PRESSED,
  [FOCUS]: FOCUSED,
  [SELECT]: SELECTED,
  [DISABLE]: DISABLED
}; // Component

const COMPONENT_ELEMENTS_MAP = {
  pressable: ['main'],
  panel: ['main'],
  inputLegend: ['sideContainer', 'inputHint']
};
const COMPONENT_NAMES = Object.keys(COMPONENT_ELEMENTS_MAP); // Sound

const SOUND_EVENTS = ['reject', 'click', 'press', 'focus', 'hover', 'hoverExit', 'contract', 'expand', 'toggle', 'lift'];
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/typeGuards.ts
 // Element

const isForegroundElement = element => {
  return FOREGROUND_ELEMENTS.includes(element);
};
const isLightingEffectElement = element => {
  return LIGHTING_EFFECT_ELEMENTS.includes(element);
};
const hasVariant = (element, variant = 'regular') => typeof element !== 'undefined' && variant in element;
const isInteractiveCollection = element => {
  if (element == null || typeof element !== 'object') {
    return false;
  }

  const propKeys = Object.keys(element);
  return propKeys.length > 0 && propKeys.every(key => MODIFIERS.includes(key));
};
const isComponentStylePath = path => {
  return path.length === 5 && COMPONENT_NAMES.includes(path[1]);
};
const isComponentCollectionType = value => {
  return value != null && typeof value === 'object';
};
const isColorPath = path => {
  return ROLES.includes(path[1]);
};
const isLightingEffectType = value => {
  return typeof value === 'object' && 'top' in value && 'bottom' in value;
};
function typeGuards_hasOwnProperty(obj, prop) {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, prop);
}
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/utils.ts

const COLLECTION_STYLE_ID_PREFIX = `semantic-tokens-collection-id-`;
const getCollectionStyleId = collectionId => `${COLLECTION_STYLE_ID_PREFIX}${collectionId}`;
function mapPseudoSelectorToModifier(pseudoSelector) {
  if (pseudoSelector === INTERACTIVE) {
    return undefined;
  }

  return PSEUDO_SELECTOR_TO_MODIFIER[pseudoSelector];
}
function mapModifierToPseudoSelector(modifier) {
  return MODIFIER_TO_PSEUDO_SELECTOR[modifier];
}
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/collectionToClassName.ts




const flattenCollection = collection => {
  const flattened = [];

  const recurse = (value, path) => {
    if (value != null && typeof value === 'object') {
      if (isInteractiveCollection(value)) {
        MODIFIERS.forEach(modifier => {
          if (value[modifier] != null) {
            flattened.push({
              path: [...path, mapModifierToPseudoSelector(modifier)],
              value: value[modifier]
            });
          }
        });
      } else {
        for (const prop in value) {
          recurse(value[prop], [...path, prop]);
        }
      }
    }
  };

  recurse(collection.color, [collection.id]);
  recurse(collection.component, [collection.id]);
  return flattened;
};

const generateCssForColor = (selector, element, value) => {
  switch (element) {
    case 'background':
    case 'icon':
    case 'shadow':
    case 'highlight':
    case 'overlay':
    case 'dropShadow':
      return `${selector} { background-color: ${value}; }`;

    case 'border':
    case 'outline':
      return `${selector} { border-color: ${value}; }`;

    case 'text':
      return `${selector} { color: ${value}; }`;

    case 'specular':
    case 'bevel':
      const {
        top,
        bottom
      } = value;

      if (selector.includes('reversed')) {
        return `${selector} { border-top-color: ${bottom}; border-left-color: ${bottom}; border-bottom-color: ${top};  border-right-color: ${top} }`;
      }

      return `${selector} { border-top-color: ${top}; border-left-color: ${top}; border-bottom-color: ${bottom};  border-right-color: ${bottom} }`;

    case 'caret':
      return `${selector} { caret-color: ${value}; }`;
  }
};

const extractSelectorAndElement = path => {
  const element = path[2];
  const foregroundElement = isForegroundElement(element);
  const lightingElement = isLightingEffectElement(element);
  const pseudo = path[path.length - 1];
  const modifier = mapPseudoSelectorToModifier(pseudo); // Note that splice will mutate path by removing variant from it

  const variant = foregroundElement ? path.splice(3, 1)[0] : undefined;
  const baseSelector = path.join('-');
  const defaultSelector = path.slice(0, -1).join('-');
  const interactiveSelector = path.slice(0, -1).concat('interactive').join('-');

  if (lightingElement) {
    const selector = pseudo === 'base' ? `.${defaultSelector},.${interactiveSelector}` : `.${baseSelector}.${modifier},.${modifier} .${baseSelector},.${interactiveSelector}.${modifier},.${modifier} .${interactiveSelector}`;
    const reversedSelector = pseudo === 'base' ? `.${defaultSelector}.reversed,.${interactiveSelector}.reversed` : `.${baseSelector}.reversed.${modifier},.${modifier} .${baseSelector}.reversed,.${interactiveSelector}.reversed.${modifier},.${modifier} .${interactiveSelector}.reversed`;
    return {
      element,
      selector: [selector, reversedSelector]
    };
  }

  const variantClassName = variant == null || variant === 'regular' ? '' : `.${variant}`;
  const selector = pseudo === 'base' ? `.${defaultSelector}${variantClassName},.${interactiveSelector}${variantClassName}` : `.${baseSelector}${variantClassName}.${modifier},.${modifier} .${baseSelector}${variantClassName},.${interactiveSelector}${variantClassName}.${modifier},.${modifier} .${interactiveSelector}${variantClassName}`;
  return {
    element,
    selector
  };
};

const generateCssForComponentCollection = (path, styles) => {
  const baseSelector = path.slice(0, -1).join('-');
  const interactiveSelector = path.slice(0, -1).concat('interactive').join('-');
  const pseudoSelector = path[path.length - 1];
  const modifier = mapPseudoSelectorToModifier(pseudoSelector);
  const selector = pseudoSelector === 'base' ? `.${baseSelector},.${interactiveSelector}` : `.${baseSelector}.${modifier},.${modifier} .${baseSelector},.${interactiveSelector}.${modifier},.${modifier} .${interactiveSelector}`;
  let css = `${selector} {`;
  let property;

  for (property in styles) {
    const kebabCaseProperty = property.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
    css += `${kebabCaseProperty}: ${styles[property]};\n`;
  }

  css += '}';
  return css;
};

const generateCssForColorCollection = (path, value) => {
  const {
    element,
    selector
  } = extractSelectorAndElement(path);
  return Array.isArray(selector) ? selector.map(selector => generateCssForColor(selector, element, value)).join('') : generateCssForColor(selector, element, value);
};

const transformToCss = arr => {
  return arr.map(({
    path,
    value
  }) => {
    if (isComponentStylePath(path)) {
      if (isComponentCollectionType(value)) {
        return generateCssForComponentCollection(path, value);
      }
    } else if (isColorPath(path)) {
      if (!(isLightingEffectType(value) || typeof value === 'string')) {
        throw new Error(`Expected ${JSON.stringify(path)}'s value "${value}" to be of type "string" or "LightingEffectType"`);
      }

      return generateCssForColorCollection(path, value);
    }

    throw new Error(`Unknown path ${JSON.stringify(path)} and value "${JSON.stringify(value)}"`);
  }).join('');
};

const collectionToClassName = collection => {
  const collectionFlattened = flattenCollection(collection);
  const css = transformToCss(collectionFlattened);
  return css;
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/SemanticRole.tsx

const SemanticRoleScopeContext = (0,react.createContext)('neutral');
const useInheritedSemanticRole = () => (0,react.useContext)(SemanticRoleScopeContext);
const SemanticRole_SemanticRoleProvider = ({
  role,
  children
}) => {
  if (role === 'inherit') {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(SemanticRoleScopeContext.Provider, {
    value: role
  }, children);
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/generateSemanticTokens.ts


 // Generate color tokens based on collection and parent tokens

const generateColorTokens = (collection, parentTokens) => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const tokens = {
    color: {},
    rawColor: {}
  };
  const id = collection == null ? null : collection.id;

  for (const role of ROLES) {
    tokens.color[role] = {};
    tokens.rawColor[role] = {};

    for (const element of ELEMENTS) {
      var _collection$color, _collection$color$rol;

      const elementCollection = collection === null || collection === void 0 ? void 0 : (_collection$color = collection.color) === null || _collection$color === void 0 ? void 0 : (_collection$color$rol = _collection$color[role]) === null || _collection$color$rol === void 0 ? void 0 : _collection$color$rol[element];

      if (elementCollection == null && parentTokens != null) {
        // Inherit all element tokens from parent
        tokens.color[role][element] = parentTokens.color[role][element];
        tokens.rawColor[role][element] = parentTokens.rawColor[role][element];
        continue;
      }

      tokens.rawColor[role][element] = {};

      if (isForegroundElement(element)) {
        for (const variant of VARIANTS) {
          var _collection$color2, _collection$color2$ro, _collection$color2$ro2;

          tokens.rawColor[role][element][variant] = {};
          const variantCollection = collection === null || collection === void 0 ? void 0 : (_collection$color2 = collection.color) === null || _collection$color2 === void 0 ? void 0 : (_collection$color2$ro = _collection$color2[role]) === null || _collection$color2$ro === void 0 ? void 0 : (_collection$color2$ro2 = _collection$color2$ro[element]) === null || _collection$color2$ro2 === void 0 ? void 0 : _collection$color2$ro2[variant];

          for (const modifier of MODIFIERS) {
            tokens.rawColor[role][element][variant][modifier] = variantCollection === null || variantCollection === void 0 ? void 0 : variantCollection[modifier];
          }
        }
      } else if (isLightingEffectElement(element)) {
        for (const modifier of MODIFIERS) {
          var _collection$color3, _collection$color3$ro, _collection$color3$ro2, _collection$color3$ro3, _collection$color4, _collection$color4$ro, _collection$color4$ro2, _collection$color4$ro3;

          tokens.rawColor[role][element][modifier] = {};
          tokens.rawColor[role][element][modifier].top = collection === null || collection === void 0 ? void 0 : (_collection$color3 = collection.color) === null || _collection$color3 === void 0 ? void 0 : (_collection$color3$ro = _collection$color3[role]) === null || _collection$color3$ro === void 0 ? void 0 : (_collection$color3$ro2 = _collection$color3$ro[element]) === null || _collection$color3$ro2 === void 0 ? void 0 : (_collection$color3$ro3 = _collection$color3$ro2[modifier]) === null || _collection$color3$ro3 === void 0 ? void 0 : _collection$color3$ro3.top;
          tokens.rawColor[role][element][modifier].bottom = collection === null || collection === void 0 ? void 0 : (_collection$color4 = collection.color) === null || _collection$color4 === void 0 ? void 0 : (_collection$color4$ro = _collection$color4[role]) === null || _collection$color4$ro === void 0 ? void 0 : (_collection$color4$ro2 = _collection$color4$ro[element]) === null || _collection$color4$ro2 === void 0 ? void 0 : (_collection$color4$ro3 = _collection$color4$ro2[modifier]) === null || _collection$color4$ro3 === void 0 ? void 0 : _collection$color4$ro3.bottom;
        }
      } else {
        for (const modifier of MODIFIERS) {
          var _collection$color5, _collection$color5$ro, _collection$color5$ro2;

          tokens.rawColor[role][element][modifier] = collection === null || collection === void 0 ? void 0 : (_collection$color5 = collection.color) === null || _collection$color5 === void 0 ? void 0 : (_collection$color5$ro = _collection$color5[role]) === null || _collection$color5$ro === void 0 ? void 0 : (_collection$color5$ro2 = _collection$color5$ro[element]) === null || _collection$color5$ro2 === void 0 ? void 0 : _collection$color5$ro2[modifier];
        }
      }

      tokens.color[role][element] = {};

      for (const pseudo of PSEUDO_SELECTORS) {
        // Fill in classes for all pseudo selectors, even though not all are defined
        if (pseudo === 'base') {
          tokens.color[role][element][pseudo] = elementCollection != null ? `${id}-${role}-${element}` : undefined;
        } else {
          tokens.color[role][element][pseudo] = elementCollection != null ? `${id}-${role}-${element}-${pseudo}` : undefined;
        }
      }
    }
  }

  return tokens;
}; // Generate component tokens based on collection


const generateComponentTokens = collection => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const tokens = {};
  const id = collection == null ? null : collection.id;

  for (const componentName of COMPONENT_NAMES) {
    tokens[componentName] = {};

    for (const role of ROLES) {
      tokens[componentName][role] = {};

      for (const componentElement of COMPONENT_ELEMENTS_MAP[componentName]) {
        var _collection$component, _collection$component2;

        tokens[componentName][role][componentElement] = {};
        const componentCollection = collection === null || collection === void 0 ? void 0 : (_collection$component = collection.component) === null || _collection$component === void 0 ? void 0 : (_collection$component2 = _collection$component[componentName]) === null || _collection$component2 === void 0 ? void 0 : _collection$component2[role];
        const elementExistsInCollection = typeGuards_hasOwnProperty(componentCollection, componentElement);
        tokens[componentName][role][componentElement] = {};

        if (elementExistsInCollection && isInteractiveCollection(componentCollection === null || componentCollection === void 0 ? void 0 : componentCollection[componentElement])) {
          // Add interactive token if at least one interactive state exists
          tokens[componentName][role][componentElement].interactive = `${id}-${componentName}-${role}-${componentElement}-${INTERACTIVE}`;
        } else {
          tokens[componentName][role][componentElement].interactive = undefined;
        }

        for (const pseudo of PSEUDO_SELECTORS_EXCLUDE_INTERACTIVE) {
          var _componentCollection$;

          const modifier = mapPseudoSelectorToModifier(pseudo);

          if (modifier == null) {
            continue;
          } // Add the token if the state exists in the collection


          if (elementExistsInCollection && (componentCollection === null || componentCollection === void 0 ? void 0 : (_componentCollection$ = componentCollection[componentElement]) === null || _componentCollection$ === void 0 ? void 0 : _componentCollection$[modifier]) != null) {
            tokens[componentName][role][componentElement][pseudo] = pseudo === 'base' ? `${id}-${componentName}-${role}-${componentElement}` : `${id}-${componentName}-${role}-${componentElement}-${pseudo}`;
          } else {
            tokens[componentName][role][componentElement][pseudo] = undefined;
          }
        }
      }
    }
  }

  return tokens;
};

const generateModifiers = () => {
  const modifiers = {};

  for (const modifier of INTERACTIVE_MODIFIERS) {
    modifiers[modifier] = modifier;
  }

  return modifiers;
};

const MODIFIER_CLASS_NAMES = generateModifiers();

const generateVariants = () => {
  const variants = {};

  for (const variant of NONE_DEFAULT_VARIANTS) {
    variants[variant] = variant;
  }

  return variants;
};

const VARIANT_CLASS_NAMES = generateVariants();

const generateSoundTokens = (collection, parentTokens) => {
  const tokens = {};

  for (const role of ROLES) {
    var _parentTokens$sound;

    tokens[role] = {};
    const parentSoundTokens = parentTokens === null || parentTokens === void 0 ? void 0 : (_parentTokens$sound = parentTokens.sound) === null || _parentTokens$sound === void 0 ? void 0 : _parentTokens$sound[role];

    for (const soundEvent of SOUND_EVENTS) {
      var _collection$sound$rol, _collection$sound, _collection$sound$rol2;

      // Fallback to parent sound event token
      tokens[role][soundEvent] = (_collection$sound$rol = collection === null || collection === void 0 ? void 0 : (_collection$sound = collection.sound) === null || _collection$sound === void 0 ? void 0 : (_collection$sound$rol2 = _collection$sound[role]) === null || _collection$sound$rol2 === void 0 ? void 0 : _collection$sound$rol2[soundEvent]) !== null && _collection$sound$rol !== void 0 ? _collection$sound$rol : parentSoundTokens === null || parentSoundTokens === void 0 ? void 0 : parentSoundTokens[soundEvent];
    }
  }

  return tokens;
};

const semanticTokensPerId = {}; // Get tokens for a collection. Generate the tokens if they don't exist yet,
// otherwise return the cached tokens.

const getSemanticTokens = (collection, parentTokens) => {
  if (collection == null) return EMPTY_SEMANTIC_TOKENS;
  const id = collection.id;

  if (semanticTokensPerId[id] == null) {
    semanticTokensPerId[id] = generateTokens(collection, parentTokens);
  }

  return semanticTokensPerId[id];
}; // Generate all tokens based on collection and parent tokens

const generateTokens = (collection, parentTokens) => {
  const sound = generateSoundTokens(collection, parentTokens);
  const {
    color,
    rawColor
  } = generateColorTokens(collection, parentTokens);
  const component = generateComponentTokens(collection);
  const tokens = {
    color,
    component,
    variant: VARIANT_CLASS_NAMES,
    modifier: MODIFIER_CLASS_NAMES,
    rawColor,
    sound
  };
  return tokens;
};

const EMPTY_SEMANTIC_TOKENS = generateTokens(null);
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/SemanticTokensProvider.tsx
function SemanticTokensProvider_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function SemanticTokensProvider_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { SemanticTokensProvider_ownKeys(Object(source), true).forEach(function (key) { SemanticTokensProvider_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { SemanticTokensProvider_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function SemanticTokensProvider_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const DEFAULT_SEMANTIC_COLLECTIONS_MANAGER_CONTEXT = {
  registerCollection: () => undefined
};
const SemanticCollectionsManagerContext = (0,react.createContext)(DEFAULT_SEMANTIC_COLLECTIONS_MANAGER_CONTEXT);
const DEFAULT_SEMANTIC_TOKENS_CONTEXT = {
  id: undefined,
  tokens: EMPTY_SEMANTIC_TOKENS
};
const SemanticTokensContext = (0,react.createContext)(DEFAULT_SEMANTIC_TOKENS_CONTEXT);
const useSemanticTokens = () => {
  const contextValue = (0,react.useContext)(SemanticTokensContext);

  if (contextValue.id == null) {
    console.error('Trying to use tokens context outside of provider.');
  }

  return contextValue.tokens;
};
// Query for styles added at build time
const initialStyleElementsById = Array.from(document.querySelectorAll(`head style[id^="${COLLECTION_STYLE_ID_PREFIX}"]`)).reduce((stylesMap, element) => SemanticTokensProvider_objectSpread(SemanticTokensProvider_objectSpread({}, stylesMap), {}, {
  [element.id.replace(COLLECTION_STYLE_ID_PREFIX, '')]: element
}), {});
const SemanticCollectionsManager = ({
  children
}) => {
  const styleElementsById = (0,react.useRef)(initialStyleElementsById);
  const registeredCollections = (0,react.useRef)({});
  const contextValue = (0,react.useMemo)(() => ({
    registerCollection: collection => {
      // In development we want to update styling when a collections changes, eg. for hot module reloading
      if (false) {} // In production we don't have a use case (yet) for updating styling dynamically, so ignore updates of collections


      if (true) {
        if (styleElementsById.current[collection.id] != null) {
          return;
        }
      }

      const styleId = getCollectionStyleId(collection.id); // Remove old styling (needed in Gameface)

      const oldStyleElement = document.querySelector(`head style[id="${styleId}"]`);

      if (oldStyleElement != null) {
        document.head.removeChild(oldStyleElement);
      } // Add new styling


      const style = document.createElement('style');
      style.id = styleId;
      style.innerHTML = collectionToClassName(collection);
      document.head.appendChild(style);
      styleElementsById.current[collection.id] = style;
      registeredCollections.current[collection.id] = collection;
    }
  }), []);
  return /*#__PURE__*/react.createElement(SemanticCollectionsManagerContext.Provider, {
    value: contextValue
  }, children);
};
const SemanticTokensProvider_SemanticTokensProvider = ({
  collection,
  children
}) => {
  const managerContext = (0,react.useContext)(SemanticCollectionsManagerContext);
  const registerCollection = managerContext === null || managerContext === void 0 ? void 0 : managerContext.registerCollection;
  const parentContext = (0,react.useContext)(SemanticTokensContext);
  (0,react.useEffect)(() => {
    if (collection == null || registerCollection == null) {
      return;
    }

    registerCollection(collection);
  }, [collection, registerCollection]);
  const collectionContextValue = (0,react.useMemo)(() => {
    const tokens = getSemanticTokens(collection, parentContext.tokens);
    return {
      id: collection === null || collection === void 0 ? void 0 : collection.id,
      tokens
    };
  }, [collection, parentContext]);

  if (collection == null) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(SemanticTokensContext.Provider, {
    value: collectionContextValue
  }, children);
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/collectionCreator.ts


const collectionCreator = collection => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const collectionWithFallbacks = {
    id: collection.id,
    color: {},
    component: collection.component,
    sound: {}
  };

  for (const role of ROLES) {
    var _collection$sound, _collection$sound2;

    collectionWithFallbacks.sound[role] = ((_collection$sound = collection.sound) === null || _collection$sound === void 0 ? void 0 : _collection$sound[role]) || ((_collection$sound2 = collection.sound) === null || _collection$sound2 === void 0 ? void 0 : _collection$sound2[DEFAULT_ROLE]) || {};

    if (!collection.color[role]) {
      continue;
    }

    collectionWithFallbacks.color[role] = {};

    for (const element of ELEMENTS) {
      var _collection$color;

      const roleCollection = collection.color[role];
      const fallbackRole = (_collection$color = collection.color) === null || _collection$color === void 0 ? void 0 : _collection$color[DEFAULT_ROLE];
      const elementCollection = roleCollection === null || roleCollection === void 0 ? void 0 : roleCollection[element];

      if (isForegroundElement(element)) {
        for (const variant of VARIANTS) {
          if (hasVariant(elementCollection, variant) || elementCollection == null && variant === DEFAULT_FOREGROUND_VARIANT) {
            var _collectionWithFallba, _fallbackRole$element, _fallbackRole$element2, _ref, _ref2, _variantCollection$DI;

            collectionWithFallbacks.color[role][element] = (_collectionWithFallba = collectionWithFallbacks.color[role][element]) !== null && _collectionWithFallba !== void 0 ? _collectionWithFallba : {};
            const variantCollection = elementCollection === null || elementCollection === void 0 ? void 0 : elementCollection[variant];
            const fallbackVariant = elementCollection === null || elementCollection === void 0 ? void 0 : elementCollection[DEFAULT_FOREGROUND_VARIANT];
            const fallbackRoleVariant = (fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element = fallbackRole[element]) === null || _fallbackRole$element === void 0 ? void 0 : _fallbackRole$element[variant]) || (fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element2 = fallbackRole[element]) === null || _fallbackRole$element2 === void 0 ? void 0 : _fallbackRole$element2[DEFAULT_FOREGROUND_VARIANT]);
            collectionWithFallbacks.color[role][element][variant] = (_ref = variantCollection !== null && variantCollection !== void 0 ? variantCollection : fallbackVariant) !== null && _ref !== void 0 ? _ref : fallbackRoleVariant;
            const disabledValue = (_ref2 = (_variantCollection$DI = variantCollection === null || variantCollection === void 0 ? void 0 : variantCollection[DISABLED]) !== null && _variantCollection$DI !== void 0 ? _variantCollection$DI : fallbackVariant === null || fallbackVariant === void 0 ? void 0 : fallbackVariant[DISABLED]) !== null && _ref2 !== void 0 ? _ref2 : fallbackRoleVariant === null || fallbackRoleVariant === void 0 ? void 0 : fallbackRoleVariant[DISABLED];

            if (disabledValue != null) {
              collectionWithFallbacks.color[role][element][variant].disabled = disabledValue;
            }
          }
        }
      } else {
        if (roleCollection) {
          const elementCollectionWithFallback = elementCollection !== null && elementCollection !== void 0 ? elementCollection : fallbackRole === null || fallbackRole === void 0 ? void 0 : fallbackRole[element];

          if (isInteractiveCollection(elementCollectionWithFallback)) {
            var _collectionWithFallba2, _elementCollectionWit, _fallbackRole$element3;

            collectionWithFallbacks.color[role][element] = (_collectionWithFallba2 = collectionWithFallbacks.color[role][element]) !== null && _collectionWithFallba2 !== void 0 ? _collectionWithFallba2 : {};
            collectionWithFallbacks.color[role][element] = elementCollectionWithFallback;
            const disabledValue = (_elementCollectionWit = elementCollectionWithFallback === null || elementCollectionWithFallback === void 0 ? void 0 : elementCollectionWithFallback[DISABLED]) !== null && _elementCollectionWit !== void 0 ? _elementCollectionWit : fallbackRole === null || fallbackRole === void 0 ? void 0 : (_fallbackRole$element3 = fallbackRole[element]) === null || _fallbackRole$element3 === void 0 ? void 0 : _fallbackRole$element3[DISABLED];

            if (disabledValue != null) {
              collectionWithFallbacks.color[role][element].disabled = disabledValue;
            }
          }
        }
      }
    }
  }

  return collectionWithFallbacks;
};
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/testHelpers.tsx
function testHelpers_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function testHelpers_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { testHelpers_ownKeys(Object(source), true).forEach(function (key) { testHelpers_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { testHelpers_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function testHelpers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







const createColorRoleCollection = value => {
  const modifiersCollection = MODIFIERS.reduce((acc, modifier) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
    [modifier]: value
  }), {});
  return ELEMENTS.reduce((elementsCollection, element) => {
    if (isForegroundElement(element)) {
      return testHelpers_objectSpread(testHelpers_objectSpread({}, elementsCollection), {}, {
        [element]: VARIANTS.reduce((variantsCollection, variant) => {
          return testHelpers_objectSpread(testHelpers_objectSpread({}, variantsCollection), {}, {
            [variant]: modifiersCollection
          });
        }, {})
      });
    }

    return testHelpers_objectSpread(testHelpers_objectSpread({}, elementsCollection), {}, {
      [element]: modifiersCollection
    });
  }, {});
};

const createSoundsForRoleCollection = (id, role) => SOUND_EVENTS.reduce((acc, sound) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
  [sound]: `${id}.${role}.${sound}`
}), {});

const createComponentCollection = componentName => {
  return ROLES.reduce((rolesCollection, role) => {
    const componentElements = Array.isArray(COMPONENT_ELEMENTS_MAP[componentName]) ? COMPONENT_ELEMENTS_MAP[componentName] : [];
    return testHelpers_objectSpread(testHelpers_objectSpread({}, rolesCollection), {}, {
      [role]: componentElements.reduce((componentElementsCollection, componentElement) => testHelpers_objectSpread(testHelpers_objectSpread({}, componentElementsCollection), {}, {
        [componentElement]: {}
      }), {})
    });
  }, {});
};

const createMockCollection = ({
  defineComponentsCollection
}) => {
  const id = 'mockTokens';
  const componentsCollection = defineComponentsCollection ? COMPONENT_NAMES.reduce((acc, componentName) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
    [componentName]: createComponentCollection(componentName)
  }), {}) : undefined;
  return collectionCreator({
    id,
    color: ROLES.reduce((acc, role) => testHelpers_objectSpread(testHelpers_objectSpread({}, acc), {}, {
      [role]: createColorRoleCollection('mock')
    }), {}),
    sound: ROLES.reduce((roles, role) => testHelpers_objectSpread(testHelpers_objectSpread({}, roles), {}, {
      [role]: createSoundsForRoleCollection(id, role)
    }), {}),
    component: componentsCollection
  });
}; // A collection that defines all possible values. The idea is that if the collection / token structure
// is changed or if anything is added to the structure that it also should be added to this collection.
// This collection is used in our unit tests and a full collection that is not tied to a specific app's / game's
// collection will unsure that component snapshots are reflecting all possible tokens that it can apply,
// but are also being stable even though tokens for an app / game changes.


const mockCollection = createMockCollection({
  defineComponentsCollection: false
});
const MockSemanticTokensProvider = ({
  children
}) => {
  return /*#__PURE__*/React.createElement(SemanticTokensProvider, {
    collection: mockCollection
  }, children);
}; // Same collection as `mockCollection`, but also defines component collections for all components.

const mockCollectionWithComponentCollections = createMockCollection({
  defineComponentsCollection: true
}); // A collection derived from vanilla that defines a good chunk of values, but not all of them.
// We expose this base collection, before it is sent through the collection creator in order
// to be able to snapshot test the collection creator with it.

const baseExampleCollection = {
  id: 'example',
  sound: {
    neutral: {
      reject: 'note.bass',
      press: 'random.click',
      contract: 'random.click',
      expand: 'random.click',
      toggle: 'random.click',
      lift: 'random.click',
      click: 'random.click'
    },
    primary: {
      press: 'tokens.vanilla.release'
    }
  },
  color: {
    neutral: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red',
        disabled: 'red'
      },
      text: {
        dimmer: {
          default: 'red',
          disabled: 'red'
        },
        dimmest: {
          default: 'red'
        },
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      shadow: {
        default: 'red',
        disabled: 'red'
      },
      dropShadow: {
        default: 'red'
      },
      icon: {
        regular: {
          default: 'red',
          disabled: 'red'
        },
        dimmer: {
          default: 'red'
        },
        dimmest: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      caret: {
        regular: {
          default: 'red'
        }
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      },
      bevel: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      },
      outline: {
        default: 'red'
      },
      highlight: {
        default: 'transparent',
        hovered: 'red'
      },
      overlay: {
        default: 'red'
      }
    },
    neutral20: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      shadow: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      icon: {
        regular: {
          default: 'red'
        }
      },
      outline: {
        default: 'red'
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      }
    },
    neutral50: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      border: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      overlay: {
        default: 'red'
      }
    },
    neutral60: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      border: {
        dimmest: {
          default: 'red'
        }
      },
      text: {
        regular: {
          default: 'red'
        }
      }
    },
    neutral80: {
      background: {
        default: 'red',
        hovered: 'red',
        selected: 'red',
        pressed: 'red'
      },
      shadow: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        },
        dimmer: {
          default: 'red'
        },
        dimmest: {
          default: 'red'
        }
      },
      caret: {
        regular: {
          default: 'red'
        }
      },
      bevel: {
        default: {
          top: 'red',
          bottom: 'red'
        },
        hovered: {
          top: 'red',
          bottom: 'red'
        },
        pressed: {
          top: 'red',
          bottom: 'red'
        },
        selected: {
          top: 'red',
          bottom: 'red'
        }
      }
    },
    neutral100: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        },
        dimmer: {
          default: 'red'
        },
        dimmest: {
          default: 'red'
        }
      }
    },
    primary: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      shadow: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      icon: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      }
    },
    primaryTint: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    secondary: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      icon: {
        regular: {
          default: 'red'
        }
      },
      shadow: {
        default: 'red'
      },
      border: {
        regular: {
          default: 'red'
        }
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      }
    },
    success: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      }
    },
    successTint: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    informative: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    informativeTint: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    destructive: {
      background: {
        default: 'red',
        hovered: 'red',
        pressed: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      icon: {
        regular: {
          default: 'red'
        }
      },
      shadow: {
        default: 'red'
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      }
    },
    destructiveTint: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    notice: {
      background: {
        default: 'red'
      }
    },
    noticeTint: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red'
        }
      },
      border: {
        regular: {
          default: 'red'
        }
      }
    },
    paper: {
      background: {
        default: 'red'
      },
      text: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      icon: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      border: {
        regular: {
          default: 'red',
          disabled: 'red'
        }
      },
      caret: {
        regular: {
          default: 'red'
        }
      },
      specular: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      },
      bevel: {
        default: {
          top: 'red',
          bottom: 'red'
        }
      },
      outline: {
        default: 'red'
      },
      highlight: {
        default: 'transparent',
        hovered: 'red'
      }
    }
  },
  component: {
    panel: {
      neutral: {
        main: {
          default: {
            borderImageSlice: '27 27 27 26 fill',
            borderImageWidth: '4rem',
            borderImageSource: 'panel'
          },
          hovered: {
            borderImageSlice: '27 27 27 26 fill',
            borderImageWidth: '4rem',
            borderImageSource: 'panel'
          }
        }
      }
    },
    pressable: {
      primary: {
        main: {
          default: {
            borderImageSlice: '62 62 62 62 fill',
            borderImageWidth: '15',
            borderImageSource: 'pressablePrimaryDefault'
          },
          hovered: {
            borderImageSlice: '62 62 62 62 fill',
            borderImageWidth: '15',
            borderImageSource: 'pressablePrimaryHovered'
          },
          pressed: {
            borderImageSlice: '62 62 62 62 fill',
            borderImageWidth: '15',
            borderImageSource: 'pressablePrimaryPressed'
          },
          disabled: {
            borderImageSlice: '62 62 62 62 fill',
            borderImageWidth: '15',
            borderImageSource: 'pressablePrimaryDisabled'
          },
          focused: {
            borderImageSlice: '62 62 62 62 fill',
            borderImageWidth: '15',
            borderImageSource: 'pressablePrimaryFocused'
          }
        }
      }
    }
  }
}; // A collection derived from vanilla that defines a good chunk of values, but not all of them.

const exampleCollection = collectionCreator(baseExampleCollection);
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/hooks.ts
function hooks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function hooks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { hooks_ownKeys(Object(source), true).forEach(function (key) { hooks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { hooks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hooks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function hooks_useSemanticColors(roleProp) {
  const tokens = useSemanticTokens();
  const inheritedRole = useInheritedSemanticRole();
  const role = roleProp === 'inherit' ? inheritedRole : roleProp;
  return role == null ? hooks_objectSpread(hooks_objectSpread({}, tokens.color), {}, {
    inherit: tokens.color[inheritedRole]
  }) : tokens.color[role];
}
function useSemanticColorValues(roleProp) {
  const tokens = useSemanticTokens();
  const inheritedRole = useInheritedSemanticRole();
  const role = roleProp === 'inherit' ? inheritedRole : roleProp;
  return role == null ? hooks_objectSpread(hooks_objectSpread({}, tokens.rawColor), {}, {
    inherit: tokens.rawColor[inheritedRole]
  }) : tokens.rawColor[role];
}
function useSemanticSounds(roleProp) {
  const tokens = useSemanticTokens();
  const inheritedRole = useInheritedSemanticRole();
  const role = roleProp === 'inherit' ? inheritedRole : roleProp;
  return role == null ? hooks_objectSpread(hooks_objectSpread({}, tokens.sound), {}, {
    inherit: tokens.sound[inheritedRole]
  }) : tokens.sound[role];
}
function useSemanticComponentTokens(componentName, roleProp) {
  const tokens = useSemanticTokens();
  const inheritedRole = useInheritedSemanticRole();
  const role = roleProp === 'inherit' ? inheritedRole : roleProp;
  return role == null ? hooks_objectSpread(hooks_objectSpread({}, tokens.component[componentName]), {}, {
    inherit: tokens.component[componentName][inheritedRole]
  }) : tokens.component[componentName][role];
}
function useSemanticVariants() {
  const tokens = useSemanticTokens();
  return tokens.variant;
}
function useSemanticModifiers() {
  const tokens = useSemanticTokens();
  return tokens.modifier;
}
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/index.ts









;// CONCATENATED MODULE: ./packages/react-router-ish/src/RouterProvider.tsx


const RouterProvider = ({
  state,
  api,
  children
}) => {
  return /*#__PURE__*/react.createElement(apiContext.Provider, {
    value: api
  }, /*#__PURE__*/react.createElement(context_stateContext.Provider, {
    value: state
  }, children));
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/routerFacet.ts


/**
 * Constant shared with the backend to indicate that even though the Gameface view is initialized,
 * we don't have any active routes.
 */
const ROUTER_INVALID_ROUTE = '/__INVALID_ROUTE__';
const ROUTER_FACET = 'core.router';
/**
 * React Hook that requests the facet
 */

const routerFacet_routerFacet = (0,react_facet_src.sharedFacet)(ROUTER_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/RouterEngineProvider.tsx










/**
 * Provider that setups our routing and gamepad infrastructure, given the focus is tied to navigating URLs in the application.
 */
function RouterEngineProvider({
  children,
  keyboardGamepadMap,
  isInputLegendClickable
}) {
  const routerFacet = (0,react_facet_src.useSharedFacet)(routerFacet_routerFacet);
  const routerState = (0,react_facet_src.useFacetMap)(routerFacet => {
    const list = routerFacet.history.list;
    return {
      length: routerFacet.history.length,
      action: routerFacet.history.action,
      list: list.length === 0 ? [// In backend, its possible to have an empty history, but that is not expected by the frontend
      {
        pathname: '/__INVALID_ROUTE__',
        hash: '',
        search: '',
        state: ''
      }] : list
    };
  }, [], [routerFacet]);
  const goBack = (0,react_facet_src.useFacetCallback)(({
    history
  }) => () => {
    history.goBack();
  }, [], [routerFacet]);
  const push = (0,react_facet_src.useFacetCallback)(({
    history
  }) => route => {
    history.push(route, '');
  }, [], [routerFacet]);
  const replace = (0,react_facet_src.useFacetCallback)(({
    history
  }) => route => {
    history.replace(route, '');
  }, [], [routerFacet]);
  const routerAPI = (0,react.useMemo)(() => ({
    goBack,
    push,
    replace
  }), [goBack, push, replace]);
  const triggerSound = useSoundEffectTrigger();
  const isNarrationEnabled = useNarrationEnabled();
  const semanticSounds = useSemanticSounds('neutral');
  const semanticRejectSound = semanticSounds === null || semanticSounds === void 0 ? void 0 : semanticSounds.reject; // semanticSounds can be undefined if a collection isn't provided to the application

  const handleFocusedIdChangeFail = (0,react.useCallback)(() => {
    if (isNarrationEnabled && semanticRejectSound != null) {
      triggerSound(semanticRejectSound, 0, 0.5, 0.75);
    }
  }, [isNarrationEnabled, triggerSound, semanticRejectSound]);
  const notifyFocusRequest = (0,react.useCallback)(onHistoryChange => {
    const cleanup = routerState.observe(({
      list
    }) => {
      const location = list[list.length - 1];
      if (location == null) return;
      const focusedId = getFocusedIdFromLocation(location);

      if (focusedId != null) {
        onHistoryChange(focusedId);
      }
    });
    return cleanup;
  }, [routerState]);
  return /*#__PURE__*/react.createElement(GamepadEngineProvider, {
    notifyFocusRequest: notifyFocusRequest,
    onFocusedIdChangeFail: handleFocusedIdChangeFail,
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, /*#__PURE__*/react.createElement(RouterProvider, {
    state: routerState,
    api: routerAPI
  }, children));
}
;// CONCATENATED MODULE: ./packages/react-router-ish/src/OverrideRouteIsActive.tsx




/**
 * Helper component that can be used by transition animation components to override the status of a route being active.
 */
const OverrideRouteIsActive = ({
  value,
  isInBackground,
  children
}) => {
  const isActiveFacet = (0,dist.useFacetWrap)(value);
  const isInBackgroundFacet = (0,dist.useFacetWrap)(isInBackground !== null && isInBackground !== void 0 ? isInBackground : false);
  const disabledAPI = (0,dist.useFacetMap)(isActive => !isActive, [], [isActiveFacet]);
  return /*#__PURE__*/react.createElement(DisableAPIProvider, {
    disabled: disabledAPI
  }, /*#__PURE__*/react.createElement(isActiveContext.Provider, {
    value: isActiveFacet
  }, isInBackground != null ? /*#__PURE__*/react.createElement(context_isInBackgroundContext.Provider, {
    value: isInBackgroundFacet
  }, children) : children));
};

/**
 * We override the API within a route to prevent navigation being triggered in unmatched routes.
 */
const DisableAPIProvider = ({
  children,
  disabled
}) => {
  const api = (0,react.useContext)(apiContext);
  const goBack = (0,dist.useFacetCallback)(disabled => () => {
    if (disabled) return;
    api.goBack();
  }, [api], [disabled]);
  const push = (0,dist.useFacetCallback)(disabled => route => {
    if (disabled) return;
    api.push(route);
  }, [api], [disabled]);
  const replace = (0,dist.useFacetCallback)(disabled => route => {
    if (disabled) return;
    api.replace(route);
  }, [api], [disabled]);
  const historyAPI = (0,react.useMemo)(() => ({
    goBack,
    push,
    replace
  }), [goBack, push, replace]);
  return /*#__PURE__*/react.createElement(apiContext.Provider, {
    value: historyAPI
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-router-ish/src/Route.tsx





const Route = ({
  route,
  component,
  transitionComponent: routeTransition,
  alwaysMounted,
  unmountOnPush,
  keepMountedOnPop,
  match,
  action = 'PUSH'
}) => {
  /**
   * Keeps the last known value of the params even after the route is no longer matching.
   * This is important for transitions to run while having access to the params of the route.
   */
  const paramsRef = (0,react.useRef)({});

  if (match != null) {
    paramsRef.current = match.params;
  } // Make sure to perform an equality check to prevent unnecessary updates


  const params = (0,dist.useFacetWrap)(paramsRef.current, dist.shallowObjectEqualityCheck);
  return /*#__PURE__*/react.createElement(IsInBackgroundProvider, {
    route: route
  }, /*#__PURE__*/react.createElement(paramsContext.Provider, {
    value: params
  }, /*#__PURE__*/react.createElement(OverrideRouteIsActive, {
    value: match != null
  }, /*#__PURE__*/react.createElement(RouteChild, {
    alwaysMounted: alwaysMounted,
    unmountOnPush: unmountOnPush,
    keepMountedOnPop: keepMountedOnPop,
    component: component,
    routeTransition: routeTransition,
    action: action,
    currentIn: match != null
  }))));
};

/**
 * Memoized child component that takes care of preparing an environment for the route component to render
 *
 * The goal is to re-render this only when necessary
 */
const RouteChild = react.memo(({
  component,
  routeTransition,
  action,
  currentIn,
  alwaysMounted,
  unmountOnPush,
  keepMountedOnPop
}) => {
  const mountComponentRef = (0,react.useRef)(null);
  const previouslyInRef = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    previouslyInRef.current = currentIn;
  }, [currentIn]); // Handles lazy rendering of a route
  // It works by having its default value as null (so not mounted)
  // Once the route is first mounted, mountComponentRef.current will be true permanently
  // This is used to maintain the state of routes as we navigate in the application

  mountComponentRef.current = mountComponentRef.current || currentIn; // If we POP from this route, we need to unmount it
  // We don't want to keep its state

  if (action === 'POP' && previouslyInRef.current && !keepMountedOnPop) {
    mountComponentRef.current = false;
  }

  const isNavigatingBack = action === 'POP';
  const RouteComponent = component;
  const RouteTransition = routeTransition;
  const unmountOnExit = !mountComponentRef.current || !!unmountOnPush;
  return /*#__PURE__*/react.createElement(RouteTransition, {
    visible: currentIn,
    alwaysMounted: alwaysMounted,
    unmountOnExit: unmountOnExit,
    contentComponent: RouteComponent,
    inverse: isNavigatingBack
  });
});

const IsInBackgroundProvider = ({
  route,
  children
}) => {
  const state = (0,react.useContext)(context_stateContext);
  const matchMemo = (0,react.useMemo)(() => match(route), [route]);
  const isInBackground = (0,dist.useFacetMemo)(({
    list
  }) => list.find(({
    pathname
  }, index) => index != list.length - 1 && matchMemo(pathname)) != null, [matchMemo], [state]);
  return /*#__PURE__*/react.createElement(context_isInBackgroundContext.Provider, {
    value: isInBackground
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/pathContext.tsx

const pathContext_PathContext = (0,react.createContext)([]);
const {
  Provider: pathContext_Provider,
  Consumer: pathContext_Consumer
} = pathContext_PathContext;

;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/id.tsx
// starts with 1 given 0 has a falsy value and can lead to incorrect checks
let seed = 1;
const __generateId = () => seed++;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/boundedFocusContext.ts

const boundedFocusContext_Context = (0,react.createContext)(true);
const useShouldBoundFocus = () => (0,react.useContext)(boundedFocusContext_Context);
const BoundedFocusProvider = boundedFocusContext_Context.Provider;
const BoundedFocusConsumer = boundedFocusContext_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useContainer.tsx






function useContainer(gamepad, type, ref, nodeIdRef) {
  const shouldBoundFocus = useShouldBoundFocus();
  const id = (0,react.useMemo)(() => __generateId(), []);

  if (nodeIdRef) {
    nodeIdRef.current = id;
  }

  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const api = (0,react.useContext)(GamepadAPIContext);
  const path = (0,react.useContext)(pathContext_PathContext);
  /**
   * Tries to add the container to the focus tree during the render body to make sure it is available by the time
   * any focusable is rendered.
   *
   * If we rely only on effects, React runs the leaves first (adding the focusables before the containers).
   */

  const gamepadValue = gamepadFacet.get();

  if (gamepadValue != null && gamepadValue != react_facet_src.NO_VALUE) {
    const container = {
      type: type,
      id: id,
      path: path,
      bounded: shouldBoundFocus && gamepadValue.bounded,
      index: gamepadValue.index,
      defaultFocusedChildAlias: gamepadValue.defaultFocusedChildAlias,
      defaultFocusedChildBehavior: gamepadValue.defaultFocusedChildBehavior,
      disabled: gamepadValue.disabled,
      ref: ref,
      scrollWithAnalog: gamepadValue.scrollWithAnalog,
      scrollIntoView: gamepadValue.scrollIntoView,
      scrollIntoViewAlign: gamepadValue.scrollIntoViewAlign,
      scrollIntoViewOffset: gamepadValue.scrollIntoViewOffset,
      scrollIntoViewSpeedFactor: gamepadValue.scrollIntoViewSpeedFactor
    };
    api.addOrUpdateNode(container);
  }

  (0,react_facet_src.useFacetEffect)(gamepad => {
    const container = {
      type: type,
      id: id,
      path: path,
      bounded: shouldBoundFocus && gamepad.bounded,
      index: gamepad.index,
      defaultFocusedChildAlias: gamepad.defaultFocusedChildAlias,
      defaultFocusedChildBehavior: gamepad.defaultFocusedChildBehavior,
      disabled: gamepad.disabled,
      ref: ref,
      scrollWithAnalog: gamepad.scrollWithAnalog,
      scrollIntoView: gamepad.scrollIntoView,
      scrollIntoViewAlign: gamepad.scrollIntoViewAlign,
      scrollIntoViewOffset: gamepad.scrollIntoViewOffset,
      scrollIntoViewSpeedFactor: gamepad.scrollIntoViewSpeedFactor
    };
    api.addOrUpdateNode(container);
  }, [api, id, path, type, ref, shouldBoundFocus], [gamepadFacet]); // does nothing on mount
  // doesn't run on updates
  // remove on unmount

  (0,react.useEffect)(() => () => api.removeNode(id), [api, id]);
  const pathWithId = [...path, id];
  const Wrapper = (0,react.useMemo)(() => ({
    children
  }) => /*#__PURE__*/react.createElement(pathContext_Provider, {
    value: pathWithId
  }, children), // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps
  pathWithId);
  return Wrapper;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useRow.tsx

function useRow(gamepad, ref, nodeIdRef) {
  return useContainer(gamepad, 'row', ref, nodeIdRef);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useColumn.tsx

function useColumn(gamepad, ref, nodeIdRef) {
  return useContainer(gamepad, 'column', ref, nodeIdRef);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/deprecated.tsx




/**
 * @deprecated use Row instead
 */
function GamepadRow(props) {
  const gamepad = {
    bounded: props.bounded,
    disabled: props.disabled,
    index: props.gamepadIndex,
    defaultFocusedChildAlias: props.defaultFocusedChildAlias,
    defaultFocusedChildBehavior: props.defaultFocusedChildBehavior,
    scrollWithAnalog: props.scrollWithAnalog,
    scrollIntoView: props.scrollIntoView,
    scrollIntoViewAlign: props.scrollIntoViewAlign,
    scrollIntoViewOffset: props.scrollIntoViewOffset,
    scrollIntoViewSpeedFactor: props.scrollIntoViewSpeedFactor
  };
  const Row = useRow(gamepad, props.scrollRef, props.nodeIdRef);
  return /*#__PURE__*/react.createElement(Row, null, props.children);
}

/**
 * @deprecated use Column instead
 */
function GamepadColumn(props) {
  const gamepad = {
    bounded: props.bounded,
    disabled: props.disabled,
    index: props.gamepadIndex,
    defaultFocusedChildAlias: props.defaultFocusedChildAlias,
    defaultFocusedChildBehavior: props.defaultFocusedChildBehavior,
    scrollWithAnalog: props.scrollWithAnalog,
    scrollIntoView: props.scrollIntoView,
    scrollIntoViewAlign: props.scrollIntoViewAlign,
    scrollIntoViewOffset: props.scrollIntoViewOffset,
    scrollIntoViewSpeedFactor: props.scrollIntoViewSpeedFactor
  };
  const Column = useColumn(gamepad, props.scrollRef, props.nodeIdRef);
  return /*#__PURE__*/react.createElement(Column, null, props.children);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/id.tsx

let id_seed = ROOT_NODE_ID + 1;
const id_generateId = () => id_seed++;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/FocusGroup.tsx





const FocusGroup = ({
  children,
  disabled,
  hidden
}) => {
  const id = (0,react.useMemo)(() => id_generateId(), []);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const focusTreeAPIRef = (0,react.useContext)(focusTreeAPI_FocusTreeAPIContext);
  const path = (0,react.useContext)(PathContext);
  const parentId = path[path.length - 1];
  const unObserve = (0,react.useRef)();
  /**
   * Tries to add the container to the focus tree during the render body to make sure it is available by the time
   * any focusable is rendered.LandmarkType
   *
   * If we rely only on effects, React runs the leaves first (adding the focusables before the containers).
   */

  (0,react.useMemo)(() => {
    var _unObserve$current;

    (_unObserve$current = unObserve.current) === null || _unObserve$current === void 0 ? void 0 : _unObserve$current.call(unObserve);
    unObserve.current = (0,react_facet_src.multiObserve)((disabled, hidden) => {
      const container = {
        id: id,
        type: types_FocusTreeNodeType.FOCUS_GROUP,
        disabled: disabled === true,
        hidden: hidden === true
      };
      focusTreeAPIRef.current.putNode(container, parentId);
    }, [disabledFacet, hiddenFacet]);
  }, [id, focusTreeAPIRef, parentId, disabledFacet, hiddenFacet]);
  (0,react.useEffect)(() => () => {
    var _unObserve$current2;

    (_unObserve$current2 = unObserve.current) === null || _unObserve$current2 === void 0 ? void 0 : _unObserve$current2.call(unObserve);
  }, []); // does nothing on mount
  // doesn't run on updates
  // remove on unmount

  (0,react.useEffect)(() => () => focusTreeAPIRef.current.removeNode(id), [focusTreeAPIRef, id]);
  const pathWithId = [...path, id];
  const FocusGroup = (0,react.useMemo)(() => ({
    children
  }) => /*#__PURE__*/react.createElement(PathContext.Provider, {
    value: pathWithId
  }, children), // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps
  pathWithId);
  return /*#__PURE__*/react.createElement(FocusGroup, null, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/disableFocusBinding.ts

const disableFocusBinding_Context = (0,react.createContext)(false);
const useDisableFocusBinding = () => (0,react.useContext)(disableFocusBinding_Context);
const DisableFocusBindingProvider = disableFocusBinding_Context.Provider;
const DisableFocusBindingConsumer = disableFocusBinding_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/context/refreshFocus.tsx


const refreshFocus_Context = (0,react_facet_src.createFacetContext)(undefined);
const useRefreshFocus = () => (0,react.useContext)(refreshFocus_Context);
const RefreshFocusProvider = refreshFocus_Context.Provider;
const RefreshFocusConsumer = refreshFocus_Context.Consumer;
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/Landmark.tsx
function Landmark_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Landmark_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Landmark_ownKeys(Object(source), true).forEach(function (key) { Landmark_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Landmark_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Landmark_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const NO_LANDMARK_KEY = 'NO_LANDMARK_KEY';
const Landmark = ({
  children,
  disabled,
  hidden,
  focusControlDisabled,
  alias,
  scrollAxis,
  scrollOptions,
  shouldBindFocus,
  containerRef,
  delegateFocusFromMemory,
  delegateFocusByAlias,
  landmarkKey,
  isGrid,
  gridContainerWidth,
  gridContainerHeight,
  gridItemWidth,
  gridItemHeight
}) => {
  if (false) {}

  const id = (0,react.useMemo)(() => id_generateId(), []);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const focusControlDisabledFacet = (0,react_facet_src.useFacetWrap)(focusControlDisabled);
  const delegateFocusFromMemoryFacet = (0,react_facet_src.useFacetWrap)(delegateFocusFromMemory);
  const delegateFocusByAliasFacet = (0,react_facet_src.useFacetWrap)(delegateFocusByAlias);
  const scrollAxisFacet = (0,react_facet_src.useFacetWrap)(scrollAxis);
  const aliasFacet = (0,react_facet_src.useFacetWrap)(alias);
  const scrollOptionsFacet = (0,react_facet_src.useFacetWrap)(scrollOptions);
  const shouldBindFocusFacet = (0,react_facet_src.useFacetWrap)(shouldBindFocus);
  const landmarkKeyFacet = (0,react_facet_src.useFacetWrap)(landmarkKey);
  const isGridFacet = (0,react_facet_src.useFacetWrap)(isGrid);
  const gridContainerWidthFacet = (0,react_facet_src.useFacetWrap)(gridContainerWidth);
  const gridContainerHeightFacet = (0,react_facet_src.useFacetWrap)(gridContainerHeight);
  const gridItemWidthFacet = (0,react_facet_src.useFacetWrap)(gridItemWidth);
  const gridItemHeightFacet = (0,react_facet_src.useFacetWrap)(gridItemHeight);
  const disableFocusBinding = useDisableFocusBinding();
  const focusTreeAPIRef = (0,react.useContext)(focusTreeAPI_FocusTreeAPIContext);
  const path = (0,react.useContext)(PathContext);
  const refreshFocusFacet = useRefreshFocus();
  const parentId = path[path.length - 1];
  const setFocusedId = setFocusedId_useSetFocusedId();
  const createIsElementAncestorOf = (0,react.useCallback)(id => element => {
    var _element$getAttribute;

    const idAttribute = (_element$getAttribute = element.getAttribute(types_DATA_FOCUSABLE_ID)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : element.getAttribute(DATA_LANDMARK_ID);
    if (idAttribute == null) return false;
    const elementId = parseInt(idAttribute, 10);
    return id === elementId || focusTreeAPIRef.current.isAncestorOf(id, elementId);
  }, [focusTreeAPIRef]);
  const getDelegatedFocus = (0,react_facet_src.useFacetCallback)(delegateFocusFromMemory => cachedDescendantElements => {
    var _containerRef$current, _containerRef$current2;

    if (focusControlDisabledFacet.get() === true) {
      console.warn('Asked a FocusControlDisabled Landmark to delegate, abort mission. (find out why)');
    }

    const enabledBindingLandmarkDescendant = focusTreeAPIRef.current.getEnabledBindingLandmarkDescendant(id); // We start by looking at enabled binding landmark descendants.
    // Binding landmarks take priority over any other behavior

    if (enabledBindingLandmarkDescendant != null) {
      const cachedDescendantElementsOfMemory = cachedDescendantElements === null || cachedDescendantElements === void 0 ? void 0 : cachedDescendantElements.filter(createIsElementAncestorOf(enabledBindingLandmarkDescendant.id));
      const delegatedFocus = enabledBindingLandmarkDescendant.getDelegatedFocus(cachedDescendantElementsOfMemory);

      if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
        return delegatedFocus;
      }
    }

    const element = focusTreeAPIRef.current.getElement(id);
    const dynasty = focusTreeAPIRef.current.getDynasty(id);
    const delegatingLandmark = types_isDelegatingLandmark(element) ? element : undefined; // Check memory for focusable descendant

    if (delegatingLandmark != null && delegateFocusFromMemory) {
      var _delegatingLandmark$l, _delegatingLandmark$d;

      const usedLandmarkKey = (_delegatingLandmark$l = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.landmarkKey) !== null && _delegatingLandmark$l !== void 0 ? _delegatingLandmark$l : NO_LANDMARK_KEY;
      const delegationMemoryStack = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : (_delegatingLandmark$d = delegatingLandmark.delegationMemoryStack) === null || _delegatingLandmark$d === void 0 ? void 0 : _delegatingLandmark$d.get(usedLandmarkKey);

      if (delegationMemoryStack != null) {
        // Loop through the memory stack and find the first available element
        let firstAvailableMemoryElement = undefined;

        for (let i = 0; i < delegationMemoryStack.length; i++) {
          const delegationMemoryId = delegationMemoryStack[i];
          const delegationMemoryElement = focusTreeAPIRef.current.getElement(delegationMemoryId);

          if (delegationMemoryElement != null && focusTreeAPIRef.current.isFocusable(delegationMemoryElement.id) && dynasty !== null && dynasty !== void 0 && dynasty.has(delegationMemoryElement.id)) {
            firstAvailableMemoryElement = delegationMemoryElement;
            break;
          }
        }

        if (firstAvailableMemoryElement != null) {
          const memoryDelegatingLandmark = types_isDelegatingLandmark(firstAvailableMemoryElement) ? firstAvailableMemoryElement : undefined;

          if (memoryDelegatingLandmark != null) {
            const cachedDecendantElementsOfMemory = cachedDescendantElements === null || cachedDescendantElements === void 0 ? void 0 : cachedDescendantElements.filter(createIsElementAncestorOf(memoryDelegatingLandmark.id));
            const delegatedFocus = memoryDelegatingLandmark.getDelegatedFocus(cachedDecendantElementsOfMemory);

            if (delegatedFocus != null && delegatedFocus != react_facet_src.NO_VALUE) {
              return delegatedFocus;
            }
          } else {
            return {
              id: firstAvailableMemoryElement.id,
              reason: NewFocusSuggestionReason.MemoryDelegation
            };
          }
        }
      }
    } // Delegate by alias. We are using the element ref here instead of the delegateFocusByAliasFacet
    // since we don't want to have several sources of truths.


    if (types_isDelegatingLandmark(focusTreeElement.current) && focusTreeElement.current.delegateFocusByAlias != null && focusTreeElement.current.delegateFocusByAlias != '') {
      const elementByAlias = focusTreeAPIRef.current.getElement(focusTreeElement.current.delegateFocusByAlias);

      if (elementByAlias != null && dynasty !== null && dynasty !== void 0 && dynasty.has(elementByAlias.id) && focusTreeAPIRef.current.isFocusable(elementByAlias.id)) {
        if (types_isDelegatingLandmark(elementByAlias)) {
          const cachedDecendantElementsOfMemory = cachedDescendantElements === null || cachedDescendantElements === void 0 ? void 0 : cachedDescendantElements.filter(createIsElementAncestorOf(elementByAlias.id));
          const delegatedFocus = elementByAlias.getDelegatedFocus(cachedDecendantElementsOfMemory);

          if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
            return delegatedFocus;
          }
        } else {
          return {
            id: elementByAlias.id,
            reason: NewFocusSuggestionReason.AliasDelegation
          };
        }
      }
    } // Get first focusable Descendant


    const defaultDelegatedId = focusTreeElement.current == null || focusTreeElement.current.hidden === true || focusTreeElement.current.disabled === true ? undefined : id;
    const defaultDelegatedFocus = defaultDelegatedId != null ? {
      id: defaultDelegatedId,
      reason: NewFocusSuggestionReason.DefaultDelegation
    } : undefined;
    const elements = cachedDescendantElements !== null && cachedDescendantElements !== void 0 ? cachedDescendantElements : Array.from((_containerRef$current = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelectorAll(`[${types_DATA_FOCUSABLE_ID}], [${DATA_LANDMARK_ID}]`)) !== null && _containerRef$current !== void 0 ? _containerRef$current : []);

    if (elements.length === 0) {
      return defaultDelegatedFocus;
    }

    for (let i = 0; i < elements.length; i++) {
      const landmarkIdAttribute = elements[i].getAttribute(DATA_LANDMARK_ID);
      const focusableIdAttribute = elements[i].getAttribute(types_DATA_FOCUSABLE_ID);

      if (landmarkIdAttribute != null) {
        const landmarkId = parseInt(landmarkIdAttribute, 10);

        if (!(dynasty !== null && dynasty !== void 0 && dynasty.has(landmarkId))) {
          continue;
        }

        const landmarkElement = focusTreeAPIRef.current.getElement(landmarkId);

        if (!types_isDelegatingLandmark(landmarkElement)) {
          continue;
        }

        if (!focusTreeAPIRef.current.isFocusable(landmarkId)) {
          continue;
        }

        const isElementAncestorOfLandmark = createIsElementAncestorOf(landmarkId);
        const landmarkDescendantElements = elements.filter(isElementAncestorOfLandmark);
        const delegatedFocus = landmarkElement.getDelegatedFocus(landmarkDescendantElements);

        if (delegatedFocus != react_facet_src.NO_VALUE && delegatedFocus != null) {
          return delegatedFocus;
        }
      } else if (focusableIdAttribute != null) {
        const focusableId = parseInt(focusableIdAttribute, 10);

        if (dynasty !== null && dynasty !== void 0 && dynasty.has(focusableId) && focusTreeAPIRef.current.isFocusable(focusableId)) {
          return {
            id: focusableId,
            reason: NewFocusSuggestionReason.FirstFoundDelegation
          };
        }
      }
    }

    return defaultDelegatedFocus;
  }, [focusTreeAPIRef, containerRef, createIsElementAncestorOf, id, focusControlDisabledFacet], [delegateFocusFromMemoryFacet]);
  const onFocusableOfDynastyFocused = (0,react.useCallback)((decendentId, origin) => {
    // We don't want to store the focused id for delegation memory when the focus
    // originates from a tree mutation, since we rely on the memory being stable
    // between focus tree mutations of a sub tree. Furthermore, it is arguable that
    // delegation after a focus tree mutation much rather should be calculated when
    // needed instead and isn't preferable to store.
    if (origin === FocusOrigin.FocusTreeMutation) return;
    const element = focusTreeAPIRef.current.getElement(id);
    const delegatingLandmark = types_isDelegatingLandmark(element) ? element : undefined;

    if ((delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.delegationMemoryStack) != null) {
      var _delegatingLandmark$l2;

      const usedLandmarkKey = (_delegatingLandmark$l2 = delegatingLandmark === null || delegatingLandmark === void 0 ? void 0 : delegatingLandmark.landmarkKey) !== null && _delegatingLandmark$l2 !== void 0 ? _delegatingLandmark$l2 : NO_LANDMARK_KEY; // We are intentionally mutating the delegationMemoryStack here without using
      // putNode, since this is considered local state of the node itself
      // and shouldn't cause any side effects / mutations of the rest of the tree or
      // to the currently focused element. The reason why we are doing this is because
      // calling putNode is a lot unnecessary overhead in this case. If we in the future
      // will do any other mutations to the node in this place then we should
      // consider to use putNode instead.

      const delegationMemoryStack = delegatingLandmark.delegationMemoryStack.get(usedLandmarkKey) || [];

      if (delegationMemoryStack != null) {
        // If the id already exists in the stack, remove it
        const itemIndexInStack = delegationMemoryStack.indexOf(decendentId);

        if (itemIndexInStack !== -1) {
          delegationMemoryStack.splice(itemIndexInStack, 1);
        } // Add the id to the top of the stack


        delegationMemoryStack.unshift(decendentId);
        delegatingLandmark.delegationMemoryStack.set(usedLandmarkKey, delegationMemoryStack);
      }
    }
  }, [focusTreeAPIRef, id]);
  const unObserve = (0,react.useRef)();
  const focusTreeElement = (0,react.useRef)(undefined);
  const refWasMissingOnFirstPutNode = (0,react.useRef)(false);
  /**
   * Tries to add the container to the focus tree during the render body to make sure it is available by the time
   * any focusable is rendered.LandmarkType
   *
   * If we rely only on effects, React runs the leaves first (adding the focusables before the containers).
   */

  (0,react.useMemo)(() => {
    var _unObserve$current;

    (_unObserve$current = unObserve.current) === null || _unObserve$current === void 0 ? void 0 : _unObserve$current.call(unObserve);
    unObserve.current = (0,react_facet_src.multiObserve)((disabled, hidden, focusControlDisabled, scrollAxis, alias, scrollOptions, shouldBindFocus, delegateFocusByAlias, delegateFocusFromMemory, landmarkKey, isGrid, gridContainerWidth, gridContainerHeight, gridItemWidth, gridItemHeight) => {
      const previousFocusable = focusTreeAPIRef.current.getElement(id);

      const container = Landmark_objectSpread(Landmark_objectSpread({
        scrollAxis: scrollAxis,
        type: types_FocusTreeNodeType.LANDMARK,
        id: id,
        ref: containerRef.current,
        alias: alias,
        scrollIntoViewAlign: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewAlign,
        scrollIntoViewOffset: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewOffset,
        scrollIntoViewSpeedFactor: scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.scrollIntoViewSpeedFactor,
        disabled: disabled === true,
        hidden: hidden === true,
        isGrid: isGrid === true,
        // We added nullish coalescing to 0 because we didnt manage to fix the ternary types yet in Landmark.tsx
        gridContainerWidth: gridContainerWidth !== null && gridContainerWidth !== void 0 ? gridContainerWidth : 0,
        gridContainerHeight: gridContainerHeight !== null && gridContainerHeight !== void 0 ? gridContainerHeight : 0,
        gridItemWidth: gridItemWidth !== null && gridItemWidth !== void 0 ? gridItemWidth : 0,
        gridItemHeight: gridItemHeight !== null && gridItemHeight !== void 0 ? gridItemHeight : 0,
        focusControlDisabled: focusControlDisabled === true,
        onFocusableOfDynastyFocused,
        getDelegatedFocus
      }, !disableFocusBinding && shouldBindFocus ? {
        shouldBindFocus: true
      } : {}), {}, {
        delegateFocusByAlias,
        landmarkKey,
        delegationMemoryStack: delegateFocusFromMemory === true ? types_isDelegatingLandmark(previousFocusable) && previousFocusable.delegationMemoryStack != null ? previousFocusable.delegationMemoryStack : new Map() : undefined
      });

      focusTreeElement.current = container;
      refWasMissingOnFirstPutNode.current = containerRef.current == null;
      focusTreeAPIRef.current.putNode(container, parentId);
    }, [disabledFacet, hiddenFacet, focusControlDisabledFacet, scrollAxisFacet, aliasFacet, scrollOptionsFacet, shouldBindFocusFacet, delegateFocusByAliasFacet, delegateFocusFromMemoryFacet, landmarkKeyFacet, isGridFacet, gridContainerWidthFacet, gridContainerHeightFacet, gridItemWidthFacet, gridItemHeightFacet]);
  }, [id, focusTreeAPIRef, parentId, onFocusableOfDynastyFocused, containerRef, getDelegatedFocus, disableFocusBinding, disabledFacet, hiddenFacet, focusControlDisabledFacet, scrollAxisFacet, aliasFacet, scrollOptionsFacet, shouldBindFocusFacet, delegateFocusByAliasFacet, delegateFocusFromMemoryFacet, landmarkKeyFacet, isGridFacet, gridContainerWidthFacet, gridContainerHeightFacet, gridItemWidthFacet, gridItemHeightFacet]);
  (0,react.useEffect)(() => () => {
    var _unObserve$current2;

    (_unObserve$current2 = unObserve.current) === null || _unObserve$current2 === void 0 ? void 0 : _unObserve$current2.call(unObserve);
  }, []);
  (0,react.useEffect)(() => {
    if (!refWasMissingOnFirstPutNode.current) {
      return;
    }

    if (containerRef.current == null || focusTreeElement.current == null) {
      // The container ref could be missing when for example the Landmark is
      // disabled and the ref is not mounted until the Landmark is enabled.
      return;
    }

    const updatedContainer = Landmark_objectSpread(Landmark_objectSpread({}, focusTreeElement.current), {}, {
      ref: containerRef.current
    }); // We need to call putNode here again since container components can be a descendent of the Landmark component
    // and the useMemo above will run before React creates the native elements of descendent components.


    focusTreeAPIRef.current.putNode(updatedContainer, parentId); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  (0,react_facet_src.useFacetEffect)(refreshFocus => {
    if (focusTreeElement.current == null || focusTreeElement.current.hidden || focusTreeElement.current.disabled || refreshFocus == null) {
      return;
    }

    const delegatedFocus = getDelegatedFocus();

    if (delegatedFocus != null && delegatedFocus !== react_facet_src.NO_VALUE) {
      setFocusedId(delegatedFocus.id, false);
    } // TODO: this didn't manage to save the memory of the child debug this

  }, [getDelegatedFocus, setFocusedId], [refreshFocusFacet]); // does nothing on mount
  // doesn't run on updates
  // remove on unmount

  (0,react.useEffect)(() => {
    const focusTreeAPI = focusTreeAPIRef.current;
    return () => focusTreeAPI.removeNode(id);
  }, [focusTreeAPIRef, id]);
  const pathWithId = [...path, id];
  const Landmark = (0,react.useMemo)(() => ({
    children
  }) => /*#__PURE__*/react.createElement(PathContext.Provider, {
    value: pathWithId
  }, children), // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps
  pathWithId); // This is for debugging the focus tree

  (0,react.useEffect)(() => {
    if (window.__REACT_FACET_DEVTOOLS_GLOBAL_HOOK__ == null) return;
    if (containerRef.current == null) return;
    containerRef.current.setAttribute(DATA_FOCUSABLE_DEBUG_ID, `${id}`);
  }, [id, containerRef]);
  return /*#__PURE__*/react.createElement(Landmark, null, children);
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadRow.tsx
function GamepadRow_extends() { GamepadRow_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GamepadRow_extends.apply(this, arguments); }





function GamepadRow_GamepadRow(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadRow, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(FocusGroup, {
      disabled: props.disabled
    }, props.children);
  }

  if (props.scrollRef == null) {
    return /*#__PURE__*/react.createElement(FocusGroup, props, props.children);
  }

  if (props.scrollAxis != null) {
    // wery weird typescript problem
    return /*#__PURE__*/react.createElement(Landmark, GamepadRow_extends({}, props, {
      scrollAxis: props.scrollAxis,
      shouldBindFocus: props.bounded,
      containerRef: props.scrollRef,
      delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
      delegateFocusByAlias: props.defaultFocusedChildAlias
    }));
  }

  return /*#__PURE__*/react.createElement(Landmark, GamepadRow_extends({}, props, {
    scrollAxis: props.scrollAxis,
    shouldBindFocus: props.bounded,
    containerRef: props.scrollRef,
    delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
    delegateFocusByAlias: props.defaultFocusedChildAlias
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/RouteInstantTransition/RouteInstantTransition.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RouteInstantTransition = ({"base":"qp8dp","exited":"Al8HR"});
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var node_modules_classnames = __webpack_require__(94184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(node_modules_classnames);
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RouteActiveProvider.tsx



/**
 * @deprecated use OverrideRouteIsActive from @mojang/react-router-ish
 */
function RouteActiveProvider({
  children,
  active
}) {
  return /*#__PURE__*/react.createElement(OverrideRouteIsActive, {
    value: active
  }, children);
}
/**
 * @deprecated use useRouteIsActive from @mojang/react-router-ish
 */

const useRouteActive = () => hooks_useRouteIsActive();
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/apiContext.ts

const RenderTrackingApiContext = (0,react.createContext)({
  block: () => {},
  unblock: () => {},
  contentfulPaint: () => {},
  meaningfulPaint: () => {}
});
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/useRenderTrackingApi.ts


function useRenderTrackingApi() {
  return (0,react.useContext)(RenderTrackingApiContext);
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingDelay.tsx




let renderTrackingDelayId = 0;

/**
 * Used to block a given type of from being fired until ready.
 *
 * Example. Blocking contentful paint event until a transition is done.
 *
 *   const transitionComplete = useRef(false)
 * 	 <Transition onComplete={() => { transitionComplete = true }} />
 * 	 <RenderTrackingDelay type="contentful" renderingCompleted={transitionComplete} />
 */
function RenderTrackingDelay({
  type,
  renderingCompleted
}) {
  const renderTrackingApi = useRenderTrackingApi();
  const isRouteActive = useRouteActive();
  const id = (0,react.useMemo)(() => renderTrackingDelayId++, []);
  (0,react_facet_src.useFacetEffect)(isRouteActive => {
    if (!isRouteActive) {
      /**
       * If the user leaves the route that this blocker was on
       * then we should unblock it.
       */
      return renderTrackingApi.unblock(id, type);
    }

    if (renderingCompleted) {
      renderTrackingApi.unblock(id, type);
    } else {
      renderTrackingApi.block(id, type);
    }
  }, [id, renderingCompleted, renderTrackingApi, type], [isRouteActive]);
  return null;
}
;// CONCATENATED MODULE: ./packages/ui/src/RouteInstantTransition/RouteInstantTransition.tsx






function RouteInstantTransition_RouteInstantTransition({
  visible,
  unmountOnExit,
  alwaysMounted,
  contentComponent
}) {
  const Content = (0,react.useMemo)(() => react.memo(contentComponent), [contentComponent]);
  const mountedRef = (0,react.useRef)(visible || alwaysMounted);
  mountedRef.current = alwaysMounted || (unmountOnExit ? visible : mountedRef.current || visible);
  const ref = (0,react.useRef)(null);
  return mountedRef.current ? /*#__PURE__*/react.createElement(OverrideRouteIsActive, {
    value: visible
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: ref,
    gamepadIndex: 0,
    disabled: !visible,
    defaultFocusedChildBehavior: "first",
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(RouteInstantTransition.base, {
      [RouteInstantTransition.entered]: visible,
      [RouteInstantTransition.exited]: !visible
    })
  }, /*#__PURE__*/react.createElement(RenderTrackingDelay, {
    type: "contentful",
    renderingCompleted: visible
  }), /*#__PURE__*/react.createElement(Content, null)))) : null;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RouterEngineProvider/index.tsx
function RouterEngineProvider_extends() { RouterEngineProvider_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return RouterEngineProvider_extends.apply(this, arguments); }








/**
 * @deprecated use useRouterAPI instead
 */

const RouterEngineProvider_useRouteHistory = () => hooks_useRouterAPI();

/**
 * @deprecated useRouteQuery instead
 */

const useRouteQueryUnwrapped = () => {
  const query = (0,react_facet_src.useFacetUnwrap)(useRouteQuery());
  if (query === react_facet_src.NO_VALUE) return new esm('');
  return query;
};

/**
 * @deprecated useRouteParams instead
 */

const RouterEngineProvider_useRouteParamsUnwrapped = () => {
  const params = (0,react_facet_src.useFacetUnwrap)(hooks_useRouteParams());
  if (params === react_facet_src.NO_VALUE) return {};
  return params;
};


const RouterEngineProvider_Route = props => {
  var _props$transitionComp;

  return /*#__PURE__*/react.createElement(Route, RouterEngineProvider_extends({}, props, {
    transitionComponent: (_props$transitionComp = props.transitionComponent) !== null && _props$transitionComp !== void 0 ? _props$transitionComp : RouteInstantTransition_RouteInstantTransition
  }));
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/decideScreenType.ts

const screenTypeMap = {
  [Platform.IOS]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.GOOGLE]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.AMAZON_HANDHELD]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.UWP]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.XBOX]: ScreenType.TV_SCREEN_TYPE,
  [Platform.NX_HANDHELD]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.PS4]: ScreenType.TV_SCREEN_TYPE,
  [Platform.GEARVR]: ScreenType.HANDHELD_SCREEN_TYPE,
  [Platform.WIN32]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.MACOS]: ScreenType.DESKTOP_SCREEN_TYPE,
  [Platform.AMAZON_TV]: ScreenType.TV_SCREEN_TYPE,
  [Platform.NX_TV]: ScreenType.TV_SCREEN_TYPE,
  [Platform.PS5]: ScreenType.TV_SCREEN_TYPE
};
function decideScreenType(platform) {
  return screenTypeMap[platform];
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/decideControllerType.ts

const controllerTypeMap = {
  [Platform.IOS]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.GOOGLE]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.AMAZON_HANDHELD]: Controller.XBOX,
  // Asuming XBOX as default because missing information
  [Platform.UWP]: Controller.XBOX,
  [Platform.XBOX]: Controller.XBOX,
  [Platform.NX_HANDHELD]: Controller.SWITCH,
  [Platform.PS4]: Controller.PS,
  [Platform.GEARVR]: Controller.QUEST,
  [Platform.WIN32]: Controller.XBOX,
  [Platform.MACOS]: Controller.XBOX,
  [Platform.AMAZON_TV]: Controller.XBOX,
  [Platform.NX_TV]: Controller.SWITCH,
  [Platform.PS5]: Controller.PS
};
function decideControllerType(platform) {
  return controllerTypeMap[platform];
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/useUpdateBodyCursor.ts


function useUpdateBodyCursor(lastInputMethodUsed) {
  (0,react_facet_src.useFacetEffect)(lastInputMethodUsed => {
    if (lastInputMethodUsed === types_InputMethod.MOUSE) {
      document.body.style.cursor = 'auto';
    } else {
      document.body.style.cursor = 'none';
    }
  }, [], [lastInputMethodUsed]);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/typeGuards.ts

const isFocusInputMethod = inputMethod => {
  return inputMethod === types_InputMethod.GAMEPAD || inputMethod === types_InputMethod.KEYBOARD;
};
const isPointerInputMethod = inputMethod => {
  return inputMethod === types_InputMethod.MOUSE || inputMethod === types_InputMethod.TOUCH;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/usePointerInputMethodState.ts





const getDefaultPointerInput = (lastInputMethodUsed, platform) => {
  if (isPointerInputMethod(lastInputMethodUsed)) {
    return lastInputMethodUsed;
  } // The defaults based on platform are just currently our "best guess" and we might need to tweak these in the future.
  // It is for example not clear if we should default to null, mouse or touch for consoles.


  switch (platform) {
    case Platform.WIN32:
    case Platform.MACOS:
      return types_InputMethod.MOUSE;

    case Platform.NX_HANDHELD:
    case Platform.IOS:
    case Platform.GOOGLE:
    case Platform.AMAZON_HANDHELD:
      return types_InputMethod.TOUCH;

    default:
      return null;
  }
}; // Handles state of the last used pointer input method (mouse or touch)


const usePointerInputMethodState = (lastInputMethodUsed, platform) => {
  const [pointerInputMethod, setPointerInputMethod] = (0,react_facet_src.useFacetState)(null);
  const isInitialized = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((lastUsed, pointer, platform) => {
    // Initialize state
    if (!isInitialized.current && pointer == null) {
      isInitialized.current = true;
      setPointerInputMethod(getDefaultPointerInput(lastUsed, platform));
    } // Sync state based on last input method used
    else if (isPointerInputMethod(lastUsed) && pointer != lastUsed) {
        setPointerInputMethod(lastUsed);
      }
  }, [setPointerInputMethod], [lastInputMethodUsed, pointerInputMethod, platform]);
  return pointerInputMethod;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/useFocusInputMethodState.ts





const getDefaultFocusInput = (lastInputMethodUsed, platform) => {
  if (isFocusInputMethod(lastInputMethodUsed)) {
    return lastInputMethodUsed;
  } // The defaults based on platform are just currently our "best guess" and we might need to tweak these in the future.
  // It is for example not clear if we should default to null, keyboard or gamepad on touch devices.


  switch (platform) {
    case Platform.WIN32:
    case Platform.MACOS:
    case Platform.UWP:
      return types_InputMethod.KEYBOARD;

    case Platform.XBOX:
    case Platform.NX_HANDHELD:
    case Platform.PS4:
    case Platform.GEARVR:
    case Platform.AMAZON_TV:
    case Platform.NX_TV:
    case Platform.PS5:
      return types_InputMethod.GAMEPAD;

    default:
      return null;
  }
}; // Handles state of the last used focus input method (gamepad or keyboard)


const useFocusInputMethodState = (lastInputMethodUsed, platform) => {
  const [focusInputMethod, setFocusInputMethod] = (0,react_facet_src.useFacetState)(null);
  const isInitialized = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((lastUsed, focus, platform) => {
    // Initialize state
    if (!isInitialized.current && focus == null) {
      isInitialized.current = true;
      setFocusInputMethod(getDefaultFocusInput(lastUsed, platform));
    } // Sync state based on last input method used
    else if (isFocusInputMethod(lastUsed) && focus != lastUsed) {
        setFocusInputMethod(lastUsed);
      }
  }, [setFocusInputMethod], [lastInputMethodUsed, focusInputMethod, platform]);
  return focusInputMethod;
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/inputMethods/useInputMethods.ts




 // Hook that takes:
// - Facet for last input method used
// - Facet for supported input methods
// And returns:
// - Facets for current focus input method (gamepad or keyboard)
// - Facets for current pointer input method used (mouse or touch)
// - Facets for last input method used (of any input method)
// - Facets for supported input methods

const useInputMethods = (lastInputMethodUsed, supportedInputMethods, platform) => {
  const pointerInputMethod = usePointerInputMethodState(lastInputMethodUsed, platform);
  const focusInputMethod = useFocusInputMethodState(lastInputMethodUsed, platform);
  const isPointerInputMouse = (0,react_facet_src.useFacetMemo)(pointer => pointer === types_InputMethod.MOUSE, [], [pointerInputMethod]);
  const isPointerInputTouch = (0,react_facet_src.useFacetMemo)(pointer => pointer === types_InputMethod.TOUCH, [], [pointerInputMethod]);
  const isPointerInputAvailable = (0,react_facet_src.useFacetMemo)(pointer => pointer != null, [], [pointerInputMethod]);
  const isFocusInputGamepad = (0,react_facet_src.useFacetMemo)(focus => focus === types_InputMethod.GAMEPAD, [], [focusInputMethod]);
  const isFocusInputKeyboard = (0,react_facet_src.useFacetMemo)(focus => focus === types_InputMethod.KEYBOARD, [], [focusInputMethod]);
  const isFocusInputAvailable = (0,react_facet_src.useFacetMemo)(focus => focus != null, [], [focusInputMethod]);
  const isLastInputMouse = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.MOUSE, [], [lastInputMethodUsed]);
  const isLastInputTouch = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.TOUCH, [], [lastInputMethodUsed]);
  const isLastInputGamepad = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.GAMEPAD, [], [lastInputMethodUsed]);
  const isLastInputKeyboard = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.KEYBOARD, [], [lastInputMethodUsed]);
  const isLastInputPointer = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.MOUSE || last === types_InputMethod.TOUCH, [], [lastInputMethodUsed]);
  const isLastInputFocus = (0,react_facet_src.useFacetMemo)(last => last === types_InputMethod.KEYBOARD || last === types_InputMethod.GAMEPAD, [], [lastInputMethodUsed]);
  const isGamepadSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.GAMEPAD), [], [supportedInputMethods]);
  const isKeyboardSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.KEYBOARD), [], [supportedInputMethods]);
  const isMouseSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.MOUSE), [], [supportedInputMethods]);
  const isTouchSupported = (0,react_facet_src.useFacetMemo)(supported => supported.includes(types_InputMethod.TOUCH), [], [supportedInputMethods]);
  const isPointerSupported = (0,react_facet_src.useFacetMemo)(supported => {
    for (let i = 0; i < supported.length; i++) {
      if (isPointerInputMethod(supported[i])) return true;
    }

    return false;
  }, [], [supportedInputMethods]);
  const isFocusSupported = (0,react_facet_src.useFacetMemo)(supported => {
    for (let i = 0; i < supported.length; i++) {
      if (isFocusInputMethod(supported[i])) return true;
    }

    return false;
  }, [], [supportedInputMethods]);
  return {
    isPointerInputMouse,
    isPointerInputTouch,
    isPointerInputAvailable,
    isFocusInputGamepad,
    isFocusInputKeyboard,
    isFocusInputAvailable,
    isLastInputMouse,
    isLastInputTouch,
    isLastInputGamepad,
    isLastInputKeyboard,
    isLastInputPointer,
    isLastInputFocus,
    isGamepadSupported,
    isKeyboardSupported,
    isMouseSupported,
    isTouchSupported,
    isPointerSupported,
    isFocusSupported
  };
};
;// CONCATENATED MODULE: ./packages/react-device-information/src/DeviceInformationProvider.tsx







function DeviceInformationProvider({
  lastInputMethodUsed,
  supportedInputMethods,
  platform,
  arvrPlatform: vrPlatform,
  children
}) {
  const inputMethods = useInputMethods(lastInputMethodUsed, supportedInputMethods, platform);
  const screenTypeFacet = (0,react_facet_src.useFacetMemo)(platform => decideScreenType(platform), [], [platform]);
  const controllerTypeFacet = (0,react_facet_src.useFacetMemo)(platform => decideControllerType(platform), [], [platform]);
  useUpdateBodyCursor(lastInputMethodUsed);
  return /*#__PURE__*/react.createElement(InputMethodsContext.Provider, {
    value: inputMethods
  }, /*#__PURE__*/react.createElement(platformContext.Provider, {
    value: platform
  }, /*#__PURE__*/react.createElement(VRPlatformContext.Provider, {
    value: vrPlatform
  }, /*#__PURE__*/react.createElement(screenTypeContext.Provider, {
    value: screenTypeFacet
  }, /*#__PURE__*/react.createElement(controllerContext.Provider, {
    value: controllerTypeFacet
  }, children)))));
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useMouseDetection.ts



const DISTANCE_THRESHOLD = 10;

const useTimeStampLastTouchEndEvent = isEnabledFacet => {
  const timeStampLastTouchEndEvent = (0,react.useRef)(-1);
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      return;
    }

    const handleTouchEnd = event => {
      timeStampLastTouchEndEvent.current = event.timeStamp;
    };

    window.addEventListener('touchend', handleTouchEnd);
    return () => {
      window.removeEventListener('touchend', handleTouchEnd);
    };
  }, [], [isEnabledFacet]);
  return timeStampLastTouchEndEvent;
};

function useMouseDetection(isEnabledFacet, onMouseDetected, availableInputMethods) {
  // We want to track last touchend event when both mouse and touch input are available. The reason is
  // that the touchend event will also trigger the mousedown and mousemove events and in those cases
  // we don't want to call the mouse detected handler, since the source was touch input.
  const shouldTrackLastTouchEndTimeStamp = (0,react_facet_src.useFacetMap)(available => available.includes(types_InputMethod.MOUSE) && available.includes(types_InputMethod.TOUCH), [], [availableInputMethods]);
  const timeStampLastTouchEndEvent = useTimeStampLastTouchEndEvent(shouldTrackLastTouchEndTimeStamp);
  const mouseStartPositionRef = (0,react.useRef)(null);
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      mouseStartPositionRef.current = null;
      return;
    }

    const shouldIgnoreMouseEvent = event => timeStampLastTouchEndEvent.current === event.timeStamp;

    const handleMouseMove = event => {
      const latestPosition = [event.clientX, event.clientY];

      if (!mouseStartPositionRef.current) {
        mouseStartPositionRef.current = latestPosition;
        return;
      }

      const a = Math.abs(latestPosition[0] - mouseStartPositionRef.current[0]);
      const b = Math.abs(latestPosition[1] - mouseStartPositionRef.current[1]);
      const distance = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));

      if (distance > DISTANCE_THRESHOLD) {
        mouseStartPositionRef.current = null;

        if (shouldIgnoreMouseEvent(event)) {
          return;
        }

        onMouseDetected();
      }
    };

    const handleMouseDown = event => {
      if (shouldIgnoreMouseEvent(event)) {
        return;
      }

      onMouseDetected();
    };

    const handleWheel = () => {
      onMouseDetected();
    };

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('wheel', handleWheel);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('wheel', handleWheel);
    };
  }, [onMouseDetected, timeStampLastTouchEndEvent], [isEnabledFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useTouchDetection.ts

function useTouchDetection(isEnabledFacet, onTouchDetected) {
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) {
      return;
    } // We need to listen to touchend here since if the current touch input is the first touch input
    // received, making touch available, then the touchstart event won't be fired. In all other cases
    // we want to detect touch on touchstart since we want to adjust the UI as soon as possible for the
    // best user experience.


    window.addEventListener('touchstart', onTouchDetected);
    window.addEventListener('touchend', onTouchDetected);
    return () => {
      window.removeEventListener('touchstart', onTouchDetected);
      window.removeEventListener('touchend', onTouchDetected);
    };
  }, [onTouchDetected], [isEnabledFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useKeyboardDetection.tsx

const useKeyboardDetection = (isEnabledFacet, onKeyboardDetected) => {
  (0,react_facet_src.useFacetEffect)(isEnabled => {
    if (!isEnabled) return;
    window.addEventListener('keyup', onKeyboardDetected);
    return () => {
      window.removeEventListener('keyup', onKeyboardDetected);
    };
  }, [onKeyboardDetected], [isEnabledFacet]);
};
;// CONCATENATED MODULE: ./packages/engine/src/onGamepadInput.ts

const DEAD_ZONE = 0.16;
const onGamepadInput_onGamepadInput = handler => {
  let requestId;

  const detectGamepadInput = () => {
    const gamepads = getGamepads();
    const activeGamepads = gamepads.filter(gamepad => {
      if (gamepad == null) return false;
      const activeAxis = gamepad.axes.find(axis => Math.abs(axis) > DEAD_ZONE);
      if (activeAxis != null) return true;
      const activeButton = gamepad.buttons.find(button => button.pressed);
      if (activeButton) return true;
      return false;
    });

    if (activeGamepads.length > 0) {
      handler(activeGamepads);
    }

    requestId = window.requestAnimationFrame(detectGamepadInput);
  };

  detectGamepadInput();
  return () => window.cancelAnimationFrame(requestId);
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useGamepadDetection.ts


function useGamepadDetection(isEnabledFacet, acceptInputFromAllControllersFacet, gameControllerIdFacet, onGamepadDetected) {
  (0,react_facet_src.useFacetEffect)((isEnabled, acceptInputFromAllControllers, gameControllerId) => {
    if (!isEnabled) {
      return;
    }

    const cleanup = onGamepadInput_onGamepadInput(gamepads => {
      const acceptedGamepads = acceptInputFromAllControllers ? gamepads : gamepads.filter(gamepad => gamepad.id === gameControllerId);

      if (acceptedGamepads.length > 0) {
        onGamepadDetected();
      }
    });
    return cleanup;
  }, [onGamepadDetected], [isEnabledFacet, acceptInputFromAllControllersFacet, gameControllerIdFacet]);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/useLastUsedAndSupportedInputMethods.ts








const useSupportedInputMethods = supportedBackendInputMethods => {
  const [supportedInputMethods, setSupportedInputMethods] = (0,react_facet_src.useFacetState)([]); // Keyboard input is not sent to use from the backend so we need to keep track of it ourselves.
  // We are currently just saying that keyboard is supported if we have ever detected it,
  // which isn't ideal but the best we can do on the frontend.

  const isKeyboardSupported = (0,react.useRef)(false);
  const setKeyboardIsSupported = (0,react_facet_src.useFacetCallback)(supported => () => {
    if (!isKeyboardSupported.current) {
      isKeyboardSupported.current = true;
      const updatedSupported = Array.from(supported);
      updatedSupported.push(types_InputMethod.KEYBOARD);
      setSupportedInputMethods(updatedSupported);
    }
  }, [setSupportedInputMethods], [supportedInputMethods]);
  (0,react_facet_src.useFacetEffect)((supported, supportedFromBackend) => {
    const supportedLengthWithoutKeyboard = isKeyboardSupported.current ? supported.length - 1 : supported.length;
    const sameCount = supportedLengthWithoutKeyboard === supportedFromBackend.length;
    const shouldSync = !sameCount || !supportedFromBackend.every(method => supported.includes(method));

    if (shouldSync) {
      // Important to keep wrapping supportedFromBackend in Array.from(). The array originates from the backend
      // and those do not support the same operators / methods as native javascript arrays.
      const updatedSupported = Array.from(supportedFromBackend);

      if (isKeyboardSupported.current) {
        updatedSupported.push(types_InputMethod.KEYBOARD);
      }

      setSupportedInputMethods(updatedSupported);
    }
  }, [setSupportedInputMethods], [supportedInputMethods, supportedBackendInputMethods]);
  return {
    supportedInputMethods,
    setKeyboardIsSupported
  };
};

const useLastInputMethodUsed = currentBackendInputMethod => {
  const facetState = (0,react_facet_src.useFacetState)(null);
  const [lastInputMethodUsed, baseSetter] = facetState;
  const previousInputMethodRef = (0,react.useRef)(null); // Decorate the base setter in order to keep track of the previous input method used.

  const setLastInputMethodUsed = (0,react.useCallback)(newValue => {
    baseSetter(currentValue => {
      if (currentValue === newValue) {
        return currentValue;
      }

      if (currentValue !== react_facet_src.NO_VALUE) {
        previousInputMethodRef.current = currentValue;
      }

      return newValue;
    });
  }, [baseSetter]); // Sync last input method used with the backend. Note that we can not only do initialization here
  // and then track the state entirely on the frontend. This is due to how we initialize input methods
  // on the backend before running functional tests (see core:test:setInputMode).

  (0,react_facet_src.useFacetEffect)(currentBackendInputMethod => {
    if (currentBackendInputMethod == null) return;
    setLastInputMethodUsed(currentBackendInputMethod);
  }, [setLastInputMethodUsed], [currentBackendInputMethod]);
  return [lastInputMethodUsed, setLastInputMethodUsed, previousInputMethodRef];
}; // We only need to detect input on the frontend when we are going back and forth between
// keyboard and other input methods. The reason is that the backend tracks all input methods
// for us besides keyboard and we sync state changes received from the backend.
//
// The below illustrates the only place where we need to track state changes on the frontend:
// 1) Using Gamepad | Mouse | Touch -> Synced from backend state
// 2) Using Keyboard -> Tracked on the frontend entirely
// 3) Using same as 1) -> Tracked on the frontend, since from a backend perspective nothing has changed.


const useShouldListenToInput = (inputMethod, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, override = false) => {
  return (0,react_facet_src.useFacetMap)((last, supported) => override || previousInputMethodRef.current === inputMethod && last === types_InputMethod.KEYBOARD && supported.includes(inputMethod), [inputMethod, previousInputMethodRef, override], [lastInputMethodUsed, supportedInputMethods]);
}; // Hook that keeps track of last used input method and supported input methods.
// Keyboard is always supported after first use (since we don't get that state from the backend and we need to keep track of it ourselves)
// We do this aggregated hook in order to avoid setting up detection hooks for gamepad, mouse, touch and keyboard multiple times.


const useLastUsedAndSupportedInputMethods = (currentBackendInputMethod, acceptInputFromAllControllers, gameControllerId, supportedBackendInputMethods, options) => {
  const {
    supportedInputMethods,
    setKeyboardIsSupported
  } = useSupportedInputMethods(supportedBackendInputMethods);
  const [lastInputMethodUsed, setLastInputMethodUsed, previousInputMethodRef] = useLastInputMethodUsed(currentBackendInputMethod);
  const shouldListenToMouse = useShouldListenToInput(types_InputMethod.MOUSE, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToTouch = useShouldListenToInput(types_InputMethod.TOUCH, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToGamepad = useShouldListenToInput(types_InputMethod.GAMEPAD, lastInputMethodUsed, supportedInputMethods, previousInputMethodRef, options === null || options === void 0 ? void 0 : options.trackAllUserInput);
  const shouldListenToKeyboard = (0,react_facet_src.useFacetMap)(last => last !== types_InputMethod.KEYBOARD, [], [lastInputMethodUsed]);
  useMouseDetection(shouldListenToMouse, () => {
    setLastInputMethodUsed(types_InputMethod.MOUSE);
  }, supportedBackendInputMethods);
  useTouchDetection(shouldListenToTouch, () => {
    setLastInputMethodUsed(types_InputMethod.TOUCH);
  });
  useKeyboardDetection(shouldListenToKeyboard, () => {
    setKeyboardIsSupported();
    setLastInputMethodUsed(types_InputMethod.KEYBOARD);
  });
  useGamepadDetection(shouldListenToGamepad, acceptInputFromAllControllers, gameControllerId, () => {
    setLastInputMethodUsed(types_InputMethod.GAMEPAD);
  });
  return {
    lastInputMethodUsed,
    supportedInputMethods
  };
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/deviceInformationFacet.ts

let StorageType;

(function (StorageType) {
  StorageType[StorageType["NONE"] = 0] = "NONE";
  StorageType[StorageType["EXTERNAL"] = 1] = "EXTERNAL";
  StorageType[StorageType["APPDATA"] = 2] = "APPDATA";
})(StorageType || (StorageType = {}));

const DEVICE_INFORMATION_FACET = 'core.deviceInformation';
/**
 * React Hook that requests the facet
 */

const deviceInformationFacet = (0,react_facet_src.sharedFacet)(DEVICE_INFORMATION_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/DeviceInformationEngineProvider.tsx
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







function DeviceInformationEngineProvider(_ref) {
  let {
    children
  } = _ref,
      options = _objectWithoutProperties(_ref, ["children"]);

  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const input = (0,react_facet_src.useSharedFacet)(inputFacet_inputFacet);
  const currentBackendInputMethod = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.currentInputType, [], [input]);
  const supportedBackendInputMethods = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.inputMethods, [], [deviceInformation]);
  const platform = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.platform, [], [deviceInformation]);
  const vrPlatform = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.arvrPlatform, [], [deviceInformation]);
  const acceptInputFromAllControllers = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.acceptInputFromAllControllers, [], [input]);
  const gameControllerId = (0,react_facet_src.useFacetMap)(inputFacet => inputFacet.gameControllerId, [], [input]); // This hook is needed since the MinecraftPE backend doesn't include keyboard input in `inputFacet.currentInputType`
  // and in `deviceInformation.inputMethods`. Ideally we would move all detection to the backend in the future.
  // We do the detection here in the engine layer instead of in the device information provider since this is a
  // Bedrock specific quirk.

  const {
    lastInputMethodUsed,
    supportedInputMethods
  } = useLastUsedAndSupportedInputMethods(currentBackendInputMethod, acceptInputFromAllControllers, gameControllerId, supportedBackendInputMethods, options);
  return /*#__PURE__*/react.createElement(DeviceInformationProvider, {
    platform: platform,
    arvrPlatform: vrPlatform,
    lastInputMethodUsed: lastInputMethodUsed,
    supportedInputMethods: supportedInputMethods
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/DeviceInformationEngineProvider/index.ts


;// CONCATENATED MODULE: ./packages/engine/src/engineWrapper/index.ts
/* eslint-env node */
if (false) {}
/*
 * There is a cohtml file provided by Coherent Labs that needs to loaded by the frontend to allow communication with the game engine.
 * Historically, this cohtml lived in this repository, but we have since moved it to be loaded and updated by the C++ backend.
 * We keep a legacyCohtml in this repository as a backwards compatible solution to older version of the C++ backend.
 *
 * YOU SHOULD NOT UPDATE THIS LOCAL cohtml file.
 */


const engineWrapper_engine =  true ? window.__bedrockProvidedCohtmljs === true ? window.engine : __webpack_require__(35341)() : 0; // eslint-disable-line @typescript-eslint/no-explicit-any
;// CONCATENATED MODULE: ./packages/engine/src/ErrorBoundary.tsx





/**
 * Catches any error in the React sub-tree and renders the provided errorComponent
 */
function ErrorBoundary({
  children,
  errorComponent
}) {
  const [error, setError] = (0,react.useState)(null);
  const handleError = (0,react.useCallback)(error => {
    setError(error);
    engineWrapper_engine.trigger('core:exception');
  }, []);
  const clearError = (0,react.useCallback)(() => {
    setError(null);
  }, []);
  const isDevMode = "production" === 'development';
  const errorMessage = isDevMode && error ? error.message || 'Unknown error' : undefined;

  if (errorComponent == null) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, "children");
  }

  return /*#__PURE__*/react.createElement(ErrorCatcher, {
    onError: handleError
  }, error ? /*#__PURE__*/react.createElement(ErrorComponentWrapper, {
    dismissTimeout: isDevMode ? undefined : 40000,
    errorMessage: errorMessage,
    errorComponent: errorComponent,
    onDismiss: clearError
  }) : children);
}

class ErrorCatcher extends react.Component {
  static getDerivedStateFromError() {}

  componentDidCatch(error) {
    this.props.onError(error);
  }

  render() {
    return this.props.children;
  }

}

/**
 * Wrapper component to render the user-provided ErrorComponent
 * We use a wrapper to only request the routerFacet when needed (preventing unnecessary renders)
 */
function ErrorComponentWrapper({
  errorComponent: ErrorComponent,
  errorMessage,
  onDismiss,
  dismissTimeout
}) {
  const router = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(routerFacet_routerFacet));
  const handleDismiss = (0,react.useCallback)(() => {
    if (router != null && router !== react_facet_src.NO_VALUE) {
      router.history.goBack();
    } // Allows the history change to propagate so that the component that caused the error
    // will no longer be rendered


    requestAnimationFrame(onDismiss);
  }, [router, onDismiss]);
  (0,react.useEffect)(() => {
    // Automatically dismisses the ErrorModal after 4 seconds
    // TODO: remove this once we fix an issue that allows buttons in the error modal to work with Gamepad
    if (dismissTimeout != null) {
      const id = setTimeout(handleDismiss, dismissTimeout);
      return () => clearTimeout(id);
    }
  }, [router, handleDismiss, dismissTimeout]);
  return /*#__PURE__*/react.createElement(ErrorComponent, {
    errorMessage: errorMessage,
    onDismiss: handleDismiss
  });
}
;// CONCATENATED MODULE: ./packages/react-feature-flag/src/flagsContext.ts

const flagsContext_context = (0,react.createContext)([]);
const useFlags = () => (0,react.useContext)(flagsContext_context);
const FeatureFlagsProvider = flagsContext_context.Provider;
FeatureFlagsProvider.displayName = 'FeatureFlagsProvider';
;// CONCATENATED MODULE: ./packages/engine/src/facets/featureFlagsFacet.ts

const FEATURE_FLAGS_FACET = 'core.featureFlags';
const UNLOCKS_RECIPES_FEATURE_FLAG = 'vanilla.settings.unlockRecipes';
/**
 * React Hook that requests the facet
 */

const featureFlagsFacet = (0,react_facet_src.sharedFacet)(FEATURE_FLAGS_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/FeatureFlagsEngineProvider.tsx




function FeatureFlagsEngineProvider({
  children
}) {
  const facetFlags = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(featureFlagsFacet));
  const flags = facetFlags === react_facet_src.NO_VALUE ? [] : facetFlags.flags;
  return /*#__PURE__*/react.createElement(FeatureFlagsProvider, {
    value: flags
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/localeFacet.ts


const LOCALE_FACET = 'core.locale';
const localeFacet = (0,react_facet_src.sharedFacet)(LOCALE_FACET);
const localeFacetSelector = (0,react_facet_src.sharedSelector)(facet => {
  // We need to bind the functions to the localeFacet because separating
  // the function from the object causes Gameface to loose track of it and
  // crashes instantly when calling the function.
  return {
    set locale(newValue) {
      if (facet != null) {
        facet.locale = newValue;
      }
    },

    get locale() {
      return facet.locale;
    },

    translate: facet.translate != null ? facet.translate.bind(facet) : translateFallback,
    translateWithParameters: facet.translateWithParameters != null ? facet.translateWithParameters.bind(facet) : translateWithParametersFallback,
    formatDate: facet.formatDate != null ? facet.formatDate.bind(facet) : formatDateFallback
  };
}, [localeFacet]);
/**
 * Fallback implementation for old builds of the backend
 */

const translateFallback = key => {
  return engineWrapper_engine.translate(key);
};
/**
 * Fallback implementation for old builds of the backend
 */


const translateWithParametersFallback = key => {
  console.error('Update Bedrock to get support for translations with parameters.');
  return engineWrapper_engine.translate(key);
};
/**
 * Fallback implementation for old builds of the backend
 */


const formatDateFallback = timestampInSeconds => {
  console.error('Update Bedrock to get support for formatDate.');
  return `${timestampInSeconds}`;
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/LocalizationEngineProvider.tsx




function LocalizationEngineProvider({
  children,
  developmentTranslations
}) {
  const locale = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(localeFacetSelector));
  const translate = (0,react.useCallback)((key, params) => {
    if (false) {}

    if (locale === react_facet_src.NO_VALUE) {
      return react_facet_src.NO_VALUE;
    }

    if (params != null) {
      return locale.translateWithParameters(key, params);
    }

    return locale.translate(key);
  }, [developmentTranslations, locale]);
  return locale !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(LocalizationProvider, {
    translationPrefix: "hbui",
    locale: locale.locale,
    translate: translate,
    formatDate: locale.formatDate
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationDriver.ts

const narrationDriverContext = (0,react.createContext)({
  narrationTree: {},
  readById: () => {},
  readText: () => {},
  clear: () => {}
});
const NarrationDriverProvider = narrationDriverContext.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/getAncestry.ts
const getAncestry = (narrationTree, narrationId) => {
  if (narrationId === '') {
    return [];
  }

  const currentNode = narrationTree[narrationId];
  return [narrationId, ...getAncestry(narrationTree, currentNode.parentNarrationId)];
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/getAncestryDifference.ts
const getAncestryDifference = (currentAncestry, previousAncestry) => {
  if (previousAncestry.length === 0) {
    return currentAncestry;
  }

  const lastCurrentItem = currentAncestry[currentAncestry.length - 1];
  const lastPreviousItem = previousAncestry[previousAncestry.length - 1];

  if (lastCurrentItem === lastPreviousItem) {
    return getAncestryDifference(currentAncestry.slice(0, -1), previousAncestry.slice(0, -1));
  }

  return currentAncestry;
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/utils/constructNarration.ts
const constructNarration = (narrationTree, ancestry) => {
  // The values on `shouldSkipParent` are the indexes of the ancestors to skip
  // The value `0` corresponds to the first parent, so the in ancestry array,
  // it corresponds to the element indexed as `1`, because the element `0` in
  // the ancestry array is the current node.
  // We index starting from the leaf instead of starting from the root
  // of the narration node tree because when we are developing we are most
  // aware of the immediate context of the current node, and not
  // necessarily of the root
  const nodesToSkip = narrationTree[ancestry[0]].shouldSkipParent;
  return ancestry.filter((_, index) => nodesToSkip.indexOf(index - 1) === -1).reverse().map(key => {
    var _narrationTree$key$ge, _narrationTree$key$ge2, _narrationTree$key;

    const item = narrationTree[key];

    if (item.text != null) {
      return item.text.trim();
    }

    return (_narrationTree$key$ge = (_narrationTree$key$ge2 = (_narrationTree$key = narrationTree[key]).getText) === null || _narrationTree$key$ge2 === void 0 ? void 0 : _narrationTree$key$ge2.call(_narrationTree$key).trim()) !== null && _narrationTree$key$ge !== void 0 ? _narrationTree$key$ge : '';
  }).filter(text => text !== '').join(' . ');
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/NarrationSetup.tsx




const NarrationSetup = ({
  children,
  disabled,
  narrationTree,
  driver,
  isIdle = true,
  shouldUseQueueSystem,
  shouldInterrupt
}) => {
  const isDisabledFacet = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : true);
  const driverFacet = (0,react_facet_src.useFacetWrap)(driver);
  const [narrationQueueFacet, setNarrationQueueFacet] = (0,react_facet_src.useFacetState)([]);
  const isIdleFacet = (0,react_facet_src.useFacetWrap)(isIdle);
  const shouldUseQueueSystemFacet = (0,react_facet_src.useFacetWrap)(shouldUseQueueSystem !== null && shouldUseQueueSystem !== void 0 ? shouldUseQueueSystem : false);
  const shouldInterruptFacet = (0,react_facet_src.useFacetWrap)(shouldInterrupt !== null && shouldInterrupt !== void 0 ? shouldInterrupt : false);
  const narrationTreeDefaultRef = (0,react.useRef)({
    root: {
      text: '',
      parentNarrationId: '',
      shouldSkipParent: []
    }
  });
  const previousNarrationId = (0,react.useRef)('');
  const isDisabled = (0,react_facet_src.useFacetUnwrap)(isDisabledFacet);
  const disabledRef = (0,react.useRef)(isDisabled);
  (0,react_facet_src.useFacetEffect)((driver, isIdle, narrationQueue) => {
    /**
     * We only want to trigger the narration if the narration queue is not empty and the two following conditions are met:
     * 1. TTS driver is idle.
     * 2.TTS driver is not idle but the first item in the queue is can interrupt current narration.
     */
    if (narrationQueue.length > 0 && (Boolean(isIdle) || !Boolean(isIdle) && narrationQueue[0].itemShouldInterrupt)) {
      const [itemToNarrate, ...restOfQueue] = narrationQueue;
      const {
        narrationId,
        textToRead,
        profanityFilterContext,
        interruptible,
        required,
        playInBackground
      } = itemToNarrate;
      driver.read(textToRead, profanityFilterContext, interruptible, required, playInBackground);

      if (false) {}

      setNarrationQueueFacet(restOfQueue);

      if (false) {}

      if (narrationId != null) {
        previousNarrationId.current = narrationId;
      }
    }
  }, [setNarrationQueueFacet], [driverFacet, isIdleFacet, narrationQueueFacet]);
  const clear = (0,react_facet_src.useFacetCallback)(driver => () => {
    driver.clear();
  }, [], [driverFacet]);
  const readText = (0,react_facet_src.useFacetCallback)((driver, shouldUseQueueSystem, shouldInterrupt) => (narration, profanityFilterContext = {
    outOfGame: true,
    inGame: true
  }, interruptible = true, required = false, playInBackground = false, narrationId) => {
    if (!Boolean(shouldUseQueueSystem)) {
      driver.read(narration, profanityFilterContext, interruptible, required, playInBackground);

      if (narrationId != null) {
        previousNarrationId.current = narrationId;
      }
    } else {
      const newQueueItem = {
        narrationId,
        textToRead: narration,
        profanityFilterContext,
        interruptible: interruptible,
        required: required,
        playInBackground: playInBackground,
        itemShouldInterrupt: shouldInterrupt
      };

      if (Boolean(shouldInterrupt)) {
        setNarrationQueueFacet([newQueueItem]);
        return;
      }

      setNarrationQueueFacet(currentQueue => currentQueue !== react_facet_src.NO_VALUE ? [...currentQueue, newQueueItem] : [newQueueItem]);
    }
  }, [setNarrationQueueFacet], [driverFacet, shouldUseQueueSystemFacet, shouldInterruptFacet]); // To make testing easier, we want to have the functionality to manually pass in narrationTree.
  // For other scenarios they are not meaningful to add by the consumer of the API

  const actualNarrationTree = narrationTree ? narrationTree : narrationTreeDefaultRef.current;
  const readById = (0,react.useCallback)((narrationId, profanityFilterContext = {
    outOfGame: true,
    inGame: true
  }, interruptible = true, required = false, playInBackground = false) => {
    var _narrationNode$getSuf, _narrationNode$getSuf2;

    // TODO should we always do this?
    // Is there any scenario at all in which we wouldn’t want to clear the current
    // narration before starting the new one?
    // driver.clear()
    const currentAncestry = getAncestry(actualNarrationTree, narrationId);
    const previousAncestry = getAncestry(actualNarrationTree, previousNarrationId.current);
    const ancestryDifference = getAncestryDifference(currentAncestry, previousAncestry);
    const narration = constructNarration(actualNarrationTree, ancestryDifference.length === 0 ? [narrationId] : ancestryDifference);
    const narrationNode = actualNarrationTree[narrationId];
    const suffixNarration = (_narrationNode$getSuf = (_narrationNode$getSuf2 = narrationNode.getSuffix) === null || _narrationNode$getSuf2 === void 0 ? void 0 : _narrationNode$getSuf2.call(narrationNode)) !== null && _narrationNode$getSuf !== void 0 ? _narrationNode$getSuf : '';
    const finalNarration = suffixNarration !== '' ? narration + ' . ' + suffixNarration : narration;

    if (false) {}

    readText(finalNarration, profanityFilterContext, interruptible, required, playInBackground, narrationId);
  }, [actualNarrationTree, readText]);
  (0,react.useEffect)(() => {
    if (disabled === true) {
      clear();
    }
  }, [clear, disabled]);
  return /*#__PURE__*/react.createElement(NarrationDriverProvider, {
    value: {
      narrationTree: actualNarrationTree,
      readById,
      readText,
      clear
    }
  }, /*#__PURE__*/react.createElement(NarrationEnabledProvider, {
    value: isDisabled !== react_facet_src.NO_VALUE ? !isDisabled : true
  }, children));
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/screenReaderFacet.ts

let ProfanityFilterContext; // refer to https://coherent-labs.com/Documentation/cpp-gameface/df/d01/javascript_virtual_machine.html
// __Type is needed by Gameface when passing javascript object to C++

(function (ProfanityFilterContext) {
  ProfanityFilterContext[ProfanityFilterContext["NONE"] = 0] = "NONE";
  ProfanityFilterContext[ProfanityFilterContext["UI_FRONT_END"] = 1] = "UI_FRONT_END";
  ProfanityFilterContext[ProfanityFilterContext["UI_IN_GAME"] = 2] = "UI_IN_GAME";
  ProfanityFilterContext[ProfanityFilterContext["ALL_UI"] = ProfanityFilterContext.UI_FRONT_END | ProfanityFilterContext.UI_IN_GAME] = "ALL_UI";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_CHAT"] = 4] = "IN_GAME_CHAT";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_ITEMS"] = 8] = "IN_GAME_ITEMS";
  ProfanityFilterContext[ProfanityFilterContext["IN_GAME_NAME"] = 16] = "IN_GAME_NAME";
  ProfanityFilterContext[ProfanityFilterContext["ALL"] = ProfanityFilterContext.UI_FRONT_END | ProfanityFilterContext.UI_IN_GAME | ProfanityFilterContext.IN_GAME_CHAT | ProfanityFilterContext.IN_GAME_ITEMS | ProfanityFilterContext.IN_GAME_NAME] = "ALL";
})(ProfanityFilterContext || (ProfanityFilterContext = {}));

const SCREEN_READER_FACET = 'core.screenReader';
/**
 * React Hook that requests the facet
 */

const screenReaderSharedFacet = (0,react_facet_src.sharedFacet)(SCREEN_READER_FACET);
const screenReaderReadFactory = screenReader => (textToRead, profanityFilterContext, interruptible, required, playInBackground, playWhenPlatformTTSEnabled) => {
  screenReader.read(textToRead, profanityFilterContext, {
    __Type: 'core.screenReaderOptions',
    canBeInterrupted: interruptible,
    isRequired: required,
    shouldPlayInBackground: playInBackground,
    shouldPlayWhenPlatformTTSEnabled: playWhenPlatformTTSEnabled
  });
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/useClearNarrationOnRouteChange.ts



/**
 * Whenever a user performs a navigation action, any narration that is currently on-going needs to stop.
 */

const useClearNarrationOnRouteChange = () => {
  const clearScreenReader = (0,react_facet_src.useFacetCallback)(screenReader => () => screenReader.clear(), [], [(0,react_facet_src.useSharedFacet)(screenReaderSharedFacet)]);
  (0,react_facet_src.useFacetEffect)(list => {
    /**
     * Since Ore UI screens can be pre-loaded for caching reasons, this code can execute
     * even without the screen being on a scene stack.
     *
     * Calling clear would wrongly cancel a narration on whatever screen is active in the game.
     */
    if (list.length !== 0) {
      clearScreenReader();
    }
  }, [clearScreenReader], [(0,react_facet_src.useFacetMap)(routerFacet => routerFacet.history.list, [], [(0,react_facet_src.useSharedFacet)(routerFacet_routerFacet)])]);
};
;// CONCATENATED MODULE: ./packages/engine/src/providers/NarratorEngineProvider.tsx







function NarratorEngineProvider({
  children,
  shouldUseQueueSystem
}) {
  useClearNarrationOnRouteChange(); // Warning note: This might cause excesive re-renders if isIdle is introduced to the screenReaderFacet

  const screenReaderFacet = (0,react_facet_src.useSharedFacet)(screenReaderSharedFacet);
  const isUITextToSpeechEnabledFacet = (0,react_facet_src.useFacetMap)(screenReader => screenReader.isUITextToSpeechEnabled, [], [screenReaderFacet]);
  const screenReaderIsIdleFacet = (0,react_facet_src.useFacetMap)(screenReader => screenReader.isIdle, [], [screenReaderFacet]);
  const read = (0,react_facet_src.useFacetCallback)(screenReaderReadFactory, [], [screenReaderFacet]);
  const clear = (0,react_facet_src.useFacetCallback)(screenReader => () => screenReader.clear(), [], [screenReaderFacet]);
  const lastFocusOriginFacet = useLastFocusOrigin();
  const shouldInterrupt = (0,react_facet_src.useFacetMap)(currentFocusChangeSource => currentFocusChangeSource === FocusOrigin.FocusInput || currentFocusChangeSource === FocusOrigin.PointerInput || currentFocusChangeSource === FocusOrigin.URL, [], [lastFocusOriginFacet]);
  const driverRead = (0,react_facet_src.useFacetCallback)(isUITextToSpeechEnabled => (text, profanityContext, interruptible, required, playInBackground) => {
    if (Boolean(isUITextToSpeechEnabled)) {
      read(text, mapProfanityContext(profanityContext), interruptible, required, playInBackground, true);
    }
  }, [read], [isUITextToSpeechEnabledFacet]);
  const driverFacet = (0,react.useMemo)(() => ({
    read: driverRead,
    clear: () => clear()
  }), [driverRead, clear]);
  const isDisabledFacet = (0,react_facet_src.useFacetMap)(isUITextToSpeechEnabled => !Boolean(isUITextToSpeechEnabled), [], [isUITextToSpeechEnabledFacet]);
  return /*#__PURE__*/react.createElement(NarrationSetup, {
    driver: driverFacet,
    disabled: isDisabledFacet,
    isIdle: screenReaderIsIdleFacet,
    shouldUseQueueSystem: shouldUseQueueSystem === true,
    shouldInterrupt: shouldInterrupt
  }, children);
}
function mapProfanityContext(profanityContext) {
  let x = 0;

  if (profanityContext.outOfGame) {
    x = x + ProfanityFilterContext.UI_FRONT_END;
  }

  if (profanityContext.inGame) {
    x = x + ProfanityFilterContext.UI_IN_GAME;
  }

  if (profanityContext.inGameChat) {
    x = x + ProfanityFilterContext.IN_GAME_CHAT;
  }

  if (profanityContext.inGameItem) {
    x = x + ProfanityFilterContext.IN_GAME_ITEMS;
  }

  if (profanityContext.inGameName) {
    x = x + ProfanityFilterContext.IN_GAME_NAME;
  }

  return x;
}
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/SoundProvider.tsx


function SoundProvider({
  children,
  driver
}) {
  return /*#__PURE__*/react.createElement(context_Provider, {
    value: driver.play
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/soundFacet.ts

const SOUND_FACET = 'core.sound';
const soundFacet = (0,react_facet_src.sharedFacet)(SOUND_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/SoundEngineProvider.tsx




function SoundEngineProvider({
  children
}) {
  const soundApi = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(soundFacet));
  const soundDriver = (0,react.useMemo)(() => ({
    play(eventName, extraDelay, volume = 1, pitch = 1) {
      const delay = extraDelay;
      let soundId;
      let timeout;

      const play = () => {
        if (soundApi == null || soundApi === react_facet_src.NO_VALUE) {
          console.log('Bedrock Sound driver not yet initialized while playing', eventName);
          return;
        }

        soundId = soundApi.play(eventName, volume, pitch);
      };

      if (delay > 0) {
        timeout = setTimeout(play, delay);
      } else {
        play();
      }

      return () => {
        if (timeout != null) clearTimeout(timeout);

        if (soundApi == null || soundApi === react_facet_src.NO_VALUE) {
          console.log('Bedrock Sound driver not yet initialized while stopping', eventName);
          return;
        } else if (soundApi.isPlaying(soundId)) {
          soundApi.fadeOut(soundId, 0);
        }
      };
    }

  }), [soundApi]);
  return /*#__PURE__*/react.createElement(SoundProvider, {
    driver: soundDriver
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/SafeZoneContext.ts

const safeZoneContext = (0,react.createContext)({
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
});
const useSafeZone = () => (0,react.useContext)(safeZoneContext);
;// CONCATENATED MODULE: ./packages/react-device-information/src/SplitScreen.tsx

let SplitScreen_SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(SplitScreen_SplitScreenDirection || (SplitScreen_SplitScreenDirection = {}));

const splitScreenContext = (0,react.createContext)({
  numActivePlayers: 1,
  direction: SplitScreen_SplitScreenDirection.HORIZONTAL,
  position: 0
});
const useSplitScreen = () => (0,react.useContext)(splitScreenContext);
function SplitScreenProvider({
  children,
  numActivePlayers,
  direction = SplitScreen_SplitScreenDirection.HORIZONTAL,
  position
}) {
  const value = (0,react.useMemo)(() => ({
    numActivePlayers,
    direction,
    position
  }), [numActivePlayers, direction, position]);
  return /*#__PURE__*/react.createElement(splitScreenContext.Provider, {
    value: value
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/calculateSafeZone.ts
function calculateSafeZone(safeAreaX, safeAreaY, screenPositionX, screenPositionY) {
  const clampedSafeAreaX = clamp(safeAreaX, 0.9, 1);
  const clampedSafeAreaY = clamp(safeAreaY, 0.9, 1);
  const clampedScreenPositionX = clamp(screenPositionX, -0.1, 0.1);
  const clampedScreenPositionY = clamp(screenPositionY, -0.1, 0.1);
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  return {
    top: Math.round((1 - clampedSafeAreaY + clampedScreenPositionY) / 2 * windowHeight),
    bottom: Math.round((1 - clampedSafeAreaY - clampedScreenPositionY) / 2 * windowHeight),
    left: Math.round((1 - clampedSafeAreaX + clampedScreenPositionX) / 2 * windowWidth),
    right: Math.round((1 - clampedSafeAreaX - clampedScreenPositionX) / 2 * windowWidth)
  };
}

function clamp(input, min, max) {
  return Math.min(Math.max(input, min), max);
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/applySplitScreen.ts
var applySplitScreen_SplitScreenDirection;

(function (SplitScreenDirection) {
  SplitScreenDirection[SplitScreenDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
  SplitScreenDirection[SplitScreenDirection["VERTICAL"] = 1] = "VERTICAL";
})(applySplitScreen_SplitScreenDirection || (applySplitScreen_SplitScreenDirection = {}));

function applySplitScreen({
  top,
  bottom,
  left,
  right
}, {
  numActivePlayers,
  direction,
  position
}) {
  return {
    top: isOnTop(numActivePlayers, position, direction) ? top : 0,
    bottom: isOnBottom(numActivePlayers, position, direction) ? bottom : 0,
    left: isOnLeft(numActivePlayers, position, direction) ? left : 0,
    right: isOnRight(numActivePlayers, position, direction) ? right : 0
  };
}

function isOnTop(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 0 || position === 1 && direction === applySplitScreen_SplitScreenDirection.VERTICAL;

    case 3:
      return position === 0 || position === 1;

    case 4:
      return position === 0 || position === 1;

    default:
      return true;
  }
}

function isOnBottom(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 1 || position === 0 && direction === applySplitScreen_SplitScreenDirection.VERTICAL;

    case 3:
      return position === 2;

    case 4:
      return position === 2 || position === 3;

    default:
      return true;
  }
}

function isOnLeft(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 0 || position === 1 && direction === applySplitScreen_SplitScreenDirection.HORIZONTAL;

    case 3:
      return position === 0 || position === 2;

    case 4:
      return position === 0 || position === 2;

    default:
      return true;
  }
}

function isOnRight(numActivePlayers, position, direction) {
  switch (numActivePlayers) {
    case 2:
      return position === 1 || position === 0 && direction === applySplitScreen_SplitScreenDirection.HORIZONTAL;

    case 3:
      return position === 1;

    case 4:
      return position === 1 || position === 3;

    default:
      return true;
  }
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/useSafeZoneCalculation/useSafeZoneCalculation.ts




function useSafeZoneCalculation(safeAreaX, safeAreaY, screenPositionX, screenPositionY) {
  const splitScreen = useSplitScreen();
  const calculateSafeZoneWithLatestValues = (0,react.useCallback)(() => calculateSafeZone(safeAreaX, safeAreaY, screenPositionX, screenPositionY), [safeAreaX, safeAreaY, screenPositionX, screenPositionY]);
  const calculateSafeZoneWithSplitScreen = (0,react.useCallback)(() => applySplitScreen(calculateSafeZoneWithLatestValues(), splitScreen), [calculateSafeZoneWithLatestValues, splitScreen]);
  const [safeZone, setSafeZone] = (0,react.useState)(calculateSafeZoneWithSplitScreen);
  (0,react.useEffect)(() => {
    setSafeZone(calculateSafeZoneWithSplitScreen);

    const onResize = () => setSafeZone(calculateSafeZoneWithSplitScreen);

    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, [calculateSafeZoneWithSplitScreen]);
  return safeZone;
}
;// CONCATENATED MODULE: ./packages/react-device-information/src/SafeZone/SafeZoneProvider.tsx



function SafeZoneProvider({
  children,
  safeAreaX,
  safeAreaY,
  screenPositionX,
  screenPositionY
}) {
  const safeZone = useSafeZoneCalculation(safeAreaX, safeAreaY, screenPositionX, screenPositionY);
  return /*#__PURE__*/react.createElement(safeZoneContext.Provider, {
    value: safeZone
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/safeZoneFacet.ts

const SAFE_ZONE_FACET = 'core.safeZone';
/**
 * React Hook that requests the facet
 */

const safeZoneFacet = (0,react_facet_src.sharedFacet)(SAFE_ZONE_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/SafeZoneEngineProvider.tsx




function SafeZoneEngineProvider({
  children
}) {
  const safeZone = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(safeZoneFacet));
  return safeZone != null && safeZone !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(SafeZoneProvider, {
    safeAreaX: safeZone.safeAreaX,
    safeAreaY: safeZone.safeAreaY,
    screenPositionX: safeZone.screenPositionX,
    screenPositionY: safeZone.screenPositionY
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/SplitScreenEngineProvider.tsx




function SplitScreenEngineProvider({
  children
}) {
  const splitScreen = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(splitScreenFacet));
  return splitScreen != null && splitScreen !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(SplitScreenProvider, {
    numActivePlayers: splitScreen.numActivePlayers,
    direction: splitScreen.splitScreenDirection,
    position: splitScreen.splitScreenPosition
  }, children) : null;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/animationConfiguration.ts


const animationConfiguration_context = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: true
}));
const ScreenAnimationEnabledProvider = animationConfiguration_context.Provider;
const useScreenAnimationEnabled = () => (0,react.useContext)(animationConfiguration_context);
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider = ({});
;// CONCATENATED MODULE: ./packages/themes/src/context.ts

const interactiveThemeContext = (0,react.createContext)({
  theme: "vanilla" || 0,
  onSetTheme: () => {}
});
const context_InteractiveThemeProvider = interactiveThemeContext.Provider;
const useInteractiveTheme = () => useContext(interactiveThemeContext).theme;
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ThemeProvider = ({"themeProvider":"N1Tqo"});
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Button_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/NintendoIcons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NintendoIcons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/PCImages.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PCImages_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/PS4Icons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS4Icons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/PS5Icons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS5Icons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/XboxIcons.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const XboxIcons_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ProgressBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioBox_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SideMenu_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Slider/Slider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Slider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Switch_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TabBar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggle_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tokens.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider_tokens_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Window_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tokens.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UIProvider_tokens_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui/src/themeVariables.ts
// Vanilla tokens




















 // Docs tokens








const toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const themeVariables = {
  docs: toClassNamesFlatList(Divider_theme_docs_variables, Link_theme_docs_variables, BackButton_theme_docs_variables, MenuButton_theme_docs_variables, NavigationBar_theme_docs_variables, UIProvider_tokens_theme_docs_variables),
  vanilla: toClassNamesFlatList(Button_theme_vanilla_variables, NintendoIcons_theme_vanilla_variables, PCImages_theme_vanilla_variables, PS4Icons_theme_vanilla_variables, PS5Icons_theme_vanilla_variables, XboxIcons_theme_vanilla_variables, Divider_theme_vanilla_variables, InputLegend_theme_vanilla_variables, Link_theme_vanilla_variables, BackButton_theme_vanilla_variables, MenuButton_theme_vanilla_variables, NavigationBar_theme_vanilla_variables, ProgressBar_theme_vanilla_variables, RadioBox_theme_vanilla_variables, SideMenu_theme_vanilla_variables, Slider_theme_vanilla_variables, Switch_theme_vanilla_variables, TabBar_theme_vanilla_variables, Toggle_theme_vanilla_variables, UIProvider_tokens_theme_vanilla_variables, Window_theme_vanilla_variables)
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSlider/BaseSlider.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSlider_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseTextField_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ScrollView_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSlider/BaseSlider.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSlider_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseTextField_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.badger.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_badger_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-internal/src/themeVariables.ts
// Vanilla tokens





 // Badger tokens





 // Docs tokens



const themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const themeVariables_themeVariables = {
  vanilla: themeVariables_toClassNamesFlatList(BaseDropdown_theme_vanilla_variables, BaseSlider_theme_vanilla_variables, BaseTextField_theme_vanilla_variables, Pressable_theme_vanilla_variables, MouseScrollbar_theme_vanilla_variables, ScrollView_theme_vanilla_variables),
  badger: themeVariables_toClassNamesFlatList(BaseDropdown_theme_badger_variables, BaseSlider_theme_badger_variables, BaseTextField_theme_badger_variables, Pressable_theme_badger_variables, MouseScrollbar_theme_badger_variables),
  docs: themeVariables_toClassNamesFlatList(MouseScrollbar_theme_docs_variables)
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForward_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForward_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/ui-icons/src/themeVariables.ts
// Vanilla

 // Docs




const src_themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const src_themeVariables_themeVariables = {
  vanilla: src_themeVariables_toClassNamesFlatList(IconArrowBack_theme_vanilla_variables, IconArrowForward_theme_vanilla_variables),
  docs: src_themeVariables_toClassNamesFlatList(IconArrowBack_theme_docs_variables, IconArrowForward_theme_docs_variables)
};
;// CONCATENATED MODULE: ./packages/react-component-playground/src/AlgoliaSearch/AlgoliaSearch.theme.docs.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AlgoliaSearch_theme_docs_variables = ({});
;// CONCATENATED MODULE: ./packages/react-component-playground/src/AlgoliaSearch/AlgoliaSearch.theme.vanilla.variables.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AlgoliaSearch_theme_vanilla_variables = ({});
;// CONCATENATED MODULE: ./packages/react-component-playground/src/themeVariables.ts



const react_component_playground_src_themeVariables_toClassNamesFlatList = (...styles) => {
  return styles.reduce((flatStyles, currentStyles) => {
    flatStyles = flatStyles.concat(Object.values(currentStyles));
    return flatStyles;
  }, []);
};

const react_component_playground_src_themeVariables_themeVariables = {
  docs: react_component_playground_src_themeVariables_toClassNamesFlatList(AlgoliaSearch_theme_docs_variables),
  vanilla: react_component_playground_src_themeVariables_toClassNamesFlatList(AlgoliaSearch_theme_vanilla_variables)
};
;// CONCATENATED MODULE: ./packages/themes/src/Provider/docs.theme.ts




const docs = [...themeVariables.docs, ...themeVariables_themeVariables.docs, ...src_themeVariables_themeVariables.docs, ...react_component_playground_src_themeVariables_themeVariables.docs];
;// CONCATENATED MODULE: ./packages/themes/src/Provider/vanilla.theme.ts




const vanilla = [...themeVariables.vanilla, ...themeVariables_themeVariables.vanilla, ...src_themeVariables_themeVariables.vanilla, ...react_component_playground_src_themeVariables_themeVariables.vanilla];
;// CONCATENATED MODULE: ./games/vanilla/theme/src/palette.ts
const palette = {
  green10: '#a0e081',
  green20: '#86d562',
  green30: '#6cc349',
  green40: '#52a535',
  green50: '#3c8527',
  green60: '#2a641c',
  green70: '#1d4d13',
  green80: '#153a0e',
  green90: '#112f0b',
  green100: '#0f2b0a',
  white: '#ffffff',
  black: '#000000',
  gray10: '#f4f6f9',
  gray20: '#e6e8eb',
  gray30: '#d0d1d4',
  gray40: '#b1b2b5',
  gray50: '#8c8d90',
  gray60: '#58585a',
  gray70: '#48494a',
  gray80: '#313233',
  gray90: '#242425',
  gray100: '#1e1e1f',
  red10: '#ff8080',
  red20: '#d93636',
  red30: '#b31b1b',
  red40: '#d54242',
  red50: '#ca3636',
  red60: '#c02d2d',
  red70: '#b62525',
  red80: '#ad1d1d',
  red90: '#a31616',
  red100: '#990f0f',
  orange10: '#ffb366',
  orange20: '#d3791f',
  orange30: '#a65b11',
  yellow10: '#ffe866',
  yellow20: '#e5c317',
  yellow30: '#8a7500',
  gold10: '#fff0c5',
  gold20: '#ffd783',
  gold30: '#f8af2b',
  gold40: '#ce8706',
  gold50: '#ae7100',
  blue10: '#8cb3ff',
  blue20: '#2e6be5',
  blue30: '#1452cc',
  blackOpacity10: 'rgba(0, 0, 0, 0.1)',
  blackOpacity20: 'rgba(0, 0, 0, 0.2)',
  blackOpacity25: 'rgba(0, 0, 0, 0.25)',
  blackOpacity30: 'rgba(0, 0, 0, 0.3)',
  blackOpacity40: 'rgba(0, 0, 0, 0.4)',
  blackOpacity50: 'rgba(0, 0, 0, 0.5)',
  blackOpacity60: 'rgba(0, 0, 0, 0.6)',
  blackOpacity70: 'rgba(0, 0, 0, 0.7)',
  blackOpacity80: 'rgba(0, 0, 0, 0.8)',
  blackOpacity90: 'rgba(0, 0, 0, 0.9)',
  blackOpacity100: 'rgba(0, 0, 0, 1)',
  whiteOpacity10: 'rgba(255, 255, 255, 0.1)',
  whiteOpacity20: 'rgba(255, 255, 255, 0.2)',
  whiteOpacity30: 'rgba(255, 255, 255, 0.3)',
  whiteOpacity40: 'rgba(255, 255, 255, 0.4)',
  whiteOpacity50: 'rgba(255, 255, 255, 0.5)',
  whiteOpacity60: 'rgba(255, 255, 255, 0.6)',
  whiteOpacity70: 'rgba(255, 255, 255, 0.7)',
  whiteOpacity80: 'rgba(255, 255, 255, 0.8)',
  whiteOpacity90: 'rgba(255, 255, 255, 0.9)',
  pink10: '#FB95E2',
  pink20: '#FFB1EC',
  pink30: '#E159C2',
  pink40: '#F877DC',
  purple40: '#643ACB',
  deepBlue10: '#AC90F3',
  deepBlue20: '#9471E0',
  deepBlue40: '#8557F8',
  deepBlue50: '#7345E5',
  deepBlue60: '#5D2CC6',
  deepBlue70: '#4A1CAC',
  deepBlue100: '#050029',
  deepBlueOpacity50: 'rgba(5, 0, 41, 0.5)'
};
;// CONCATENATED MODULE: ./games/vanilla/theme/src/index.ts

;// CONCATENATED MODULE: ./support/docs/theme/src/palette.ts

;// CONCATENATED MODULE: ./support/docs/theme/src/index.ts

;// CONCATENATED MODULE: ./games/edu/theme/src/palette.ts

;// CONCATENATED MODULE: ./games/edu/theme/src/index.ts

;// CONCATENATED MODULE: ./games/example/theme/src/palette.ts

;// CONCATENATED MODULE: ./games/example/theme/src/index.ts

;// CONCATENATED MODULE: ./support/test-screens/theme/src/palette.ts

;// CONCATENATED MODULE: ./support/test-screens/theme/src/index.ts

;// CONCATENATED MODULE: ./palettes.ts





const palettes_docs = (/* unused pure expression or super */ null && (docsPalette));
const edu = (/* unused pure expression or super */ null && (eduPalette));
const example = (/* unused pure expression or super */ null && (examplePalette));
const testScreens = (/* unused pure expression or super */ null && (testScreensPalette));
const palettes_vanilla = (/* unused pure expression or super */ null && (vanillaPalette));
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.dynamic.tsx







const themes = {
  docs: docs,
  legacy: [],
  vanilla: vanilla
};
const defaultTheme = (/* unused pure expression or super */ null && ("vanilla" || 0));
/**
 * Theme provider that loads all the available themes and let them be selected dynamically at runtime.
 * This component should not be used by the "production build" of game screens.
 *
 * This is toggled by a configuration flag within `loom` (webpack config)
 */

function ThemeProvider_dynamic_ThemeProvider({
  children,
  theme = defaultTheme
}) {
  const ref = useRef(null);
  const [currentTheme, setCurrentTheme] = useState(theme);
  const themeClasses = themes[currentTheme];
  const vanillaThemeClasses = themes['vanilla'];
  useEffect(() => {
    if (ref.current == null) return;
    const palette = palettes[theme];
    const style = ref.current.style;

    for (const key in palette) {
      style.setProperty(`--${key}`, palette[key]);
    }
  }, [ref, theme]); // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions

  if (!themeClasses && "production" === 'development') {}

  useEffect(() => {
    setCurrentTheme(theme);
  }, [theme]);
  return /*#__PURE__*/React.createElement(InteractiveThemeProvider, {
    value: {
      theme: currentTheme,
      onSetTheme: setCurrentTheme
    }
  }, /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: classnames(styles.themeProvider, vanillaThemeClasses)
  }, /*#__PURE__*/React.createElement("div", {
    className: classnames(styles.themeProvider, themeClasses)
  }, children)));
}
;// CONCATENATED MODULE: ./packages/themes/src/Provider/ThemeProvider.static.tsx


const ThemeProvider_static_defaultTheme = "vanilla" || 0;
/**
 * Dummy component that is used to not have any dynamic theme being applied (has a static theme)
 * This is toggled by a configuration flag within `loom` (webpack config)
 */

function ThemeProvider_static_ThemeProvider({
  children
}) {
  return /*#__PURE__*/react.createElement(context_InteractiveThemeProvider, {
    value: {
      theme: ThemeProvider_static_defaultTheme,
      onSetTheme: () => {}
    }
  }, children);
}
;// CONCATENATED MODULE: ./packages/themes/src/Provider/index.ts



;// CONCATENATED MODULE: ./packages/themes/src/index.ts




;// CONCATENATED MODULE: ./packages/ui-hooks/src/useAnimationState.ts
 // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars

const useAnimationState_noop = (...args) => undefined;
/**
 * @deprecated use InteractivePrimitive instead
 */


function useAnimationState({
  onClick = useAnimationState_noop,
  resetDelay = 200,
  animationLength = 0,
  touchUpDelay = 200
} = {}) {
  const [clicked, setClicked] = useState(false);
  const [touchedUp, setTouchedUp] = useState(false);
  const [touchedDown, setTouchedDown] = useState(false);
  const setTimeoutRef = useRef(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  const wrappedOnClick = (...args) => {
    setTouchedDown(true);
    setTimeoutRef.current = setTimeout(() => {
      setTouchedUp(true);
      setTimeoutRef.current = setTimeout(() => {
        setClicked(true);
        onClick(...args);
        setTimeoutRef.current = setTimeout(() => {
          setTouchedDown(false);
          setTouchedUp(false);
          setClicked(false);
          setTimeoutRef.current = undefined;
        }, Math.max(0, resetDelay - animationLength));
      }, animationLength);
    }, touchUpDelay);
  };

  useEffect(() => () => setTimeoutRef.current && clearTimeout(setTimeoutRef.current), [setTimeoutRef]);
  return {
    clicked,
    touchedUp,
    touchedDown,
    wrappedOnClick
  };
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useLangDirection.ts

function useLangDirection(isRtl) {
  (0,react.useEffect)(() => {
    if (false) {}
    const html = document.getElementsByTagName('html')[0];
    const cssLink = document.querySelector('link[rel="stylesheet"]');

    if (cssLink == null) {
      console.error('No stylesheet link tag found, RTL is not applied');
      return;
    }

    const cssHref = cssLink.getAttribute('href');

    if (cssHref == null) {
      console.error('Something wrong with style attribute, RTL is not applied');
      return;
    }

    const cssFileName = cssHref.substring(0, cssHref.length - 4).replace('.rtl', '');
    const suffix = isRtl ? '.rtl' : '';
    const transformedLink = cssFileName + suffix + '.css';

    if (isRtl) {
      html.setAttribute('dir', 'rtl');
    } else {
      html.removeAttribute('dir');
    }

    cssLink.setAttribute('href', transformedLink);
  }, [isRtl]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useOnChange.ts

function useOnChange(value, onChange) {
  const previousValueRef = useRef(value);
  useEffect(() => {
    if (previousValueRef.current !== value) {
      previousValueRef.current = value;
      onChange();
    }
  }, [value, onChange]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useOnClickOutside.ts

function useOnClickOutside(ref, callback, isOpen = true) {
  const isOpenFacet = (0,react_facet_src.useFacetWrap)(isOpen);
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (!isOpen) return;

    const listener = event => {
      if (!(ref.current && ref.current.contains(event.target))) {
        callback();
      }
    };

    document.addEventListener('click', listener, true);
    return () => {
      document.removeEventListener('click', listener, true);
    };
  }, [ref, callback], [isOpenFacet]);
}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useUniqueIdentifier.ts

let counter = 0;
const useUniqueIdentifier = () => {
  return (0,react.useMemo)(() => `unique-identifier${counter++}`, []);
};
;// CONCATENATED MODULE: ./packages/ui-hooks/src/useRestoreFocus.ts



const useRestoreFocus = (captureFocus, targetGamepadAlias) => {
  const setFocusedId = useSetFocusedId();
  const restoreFocusedId = useRef(useRestoreFocus_noop);
  useFacetEffect(captureFocus => {
    if (captureFocus) {
      const restoreFocusedIdValue = setFocusedId(targetGamepadAlias);

      if (restoreFocusedIdValue !== NO_VALUE) {
        restoreFocusedId.current = restoreFocusedIdValue;
      }
    } else {
      restoreFocusedId.current();
    }
  }, [setFocusedId, targetGamepadAlias], [captureFocus]);
};

function useRestoreFocus_noop() {}
;// CONCATENATED MODULE: ./packages/ui-hooks/src/index.ts






;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/useLocaleSpecificFonts.ts

/**
 * Defines custom CSS properties with font fallbacks custom tailored based
 * on the current locale.
 *
 * These properties are injected by @mojang/postcss-minecraft-fallback-font-family
 *
 * We need to do this because there are unicode clashes between some of the fonts that we use.
 * For example, Japanese and Chinese characters end up using the wrong period ('.') if we don't
 * order the font families in a specific order.
 *
 * For more information on why this is needed, check the ticket:
 * - https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/504080
 */

const DEFAULT = 'Noto Sans';
const JP = 'Noto Sans JP';
const TC = 'Noto Sans TC';
const SC = 'Noto Sans SC';
const KR = 'Noto Sans KR';
const AR = 'Noto Sans AR';
const FALLBACKS = ['Noto Sans Mongolian', 'Noto Sans Syriac', 'Noto Sans TamilSupplement'];
function getLocaleSpecificFonts(locale) {
  if (locale.startsWith('ja')) {
    return [JP, TC, SC, KR, DEFAULT, ...FALLBACKS];
  } else if (locale === 'zh_TW') {
    return [TC, SC, JP, KR, DEFAULT, ...FALLBACKS];
  } else if (locale === 'zh_CN') {
    return [SC, TC, JP, KR, DEFAULT, ...FALLBACKS];
  } else if (locale.startsWith('ko')) {
    return [KR, TC, SC, JP, DEFAULT, ...FALLBACKS];
  } else if (locale.startsWith('ar_')) {
    return [AR, DEFAULT, KR, TC, SC, JP, ...FALLBACKS];
  } else {
    return [DEFAULT, SC, TC, JP, KR, AR, ...FALLBACKS];
  }
}
function useLocaleSpecificFonts(locale) {
  (0,react.useEffect)(() => {
    const localeSpecificFonts = getLocaleSpecificFonts(locale);
    document.body.style.setProperty('--localeSpecificNotoSansFonts', localeSpecificFonts.join(','));
  }, [locale]);
}
// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(17187);
;// CONCATENATED MODULE: ./packages/react-scaling/src/useOnComponentResize.ts



/**
 * Hook that allows listening on changes of the size of a component
 *
 * @param ref ref to the DOM element being listened
 * @param onResize callback that will be called with the new sizes
 */
const useOnComponentResize_useOnComponentResize = (ref, onResize) => {
  const eventEmitter = (0,react.useContext)(resizesRecalculationContext);
  (0,react.useEffect)(() => {
    const element = ref.current;
    if (element == null) return;
    return observeResize(element, onResize, eventEmitter);
  }, [ref, onResize, eventEmitter]);
};
/**
 * Implementation based on https://github.com/batata-frita/element-rect-observer
 */

const observeResize = (element, onResize, eventEmitter) => {
  let recordedSize;
  let frameId;

  const handler = () => {
    const boundingClientRect = element.getBoundingClientRect(); // If the new bounding client rect is completely zero, that means
    // that the component got hidden. We don't want to act on that, since
    // it is not a resize: when the component gets displayed again, it will
    // have the same size as it had before it being hidden.

    if ( true && boundingClientRect.width === 0 && boundingClientRect.height === 0 && boundingClientRect.top === 0 && boundingClientRect.left === 0 && boundingClientRect.right === 0 && boundingClientRect.bottom === 0 && boundingClientRect.x === 0 && boundingClientRect.y === 0) {
      // However, it could also just be that the component has not yet been made visible,
      // so as a safety we should schedule a new check for the next frame.
      // Just ignoring this would cause components to be rendered incorrectly.
      frameId = requestAnimationFrame(handler);
      return;
    }

    if (recordedSize != null && boundingClientRect.width === recordedSize.width && boundingClientRect.height === recordedSize.height && boundingClientRect.top === recordedSize.top && boundingClientRect.left === recordedSize.left && boundingClientRect.right === recordedSize.right && boundingClientRect.bottom === recordedSize.bottom && boundingClientRect.x === recordedSize.x && boundingClientRect.y === recordedSize.y) {
      return;
    }

    recordedSize = boundingClientRect;
    onResize(recordedSize);
  };
  /**
   * Wait three frames to get the initial value, as Gameface doesn't calculate bounding rect on request.
   * On testing we don't wait so we can have snapshots.
   */


  const handlerWrapper =  false ? 0 : () => {
    frameId = requestAnimationFrame(() => {
      frameId = requestAnimationFrame(handler);
    });
  };
  const observer = new window.MutationObserver(handlerWrapper);
  window.addEventListener('resize', handlerWrapper);
  observer.observe(element, {
    attributes: true,
    childList: true,
    characterData: true,
    subtree: true
  });
  eventEmitter.addListener('recalculate', handlerWrapper);
  handlerWrapper();
  return () => {
    observer.disconnect();
    window.removeEventListener('resize', handlerWrapper);
    eventEmitter.removeListener('recalculate', handlerWrapper);
    cancelAnimationFrame(frameId);
  };
};

const resizesRecalculationContext = (0,react.createContext)(new events.EventEmitter());
/**
 * Hook that returns a function that once called will force recalculating the sizes of all
 * components we are listening on resizing.
 *
 * Can be useful on situations such as transitions or animations that causes the UI to change size unexpectedly.
 */

const useOnComponentResizeForceRecalculate = () => {
  const eventEmitter = (0,react.useContext)(resizesRecalculationContext);
  return (0,react.useCallback)(() => {
    eventEmitter.emit('recalculate');
  }, [eventEmitter]);
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/ScalingProvider.tsx




let GUIScales;

(function (GUIScales) {
  GUIScales[GUIScales["SCALING_25"] = 1] = "SCALING_25";
  GUIScales[GUIScales["SCALING_50"] = 2] = "SCALING_50";
  GUIScales[GUIScales["SCALING_75"] = 3] = "SCALING_75";
  GUIScales[GUIScales["SCALING_100"] = 4] = "SCALING_100";
  GUIScales[GUIScales["SCALING_125"] = 5] = "SCALING_125";
  GUIScales[GUIScales["SCALING_150"] = 6] = "SCALING_150";
  GUIScales[GUIScales["SCALING_175"] = 7] = "SCALING_175";
  GUIScales[GUIScales["SCALING_200"] = 8] = "SCALING_200";
})(GUIScales || (GUIScales = {}));

/**
 * Private API Provider that setups scaling in the UI
 */
function ScalingProvider({
  guiScale,
  onGuiScaleApplied,
  children
}) {
  const [baseFontSize, setBaseFontSize] = (0,react_facet_src.useFacetState)(10);
  (0,react_facet_src.useFacetEffect)(guiScale => {
    setBaseFontSize(guiScale * 2.5);
  }, [setBaseFontSize], [guiScale]);
  (0,react_facet_src.useFacetEffect)((guiScale, baseFontSize) => {
    const html = document.getElementsByTagName('html')[0];
    const body = document.body;
    html.style.fontSize = `${baseFontSize}px`;
    body.style.setProperty('--baseFontSize', `${baseFontSize}px`);
    const base2Scale = Math.max(Math.round(guiScale / 4 * 2), 1);
    body.style.setProperty('--base2Scale', `${base2Scale}px`);
    body.style.setProperty('--base2ScaleNeg', `-${base2Scale}px`);
    const base1Scale = Math.max(Math.round(guiScale / 4), 1);
    body.style.setProperty('--base1Scale', `${base1Scale}px`);
    body.style.setProperty('--base1ScaleNeg', `-${base1Scale}px`);
    onGuiScaleApplied();
  }, [onGuiScaleApplied], [guiScale, baseFontSize]);
  return /*#__PURE__*/react.createElement(resizesRecalculationContext.Provider, {
    value: (0,react.useMemo)(() => new events.EventEmitter(), [])
  }, /*#__PURE__*/react.createElement(scaleContext.Provider, {
    value: guiScale
  }, /*#__PURE__*/react.createElement(baseFontSizeContext.Provider, {
    value: baseFontSize
  }, children)));
}
const baseFontSizeContext = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: 10
}));
const scaleContext = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: 4
}));
;// CONCATENATED MODULE: ./packages/react-scaling/src/useSizeInPixels.ts



/**
 * Converts a size in rems to pixels using the scaling information
 * @deprecated useSizeInPixelsFacet
 */

const useSizeInPixels = sizeInRems => {
  const baseFontSize = (0,react_facet_src.useFacetUnwrap)((0,react.useContext)(baseFontSizeContext));
  const fontSize = baseFontSize === react_facet_src.NO_VALUE ? 10 : baseFontSize;
  return sizeInRems * fontSize;
};
/**
 * Converts a size in rems to pixels using the scaling information
 */

const useSizeInPixelsFacet = sizeInRems => {
  return (0,react_facet_src.useFacetMap)((sizeInRems, baseFontSize) => sizeInRems * baseFontSize, [], [(0,react_facet_src.useFacetWrap)(sizeInRems), (0,react.useContext)(baseFontSizeContext)]);
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useWindowBreakpoint.ts



/**
 * Hook that takes scaling and window size into consideration to calculate styling breakpoints
 */
const useWindowBreakpoint_useWindowBreakpoint = (narrowBreakpointWidth = 70) => {
  const narrowBreakpoint = useSizeInPixels(narrowBreakpointWidth);
  const tabletBreakpoint = useSizeInPixels(128);
  const [breakpoint, setBreakpoint] = (0,react.useState)('desktop');
  (0,react.useEffect)(() => {
    const checkBreakpoint = () => {
      const screenWidth = window.innerWidth;

      if (screenWidth < narrowBreakpoint) {
        return 'narrow';
      }

      if (screenWidth < tabletBreakpoint) {
        return 'tablet';
      }

      return 'desktop';
    };

    const update = () => setBreakpoint(checkBreakpoint());

    update();
    window.addEventListener('resize', update);
    return () => window.removeEventListener('resize', update);
  }, [narrowBreakpoint, tabletBreakpoint]);
  return breakpoint;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useIsWindowNarrow.ts


/**
 * Given a size in rems, taking scaling in consideration it checks if the window is smaller in width
 * than the provided size.
 *
 * @param size in rems
 * @returns if the window is narrower then the provided size
 */

const useIsWindowNarrow = (size = 100) => {
  const sizeInPixels = useSizeInPixels(size);
  const checkNarrow = (0,react.useCallback)(() => {
    return window.innerWidth < sizeInPixels;
  }, [sizeInPixels]);
  const [isNarrow, setIsNarrow] = (0,react.useState)(checkNarrow());
  (0,react.useEffect)(() => {
    const update = () => setIsNarrow(checkNarrow());

    update();
    window.addEventListener('resize', update);
    return () => window.removeEventListener('resize', update);
  }, [checkNarrow]);
  return isNarrow;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/useCustomBreakpoint.ts



/**
 * This code checks the width of the screen to determine if the screen is
 * currently within a breakpoint. The breakpoints are defined by the array
 * of rem widths that is passed in.
 *
 * @param {number[]} widths The rem widths to use as breakpoints
 * @returns {boolean[]} An array of booleans indicating whether the screen
 *   is within the breakpoint or not
 */

function useCustomBreakpoint(widths) {
  const onceRef = (0,react.useRef)(true);
  const [breakpoint, setBreakpoint] = (0,react.useState)([]);
  const allWidthsInPx = (0,react_facet_src.useFacetMap)((widths, baseFontSize) => [0, ...widths].map(width => width * baseFontSize), [], [(0,react_facet_src.useFacetWrap)(widths), (0,react.useContext)(baseFontSizeContext)]);
  (0,react_facet_src.useFacetEffect)(allWidths => {
    const checkBreakpoint = () => {
      const screenWidth = window.innerWidth;
      return allWidths.map((width, i, arr) => {
        if (i === arr.length - 1) {
          return screenWidth >= width;
        }

        return screenWidth >= width && screenWidth < arr[i + 1];
      });
    };

    const update = () => setBreakpoint(checkBreakpoint());

    if (onceRef.current) {
      setBreakpoint(checkBreakpoint());
      onceRef.current = false;
    }

    window.addEventListener('resize', update);
    return () => window.removeEventListener('resize', update);
  }, [setBreakpoint], [allWidthsInPx]);
  return breakpoint;
}
;// CONCATENATED MODULE: ./packages/react-scaling/src/useIsComponentSmallerThan.ts



/**
 * If "unknown', the size of the component is not yet known and the recommendation is to render a skeleton
 */

/**
 * Hook that returns a facet with the information about this component being smaller than a given size
 *
 * @param ref ref to the DOM element being listened
 * @param sizeInRem size in rems
 * @returns Facet<SmallerThanResult>
 */
const useIsComponentSmallerThan = (ref, sizeInRem) => {
  const [isSmallerFacet, setIsSmaller] = (0,react_facet_src.useFacetState)('unknown');
  const onResize = (0,react_facet_src.useFacetCallback)(sizeInPixels => newSize => {
    setIsSmaller(newSize.width < sizeInPixels ? 'smaller' : 'bigger');
  }, [setIsSmaller], [useSizeInPixelsFacet(sizeInRem)]);
  useOnComponentResize_useOnComponentResize(ref, onResize);
  return isSmallerFacet;
};
;// CONCATENATED MODULE: ./packages/react-scaling/src/Scaling.ts






;// CONCATENATED MODULE: ./packages/react-scaling/src/index.ts


;// CONCATENATED MODULE: ./packages/ui/src/UIProvider/UIProvider.tsx








if (false) {}

function UIProvider_UIProvider({
  children,
  guiScale,
  onGuiScaleApplied = UIProvider_noop,
  screenAnimationEnabled,
  isRtl = false,
  locale
}) {
  useLangDirection(isRtl);
  useLocaleSpecificFonts(locale);
  return /*#__PURE__*/react.createElement(ScreenAnimationEnabledProvider, {
    value: screenAnimationEnabled
  }, /*#__PURE__*/react.createElement(ThemeProvider_static_ThemeProvider, null, /*#__PURE__*/react.createElement(ScalingProvider, {
    guiScale: guiScale,
    onGuiScaleApplied: onGuiScaleApplied
  }, children)));
}

const UIProvider_noop = () => {};
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocale.tsx


const useLocale = () => {
  return (0,react.useContext)(LocalizationContext).locale;
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/customScalingFacet.ts

const CUSTOM_SCALING_FACET = 'core.customScaling';
/**
 * React Hook that requests the facet
 */

const customScalingFacet = (0,react_facet_src.sharedFacet)(CUSTOM_SCALING_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/calculateScale.ts

/**
 * How the UI should scale across different screens
 *
 * - default: the way we want to move in the future (should be used by most teams)
 * - compat: some teams have the relative sizes of their components not being mobile-first
 * - legacy: scale the UI so that relative sises compared to legacy screens feels the same
 * - fixed: will only scale when a user actively chooses to scale through an option
 */

function isHandheld(a, b) {
  return b === ScreenType.HANDHELD_SCREEN_TYPE;
}

function calculateScale(mode, screenType, guiScaleModifier, width, height, pixelsPerMillimeter, accessibleGuiScale) {
  if (false) {}
  /**
   * For now, scaling mode 'fixed' will do the same thing as if
   * the user was running in a browser, but that might change.
   */


  if (mode === 'fixed') {
    /**
     * It's possible that guiScaleModifier is also set from the
     * engine when the window is resized. In that case, we probably
     * want to use a different variable here, such as fixedGuiScaleModifier.
     * This potential new value would need to be added to the UIEngineProvider.
     * Basically, we only want fixed scaling to be set by a menu option, the way
     * that scaling can be set in the browser through handleScaleChange (which
     * in turn triggers useScale)
     */
    return calculateFixedGuiScale(guiScaleModifier, accessibleGuiScale);
    /**
     * If this turns out to be an issue, we could temporarily just always return
     * 100% scaling like so:
     *
     * return Scale.SCALE_100_PERCENT
     *
     * This should force the scaling to be fixed, but it won't let the user manually
     * change the scaling, so we will definitely want to have a variable for that.
     */
  }

  const screenTypeBaseScale = SCREEN_TYPE_BASE_SCALE[mode][screenType];

  if (isHandheld(screenTypeBaseScale, screenType)) {
    return calculatePPIGuiScale(mode, screenTypeBaseScale, guiScaleModifier, pixelsPerMillimeter, width, height, accessibleGuiScale);
  }

  return calculateResolutionGuiScale(mode, screenTypeBaseScale, guiScaleModifier, width, height, accessibleGuiScale);
}
/**
 * Calculates the final scaling of UI elements based on the pixel density (PPI) of the current device.
 * It uses the PPI of the original iPhone as a base, and calculates a scaling factor to be applied on the UI.
 *
 * For example:
 * 	- running the game on the original iPhone (163ppi), would result in a guiScale of 4 (the base scale)
 *  - running the game on an iPhone 7 (326ppi, 14.330709 ppm), would return a guiScale of 8
 */

function calculatePPIGuiScale(mode, screenTypeBaseScale, guiScaleModifier, pixelsPerMillimeter, width, height, accessibleGuiScale) {
  const dpiScaleFactor = pixelsPerMillimeter / SCREEN_TYPE_BASE_PPM;
  const widthPoints = width / dpiScaleFactor;
  const heightPoints = height / dpiScaleFactor;
  const currentHandheldDeviceType = widthPoints > 1000 && heightPoints > 700 ? HandheldDeviceType.TABLET : HandheldDeviceType.PHONE;
  const handheldDeviceTypeBaseScale = screenTypeBaseScale[currentHandheldDeviceType];
  const guiScaleBase = Math.round(dpiScaleFactor * handheldDeviceTypeBaseScale);
  const scaledGuiScaleModifier = Math.round(dpiScaleFactor * guiScaleModifier);
  const PPIGuiScale = guiScaleBase + scaledGuiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(PPIGuiScale);
  }

  return PPIGuiScale;
}
/**
 * For TVs and Desktops, the PPI information is not reliable
 * so instead we use a base resolution (1920x1080) and calculate a scaling factor from it
 *
 * For example:
 * - running the game in a console in 1080p will result in the scale of 7 (the base for that screen type)
 * - running the game in a console in 4k will result in the scale of 14 (twice the base for that screen type)
 */


function calculateResolutionGuiScale(mode, screenTypeBaseScale, guiScaleModifier, width, height, accessibleGuiScale) {
  const widthNeeded = 1920;
  const heightNeeded = 1080;
  const widthScale = width / widthNeeded;
  const heightScale = height / heightNeeded;
  const resolutionScaleFactor = Math.min(heightScale, widthScale);
  const guiScaleBase = Math.round(resolutionScaleFactor * screenTypeBaseScale);
  const scaledGuiScaleModifier = Math.round(resolutionScaleFactor * guiScaleModifier);
  const resolutionGuiScale = guiScaleBase + scaledGuiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(resolutionGuiScale);
  }

  return resolutionGuiScale;
}
/**
 * Fixed scaling is to be used on development environments where we don't want the ui to scale (ex: browser)
 */


function calculateFixedGuiScale(guiScaleModifier, accessibleGuiScale) {
  const fixedGuiScale = Scale.SCALE_100_PERCENT + guiScaleModifier;

  if (accessibleGuiScale === true) {
    return calculateAccessibleGuiScale(fixedGuiScale);
  }

  return fixedGuiScale;
}
/**
 * This function returns an increased scale by 25% for accessibility purposes
 */


function calculateAccessibleGuiScale(guiScale) {
  return Math.ceil(guiScale * 1.25);
}
/**
 * For different platforms, what is the "starting scale"
 *
 * In this context, 4 means 100% scaling.
 */


const SCREEN_TYPE_BASE_SCALE = {
  /**
   * There are currently some inconsistencies in how different teams within the monorepo
   * work with scaling, so we provide this mode to keep the "starting scale" consistent
   * across different screen types.
   */
  compat: {
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },

  /**
   * Legacy mode allows better relative sizes between new UI elements and legacy UI elements
   * and can be used in a game that is transitioning to Ore UI (Gameface)
   */
  legacy: {
    /**
     * On desktop, font size should equal or exceed:
     * - 18px at 1080p
     * - 29px at 4k
     *
     * Our base size (for handheld) is 16px, so we should do 125% (5)
     * However, this makes the UI too small in comparison with the legacy UI
     * To keep things more consistently, we are keeping the UI bigger overall, thus having base size as 175% (7) (for the time being)
     *
     * TODO: once more screens are converted to Gameface, we can update this to a more correct number
     */
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * On tv, font size should equal or exceed:
     * - 26px at 1080p
     * - 44px at 4k
     *
     * Our base size (for handheld) is 16px, so we do 175% (7)
     */
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * We use PPI information for handheld, so the base is 100% (4),
     * except for tablets that we bump up to 6 in order to match
     * the size of the UI in the legacy screens.
     */
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_150_PERCENT
    },

    /**
     * TODO: still needs to be defined
     */
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },
  default: {
    /**
     * On desktop, font size should equal or exceed:
     * - 18px at 1080p
     * - 29px at 4k
     *
     * Our base size (for handheld) is 16px, so we should do 125% (5)
     */
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_125_PERCENT,

    /**
     * On tv, font size should equal or exceed:
     * - 26px at 1080p
     * - 44px at 4k
     *
     * Our base size (for handheld) is 16px, so we do 175% (7)
     */
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_175_PERCENT,

    /**
     * We use PPI information for handheld, so the base is 100% (4)
     */
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },

    /**
     * TODO: still needs to be defined
     */
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  },

  /**
   * This is an experimental ScalingMode that will never scale based on resolution
   * or screen size. It can, however, be scaled manually by a user through settings.
   */
  fixed: {
    [ScreenType.DESKTOP_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.TV_SCREEN_TYPE]: Scale.SCALE_100_PERCENT,
    [ScreenType.HANDHELD_SCREEN_TYPE]: {
      [HandheldDeviceType.PHONE]: Scale.SCALE_100_PERCENT,
      [HandheldDeviceType.TABLET]: Scale.SCALE_100_PERCENT
    },
    [ScreenType.VR_SCREEN_TYPE]: Scale.SCALE_100_PERCENT
  }
};
/**
 * 163ppi which is the original iPhone
 */

const SCREEN_TYPE_BASE_PPM = 6.417322835;
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/UIEngineProvider.tsx











function UIEngineProvider({
  children,
  scalingMode
}) {
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const customScaling = (0,react_facet_src.useSharedFacet)(customScalingFacet);
  const splitScreen = (0,react_facet_src.useSharedFacet)(splitScreenFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const scalingModeToUse = (0,react_facet_src.useFacetMap)(customScaling => customScaling.scalingModeOverride != null && customScaling.scalingModeOverride && customScaling.scalingModeOverride.length > 0 ? customScaling.scalingModeOverride : scalingMode, [scalingMode], [customScaling]);
  const fixedGuiScaleModifier = (0,react_facet_src.useFacetMap)(customScaling => customScaling.fixedGuiScaleModifier, [], [customScaling]);
  const accessibleGuiScale = (0,react_facet_src.useFacetMap)(customScaling => {
    var _customScaling$guiAcc;

    return (_customScaling$guiAcc = customScaling.guiAccessibilityScaling) !== null && _customScaling$guiAcc !== void 0 ? _customScaling$guiAcc : false;
  }, [], [customScaling]); // Wait for all facets to emit values

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [deviceInformation, splitScreen, animation, fixedGuiScaleModifier, scalingModeToUse, accessibleGuiScale]); // Performance while running the game in split screen is degraded,
  // so we disable animations to a more snappy UI

  const screenAnimationEnabled = (0,react_facet_src.useFacetMap)((animation, splitScreen) => animation.screenAnimationEnabled && splitScreen.numActivePlayers === 1, [], [animation, splitScreen]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(ScaleProvider, {
    deviceInformationFacet: deviceInformation,
    scalingMode: scalingModeToUse,
    screenAnimationEnabled: screenAnimationEnabled,
    fixedGuiScaleModifier: fixedGuiScaleModifier,
    accessibleGuiScale: accessibleGuiScale
  }, children));
}

function ScaleProvider({
  scalingMode,
  children,
  deviceInformationFacet,
  screenAnimationEnabled,
  fixedGuiScaleModifier,
  accessibleGuiScale
}) {
  const screenType = useDeviceScreenType();
  const guiScale = useScale(scalingMode, screenType, deviceInformationFacet, fixedGuiScaleModifier, accessibleGuiScale);
  const locale = useLocale();
  const isRtl = useIsLocaleRtl();
  const handleGuiScaleApplied = (0,react.useCallback)(() => {
    // Gameface currently has a bug where it will apply incorrect proportions to elements
    // when a new base font-size is applied.
    // This events lets the backend knows we just changed the font size so that they can
    // do a workaround
    // More information at https://coherentlabs.zendesk.com/hc/requests/16845
    engineWrapper_engine.trigger('core:gui:resize-hack');
  }, []);
  return /*#__PURE__*/react.createElement(UIProvider_UIProvider, {
    guiScale: guiScale,
    onGuiScaleApplied: handleGuiScaleApplied,
    screenAnimationEnabled: screenAnimationEnabled,
    isRtl: isRtl,
    locale: locale
  }, children);
}

function useScale(scalingMode, screenType, deviceInformation, fixedGuiScaleModifier, accessibleGuiScale) {
  const guiScaleModifier = (0,react_facet_src.useFacetMap)((deviceInformation, fixedGuiScaleModifier, scalingMode) => scalingMode == 'fixed' ? fixedGuiScaleModifier : deviceInformation.guiScaleModifier, [], [deviceInformation, fixedGuiScaleModifier, scalingMode]);
  const calculateCurrentScale = (0,react_facet_src.useFacetCallback)((scalingMode, screenType, deviceInformation, guiScaleModifier, accessibleGuiScale) => () => calculateScale(scalingMode, screenType, guiScaleModifier, window.innerWidth, window.innerHeight, deviceInformation.pixelsPerMillimeter, accessibleGuiScale), [], [scalingMode, screenType, deviceInformation, guiScaleModifier, accessibleGuiScale]); // Initialize the state by calling the calculateCurrentScale function

  const [scale, setScale] = (0,react_facet_src.useFacetState)(calculateCurrentScale());
  (0,react.useEffect)(() => {
    const resize = () => setScale(calculateCurrentScale);

    resize();
    window.addEventListener('resize', resize);
    return () => window.removeEventListener('resize', resize);
  }, [calculateCurrentScale, setScale]);
  (0,react_facet_src.useFacetEffect)(() => {
    setScale(calculateCurrentScale);
  }, [setScale, calculateCurrentScale], [deviceInformation, fixedGuiScaleModifier]);
  return scale;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/UIEngineProvider/index.ts

;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/context/onGlobalChange.ts

function createEmptyTextInputChange() {
  return {
    addedChars: '',
    removedChars: '',
    invalidChars: '',
    index: -1
  };
}
const textFieldOnChangeContext = (0,react.createContext)(null);
const useKeyboardEventCallbacks = () => (0,react.useContext)(textFieldOnChangeContext);
const OnChangeProvider = textFieldOnChangeContext.Provider;
;// CONCATENATED MODULE: ./packages/engine/src/onEvent.ts

function onEvent_onEvent(eventName, cb) {
  const callback = cb; // eslint-disable-line @typescript-eslint/no-explicit-any

  engineWrapper_engine.on(eventName, callback);
  return () => engineWrapper_engine.off(eventName, callback);
}
// Gameface doesn't support returning values from JavaScript so we use
// OutParameter<T> as a workaround and return a value by modifying its
// value property
function onEvent_onReturnValueEvent(eventName, getValue) {
  return onEvent_onEvent(eventName, (out, ...args) => {
    out.value = getValue(...args);
  }); // eslint-disable-next-line react-hooks/exhaustive-deps
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/TextFieldEngineProvider.tsx



function TextFieldEngineProvider({
  children
}) {
  const onGlobalChange = (0,react.useCallback)(cb => {
    // inputChange object will be destroyed after this callback, this is to make sure it can be accessed after the callback
    // TextInputChange only has immutable parameters, so shallow copy applied. Otherwise, it shall be deep copied.
    const copyInputChangeCB = inputChange => {
      cb({
        addedChars: inputChange.addedChars + '',
        removedChars: inputChange.removedChars + '',
        invalidChars: inputChange.invalidChars + '',
        index: inputChange.index + 0
      });
    };

    return onEvent_onEvent('core:keyboard:changed', copyInputChangeCB);
  }, []);
  const onKeyboardSubmitted = (0,react.useCallback)(cb => onEvent_onEvent('core:keyboard:submitted', cb), []);
  const onKeyboadrDismissed = (0,react.useCallback)(cb => onEvent_onEvent('core:keyboard:dismissed', cb), []);
  const onKeyboardTabbed = (0,react.useCallback)(cb => onEvent_onEvent('core:keyboard:tabbed', cb), []);
  const KeyboardCallbacks = {
    changedCB: onGlobalChange,
    submittedCB: onKeyboardSubmitted,
    dismissedCB: onKeyboadrDismissed,
    tabbedCB: onKeyboardTabbed
  };
  return /*#__PURE__*/react.createElement(OnChangeProvider, {
    value: KeyboardCallbacks
  }, children);
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingProvider.tsx


let TelemetryEvent;

(function (TelemetryEvent) {
  TelemetryEvent["FIRST_MEANINGFUL_PAINT"] = "core:telemetry:firstMeaningfulPaint";
  TelemetryEvent["FIRST_CONTENTFUL_PAINT"] = "core:telemetry:firstContentfulPaint";
})(TelemetryEvent || (TelemetryEvent = {}));

const renderQueueMap = () => new Map();

function RenderTrackingProvider({
  children,
  triggerEvent
}) {
  const contentfulRenderQueue = (0,react.useMemo)(renderQueueMap, []);
  const meaningfulRenderQueue = (0,react.useMemo)(renderQueueMap, []);
  const shouldFireMeaningfulPaint = (0,react.useRef)(false);
  const shouldFireContentfulPaint = (0,react.useRef)(false);
  const api = (0,react.useMemo)(() => {
    const meaningfulPaint = () => {
      shouldFireMeaningfulPaint.current = true;
      tryMeaningfulPaint();
    };

    const contentfulPaint = () => {
      shouldFireContentfulPaint.current = true;
      tryContentfulPaint();
    };

    const tryMeaningfulPaint = () => {
      if (contentfulRenderQueue.size === 0 && meaningfulRenderQueue.size === 0 && // Don't fire a meaningful paint if the contentful paints aren't finished
      shouldFireMeaningfulPaint.current) {
        // 👇 Log intentionally left in for debugging
        // console.log(`%c ${TelemetryEvent.FIRST_MEANINGFUL_PAINT}`, 'background: #c6c4f5; color: #222')
        triggerEvent(TelemetryEvent.FIRST_MEANINGFUL_PAINT);
        shouldFireMeaningfulPaint.current = false; // Reset the flag for future use
      }
    };

    const tryContentfulPaint = () => {
      if (contentfulRenderQueue.size === 0 && shouldFireContentfulPaint.current) {
        // 👇 Log intentionally left in for debugging
        // console.log(`%c ${TelemetryEvent.FIRST_CONTENTFUL_PAINT}`, 'background: #c4f5d1; color: #222')
        triggerEvent(TelemetryEvent.FIRST_CONTENTFUL_PAINT);
        shouldFireContentfulPaint.current = false;
      } // We should try a meaningful paint, because all of the meaningful events
      // may have fired before the contentful events were ready (note: this cannot
      // be the other way around, because you cannot have meaningful without contentful)


      tryMeaningfulPaint();
    };

    const block = (id, type) => {
      const renderStates = type === 'contentful' ? contentfulRenderQueue : meaningfulRenderQueue;
      renderStates.set(id, true);
    };

    const unblock = (id, type) => {
      const renderStates = type === 'contentful' ? contentfulRenderQueue : meaningfulRenderQueue;
      renderStates.delete(id); // Try and fire the event if it's ready

      type === 'contentful' ? tryContentfulPaint() : tryMeaningfulPaint();
    };

    return {
      block,
      unblock,
      meaningfulPaint,
      contentfulPaint
    };
  }, [triggerEvent, contentfulRenderQueue, meaningfulRenderQueue]);
  return /*#__PURE__*/react.createElement(RenderTrackingApiContext.Provider, {
    value: api
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/RenderTrackingEngineProvider.tsx



function RenderTrackingEngineProvider({
  children
}) {
  const trigger = (0,react.useMemo)(() => engineWrapper_engine.trigger.bind(engineWrapper_engine), []);
  return /*#__PURE__*/react.createElement(RenderTrackingProvider, {
    triggerEvent: trigger
  }, children);
}
;// CONCATENATED MODULE: ./packages/engine/src/GamepadPolyfillInitializer.tsx


const GamepadPolyfillInitializer = ({
  children
}) => {
  (0,react.useEffect)(() => {
    if (isInitialized()) return;
    const cleanup = initialize();
    return cleanup;
  }, []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, children);
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/requestFacet.ts

const referenceCount = new Map();
const instancePool = new Map(); // eslint-disable-line @typescript-eslint/no-explicit-any

const notFoundPool = new Map(); // eslint-disable-line @typescript-eslint/no-explicit-any

const ERROR_ACTIVATE_NOT_FOUND = 'activate-facet-not-found';
function requestFacet(facetName, update, fallBack, customErrorHandler) {
  var _referenceCount$get;

  const notFound = notFoundPool.get(facetName);

  if (notFound != null) {
    // if not found, we just use the fallback implementation already stored
    // and don't try to request it ever again
    update(notFound);
    return () => {// given it's a facet that was not found, there is no cleanup that needs to be performed
    };
  }

  const defaultErrorHandler = errorCode => {
    console.warn(`Error "${errorCode}" while using facet ${facetName}`);
  };

  const handleError = errorCode => {
    if (errorCode === ERROR_ACTIVATE_NOT_FOUND && fallBack != null) {
      notFoundPool.set(facetName, fallBack);
      update(fallBack);
    } else if (customErrorHandler) {
      customErrorHandler(errorCode);
    } else {
      defaultErrorHandler(errorCode);
    }
  };

  const handleUpdated = newValue => {
    instancePool.set(facetName, newValue);
    update(newValue);
  };

  const facetReferenceCount = (_referenceCount$get = referenceCount.get(facetName)) !== null && _referenceCount$get !== void 0 ? _referenceCount$get : 0;
  const facetInstance = instancePool.get(facetName);
  engineWrapper_engine.on(`facet:updated:${facetName}`, handleUpdated);
  engineWrapper_engine.on(`facet:error:${facetName}`, handleError);

  if (facetReferenceCount === 0) {
    // request the facet if it is the first time
    engineWrapper_engine.trigger('facet:request', [facetName]);
  } else if (facetInstance != null) {
    // since we are not requesting, we send an instance if it is available
    update(facetInstance);
  } // increment the reference count


  referenceCount.set(facetName, facetReferenceCount + 1); // returns a function that performs a cleanup

  return () => {
    var _referenceCount$get2;

    const currentFacetReferenceCount = (_referenceCount$get2 = referenceCount.get(facetName)) !== null && _referenceCount$get2 !== void 0 ? _referenceCount$get2 : 0;
    engineWrapper_engine.off(`facet:updated:${facetName}`, handleUpdated);
    engineWrapper_engine.off(`facet:error:${facetName}`, handleError);

    if (currentFacetReferenceCount === 1) {
      // if it is the last reference, inform the backend it can
      // stop updating this facet
      engineWrapper_engine.trigger('facet:discard', [facetName]); // and remove it from the instance pool

      instancePool.delete(facetName);
    }

    if (currentFacetReferenceCount > 0) {
      referenceCount.set(facetName, currentFacetReferenceCount - 1);
    }
  };
}
function resetInstancePool() {
  instancePool.clear();
  referenceCount.clear();
  notFoundPool.clear();
}
;// CONCATENATED MODULE: ./packages/ui-primitive/src/controllerSpecificButtonTranslation/controllerSpecificButtonTranslation.ts


// TODO: Should this context be part of GamepadProvider? Is it related to Navigation?
// It seems as if it could be part of the device information package instead, or something else unrelated
const controllerSpecificButtonTranslationsContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)({
  keyboard: {},
  gamepad: {}
}));
const useControllerSpecificButtonTranslations = () => (0,react.useContext)(controllerSpecificButtonTranslationsContext);
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocalization.tsx


function generateLocKey(prefix, namespace, key) {
  return `${prefix}${prefix !== '' ? '.' : ''}${namespace}${key}`;
}
function useLocalization_useLocalization(namespace) {
  const {
    translationPrefix,
    translate,
    formatDate
  } = (0,react.useContext)(LocalizationContext);
  const localization = (0,react.useMemo)(() => {
    const t = (key, params) => {
      const completeKey = generateLocKey(translationPrefix, namespace, key);
      const translation = translate(completeKey, params);

      if (!translation && "real" == 'fake') {}

      return translation !== null && translation !== void 0 ? translation : completeKey;
    };

    return {
      f: {
        formatDate
      },
      t
    };
  }, [translationPrefix, namespace, translate, formatDate]);
  return localization;
}
;// CONCATENATED MODULE: ./packages/engine/src/providers/ControllerSpecificButtonTranslationsProvider.tsx







const ControllerSpecificButtonTranslationsProvider = ({
  children
}) => {
  const {
    t
  } = useLocalization_useLocalization('ControllerSpecificButtonNarration'); // We don't want to use useFacetMemo because of the assumption that it might not run when there's no facet,
  // we're not sure if that bug has been fixed. In either case, we only wanna memoize an object and then wrap it to a facet.
  // When the object changes facet update should take care of propagating the update.

  const translations = (0,react.useMemo)(() => ({
    gamepad: {
      [types_ButtonType.A]: {
        [Controller.XBOX]: t('.Gamepad.A.XBOX'),
        [Controller.PS]: t('.Gamepad.A.PS'),
        [Controller.STEAM]: t('.Gamepad.A.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.A.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.A.QUEST')
      },
      [types_ButtonType.B]: {
        [Controller.XBOX]: t('.Gamepad.B.XBOX'),
        [Controller.PS]: t('.Gamepad.B.PS'),
        [Controller.STEAM]: t('.Gamepad.B.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.B.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.B.QUEST')
      },
      [types_ButtonType.X]: {
        [Controller.XBOX]: t('.Gamepad.X.XBOX'),
        [Controller.PS]: t('.Gamepad.X.PS'),
        [Controller.STEAM]: t('.Gamepad.X.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.X.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.X.QUEST')
      },
      [types_ButtonType.Y]: {
        [Controller.XBOX]: t('.Gamepad.Y.XBOX'),
        [Controller.PS]: t('.Gamepad.Y.PS'),
        [Controller.STEAM]: t('.Gamepad.Y.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.Y.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.Y.QUEST')
      },
      [types_ButtonType.START]: {
        [Controller.XBOX]: t('.Gamepad.START.XBOX'),
        [Controller.PS]: t('.Gamepad.START.PS'),
        [Controller.STEAM]: t('.Gamepad.START.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.START.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.START.QUEST')
      },
      [types_ButtonType.SELECT]: {
        [Controller.XBOX]: t('.Gamepad.SELECT.XBOX'),
        [Controller.PS]: t('.Gamepad.SELECT.PS'),
        [Controller.STEAM]: t('.Gamepad.SELECT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.SELECT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.SELECT.QUEST')
      },
      [types_ButtonType.XBOX]: {
        [Controller.XBOX]: t('.Gamepad.XBOX.XBOX'),
        [Controller.PS]: t('.Gamepad.XBOX.PS'),
        [Controller.STEAM]: t('.Gamepad.XBOX.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.XBOX.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.XBOX.QUEST')
      },
      [types_ButtonType.RIGHT_TRIGGER]: {
        [Controller.XBOX]: t('.Gamepad.RT.XBOX'),
        [Controller.PS]: t('.Gamepad.RT.PS'),
        [Controller.STEAM]: t('.Gamepad.RT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RT.QUEST')
      },
      [types_ButtonType.LEFT_TRIGGER]: {
        [Controller.XBOX]: t('.Gamepad.LT.XBOX'),
        [Controller.PS]: t('.Gamepad.LT.PS'),
        [Controller.STEAM]: t('.Gamepad.LT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LT.QUEST')
      },
      [types_ButtonType.LEFT_BUMPER]: {
        [Controller.XBOX]: t('.Gamepad.LB.XBOX'),
        [Controller.PS]: t('.Gamepad.LB.PS'),
        [Controller.STEAM]: t('.Gamepad.LB.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LB.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LB.QUEST')
      },
      [types_ButtonType.RIGHT_BUMPER]: {
        [Controller.XBOX]: t('.Gamepad.RB.XBOX'),
        [Controller.PS]: t('.Gamepad.RB.PS'),
        [Controller.STEAM]: t('.Gamepad.RB.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RB.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RB.QUEST')
      },
      [types_ButtonType.L3]: {
        [Controller.XBOX]: t('.Gamepad.L3.XBOX'),
        [Controller.PS]: t('.Gamepad.L3.PS'),
        [Controller.STEAM]: t('.Gamepad.L3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L3.QUEST')
      },
      [types_ButtonType.R3]: {
        [Controller.XBOX]: t('.Gamepad.R3.XBOX'),
        [Controller.PS]: t('.Gamepad.R3.PS'),
        [Controller.STEAM]: t('.Gamepad.R3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R3.QUEST')
      },
      [types_ButtonType.LEFT]: {
        [Controller.XBOX]: t('.Gamepad.LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT.QUEST')
      },
      [types_ButtonType.RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT.QUEST')
      },
      [types_ButtonType.UP]: {
        [Controller.XBOX]: t('.Gamepad.UP.XBOX'),
        [Controller.PS]: t('.Gamepad.UP.PS'),
        [Controller.STEAM]: t('.Gamepad.UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.UP.QUEST')
      },
      [types_ButtonType.DOWN]: {
        [Controller.XBOX]: t('.Gamepad.DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.DOWN.QUEST')
      },
      [types_ButtonType.NEXT]: {
        [Controller.XBOX]: t('.Gamepad.NEXT.XBOX'),
        [Controller.PS]: t('.Gamepad.NEXT.PS'),
        [Controller.STEAM]: t('.Gamepad.NEXT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.NEXT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.NEXT.QUEST')
      },
      [types_ButtonType.PREV]: {
        [Controller.XBOX]: t('.Gamepad.PREV.XBOX'),
        [Controller.PS]: t('.Gamepad.PREV.PS'),
        [Controller.STEAM]: t('.Gamepad.PREV.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PREV.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PREV.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_LEFT]: {
        [Controller.XBOX]: t('.Gamepad.L_LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.L_LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.L_LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_LEFT.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.L_RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.L_RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.L_RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_RIGHT.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_UP]: {
        [Controller.XBOX]: t('.Gamepad.L_UP.XBOX'),
        [Controller.PS]: t('.Gamepad.L_UP.PS'),
        [Controller.STEAM]: t('.Gamepad.L_UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_UP.QUEST')
      },
      [types_ButtonType.LEFT_ANALOG_DOWN]: {
        [Controller.XBOX]: t('.Gamepad.L_DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.L_DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.L_DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.L_DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.L_DOWN.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_LEFT]: {
        [Controller.XBOX]: t('.Gamepad.R_LEFT.XBOX'),
        [Controller.PS]: t('.Gamepad.R_LEFT.PS'),
        [Controller.STEAM]: t('.Gamepad.R_LEFT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_LEFT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_LEFT.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_RIGHT]: {
        [Controller.XBOX]: t('.Gamepad.R_RIGHT.XBOX'),
        [Controller.PS]: t('.Gamepad.R_RIGHT.PS'),
        [Controller.STEAM]: t('.Gamepad.R_RIGHT.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_RIGHT.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_RIGHT.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_UP]: {
        [Controller.XBOX]: t('.Gamepad.R_UP.XBOX'),
        [Controller.PS]: t('.Gamepad.R_UP.PS'),
        [Controller.STEAM]: t('.Gamepad.R_UP.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_UP.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_UP.QUEST')
      },
      [types_ButtonType.RIGHT_ANALOG_DOWN]: {
        [Controller.XBOX]: t('.Gamepad.R_DOWN.XBOX'),
        [Controller.PS]: t('.Gamepad.R_DOWN.PS'),
        [Controller.STEAM]: t('.Gamepad.R_DOWN.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.R_DOWN.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.R_DOWN.QUEST')
      },
      [types_ButtonType.LEFT_HORIZONTAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT_HORIZONTAL_AXIS.QUEST')
      },
      [types_ButtonType.LEFT_VERTICAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.LEFT_VERTICAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.LEFT_VERTICAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.LEFT_VERTICAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.LEFT_VERTICAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.LEFT_VERTICAL_AXIS.QUEST')
      },
      [types_ButtonType.RIGHT_HORIZONTAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT_HORIZONTAL_AXIS.QUEST')
      },
      [types_ButtonType.RIGHT_VERTICAL_AXIS]: {
        [Controller.XBOX]: t('.Gamepad.RIGHT_VERTICAL_AXIS.XBOX'),
        [Controller.PS]: t('.Gamepad.RIGHT_VERTICAL_AXIS.PS'),
        [Controller.STEAM]: t('.Gamepad.RIGHT_VERTICAL_AXIS.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.RIGHT_VERTICAL_AXIS.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.RIGHT_VERTICAL_AXIS.QUEST')
      },
      // these are "pseudo buttons" defined to allow us to use additional keyboard-only inputs that remain unmapped on gamepad
      [types_ButtonType.PSEUDO_BUTTON_1]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_1.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_1.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_1.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_1.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_1.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_2]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_2.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_2.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_2.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_2.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_2.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_3]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_3.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_3.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_3.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_3.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_3.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_4]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_4.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_4.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_4.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_4.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_4.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_5]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_5.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_5.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_5.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_5.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_5.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_6]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_6.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_6.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_6.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_6.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_6.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_7]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_7.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_7.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_7.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_7.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_7.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_8]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_8.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_8.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_8.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_8.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_8.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_9]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_9.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_9.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_9.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_9.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_9.QUEST')
      },
      [types_ButtonType.PSEUDO_BUTTON_10]: {
        [Controller.XBOX]: t('.Gamepad.PSEUDO_BUTTON_10.XBOX'),
        [Controller.PS]: t('.Gamepad.PSEUDO_BUTTON_10.PS'),
        [Controller.STEAM]: t('.Gamepad.PSEUDO_BUTTON_10.STEAM'),
        [Controller.SWITCH]: t('.Gamepad.PSEUDO_BUTTON_10.SWITCH'),
        [Controller.QUEST]: t('.Gamepad.PSEUDO_BUTTON_10.QUEST')
      }
    },
    keyboard: {
      [types_KeyboardKey.BACKSPACE]: t('.Keyboard.BACKSPACE'),
      [types_KeyboardKey.TAB]: t('.Keyboard.TAB'),
      [types_KeyboardKey.ENTER]: t('.Keyboard.ENTER'),
      [types_KeyboardKey.SHIFT]: t('.Keyboard.SHIFT'),
      [types_KeyboardKey.CTRL]: t('.Keyboard.CTRL'),
      [types_KeyboardKey.ALT]: t('.Keyboard.ALT'),
      [types_KeyboardKey.ESCAPE]: t('.Keyboard.ESCAPE'),
      [types_KeyboardKey.SPACE]: t('.Keyboard.SPACE'),
      [types_KeyboardKey.LEFT]: t('.Keyboard.LEFT'),
      [types_KeyboardKey.UP]: t('.Keyboard.UP'),
      [types_KeyboardKey.RIGHT]: t('.Keyboard.RIGHT'),
      [types_KeyboardKey.DOWN]: t('.Keyboard.DOWN'),
      [types_KeyboardKey.INSERT]: t('.Keyboard.INSERT'),
      [types_KeyboardKey.DELETE]: t('.Keyboard.DELETE'),
      [types_KeyboardKey.KEY_0]: t('.Keyboard.KEY_0'),
      [types_KeyboardKey.KEY_1]: t('.Keyboard.KEY_1'),
      [types_KeyboardKey.KEY_2]: t('.Keyboard.KEY_2'),
      [types_KeyboardKey.KEY_3]: t('.Keyboard.KEY_3'),
      [types_KeyboardKey.KEY_4]: t('.Keyboard.KEY_4'),
      [types_KeyboardKey.KEY_5]: t('.Keyboard.KEY_5'),
      [types_KeyboardKey.KEY_6]: t('.Keyboard.KEY_6'),
      [types_KeyboardKey.KEY_7]: t('.Keyboard.KEY_7'),
      [types_KeyboardKey.KEY_8]: t('.Keyboard.KEY_8'),
      [types_KeyboardKey.KEY_9]: t('.Keyboard.KEY_9'),
      [types_KeyboardKey.KEY_A]: t('.Keyboard.KEY_A'),
      [types_KeyboardKey.KEY_B]: t('.Keyboard.KEY_B'),
      [types_KeyboardKey.KEY_C]: t('.Keyboard.KEY_C'),
      [types_KeyboardKey.KEY_D]: t('.Keyboard.KEY_D'),
      [types_KeyboardKey.KEY_E]: t('.Keyboard.KEY_E'),
      [types_KeyboardKey.KEY_F]: t('.Keyboard.KEY_F'),
      [types_KeyboardKey.KEY_G]: t('.Keyboard.KEY_G'),
      [types_KeyboardKey.KEY_H]: t('.Keyboard.KEY_H'),
      [types_KeyboardKey.KEY_I]: t('.Keyboard.KEY_I'),
      [types_KeyboardKey.KEY_J]: t('.Keyboard.KEY_J'),
      [types_KeyboardKey.KEY_K]: t('.Keyboard.KEY_K'),
      [types_KeyboardKey.KEY_L]: t('.Keyboard.KEY_L'),
      [types_KeyboardKey.KEY_M]: t('.Keyboard.KEY_M'),
      [types_KeyboardKey.KEY_N]: t('.Keyboard.KEY_N'),
      [types_KeyboardKey.KEY_O]: t('.Keyboard.KEY_O'),
      [types_KeyboardKey.KEY_P]: t('.Keyboard.KEY_P'),
      [types_KeyboardKey.KEY_Q]: t('.Keyboard.KEY_Q'),
      [types_KeyboardKey.KEY_R]: t('.Keyboard.KEY_R'),
      [types_KeyboardKey.KEY_S]: t('.Keyboard.KEY_S'),
      [types_KeyboardKey.KEY_T]: t('.Keyboard.KEY_T'),
      [types_KeyboardKey.KEY_U]: t('.Keyboard.KEY_U'),
      [types_KeyboardKey.KEY_V]: t('.Keyboard.KEY_V'),
      [types_KeyboardKey.KEY_W]: t('.Keyboard.KEY_W'),
      [types_KeyboardKey.KEY_X]: t('.Keyboard.KEY_X'),
      [types_KeyboardKey.KEY_Y]: t('.Keyboard.KEY_Y'),
      [types_KeyboardKey.KEY_Z]: t('.Keyboard.KEY_Z'),
      [types_KeyboardKey.F1]: t('.Keyboard.F1'),
      [types_KeyboardKey.F2]: t('.Keyboard.F2'),
      [types_KeyboardKey.F3]: t('.Keyboard.F3'),
      [types_KeyboardKey.F4]: t('.Keyboard.F4'),
      [types_KeyboardKey.F5]: t('.Keyboard.F5'),
      [types_KeyboardKey.F6]: t('.Keyboard.F6'),
      [types_KeyboardKey.F7]: t('.Keyboard.F7'),
      [types_KeyboardKey.F8]: t('.Keyboard.F8'),
      [types_KeyboardKey.F9]: t('.Keyboard.F9'),
      [types_KeyboardKey.F10]: t('.Keyboard.F10'),
      [types_KeyboardKey.F11]: t('.Keyboard.F11'),
      [types_KeyboardKey.F12]: t('.Keyboard.F12'),
      [types_KeyboardKey.MOUSE_MOVEMENT]: t('.Keyboard.MOUSE_MOVEMENT'),
      [types_KeyboardKey.MOUSE_BUTTON_LEFT]: t('.Keyboard.MOUSE_BUTTON_LEFT'),
      [types_KeyboardKey.MOUSE_BUTTON_MIDDLE]: t('.Keyboard.MOUSE_BUTTON_MIDDLE'),
      [types_KeyboardKey.MOUSE_BUTTON_RIGHT]: t('.Keyboard.MOUSE_BUTTON_RIGHT'),
      [types_KeyboardKey.MOUSE_WHEEL]: t('.Keyboard.MOUSE_WHEEL'),
      [types_KeyboardKey.BRACKET_OPEN]: t('.Keyboard.BRACKET_OPEN'),
      [types_KeyboardKey.BRACKET_CLOSE]: t('.Keyboard.BRACKET_CLOSE'),
      [types_KeyboardKey.PSEUDO_KEY_1]: t('.Keyboard.PSEUDO_KEY_1'),
      [types_KeyboardKey.PSEUDO_KEY_2]: t('.Keyboard.PSEUDO_KEY_2'),
      [types_KeyboardKey.PSEUDO_KEY_3]: t('.Keyboard.PSEUDO_KEY_3'),
      [types_KeyboardKey.PSEUDO_KEY_4]: t('.Keyboard.PSEUDO_KEY_4')
    }
  }), [t]);
  const translationsFacet = (0,react_facet_src.useFacetWrap)(translations);
  return /*#__PURE__*/react.createElement(controllerSpecificButtonTranslationsContext.Provider, {
    value: translationsFacet
  }, children);
};
;// CONCATENATED MODULE: ./packages/react-modal-manager/src/ModalManager.tsx


const ModalContext = (0,react.createContext)({
  showModal: () => {},
  hideModal: () => {},
  updateModal: () => {}
});
const NO_MODAL_NO_PAYLOAD = {
  component: null,
  payload: null
};
function ModalManager({
  children,
  ModalContainerWrapper
}) {
  const modalQueue = (0,react.useRef)([]);
  const [currentModalAndPayload, setCurrentModalAndPayload] = (0,react_facet_src.useFacetState)(NO_MODAL_NO_PAYLOAD); // If the modalQueue changes, we call this function to ensure the correct modal is shown.

  const refreshMountedModal = (0,react.useCallback)(() => {
    // No modals on the queue
    if (modalQueue.current.length <= 0) {
      setCurrentModalAndPayload(NO_MODAL_NO_PAYLOAD);
    } // Modals on the queue
    else {
        const head = modalQueue.current[modalQueue.current.length - 1];
        setCurrentModalAndPayload({
          component: head.component,
          payload: head.payload
        });
      }
  }, [setCurrentModalAndPayload]);
  /**
   * API for showing/hiding modals, provided to consumers via context
   */

  const api = (0,react.useMemo)(() => ({
    showModal: (component, payload) => {
      modalQueue.current.push({
        component: component,
        payload: payload
      });
      refreshMountedModal();
    },
    // Used to updated props on a declaratively rendered modal
    updateModal: (targetComponent, prevPayload, newPayload) => {
      // Return early if queue is empty
      if (modalQueue.current.length <= 0) return; // Find the modal we want to update

      const index = modalQueue.current.findIndex(({
        component,
        payload
      }) => component === targetComponent && payload === prevPayload); // Return early if we can't find a matching modal in the queue

      if (index === -1) return; // Update the props of the item in the queue

      modalQueue.current[index] = {
        component: targetComponent,
        payload: newPayload
      }; // Re-render the mounted modal

      refreshMountedModal();
    },
    hideModal: (targetComponent, targetPayload) => {
      if (modalQueue.current.length <= 0) return; // If trying to hide a specific modal (usually triggered declaratively on unmount)
      // then we need to find that target modal because it could be anywhere in the queue.

      if (targetComponent != null) {
        const index = modalQueue.current.findIndex(({
          component,
          payload
        }) => component === targetComponent && payload === targetPayload);
        if (index === -1) return;
        modalQueue.current.splice(index, 1);
      } // Otherwise being called imperatively, so just pop the latest on the queue
      // because we know this must be triggered by a user within the current modal.
      else {
          modalQueue.current.splice(modalQueue.current.length - 1, 1);
        }

      refreshMountedModal();
    }
  }), [refreshMountedModal]);
  const ModalContainer = ModalContainerWrapper !== null && ModalContainerWrapper !== void 0 ? ModalContainerWrapper : react.Fragment;
  return /*#__PURE__*/react.createElement(ModalContext.Provider, {
    value: api
  }, children, /*#__PURE__*/react.createElement(ModalContainer, null, /*#__PURE__*/react.createElement(ModalRenderer, {
    modalAndPayload: currentModalAndPayload
  })));
}

function ModalRenderer({
  modalAndPayload
}) {
  const unwrapped = (0,react_facet_src.useFacetUnwrap)(modalAndPayload);

  if (unwrapped === react_facet_src.NO_VALUE) {
    return null;
  }

  const {
    component: Component,
    payload
  } = unwrapped;

  if (Component == null) {
    return null;
  }

  return /*#__PURE__*/react.createElement(Component, payload !== null && payload !== void 0 ? payload : {});
}

const useModalAPI = () => (0,react.useContext)(ModalContext);
/**
 * @deprecated use declarative API instead. The imperative API can lead to bugs.
 * More info: https://github.com/Mojang/minecraft-ui/pull/6120
 */


const useHideModal = () => useModalAPI().hideModal;
const registerModal = component => {
  return {
    // Imperative API

    /**
     * @deprecated use declarative API instead. The imperative API can lead to bugs.
     * More info: https://github.com/Mojang/minecraft-ui/pull/6120
     */
    useShowModal: () => {
      const api = (0,react.useContext)(ModalContext);
      return (0,react.useCallback)((...payload) => {
        api.showModal(component, payload[0]);
      }, [api]);
    },
    useModal: (visible = false) => {
      const [isVisible, setIsVisible] = (0,react_facet_src.useFacetState)(visible);
      const modal = (0,react.useMemo)(() => ({
        isVisible,
        show: () => setIsVisible(true),
        hide: () => setIsVisible(false)
      }), [isVisible, setIsVisible]);
      return modal;
    },
    // Declarative API
    Component: (...payload) => {
      const api = (0,react.useContext)(ModalContext); // We store the payload in a ref and use that so that if anything
      // causes this component to re-render, it won't trigger another `showModal` call.

      const payloadRef = (0,react.useRef)(payload[0]); // Check if props changed, and request to update them if they did

      let propsMismatch = false;

      if (typeof payloadRef.current === 'object') {
        if (typeof payload[0] != 'object') {
          propsMismatch = true;
        } else {
          for (const i in payloadRef.current) {
            if (payload[0][i] != payloadRef.current[i]) {
              propsMismatch = true;
              break;
            }
          }
        }

        if (propsMismatch) {
          api.updateModal(component, payloadRef.current, payload[0]);
        }
      }

      (0,react.useEffect)(() => {
        const payloadRefCurrent = payloadRef.current;
        api.showModal(component, payloadRefCurrent);
        return () => {
          api.hideModal(component, payloadRefCurrent);
        };
      }, [api]);
      return null;
    }
  };
};
/**
 * Type testing bed can be uncommented below for sanity check during development
 */

/*
const Foo = registerModal(({ label }: { label: string }) => <div>{label}</div>)
const Bar = registerModal(() => <div />)

;() => {
	const showFoo = Foo.useShowModal()
	const showBar = Bar.useShowModal()

	// Should NOT error
	showBar()
	showFoo({ label: 'hello' })

	// Should error
	showFoo()
	showFoo({ label: 213 })
	showBar({ x: 123 })
	showBar({ y: '123' })

	return (
		<>
			<p>Should NOT error</p>
			<foo.Component label="foo" />
			<bar.Component />

			<p>Should error</p>
			<foo.Component />
			<foo.Component label={123} />
			<foo.Component x={123} />
		</>
	)
}
*/
;// CONCATENATED MODULE: ./packages/ui-internal/src/Focus/Focus.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Focus = ({"focus":"Yp0em","focused":"wI0IL","inset":"L0e76","withoutBorders":"n2X5o"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Focus/Focus.tsx
function Focus_extends() { Focus_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Focus_extends.apply(this, arguments); }

function Focus_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Focus_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Focus_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const FocusEffect = ({
  semanticStyles,
  className,
  withoutBorders,
  inset
}) => {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Focus.focus, semanticStyles, className, {
      [Focus.withoutBorders]: withoutBorders,
      [Focus.inset]: inset
    })
  });
};

const DynamicFocus = (_ref) => {
  let {
    disabled
  } = _ref,
      props = Focus_objectWithoutProperties(_ref, ["disabled"]);

  const unwrappedDisabled = (0,react_facet_src.useFacetUnwrap)(disabled);
  const disabledValue = unwrappedDisabled === react_facet_src.NO_VALUE ? false : !!unwrappedDisabled;
  return disabledValue ? null : /*#__PURE__*/react.createElement(FocusEffect, props);
};

const Focus_Focus = (_ref2) => {
  let {
    role = 'inherit',
    interactive = true
  } = _ref2,
      props = Focus_objectWithoutProperties(_ref2, ["role", "interactive"]);

  const {
    outline
  } = hooks_useSemanticColors(role);
  const semanticStyles = interactive ? outline.interactive : outline.base;
  return props.disabled != null ? /*#__PURE__*/react.createElement(DynamicFocus, Focus_extends({
    semanticStyles: semanticStyles
  }, props)) : /*#__PURE__*/react.createElement(FocusEffect, Focus_extends({
    semanticStyles: semanticStyles
  }, props));
};
const focusClass = Focus.focused;
;// CONCATENATED MODULE: ./packages/react-gamepad/src/useFocus.ts






function useFocus(gamepad, onClick, ref, nodeIdRef) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();
  const id = (0,react.useMemo)(() => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      return __generateId();
    } else {
      return id_generateId();
    }
  }, [gamepadVersion]); // One use case for this is that the facet effect that calls the onFocusChanged function might not be called in time
  // if something is focused on mount. This allows the consumer to obtain the nodeIdRef as soon as we have assigned it.

  if (nodeIdRef != null) {
    nodeIdRef.current = id;
  }

  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const visualApiRef = (0,react.useContext)(focusTreeAPI_FocusTreeAPIContext);
  const visualRequestFocusIdUpdate = setFocusedId_useSetFocusedId();
  const legacyApi = (0,react.useContext)(GamepadAPIContext);
  const legacyPath = (0,react.useContext)(pathContext_PathContext);
  const visualPath = (0,react.useContext)(PathContext);
  const [isFocusedFacet, setIsFocusedFacet] = (0,react_facet_src.useFacetState)(false);
  /** This is only part of Visual API */

  const onFocus = (0,react.useCallback)((origin = FocusOrigin.Unknown) => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      legacyApi.requestFocus(id, true);
    } else {
      visualRequestFocusIdUpdate(id, false, origin);
    }
  }, [visualRequestFocusIdUpdate, id, legacyApi, gamepadVersion]);
  (0,react_facet_src.useFacetEffect)(gamepad => {
    const handleFocusChanged = focused => {
      if (gamepad.onFocusChanged) {
        gamepad.onFocusChanged(focused);
      }

      setIsFocusedFacet(focused);
    };

    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      const focusable = {
        type: 'focusable',
        id: id,
        path: legacyPath,
        alias: gamepad.alias,
        ref: ref,
        disabled: gamepad.disabled,
        autofocus: gamepad.autofocus,
        disableScrollIntoView: gamepad.disableScrollIntoView,
        scrollSpeedFactor: gamepad.scrollIntoViewSpeedFactor,
        scrollAlign: gamepad.scrollIntoViewAlign,
        scrollOffset: gamepad.scrollIntoViewOffset,
        onClick: onClick,
        onFocusedChange: handleFocusChanged,
        index: gamepad.index,
        inputLegend: gamepad.inputLegend,
        onRight: gamepad.onRight,
        onLeft: gamepad.onLeft,
        onUp: gamepad.onUp,
        onDown: gamepad.onDown
      };
      legacyApi.addOrUpdateNode(focusable);
      const isFocused = legacyApi.isFocusableFocused(id, gamepad.alias);
      setIsFocusedFacet(isFocused);
    } else {
      const focusable = {
        type: types_FocusTreeNodeType.ITEM,
        id: id,
        alias: gamepad.alias,
        ref: ref.current,
        disabled: gamepad.disabled || false,
        hidden: gamepad.hidden || false,
        scrollSpeedFactor: gamepad.scrollIntoViewSpeedFactor,
        scrollAlign: gamepad.scrollIntoViewAlign,
        scrollOffset: gamepad.scrollIntoViewOffset,
        onFocus: () => {
          handleFocusChanged(true);
        },
        onBlur: () => {
          handleFocusChanged(false);
        },
        onRight: gamepad.onRight,
        onLeft: gamepad.onLeft,
        onUp: gamepad.onUp,
        onDown: gamepad.onDown,
        gridIndex: gamepad.gridIndex
      };
      visualApiRef.current.putNode(focusable, visualPath[visualPath.length - 1]);
      visualApiRef.current.putShortcut(id, types_ButtonType.A, {
        callback: onClick,
        inputLegend: gamepad.inputLegend
      });
      setIsFocusedFacet(visualApiRef.current.isFocused(id, gamepad.alias));
    }
  }, [gamepadVersion, setIsFocusedFacet, legacyApi, visualApiRef, legacyPath, visualPath, id, onClick, ref], [gamepadFacet]);
  /**
   * Tries to request autofocus if disabled or autofocus options changes
   *
   * This effect must come after the effect that addOrUpdateNode
   */

  (0,react_facet_src.useFacetEffect)(autofocus => {
    if (autofocus) {
      if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
        legacyApi.requestAutofocus(id);
      }
    }
  }, [legacyApi, id, gamepadVersion], [(0,react_facet_src.useFacetMap)(gamepad => gamepad.autofocus && !gamepad.disabled, [], [gamepadFacet])]);
  (0,react.useEffect)(() => {
    if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
      legacyApi.runAddNodeEffect();
      return () => legacyApi.removeNode(id);
    } else {
      const visualApi = visualApiRef.current;
      return () => visualApi.removeNode(id);
    }
  }, [visualApiRef, legacyApi, gamepadVersion, id]);
  (0,react.useLayoutEffect)(() => {
    const node = ref.current;
    if (node == null) return;

    const handleFocused = () => {
      if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
        legacyApi.requestFocus(id);
      } else {
        visualRequestFocusIdUpdate(id);
      }
    };

    node.addEventListener('focusin', handleFocused);
    return () => {
      node.removeEventListener('focusin', handleFocused);
    };
  }, [ref, id, visualApiRef, legacyApi, gamepadVersion, visualRequestFocusIdUpdate]);
  return {
    isFocused: isFocusedFacet,
    onFocus
  };
}
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/useScheduledFunctions.ts

const useScheduledFunctions = () => {
  const timerRef = (0,react.useRef)([]);
  const cancelSchedule = (0,react.useCallback)(() => {
    timerRef.current.forEach(clearTimeout);
    timerRef.current = [];
  }, [timerRef]);
  const scheduleFunctions = (0,react.useCallback)(schedule => {
    cancelSchedule();
    let accumulatedDelay = 0;
    schedule.forEach(unit => {
      if (typeof unit === 'number') {
        accumulatedDelay += unit;
      } else {
        timerRef.current.push(setTimeout(() => unit(), accumulatedDelay));
      }
    });
  }, [cancelSchedule]);
  (0,react.useEffect)(() => {
    // Cleanup function that is triggered on component unmount to clear all the timers
    const timers = timerRef.current;
    return () => {
      timers.forEach(timeoutId => clearTimeout(timeoutId));
    };
  }, []);
  return scheduleFunctions;
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InputStateOverride/InputStateOverride.tsx

const InputStateOverride_context = (0,react.createContext)(null);
const useInputStateOverride = () => (0,react.useContext)(InputStateOverride_context);
const InputStateOverride = InputStateOverride_context.Provider;
;// CONCATENATED MODULE: ./packages/react-narrator/src/context/narrationContext.ts


const narrationContextContext = (0,react.createContext)((0,react_facet_src.createStaticFacet)('root'));
const NarrationContextProvider = narrationContextContext.Provider;
const useNarrationContext = () => (0,react.useContext)(narrationContextContext);
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrationPutNode.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */



const useNarrationPutNode = () => {
  const {
    narrationTree
  } = (0,react.useContext)(narrationDriverContext);
  const parentNarrationIdRef = (0,react_facet_src.useFacetRef)((0,react.useContext)(narrationContextContext));
  const narrationPutNode = (0,react.useCallback)((text, shouldSkipParent = [], getSuffix) => {
    const parentNarrationId = parentNarrationIdRef.current !== react_facet_src.NO_VALUE ? parentNarrationIdRef.current : '';
    const fullNarrationId = `${parentNarrationId}-${text}`;
    narrationTree[fullNarrationId] = {
      parentNarrationId,
      text,
      shouldSkipParent,
      getSuffix
    };
    return fullNarrationId;
  }, [narrationTree, parentNarrationIdRef]); // Providing a callback to retrieve the text allows us to delay potentially
  // expensive computations used to compute the text to narrate to the moment
  // where the text will actually be read (if read)
  //
  // This is particularly useful because text is read after a delay of about
  // 300ms after the focus / hover is triggered, so that it can be canceled if
  // many focus events happen one after the other.
  //
  // This will also help keeping the frame associated with the focus event
  // small in computation time, since the computation that computes the text
  // is done asynchronously, which means the focus-related style changes
  // will be finished before it triggers.

  const narrationPutNodeWithIdAndCallback = (0,react.useCallback)((id, getText, shouldSkipParent = [], getSuffix) => {
    const parentNarrationId = parentNarrationIdRef.current !== react_facet_src.NO_VALUE ? parentNarrationIdRef.current : '';
    const fullNarrationId = `${parentNarrationId}-${id}`;
    narrationTree[fullNarrationId] = {
      parentNarrationId,
      getText,
      shouldSkipParent,
      getSuffix
    };
    return fullNarrationId;
  }, [narrationTree, parentNarrationIdRef]);
  return {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  };
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/constants.ts
const NARRATION_DEBOUNCE_DELAY = 200;
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateCurrentContext.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */




// `useNarrateCurrentContext` will narrate the content of the current narration node
// and, if necessary, all the ancestors of the current narration node.
// The goal of `useNarrateCurrentContext` is to allow the user to understand what and where the
// currently highlighted content is, for example with a focus event or with
// a mouse over event.
const useNarrateCurrentContext = () => {
  const narrateTimeoutRef = (0,react.useRef)();
  const narrationId = (0,react.useContext)(narrationContextContext);
  const {
    readById,
    narrationTree
  } = (0,react.useContext)(narrationDriverContext);
  const narrateCurrentContext = (0,react_facet_src.useFacetCallback)(narrationId => (profanityFilterContext, interruptible = true, required, playInBackground) => {
    if (Object.keys(narrationTree).length > 0) {
      narrateTimeoutRef.current = setTimeout(() => {
        readById(narrationId, profanityFilterContext ? profanityFilterContext : undefined, interruptible, required, playInBackground);
      }, NARRATION_DEBOUNCE_DELAY);
    }
  }, [readById, narrationTree], [narrationId]);
  const preventNarrateCurrentContext = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateCurrentContext,
    preventNarrateCurrentContext
  };
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateById.ts
/**
 * NOTE: This hook is meant to be used only by Core components.
 * It shouldn't be considered a public API.
 *
 * In order to use it, it is exposed through the main package, but
 * the documentation for it is not in the README to avoid confusion.
 */



const useNarrateById = () => {
  const narrateTimeoutRef = (0,react.useRef)();
  const {
    readById
  } = (0,react.useContext)(narrationDriverContext);
  const narrateById = (0,react.useCallback)((narrationId, interruptible = true, profanityFilterContext, required, playInBackground) => {
    narrateTimeoutRef.current = setTimeout(() => {
      readById(narrationId, profanityFilterContext, interruptible, required, playInBackground);
    }, NARRATION_DEBOUNCE_DELAY);
  }, [readById]);
  const preventNarrateById = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateById,
    preventNarrateById
  };
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/InteractivePrimitive.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InteractivePrimitive = ({"interactivePrimitive":"BlHLJ","disabled":"OO8Fh"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/InteractivePrimitive/InteractivePrimitive.tsx
function InteractivePrimitive_extends() { InteractivePrimitive_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return InteractivePrimitive_extends.apply(this, arguments); }

function InteractivePrimitive_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = InteractivePrimitive_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function InteractivePrimitive_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }















/**
 * If any parent containers want to be informed when an InteractivePrimitive
 * is mounted, they can use this context to receive a callback on mount.
 */

const InteractivePrimitiveMountCallback = (0,react.createContext)(InteractivePrimitive_noop);

function useMountNotification() {
  const notify = (0,react.useContext)(InteractivePrimitiveMountCallback);
  (0,react.useEffect)(notify, [notify]);
}

const DEFAULT_PRESS_DURATION = 150;
const DEFAULT_TOUCH_DETECTION_DELAY = 150;
const DEFAULT_MOUSE_OVER_HANDLER_DELAY = 50;
const TOUCH_DISTANCE_THRESHOLD = 3;
const SOUND_WAIT_DURATION = 10;
const NARRATION_SUFFIX_BUTTONS_TO_SKIP = DEFAULT_ACTIONS.map(key => `${key}`);
/**
 * The recommended abstraction to create interactive targets.
 *
 * It supports:
 * - all input methods (mouse, touch, gamepad)
 * - text-to-speech narration via an ariaLabel prop
 * - sound effect support
 *
 * All done in a better performing way for Gameface.
 */

function InteractivePrimitive_InteractivePrimitive(props) {
  const {
    onHoverChanged,
    onFocusChanged,
    onPressChanged,
    onClick,
    onGamepadClick,
    onKeyDown,
    onMouseDown,
    onUp,
    onDown,
    onLeft,
    onRight,
    touchDetectionDelay = DEFAULT_TOUCH_DETECTION_DELAY,
    focusRefOverride,
    nodeIdRef
  } = props;
  const autofocusFacet = (0,react_facet_src.useFacetWrap)(props.autofocus);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(props.className);
  const dataTestIdFacet = (0,react_facet_src.useFacetWrap)(props['data-testid']);
  const classNameFocusedFacet = (0,react_facet_src.useFacetWrap)(props.classNameFocused);
  const classNameHoveredFacet = (0,react_facet_src.useFacetWrap)(props.classNameHovered);
  const classNamePressedFacet = (0,react_facet_src.useFacetWrap)(props.classNamePressed);
  const classNameDisabledFacet = (0,react_facet_src.useFacetWrap)(props.classNameDisabled);
  const delayedClickFacet = (0,react_facet_src.useFacetWrap)(props.delayedClick);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(props.disabled);
  const nonFocusableFacet = (0,react_facet_src.useFacetWrap)(props.nonFocusable);
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(props.hidden);
  const disableScrollIntoViewFacet = (0,react_facet_src.useFacetWrap)(props.disableScrollIntoView);
  const gamepadAliasFacet = (0,react_facet_src.useFacetWrap)(props.gamepadAlias);
  const gamepadIndexFacet = (0,react_facet_src.useFacetWrap)(props.gamepadIndex);
  const inputLegendFacet = (0,react_facet_src.useFacetWrap)(props.inputLegend);
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)('narrationText' in props ? props.narrationText : false);
  const narrationIdFacet = (0,react_facet_src.useFacetWrap)('narrationId' in props ? props.narrationId : undefined);
  const pressDurationFacet = (0,react_facet_src.useFacetWrap)(props.pressDuration);
  const soundEffectFocusedFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectFocused);
  const soundEffectHoveredFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectHovered);
  const soundEffectPressedFacet = (0,react_facet_src.useFacetWrap)(props.soundEffectPressed);
  const lastFocusOriginFacet = useLastFocusOrigin();
  const isLastInputMouse = useIsLastInputMouse();
  const isLastInputTouch = useIsLastInputTouch();
  const isLastInputGamepad = useIsLastInputGamepad();
  const isLastInputKeyboard = useIsLastInputKeyboard();
  const isLastInputKeyboardRef = (0,react_facet_src.useFacetRef)(isLastInputKeyboard);
  const localRef = (0,react.useRef)(null);
  const ref = props.innerRef || localRef;
  const lastTouchPositionRef = (0,react.useRef)({
    x: 0,
    y: 0
  });
  const stateOverride = useInputStateOverride();
  const isNarrationEnabled = useNarrationEnabled();
  const scheduleFunctions = useScheduledFunctions();
  const triggerSoundEffect = useSoundEffectTrigger();
  const availableInputLegendsFacet = useAvailableInputLegends();
  const availableInputLegendsFacetRef = (0,react_facet_src.useFacetRef)(availableInputLegendsFacet);
  const controllerSpecificButtonTranslationsFacet = useControllerSpecificButtonTranslations();
  const controllerSpecificButtonTranslationsFacetRef = (0,react_facet_src.useFacetRef)(controllerSpecificButtonTranslationsFacet);
  const currentControllerFacet = useControllerSelected();
  const currentControllerFacetRef = (0,react_facet_src.useFacetRef)(currentControllerFacet);
  const {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  } = useNarrationPutNode();
  const {
    narrateCurrentContext,
    preventNarrateCurrentContext
  } = useNarrateCurrentContext();
  const narrationContextFacet = useNarrationContext();
  const {
    narrateById,
    preventNarrateById
  } = useNarrateById();
  const [keyboardGamepadMapFacet] = useKeyboardGamepadMap();
  const keyboardGamepadMapFacetRef = (0,react_facet_src.useFacetRef)(keyboardGamepadMapFacet);
  const hasNarrationId = ('narrationId' in props);
  const getNarrationText = 'getNarrationText' in props ? props.getNarrationText : noopString;
  const getNarrationSuffix = (0,react.useCallback)(() => {
    const currentValue = availableInputLegendsFacetRef.current;
    const currentControllerSpecificButtonTranslations = controllerSpecificButtonTranslationsFacetRef.current;
    const currentController = currentControllerFacetRef.current;
    const currentKeyboardGamepadMap = keyboardGamepadMapFacetRef.current;

    if (currentValue === react_facet_src.NO_VALUE || currentControllerSpecificButtonTranslations === react_facet_src.NO_VALUE || currentController === react_facet_src.NO_VALUE || currentKeyboardGamepadMap === react_facet_src.NO_VALUE) {
      return '';
    }

    let result = '';
    recordEntries(currentValue, (gamepadButton, narrationString) => {
      var _currentControllerSpe;

      if (NARRATION_SUFFIX_BUTTONS_TO_SKIP.indexOf(gamepadButton) !== -1) return;
      if (narrationString == null) return;
      const keyboardKey = currentKeyboardGamepadMap[gamepadButton];
      const buttonActionNarration = isLastInputKeyboardRef.current === true ? currentControllerSpecificButtonTranslations.keyboard[keyboardKey[0]] : (_currentControllerSpe = currentControllerSpecificButtonTranslations.gamepad[gamepadButton]) === null || _currentControllerSpe === void 0 ? void 0 : _currentControllerSpe[currentController];
      if (buttonActionNarration == null) return;
      result += `${buttonActionNarration}: ${narrationString} . `;
    });
    return result;
  }, [availableInputLegendsFacetRef, controllerSpecificButtonTranslationsFacetRef, currentControllerFacetRef, keyboardGamepadMapFacetRef, isLastInputKeyboardRef]);
  const getNewFullPathNarrationId = (0,react_facet_src.useFacetCallback)((narrationText, narrationId) => () => {
    if (hasNarrationId && narrationId != null) {
      return narrationPutNodeWithIdAndCallback(narrationId, getNarrationText, undefined, getNarrationSuffix);
    }

    return narrationText !== false && narrationText != null ? narrationPutNode(narrationText, undefined, getNarrationSuffix) : undefined;
  }, [narrationPutNode, hasNarrationId, narrationPutNodeWithIdAndCallback, getNarrationText, getNarrationSuffix], [narrationTextFacet, narrationIdFacet]);
  const [fullPathNarrationIdFacet, setFullPathNarrationIdFacet] = (0,react_facet_src.useFacetState)(getNewFullPathNarrationId());
  (0,react_facet_src.useFacetEffect)(() => {
    const newNarrationId = getNewFullPathNarrationId();
    setFullPathNarrationIdFacet(newNarrationId !== react_facet_src.NO_VALUE ? newNarrationId : undefined);
  }, [setFullPathNarrationIdFacet, getNewFullPathNarrationId], [narrationTextFacet, narrationContextFacet]);
  const getCurrentNarrationId = (0,react_facet_src.useFacetCallback)(narrationId => () => narrationId, [], [fullPathNarrationIdFacet]);
  const [isHoveredFacet, setIsHoveredFacet] = (0,react_facet_src.useFacetState)(false);
  const [isPressedFacet, setIsPressedFacet] = (0,react_facet_src.useFacetState)(false);
  (0,react_facet_src.useFacetEffect)(isLastInputMouse => {
    if (!isLastInputMouse) {
      setIsHoveredFacet(false);
    }
  }, [setIsHoveredFacet], [isLastInputMouse]);
  const handleMouseLeave = (0,react_facet_src.useFacetCallback)(disabled => () => {
    setIsHoveredFacet(false);
    setIsPressedFacet(false);

    if (disabled) {
      return;
    }

    onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(false);
    preventNarrateCurrentContext();
    preventNarrateById();
  }, [preventNarrateById, preventNarrateCurrentContext, setIsHoveredFacet, setIsPressedFacet, onHoverChanged], [disabledFacet]);
  const handleDown = (0,react_facet_src.useFacetCallback)((soundEffectPressed, disabled) => (event, ignoreHandlers) => {
    if (disabled) {
      return;
    } // Only handle primary clicks


    if (event && event.button != null && event.button > 0) {
      return;
    } // Used for if you need access to the react mouse event


    if (!ignoreHandlers && onMouseDown) {
      onMouseDown(event);
    }

    setIsPressedFacet(true);

    if (soundEffectPressed != null) {
      triggerSoundEffect(soundEffectPressed);
    }

    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(true);
  }, [triggerSoundEffect, setIsPressedFacet, onPressChanged, onMouseDown], [soundEffectPressedFacet, disabledFacet]);
  const handleMouseDown = (0,react_facet_src.useFacetCallback)(isLastInputMouse => (event, ignoreHandlers) => {
    if (!isLastInputMouse) {
      return;
    }

    handleDown(event, ignoreHandlers);
  }, [handleDown], [isLastInputMouse]);
  const handleUp = (0,react_facet_src.useFacetCallback)(disabled => event => {
    setIsPressedFacet(false);

    if (disabled) {
      return;
    } // Only handle primary clicks


    if (event && event.button > 0) {
      return;
    }

    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(false);
  }, [setIsPressedFacet, onPressChanged], [disabledFacet]);
  const handleMouseUp = (0,react_facet_src.useFacetCallback)(isLastInputMouse => event => {
    if (!isLastInputMouse) {
      return;
    }

    handleUp(event);
  }, [handleUp], [isLastInputMouse, disabledFacet]);
  const handleMouseClick = (0,react_facet_src.useFacetCallback)(disabled => event => {
    if (disabled || onClick == null) {
      return;
    }

    event.stopPropagation(); // Only handle primary clicks

    if (event.button > 0) {
      return;
    }

    return onClick();
  }, [onClick], [disabledFacet]);
  /**
   * Touch Event Handlers
   */

  const handleTouchStart = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => e => {
    if (!isLastInputTouch || disabled) {
      return;
    }

    lastTouchPositionRef.current.x = e.touches[0].clientX;
    lastTouchPositionRef.current.y = e.touches[0].clientY;
    scheduleFunctions([touchDetectionDelay, () => handleDown({
      clientX: e.touches[0].clientX,
      clientY: e.touches[0].clientY
    })]);
    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(true);
  }, [touchDetectionDelay, scheduleFunctions, handleDown, onPressChanged], [isLastInputTouch, disabledFacet]);
  const handleTouchMove = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => e => {
    if (!isLastInputTouch || disabled) {
      return;
    }

    if (Math.abs(lastTouchPositionRef.current.x - e.touches[0].clientX) > TOUCH_DISTANCE_THRESHOLD || Math.abs(lastTouchPositionRef.current.y - e.touches[0].clientY) > TOUCH_DISTANCE_THRESHOLD) {
      // We need to call schedule so that it cancels the handleTouchStart schedule
      scheduleFunctions([handleUp]);
    }
  }, [scheduleFunctions, handleUp], [isLastInputTouch, disabledFacet]);
  const handleTouchEnd = (0,react_facet_src.useFacetCallback)((isLastInputTouch, disabled) => () => {
    if (!isLastInputTouch || disabled) {
      return;
    } // We need to call schedule so that it cancels the handleTouchStart schedule


    scheduleFunctions([handleUp]);
    onPressChanged === null || onPressChanged === void 0 ? void 0 : onPressChanged(false);
  }, [scheduleFunctions, handleUp, onPressChanged], [isLastInputTouch, disabledFacet]);
  const handleTouchClick = (0,react_facet_src.useFacetCallback)((pressDuration, delayedClick, disabled) => event => {
    if (disabled || onClick == null) {
      return;
    }

    event.stopPropagation();
    const schedule = delayedClick ? [handleDown, SOUND_WAIT_DURATION, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp, onClick] : [handleDown, SOUND_WAIT_DURATION, onClick, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp];
    scheduleFunctions(schedule);
  }, [handleDown, handleUp, scheduleFunctions, onClick], [pressDurationFacet, delayedClickFacet, disabledFacet]);
  const handleGamepadOrKeyboardClick = (0,react_facet_src.useFacetCallback)((pressDuration, delayedClick, disabled) => () => {
    if (disabled || onClick == null) {
      return;
    } // If the user provided an onGamepadClick we should only call that and not the
    // onClick; this allows for specific functionality when using gamepad/keyboard.
    // Fallback to the usual onClick if no handler is provided.


    const handleClick = onGamepadClick || onClick; // We suppress the onMouseDown handler as we are calling handleMouseDown synthetically

    const handleMouseDownWithoutHandlers = () => handleDown(undefined, true);

    const schedule = delayedClick ? [handleMouseDownWithoutHandlers, SOUND_WAIT_DURATION, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp, handleClick] : [handleMouseDownWithoutHandlers, SOUND_WAIT_DURATION, handleClick, pressDuration !== null && pressDuration !== void 0 ? pressDuration : DEFAULT_PRESS_DURATION, handleUp];
    scheduleFunctions(schedule);
  }, [handleDown, handleUp, scheduleFunctions, onGamepadClick, onClick], [pressDurationFacet, delayedClickFacet, disabledFacet]);
  const localIdRef = (0,react.useRef)();
  const idRef = nodeIdRef !== null && nodeIdRef !== void 0 ? nodeIdRef : localIdRef;
  const {
    isFocused: isFocusedFacet,
    onFocus
  } = useFocus((0,react_facet_src.useFacetMap)((gamepadIndex, gamepadAlias, inputLegend, disabled, hidden, nonFocusable, autofocus, disableScrollIntoView) => ({
    // TODO: Remove index in favor of gamepadIndex when we migrate to visual navigation completely
    index: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    gridIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    alias: gamepadAlias,
    inputLegend: inputLegend === false || inputLegend === '' ? undefined : inputLegend,
    disabled: disabled,
    hidden: hidden || nonFocusable,
    autofocus: autofocus,
    disableScrollIntoView: disableScrollIntoView,
    onFocusChanged,
    onUp,
    onDown,
    onLeft,
    onRight
  }), [onFocusChanged, onUp, onDown, onLeft, onRight], [gamepadIndexFacet, gamepadAliasFacet, inputLegendFacet, disabledFacet, hiddenFacet, nonFocusableFacet, autofocusFacet, disableScrollIntoViewFacet]), handleGamepadOrKeyboardClick, (focusRefOverride === null || focusRefOverride === void 0 ? void 0 : focusRefOverride.current) != null ? focusRefOverride : ref, idRef);
  /**
   * Mouse Event Handlers
   */

  const handleMouseMove = (0,react_facet_src.useFacetCallback)((isLastInputMouse, isLastInputTouch, isLastInputKeyboard, isLastInputGamepad, soundEffectHovered, disabled, isFocused, isHovered, hidden) => () => {
    if (!(isLastInputMouse || isLastInputTouch && isNarrationEnabled)) {
      return;
    }

    if (disabled || hidden || isFocused && isHovered) {
      return;
    }
    /**
     * Handle hover scenario
     */


    if (!isHovered) {
      setIsHoveredFacet(true);

      if (soundEffectHovered != null && !isFocused) {
        triggerSoundEffect(soundEffectHovered);
      } // Pointer need to narrate on every hover


      if (isLastInputMouse || isLastInputTouch) {
        const narrationId = getCurrentNarrationId();

        if (narrationId === react_facet_src.NO_VALUE || narrationId == null) {
          narrateCurrentContext();
        } else {
          narrateById(narrationId);
        }
      }

      onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(true);
    }
    /**
     * Handle focus scenario
     */


    if (isFocused) {
      return;
    }

    if (!(isLastInputKeyboard || isLastInputGamepad)) {
      onFocus(FocusOrigin.PointerInput);
    }
  }, [triggerSoundEffect, setIsHoveredFacet, onHoverChanged, onFocus, getCurrentNarrationId, narrateById, narrateCurrentContext, isNarrationEnabled], [isLastInputMouse, isLastInputTouch, isLastInputKeyboard, isLastInputGamepad, soundEffectHoveredFacet, disabledFacet, isFocusedFacet, isHoveredFacet, hiddenFacet]);
  const handleClick = (0,react_facet_src.useFacetCallback)((isMouse, isTouch) => event => {
    if (isMouse === true) return handleMouseClick(event);
    if (isTouch === true) return handleTouchClick(event);
  }, [handleMouseClick, handleTouchClick], [isLastInputMouse, isLastInputTouch]);
  const isFocusedAndSoundEffectFocusedFacets = (0,react_facet_src.useFacetMap)((isFocused, soundEffect) => {
    if (isFocused === true) return soundEffect;
  }, [], [isFocusedFacet, soundEffectFocusedFacet]);
  (0,react_facet_src.useFacetEffect)(soundEffectFocused => {
    // Trigger sounds
    if (soundEffectFocused != null) {
      triggerSoundEffect(soundEffectFocused);
    }
  }, [triggerSoundEffect], [isFocusedAndSoundEffectFocusedFacets]);
  (0,react_facet_src.useFacetEffect)((focused, isLastInputGamepad, isLastInputKeyboard, lastFocusOrigin) => {
    // Trigger narration for gamepad/keyboard (mouse/touch narration is handled in handleMouseMove)
    if (isLastInputGamepad || isLastInputKeyboard || lastFocusOrigin === FocusOrigin.FocusTreeMutation) {
      if (focused === true) {
        const narrationId = getCurrentNarrationId();

        if (narrationId == null || narrationId == react_facet_src.NO_VALUE) {
          narrateCurrentContext();
        } else {
          narrateById(narrationId);
        }
      } else {
        preventNarrateCurrentContext();
        preventNarrateById();
      }
    }
  }, [getCurrentNarrationId, narrateById, narrateCurrentContext, preventNarrateById, preventNarrateCurrentContext, onFocusChanged], [isFocusedFacet, isLastInputGamepad, isLastInputKeyboard, lastFocusOriginFacet]);
  const composedClassNameFacet = (0,react_facet_src.useFacetMap)((className, classNameHovered, classNamePressed, classNameFocused, classNameDisabled, disabledValue, isHoveredValue, isPressedValue, isFocusedValue, isLastInputKeyboard, isLastInputGamepad) => {
    const isHovered = stateOverride ? stateOverride.hovered : isHoveredValue;
    const isPressed = onClick != null && (stateOverride ? stateOverride.pressState === 'pressed' : isPressedValue);
    const isFocused = isFocusedValue && (isLastInputKeyboard || isLastInputGamepad);
    const base = className == null || className === '' ? '' : ` ${className}`;
    const hovered = isHovered ? ` ${MODIFIER_CLASS_NAMES.hovered}${classNameHovered != null ? ` ${classNameHovered}` : ''}` : '';
    const pressed = isPressed ? ` ${MODIFIER_CLASS_NAMES.pressed}${classNamePressed != null ? ` ${classNamePressed}` : ''}` : '';
    const focused = (isFocused || stateOverride !== null && stateOverride !== void 0 && stateOverride.focused) && classNameFocused != null ? ` ${MODIFIER_CLASS_NAMES.focused}${classNameFocused != null ? ` ${classNameFocused}` : ''}` : '';
    const disabled = disabledValue === true ? ` ${InteractivePrimitive.disabled}${MODIFIER_CLASS_NAMES.disabled !== InteractivePrimitive.disabled ? ' ' + MODIFIER_CLASS_NAMES.disabled : ''}` : '';
    const disabledClass = disabledValue === true && classNameDisabled != null && classNameDisabled != InteractivePrimitive.disabled ? ` ${classNameDisabled}` : '';
    return `${InteractivePrimitive.interactivePrimitive}${base}${hovered}${pressed}${focused}${disabled}${disabledClass}`;
  }, [stateOverride, onClick], [classNameFacet, classNameHoveredFacet, classNamePressedFacet, classNameFocusedFacet, classNameDisabledFacet, disabledFacet, isHoveredFacet, isPressedFacet, isFocusedFacet, isLastInputKeyboard, isLastInputGamepad]);

  if (false) {}

  useMountNotification();

  if (props.tag === 'span') {
    return /*#__PURE__*/react.createElement("fast-span", {
      ref: ref,
      className: composedClassNameFacet,
      style: props.style,
      "data-testid": dataTestIdFacet,
      onClick: handleClick,
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      onMouseDown: handleMouseDown,
      onMouseUp: handleMouseUp,
      onMouseMove: handleMouseMove,
      onMouseLeave: handleMouseLeave,
      onKeyDown: onKeyDown
    }, props.children);
  }

  return /*#__PURE__*/react.createElement("fast-div", {
    ref: ref,
    className: composedClassNameFacet,
    style: props.style,
    "data-testid": dataTestIdFacet,
    onClick: handleClick,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    onKeyDown: onKeyDown
  }, props.children);
}
/**
 * InteractivePrimitive.Maybe can be used to conditionally wrap content
 * in an InteractivePrimitive. Commonly used for narration. The
 * InteractivePrimitive will only be enabled when narration is also enabled.
 */

const InteractivePrimitiveMaybe = (_ref) => {
  let {
    isInteractive,
    children,
    onClick,
    inputLegend,
    innerRef,
    className,
    classNameDisabled,
    disabled,
    style
  } = _ref,
      props = InteractivePrimitive_objectWithoutProperties(_ref, ["isInteractive", "children", "onClick", "inputLegend", "innerRef", "className", "classNameDisabled", "disabled", "style"]);

  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const classNameDisabledFacet = (0,react_facet_src.useFacetWrap)(classNameDisabled);
  const childrenWrapped = (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
  const notInteractiveClassName = (0,react_facet_src.useFacetMap)((className, disabled, classNameDisabled) => classnames_default()(className, disabled === true && MODIFIER_CLASS_NAMES.disabled !== InteractivePrimitive.disabled ? MODIFIER_CLASS_NAMES.disabled : null, disabled === true && classNameDisabled !== InteractivePrimitive.disabled ? classNameDisabled : null, disabled === true ? InteractivePrimitive.disabled : null), [], [classNameFacet, disabledFacet, classNameDisabledFacet]);
  return (0,react_facet_src.useFacetUnwrap)(isInteractive) === true ? /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, InteractivePrimitive_extends({
    onClick: onClick,
    inputLegend: inputLegend !== null && inputLegend !== void 0 ? inputLegend : false,
    innerRef: innerRef,
    className: classNameFacet,
    classNameDisabled: classNameDisabledFacet,
    disabled: disabledFacet
  }, props), childrenWrapped) : /*#__PURE__*/react.createElement("fast-div", {
    ref: innerRef,
    className: notInteractiveClassName,
    style: style
  }, childrenWrapped);
};
InteractivePrimitive_InteractivePrimitive.displayName = 'InteractivePrimitive';
InteractivePrimitive_InteractivePrimitive.Maybe = InteractivePrimitiveMaybe;

function InteractivePrimitive_noop() {}

function noopString() {
  return '';
}

const recordEntries = (record, callback) => {
  for (const key in record) {
    callback(key, record[key]);
  }
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/NavigationButton/NavigationButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationButton = ({"button":"TWMF_","disabled":"w2q1p"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/NavigationButton/NavigationButton.tsx







const NavigationButton_NavigationButton = ({
  narrationText,
  inputLegend,
  disabled,
  onClick,
  children,
  gamepadIndex,
  gamepadAlias,
  role = 'inherit',
  soundEffectPressed,
  className,
  selected,
  testId
}) => {
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const semanticColors = hooks_useSemanticColors(role);
  const semanticSounds = useSemanticSounds(role);
  const modifiers = useSemanticModifiers();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: narrationText,
    className: (0,react_facet_src.useFacetMap)(selected => classnames_default()(NavigationButton.button, semanticColors.background.interactive, semanticColors.text.interactive, className, {
      [modifiers.selected]: selected
    }), [className, semanticColors, modifiers], [(0,react_facet_src.useFacetWrap)(selected !== null && selected !== void 0 ? selected : false)]),
    classNameFocused: focusClass,
    classNameDisabled: NavigationButton.disabled,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    onClick: onClick,
    disabled: disabledFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press,
    "data-testid": testId
  }, children, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true,
    role: role
  }));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/Reflection/Reflection.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Reflection = ({"base":"VhM7i","top":"IJLgK","thin":"TlrkS","bottom":"vgsJS","left":"TayiM","right":"NnaWJ"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Reflection/Reflection.tsx
function Reflection_extends() { Reflection_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Reflection_extends.apply(this, arguments); }

function Reflection_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Reflection_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Reflection_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const ReflectionEffect = ({
  thin,
  top = true,
  bottom = true,
  left = true,
  right = true,
  className,
  semanticStyles
}) => {
  const classList = classnames_default()(Reflection.base, semanticStyles, className, {
    [Reflection.thin]: thin
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(classList, {
      [Reflection.top]: top,
      [Reflection.left]: left
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(classList, {
      [Reflection.bottom]: bottom,
      [Reflection.right]: right
    })
  }));
};

const StaticReflection = (_ref) => {
  let {
    children
  } = _ref,
      props = Reflection_objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ReflectionEffect, props), children);
};

const DynamicReflection = (_ref2) => {
  let {
    disabled,
    children
  } = _ref2,
      props = Reflection_objectWithoutProperties(_ref2, ["disabled", "children"]);

  const enabled = (0,react_facet_src.useFacetMap)(disabled => (disabled !== null && disabled !== void 0 ? disabled : false) === false, [], [(0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: enabled
  }, /*#__PURE__*/react.createElement(ReflectionEffect, props)), children);
};

const Reflection_Reflection = (_ref3) => {
  let {
    effect = 'specular',
    reversed,
    role = 'inherit',
    interactive = true
  } = _ref3,
      props = Reflection_objectWithoutProperties(_ref3, ["effect", "reversed", "role", "interactive"]);

  const {
    [effect]: element
  } = hooks_useSemanticColors(role);
  const variants = useSemanticVariants();
  const semanticStyles = classnames_default()(interactive ? element.interactive : element.base, {
    [variants.reversed]: reversed
  });
  return props.disabled != null ? /*#__PURE__*/react.createElement(DynamicReflection, Reflection_extends({
    semanticStyles: semanticStyles
  }, props)) : /*#__PURE__*/react.createElement(StaticReflection, Reflection_extends({
    semanticStyles: semanticStyles
  }, props));
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/Row.tsx



function Row_RowLegacy({
  options,
  children,
  scrollRef
}) {
  const gamepadAdapterVersion = (0,react.useContext)(gamepadAdapterContext);

  if (gamepadAdapterVersion.version === GamepadAdapterVersion.VISUAL) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(RowLegacyInternal, {
    options: options,
    scrollRef: scrollRef
  }, children);
}
function RowLegacyInternal({
  options,
  children,
  scrollRef
}) {
  const Row = useRow(options, scrollRef);
  return /*#__PURE__*/react.createElement(Row, null, children);
}
;// CONCATENATED MODULE: ./packages/ui-primitive/src/Image/Image.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Image_Image = ({"cover":"N00gN","respectingAspectRatio":"JhYHo","flippedOrigin":"J9E9R"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/Image/Image.tsx





function Image_Image_Image({
  className: classNameParam,
  src,
  imageRendering,
  height,
  width,
  aspectRatio,
  cover,
  shouldFlipOrigin = false
}) {
  const imageRenderingFacet = (0,react_facet_src.useFacetWrap)(imageRendering);
  const srcFacet = (0,react_facet_src.useFacetWrap)(src);
  const respectAspectRatio = aspectRatio != null;
  const imageClassnames = (0,react_facet_src.useFacetMap)(className => classnames_default()(className, {
    [Image_Image.respectingAspectRatio]: respectAspectRatio
  }), [respectAspectRatio], [(0,react_facet_src.useFacetWrap)(classNameParam)]);
  const paddingTop = aspectRatio ? `${aspectRatio.height / aspectRatio.width * 100}%` : undefined; //Temporary workaround for Bug 1004251, once we can flip origins for gifs on the backend side
  //this can be reverted to being simply styles.mainImage

  const className = (0,react_facet_src.useFacetMap)((className, shouldFlipOrigin) => classnames_default()(className, {
    [Image_Image.flippedOrigin]: !!shouldFlipOrigin
  }), [], [(0,react_facet_src.useFacetWrap)(classNameParam), (0,react_facet_src.useFacetWrap)(shouldFlipOrigin)]); // Cover property needs to be applied for the aspect ratio to work properly

  return cover === true || respectAspectRatio ? /*#__PURE__*/react.createElement(BackgroundImage, {
    paddingTop: paddingTop,
    src: srcFacet,
    className: imageClassnames,
    imageRendering: imageRenderingFacet,
    height: height,
    width: width
  }) : /*#__PURE__*/react.createElement("fast-img", {
    src: srcFacet,
    className: className,
    style: {
      height,
      width,
      imageRendering: imageRenderingFacet,
      paddingTop: paddingTop
    }
  });
}

function BackgroundImage({
  className,
  src,
  imageRendering,
  width,
  height,
  paddingTop
}) {
  const backgroundImage = (0,react_facet_src.useFacetMap)(src => `url(${src})`, [], [src]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(className => classnames_default()(Image_Image.cover, className), [], [(0,react_facet_src.useFacetWrap)(className)]),
    style: {
      width,
      height,
      paddingTop,
      backgroundImage,
      imageRendering: imageRendering
    }
  });
}

const ImageResponsive = ({
  images,
  cover,
  className,
  height
}) => {
  const ref = useRef(null);
  const imagesFacet = useFacetWrap(images);
  const [containerWidth, setContainerWidth] = useFacetState(0);
  useOnComponentResize(ref, ({
    width
  }) => setContainerWidth(Math.round(width)));
  const imagesSorted = useFacetMemo(images => images.sort((a, b) => b.maxWidth - a.maxWidth), [], [imagesFacet]);
  const image = useFacetMap((images, containerWidth) => images.find(image => image.maxWidth <= containerWidth), [], [imagesSorted, containerWidth]);
  const src = useFacetMap(image => image === null || image === void 0 ? void 0 : image.src, [], [image]);
  const width = useFacetMap(image => `${image === null || image === void 0 ? void 0 : image.maxWidth}px`, [], [image]);
  return /*#__PURE__*/React.createElement("div", {
    ref: ref
  }, /*#__PURE__*/React.createElement(With, {
    data: src
  }, src => /*#__PURE__*/React.createElement(Image_Image_Image, {
    cover: cover,
    src: src,
    className: className,
    width: width,
    height: height,
    imageRendering: 'pixelated'
  })));
}; // 16:9 is a commonly used aspect ratio for Vanilla images

Image_Image_Image.AspectRatio = {
  '16:9': {
    width: 16,
    height: 9
  },
  '10:3': {
    width: 10,
    height: 3
  },
  '1:1': {
    width: 1,
    height: 1
  }
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/images/arrowBackWhite.png
const arrowBackWhite_namespaceObject = __webpack_require__.p + "assets/arrowBackWhite-2eb91.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/IconArrowBackWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBackWhite = ({"iconArrowBackWhite":"QY9oU"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/utilities.ts

// Could this be rewritten to support arity (n) instead of just (2)?
const useCombinedClassNames = (cn1, cn2) => {
  const cn1Facet = (0,react_facet_src.useFacetWrap)(cn1);
  const cn2Facet = (0,react_facet_src.useFacetWrap)(cn2);
  const classNames = (0,react_facet_src.useFacetMap)((cn1, cn2) => cn1 == null && cn2 == null ? react_facet_src.NO_VALUE : [cn1, cn2].filter(Boolean).join(' '), [], [cn1Facet, cn2Facet]);
  return classNames;
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBackWhite/IconArrowBackWhite.tsx
function IconArrowBackWhite_extends() { IconArrowBackWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowBackWhite_extends.apply(this, arguments); }

function IconArrowBackWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowBackWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowBackWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconArrowBackWhite_IconArrowBackWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconArrowBackWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconArrowBackWhite.iconArrowBackWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowBackWhite_extends({}, props, {
    className: classNames,
    src: arrowBackWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/images/crossWhite.png
const crossWhite_namespaceObject = __webpack_require__.p + "assets/crossWhite-0f6ce.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/IconCrossWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCrossWhite = ({"iconCrossWhite":"pOfo3"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCrossWhite/IconCrossWhite.tsx
function IconCrossWhite_extends() { IconCrossWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconCrossWhite_extends.apply(this, arguments); }

function IconCrossWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconCrossWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconCrossWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconCrossWhite_IconCrossWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconCrossWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconCrossWhite.iconCrossWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconCrossWhite_extends({}, props, {
    className: classNames,
    src: crossWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/TitleBar/TitleBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TitleBar = ({"header":"cMby9","headerShadow":"N2O5_","headerButton":"b22sN","left":"R_MXY","right":"QCx_V"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/TitleBar/TitleBar.tsx










const Buttons = {
  Back: {
    useLocalization: () => useLocalization_useLocalization('TitleBar.Buttons.Back'),
    Component: ({
      onClick,
      gamepadIndex,
      gamepadAlias
    }) => {
      const {
        t
      } = Buttons.Back.useLocalization();
      return /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
        role: "neutral",
        inputLegend: t('.inputLegend'),
        narrationText: t('.narration'),
        onClick: onClick,
        gamepadIndex: gamepadIndex,
        gamepadAlias: gamepadAlias,
        className: TitleBar.headerButton
      }, /*#__PURE__*/react.createElement(IconArrowBackWhite_IconArrowBackWhite, null));
    }
  },
  Close: {
    useLocalization: () => useLocalization_useLocalization('TitleBar.Buttons.Close'),
    Component: ({
      onClick,
      gamepadIndex,
      gamepadAlias,
      narrationSuffix,
      narrationPrefix
    }) => {
      const {
        t
      } = Buttons.Close.useLocalization();
      const narration = (0,react_facet_src.useFacetMap)((narrationPrefix, narrationSuffix) => [narrationPrefix, t('.narration'), narrationSuffix].filter(x => x).join(' . '), [t], [(0,react_facet_src.useFacetWrap)(narrationPrefix !== null && narrationPrefix !== void 0 ? narrationPrefix : ''), (0,react_facet_src.useFacetWrap)(narrationSuffix !== null && narrationSuffix !== void 0 ? narrationSuffix : '')]);
      return /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
        role: "neutral",
        inputLegend: t('.inputLegend'),
        narrationText: narration,
        onClick: onClick,
        gamepadIndex: gamepadIndex,
        gamepadAlias: gamepadAlias,
        className: TitleBar.headerButton
      }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null));
    }
  }
};
const TitleBar_TitleBar = ({
  children,
  role = 'inherit',
  gamepadIndex,
  left,
  right
}) => {
  const semanticColors = hooks_useSemanticColors(role);
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(TitleBar.header, semanticColors.background.base, semanticColors.text.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: TitleBar.left
  }, left), children, /*#__PURE__*/react.createElement("div", {
    className: TitleBar.right
  }, right))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TitleBar.headerShadow, semanticColors.shadow.base)
  }));
};
TitleBar_TitleBar.Buttons = Buttons;
;// CONCATENATED MODULE: ./packages/ui-internal/src/InteractiveSiblingState/InteractiveSiblingState.tsx


const InteractiveSiblingState = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: false
}));
const useHasInteractiveSiblings = () => (0,react.useContext)(InteractiveSiblingState);
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spacing/Spacing.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spacing_Spacing = ({"size1":"dKnsZ","size2":"jlzzq","size3":"kImvy","size4":"wuFIX","size5":"N0bYN","size6":"IhAF5","size7":"hzGpu","size8":"pqqwM"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spacing/Spacing.tsx



function Spacing_Spacing_Spacing({
  size
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: Spacing_Spacing[`size${size}`]
  });
} // Most common use case is to *not* use a facet, so we put it into its
// own component as to not add an unnecessary bloat to Spacing()

function FacetSpacing({
  size
}) {
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(size => Spacing_Spacing[`size${size}`], [], [size])
  });
}

Spacing_Spacing_Spacing.displayName = 'Spacing';
Spacing_Spacing_Spacing.Facet = FacetSpacing;
;// CONCATENATED MODULE: ./packages/ui-primitive/src/TransitionPrimitive/TransitionPrimitive.tsx


const UNMOUNTED = 'unmounted';
const EXITED = 'exited';
const ENTERING = 'entering';
const ENTERED = 'entered';
const EXITING = 'exiting';

/**
 * Some extra timing after a transition is completed to allow it some "breathing room" before we do any JavaScript operation
 * Without this extra time, we can see a small "hitch" at the end of a transition.
 */
const EXTRA_SMOOTHNESS_TIMEOUT = 100;

/**
 * Transition component based on react-transition-group, but with a much slimmer implementation
 * and without a dependency to react-dom.
 */
function TransitionPrimitive({
  visible,
  alwaysMounted,
  inverse = false,
  appear,
  unmountOnExit,
  timeout,
  children
}) {
  const timerIdRef = (0,react.useRef)(null); // Ref to keep track of what is the direction of a transition to be used on effects
  // See more information on its usage below

  const inverseRef = (0,react.useRef)(inverse);
  inverseRef.current = inverse; // We should never unmount if alwaysMounted is set

  unmountOnExit = alwaysMounted ? false : unmountOnExit; // Ref to update effects on the current value of unmountOnExit
  // without needing to re-creating them

  const unmountOnExitRef = (0,react.useRef)(unmountOnExit);
  unmountOnExitRef.current = unmountOnExit;
  const [status, setStatus] = (0,react.useState)(() => {
    if (alwaysMounted && !visible) return [EXITED, inverse];
    if (visible && appear) return [EXITED, inverse];
    if (visible) return [ENTERED, inverse];
    return [UNMOUNTED, inverse];
  });
  (0,react.useEffect)(() => {
    // Before we do any effect, we need to make sure to stop any scheduled state update.
    clearTimerId(timerIdRef); // Read the inverse configuration from a ref since we don't want to trigger an animation
    // just by changing its direction
    // More info: ADO 413018

    const inverse = inverseRef.current;
    setStatus(state => {
      if (visible) {
        if (state[0] === UNMOUNTED) return [EXITED, inverse];
      }

      return state;
    }); // Only start any animation after the default press duration of a button.
    // This is to allow the user to see the press animation and to also allow React to perform any
    // rendering before we start the animation.

    const id = setTimeout(() => {
      setStatus(([currentStatus]) => {
        if (visible) {
          if (currentStatus === ENTERED) return [ENTERED, inverse];
          return [ENTERING, inverse];
        } else {
          if (currentStatus === EXITED) return [EXITED, inverse];
          if (currentStatus === UNMOUNTED) return [UNMOUNTED, inverse];
          return [EXITING, inverse];
        }
      });
    }, DEFAULT_PRESS_DURATION);
    return () => clearTimeout(id);
  }, [visible]);
  const statusStatus = status[0];
  (0,react.useEffect)(() => {
    const isEntering = statusStatus === ENTERING;
    const isExiting = statusStatus === EXITING;
    const isExited = statusStatus === EXITED; // Before we do any effect, we need to make sure to stop any scheduled state update.

    clearTimerId(timerIdRef);

    if (isEntering) {
      timerIdRef.current = setTimeout(() => setStatus(status => [ENTERED, status[1]]), timeout + EXTRA_SMOOTHNESS_TIMEOUT);
    }

    if (isExiting) {
      timerIdRef.current = setTimeout(() => setStatus(status => [unmountOnExitRef.current ? UNMOUNTED : EXITED, status[1]]), timeout + EXTRA_SMOOTHNESS_TIMEOUT);
    }

    if (isExited && unmountOnExit) {
      setStatus(status => [UNMOUNTED, status[1]]);
    }
  }, [statusStatus, unmountOnExit, timeout]);
  (0,react.useEffect)(() => {
    // Make sure to clear any timer on unmounting this component.
    return () => clearTimerId(timerIdRef);
  }, []);
  return statusStatus === UNMOUNTED ? null : children(statusStatus, status[1]);
}

const clearTimerId = ref => {
  if (ref.current) {
    clearTimeout(ref.current);
    ref.current = null;
  }
};
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GamepadColumn.tsx
function GamepadColumn_extends() { GamepadColumn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GamepadColumn_extends.apply(this, arguments); }





function GamepadColumn_GamepadColumn(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GamepadColumn, props);
  }

  if (props.shouldSkipLandmarkInVisual) {
    return /*#__PURE__*/react.createElement(FocusGroup, {
      disabled: props.disabled
    }, props.children);
  }

  if (props.scrollRef == null) {
    return /*#__PURE__*/react.createElement(FocusGroup, props, props.children);
  }

  if (props.scrollAxis != null) {
    // wery weird typescript problem
    return /*#__PURE__*/react.createElement(Landmark, GamepadColumn_extends({}, props, {
      scrollAxis: props.scrollAxis,
      shouldBindFocus: props.bounded,
      containerRef: props.scrollRef,
      delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
      delegateFocusByAlias: props.defaultFocusedChildAlias
    }));
  }

  return /*#__PURE__*/react.createElement(Landmark, GamepadColumn_extends({}, props, {
    scrollAxis: props.scrollAxis,
    shouldBindFocus: props.bounded,
    containerRef: props.scrollRef,
    delegateFocusFromMemory: props.defaultFocusedChildBehavior === 'remember',
    delegateFocusByAlias: props.defaultFocusedChildAlias
  }));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MouseScrollbar = ({"vertical":"X5AON","disabled":"HTEVa","mouseScrollbarBackground":"I0uqP","minimal":"WfHBb","mouseScrollbarRail":"p04xH","mouseScrollbarHandler":"VOQuh","reflectionContainer":"dDEKV","mouseScrollbarHandlerBottomBevel":"ZT0PP","horizontal":"IXDlR","floating":"jHZDI","mouseScrollbarTopDetail":"FqQCr","dark":"KRqUY","horizontalIcon":"UmdPV","mouseScrollbarBottomDetail":"aEsRX"});
// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js
var lodash_debounce = __webpack_require__(91296);
var lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/useUpdateScrollbar.ts




 // How long to wait before notifying any listeners that scrolling has stopped

const SCROLL_STATE_CHANGE_TIMEOUT = 500;
const INPUT_LEGEND_BASE_HEIGHT = 4;
const MAX_HORIZONTAL_HANDLER_WIDTH_PERCENTAGE = 0.4;
/**
 * Hook that reads the scroll value of the container and updates the handler position
 * It does so by directly mutating the DOM element (for performance reasons)
 */

function useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, scrollWrapperElement, horizontalScrolling = false, safeZonePadding = 0) {
  const [isScrolling, setIsScrolling] = (0,react_facet_src.useFacetState)(false);
  const [isBehindInputLegendFacet, setIsBehindInputLegend] = (0,react_facet_src.useFacetState)(false);
  const listenForScrolls = (0,react_facet_src.useFacetWrap)(shouldListenForScrolls !== null && shouldListenForScrolls !== void 0 ? shouldListenForScrolls : true);
  const isInitialRenderRef = (0,react.useRef)(true);
  const isFocusInputGamepad = useIsFocusInputGamepad(); // Convert rem units to pixels

  const inputLegendHeight = useSizeInPixels(INPUT_LEGEND_BASE_HEIGHT) + safeZonePadding;
  const handlerPadding = useSizeInPixels(8);
  const onScrollStart = (0,react.useMemo)(() => lodash_debounce_default()(() => setIsScrolling(true), SCROLL_STATE_CHANGE_TIMEOUT, {
    leading: true,
    trailing: false
  }), [setIsScrolling]);
  const onScrollStop = (0,react.useMemo)(() => lodash_debounce_default()(() => setIsScrolling(false), SCROLL_STATE_CHANGE_TIMEOUT, {
    leading: false,
    trailing: true
  }), [setIsScrolling]);
  /**
   * Effect that fixes the position of the scrollbar handle so that it doesn't become hidden or partially hidden behind the input legend.
   *
   * It needs to run its logic after a setTimeout to compensate for a quirk in Gameface on how getBoundingClientRect works.
   *
   * In Gameface, getBoundingClientRect should return the information from the previous frame, but unfortunately for this particular code we actually
   * need to wait a little longer before we can safely read its bounding rect.
   */

  (0,react.useEffect)(() => {
    let timeoutId = null;
    timeoutId = setTimeout(() => {
      if (!scrollWrapperElement || !scrollWrapperElement.current || horizontalScrolling) {
        return;
      }

      if (isFocusInputGamepad.get() !== true) {
        return setIsBehindInputLegend(false);
      }

      const isBehindInputLegendCurrent = window.innerHeight - scrollWrapperElement.current.getBoundingClientRect().bottom - handlerPadding < inputLegendHeight;
      setIsBehindInputLegend(isBehindInputLegendCurrent);
    }, 250);
    return () => {
      timeoutId && window.clearTimeout(timeoutId);
    };
  }, [setIsBehindInputLegend, handlerPadding, inputLegendHeight, isFocusInputGamepad, scrollWrapperElement, scrollingContainerRef, horizontalScrolling]);
  const animationFrameRef = (0,react.useRef)(null);
  const checkScroll = (0,react.useMemo)(() => {
    let previousBehindInputLegend = null;
    let previousWindowSize = null;
    let previousScroll = null;
    let shouldRerender = true;
    return () => {
      var _window$requestAnimat, _window;

      const isBehindInputLegend = isBehindInputLegendFacet.get() === true;
      const scrollingContainer = scrollingContainerRef.current;
      const handlerElement = handlerRef.current;
      const railElement = railRef.current;

      if (!scrollingContainer || !handlerElement || !railElement) {
        return;
      } // BUG - `scrollTop` behaves differently when using the gamepad, this may be due to how the gamepad input is update.


      const currentScroll = horizontalScrolling ? scrollingContainer.scrollLeft : scrollingContainer.scrollTop;
      const currentWindowSize = horizontalScrolling ? window.innerWidth : window.innerHeight; // If we detected that the scroll has changed on a previous check
      // we can update the position of affected DOM elements

      if (shouldRerender) {
        const scrollingElementRect = scrollingContainer.getBoundingClientRect(); // If we are mounting and still don't have a size for the element, we wait until the next frame

        if (!(scrollingElementRect.width === 0 || scrollingElementRect.height === 0)) {
          const inputLegendOffset = isBehindInputLegend ? inputLegendHeight : 0;
          const scrollableAreaSize = (horizontalScrolling ? scrollingElementRect.width : scrollingElementRect.height) - inputLegendOffset;
          const scrollingElementSize = horizontalScrolling ? scrollingContainer.scrollWidth : scrollingContainer.scrollHeight;
          const maxScroll = scrollingElementSize - (horizontalScrolling ? scrollingElementRect.width : scrollingElementRect.height); // NOTE - When using a gamepad, the currentScroll value is incorrect due to the `scrollingContainer.scrollTop` values being
          // Calculated differently, this `newvalue` should not exceed a ratio of 1 and the `min` functions is in place as a safeguard.

          const newValue = Math.min(1, currentScroll / maxScroll);
          const scrollViewPaddingOffset = horizontalScrolling ? scrollingContainer.getBoundingClientRect().left - scrollingElementRect.left : railElement.getBoundingClientRect().top - scrollingElementRect.top;
          const handlerFluidSize = scrollableAreaSize / scrollingElementSize * scrollableAreaSize - scrollViewPaddingOffset * 2;
          const handlerSize = Math.max(40, horizontalScrolling ? Math.min(MAX_HORIZONTAL_HANDLER_WIDTH_PERCENTAGE * scrollableAreaSize - scrollViewPaddingOffset * 2, handlerFluidSize) : handlerFluidSize);

          if (horizontalScrolling) {
            handlerElement.style.left = `${newValue * 100}%`;
            handlerElement.style.widthPX = handlerSize;
            handlerElement.style.marginLeft = `${-handlerSize / 2}px`;
            railElement.style.leftPX = handlerSize / 2;
            railElement.style.rightPX = handlerSize / 2;
          } else {
            const handlerStartPosition = newValue * (scrollableAreaSize - handlerSize - scrollViewPaddingOffset * 2);
            handlerElement.style.topPX = handlerStartPosition;
            handlerElement.style.heightPX = handlerSize;
            railElement.style.bottomPX = inputLegendOffset;
          }

          shouldRerender = false;
        }
      }

      if (isBehindInputLegend !== previousBehindInputLegend) {
        previousBehindInputLegend = isBehindInputLegend;
        shouldRerender = true;
      }

      if (currentScroll !== previousScroll) {
        if (isInitialRenderRef.current) {
          isInitialRenderRef.current = false;
        } else {
          onScrollStart();
          onScrollStop();
        }

        previousScroll = currentScroll;
        shouldRerender = true;
      }

      if (currentWindowSize !== previousWindowSize) {
        previousWindowSize = currentWindowSize;
        shouldRerender = true;
      } // Needed to be able to run visual regression testing


      animationFrameRef.current = (_window$requestAnimat = (_window = window).requestAnimationFrame) === null || _window$requestAnimat === void 0 ? void 0 : _window$requestAnimat.call(_window, checkScroll);
    };
  }, [onScrollStart, onScrollStop, horizontalScrolling, inputLegendHeight, isBehindInputLegendFacet, scrollingContainerRef, handlerRef, railRef]); // We give the user of this hook the option of providing us with a Facet<boolean>. We can use
  // that facet to determine if we should enqueue scroll checks on subsequent animation frames. If
  // the scroll view isn't visible, or we don't have a scrollbar, there is no point in putting
  // functions on every animation frame. It also scales very poorly. Unfortunately, we have to do
  // it this way because Gameface dosen't provide us with any scroll listeners - but we can at least
  // try to keep it to a minimum.

  (0,react_facet_src.useFacetEffect)(shouldListenForScrolls => {
    if (shouldListenForScrolls) {
      checkScroll();
    }

    return () => {
      var _window$cancelAnimati, _window2;

      animationFrameRef.current != null && ((_window$cancelAnimati = (_window2 = window).cancelAnimationFrame) === null || _window$cancelAnimati === void 0 ? void 0 : _window$cancelAnimati.call(_window2, animationFrameRef.current));
      onScrollStop.cancel();
      onScrollStart.cancel();
    };
  }, [checkScroll, onScrollStop, onScrollStart], [listenForScrolls]);
  return isScrolling;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/useHasScrollbar.ts


/**
 * Hook that checks if there is enough content vertically to render the scrollbar
 */

function useHasScrollbar(scrollingContainerRef, horizontal = false, stopTrackingScrollDimensions) {
  const [hasScrollbar, setHasScrollbar] = (0,react_facet_src.useFacetState)(false);
  const previousDimension = (0,react.useRef)(0);
  (0,react.useEffect)(() => {
    const check = () => {
      const scrollingElement = scrollingContainerRef.current;
      if (!scrollingElement) return;
      const {
        scrollHeight,
        scrollWidth
      } = scrollingElement; // If the container has no height then it means it is hidden
      // No need to update any state

      if (scrollHeight === 0) return;
      const {
        width,
        top,
        left,
        height
      } = scrollingElement.getBoundingClientRect();

      if (stopTrackingScrollDimensions) {
        if (horizontal) {
          return setHasScrollbar(scrollWidth > Math.ceil(width));
        } else {
          return setHasScrollbar(scrollHeight > Math.ceil(height));
        }
      }
      /*
      If a non-floating scrollbar is used, we need to need to keep track of the dimensions of the ScrollView in order
      to not end up in a state where the scrollbar appears and re-appears.
      See https://dev.azure.com/dev-mc/Minecraft/_workitems/edit/961077 for more information.
      */


      setHasScrollbar(hasScrollbarCurrently => {
        if (hasScrollbarCurrently === true && previousDimension.current > 0) {
          if (horizontal) {
            const delta = previousDimension.current - scrollWidth;
            const position = window.innerWidth - (left + scrollWidth);

            if (position <= delta) {
              return scrollWidth > Math.ceil(width - delta);
            }
          } else {
            const delta = previousDimension.current - scrollHeight;
            const position = window.innerHeight - (top + scrollHeight);

            if (position <= delta) {
              return scrollHeight > Math.ceil(height - delta);
            }
          }
        }

        if (horizontal) {
          previousDimension.current = scrollWidth;
          return scrollWidth > Math.ceil(width);
        } else {
          previousDimension.current = scrollHeight;
          return scrollHeight > Math.ceil(height);
        }
      });
    };

    check();
    const intervalId = setInterval(check, 1000);
    return () => clearInterval(intervalId);
  }, [stopTrackingScrollDimensions, horizontal, scrollingContainerRef, setHasScrollbar]);
  return hasScrollbar;
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/MouseScrollbar.tsx








function MouseScrollbar_MouseScrollbar({
  scrollingContainerRef,
  horizontal,
  stopCheckingForScroll,
  floating,
  stopTrackingScrollDimensions,
  darkTheme,
  minimalTheme,
  safeZonePadding,
  backgroundRole = 'neutral60',
  className
}) {
  const {
    handlerRef,
    railRef
  } = useHandlerDrag(scrollingContainerRef, horizontal);
  const handleClick = useClickToScroll(scrollingContainerRef, railRef, horizontal);
  const hasScrollbarFacet = useHasScrollbar(scrollingContainerRef, horizontal, floating || stopTrackingScrollDimensions);
  const stopChecking = (0,react_facet_src.useFacetWrap)(stopCheckingForScroll !== null && stopCheckingForScroll !== void 0 ? stopCheckingForScroll : false);
  const shouldListenForScrolls = (0,react_facet_src.useFacetMap)((hasScrollbar, stopChecking) => hasScrollbar && !stopChecking, [], [hasScrollbarFacet, stopChecking]);
  const {
    background: {
      base: scrollBarBackground
    }
  } = hooks_useSemanticColors(backgroundRole);
  useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, undefined, horizontal, safeZonePadding);
  const rootClassName = (0,react_facet_src.useFacetMap)(hasScrollbar => classnames_default()(className, {
    [MouseScrollbar.vertical]: !horizontal,
    [MouseScrollbar.horizontal]: horizontal,
    [MouseScrollbar.disabled]: !hasScrollbar,
    [MouseScrollbar.floating]: floating
  }), [horizontal, floating, className], [hasScrollbarFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: rootClassName,
    onClick: handleClick
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarTopDetail, {
      [MouseScrollbar.horizontalIcon]: horizontal,
      [MouseScrollbar.minimal]: minimalTheme,
      [MouseScrollbar.dark]: darkTheme
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarBackground, scrollBarBackground, {
      [MouseScrollbar.minimal]: minimalTheme
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarRail,
    ref: railRef
  }, /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarHandler,
    ref: handlerRef
  }, /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.reflectionContainer
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: "secondary"
  })), /*#__PURE__*/react.createElement("div", {
    className: MouseScrollbar.mouseScrollbarHandlerBottomBevel
  }))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(MouseScrollbar.mouseScrollbarBottomDetail, {
      [MouseScrollbar.horizontalIcon]: horizontal,
      [MouseScrollbar.minimal]: minimalTheme,
      [MouseScrollbar.dark]: darkTheme
    })
  }));
}
/**
 * Hook that allows clicking anywhere in the Scrollbar to update the scroll position of the container
 */

const useClickToScroll = (scrollingContainerRef, railRef, horizontalScrollBar) => {
  return (0,react.useCallback)(event => {
    const scrollingElement = scrollingContainerRef.current;
    const railElement = railRef.current;
    if (!scrollingElement || !railElement) return;
    const railRect = railElement.getBoundingClientRect();
    const scrollingElementRect = scrollingElement.getBoundingClientRect();
    /* If it's a horizontal scrollbar the width, x and left properties of the elements should be considered, instead of height, y and top */

    if (horizontalScrollBar) {
      const scrollPercentage = (event.clientX - railRect.left) / railRect.width;
      scrollingElement.scrollLeft = scrollPercentage * (scrollingElement.scrollWidth - scrollingElementRect.width);
    } else {
      const scrollPercentage = (event.clientY - railRect.top) / railRect.height;
      scrollingElement.scrollTop = scrollPercentage * (scrollingElement.scrollHeight - scrollingElementRect.height);
    }
  }, [scrollingContainerRef, railRef, horizontalScrollBar]);
};
/**
 * Hook that allows dragging the handler to update the scroll position of the container vertically and horizontally
 * The flag horizontalScrolling is used to determine the direction of the scroll
 */


const useHandlerDrag = (scrollingContainerRef, horizontalScrolling = false) => {
  const handlerRef = (0,react.useRef)(null);
  const railRef = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    const handlerElement = handlerRef.current;
    const scrollingContainerElement = scrollingContainerRef.current;
    const railElement = railRef.current;
    if (!handlerElement || !scrollingContainerElement || !railElement) return;
    let isDragging = false;
    let delta = 0;

    const handleMouseDown = event => {
      isDragging = true;
      const rect = handlerElement.getBoundingClientRect();
      delta = horizontalScrolling ? event.clientX - rect.left : event.clientY - rect.top;
    };

    const handleMouseUp = () => {
      isDragging = false;
      delta = 0;
    };

    const handleMouseMove = event => {
      if (!isDragging) return;
      const railElementRect = railElement.getBoundingClientRect();
      const handlerElementRect = handlerElement.getBoundingClientRect();
      const scrollingContainerElementRect = scrollingContainerElement.getBoundingClientRect();
      /* If it's a horizontally scrolling scrollbar, use width, if vertical use height */

      const scrollPercentage = horizontalScrolling ? (event.clientX - delta - railElementRect.left) / (railElementRect.width - handlerElementRect.width) : (event.clientY - delta - railElementRect.top) / (railElementRect.height - handlerElementRect.height);
      /* If it's a horizontally scrolling scrollbar, use width, if vertical use height */

      if (horizontalScrolling) {
        scrollingContainerElement.scrollLeft = scrollPercentage * (scrollingContainerElement.scrollWidth - scrollingContainerElementRect.width);
      } else {
        scrollingContainerElement.scrollTop = scrollPercentage * (scrollingContainerElement.scrollHeight - scrollingContainerElementRect.height);
      }
    };

    const handleClick = event => {
      event.preventDefault();
      event.stopPropagation();
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    handlerElement.addEventListener('mousedown', handleMouseDown);
    handlerElement.addEventListener('click', handleClick);
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      handlerElement.removeEventListener('mousedown', handleMouseDown);
      handlerElement.removeEventListener('click', handleClick);
    };
  }, [handlerRef, scrollingContainerRef, railRef, horizontalScrolling]);
  return {
    handlerRef,
    railRef
  };
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/AutoHidingScrollbar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AutoHidingScrollbar = ({"vertical":"pKafk","scrollbarNonInteractiveRail":"hhUBB","scrollbarHandlerNonInteractive":"VLAZG","horizontal":"qBOw1","scrollbarHandlerNonInteractiveActive":"VEGv3","scrollbarHandlerNonInteractiveIdle":"eC0Tu"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/AutoHidingScrollbar.tsx






function AutoHidingScrollbar_AutoHidingScrollbar({
  scrollingContainerRef,
  horizontal,
  stopCheckingForScroll,
  alwaysVisible,
  safeZonePadding
}) {
  const handlerRef = (0,react.useRef)(null);
  const railRef = (0,react.useRef)(null);
  const scrollWrapperRef = (0,react.useRef)(null);
  const isTouchingFacet = useTouchCheck(scrollingContainerRef);
  const stopChecking = (0,react_facet_src.useFacetWrap)(stopCheckingForScroll !== null && stopCheckingForScroll !== void 0 ? stopCheckingForScroll : false);
  const hasScrollbarFacet = useHasScrollbar(scrollingContainerRef, horizontal);
  const shouldListenForScrolls = (0,react_facet_src.useFacetMap)((hasScrollbar, stopChecking) => hasScrollbar && !stopChecking, [], [hasScrollbarFacet, stopChecking]);
  const isScrollingFacet = useUpdateScrollbar(scrollingContainerRef, handlerRef, railRef, shouldListenForScrolls, scrollWrapperRef, horizontal, safeZonePadding);
  const rootClassName = classnames_default()({
    [AutoHidingScrollbar.vertical]: !horizontal,
    [AutoHidingScrollbar.horizontal]: horizontal
  });
  const handlerClassName = (0,react_facet_src.useFacetMap)((isTouching, isScrolling, hasScrollbar) => {
    const isIdle = !isScrolling && !isTouching && !alwaysVisible;
    return `${AutoHidingScrollbar.scrollbarHandlerNonInteractive} ${hasScrollbar && !isIdle ? AutoHidingScrollbar.scrollbarHandlerNonInteractiveActive : AutoHidingScrollbar.scrollbarHandlerNonInteractiveIdle}`;
  }, [alwaysVisible], [isTouchingFacet, isScrollingFacet, hasScrollbarFacet]);
  return /*#__PURE__*/react.createElement("div", {
    className: rootClassName,
    ref: scrollWrapperRef
  }, /*#__PURE__*/react.createElement("div", {
    className: AutoHidingScrollbar.scrollbarNonInteractiveRail,
    ref: railRef
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: handlerClassName,
    ref: handlerRef
  })));
}
const useTouchCheck = ref => {
  const [isTouching, setIsTouching] = (0,react_facet_src.useFacetState)(false);
  (0,react.useEffect)(() => {
    var _ref$current;

    const handleStart = () => setIsTouching(true);

    const handleEnd = () => setIsTouching(false);

    const element = (_ref$current = ref === null || ref === void 0 ? void 0 : ref.current) !== null && _ref$current !== void 0 ? _ref$current : window;
    element.addEventListener('touchstart', handleStart);
    element.addEventListener('touchend', handleEnd);
    return () => {
      element.removeEventListener('touchstart', handleStart);
      element.removeEventListener('touchend', handleEnd);
    };
  }, [ref, setIsTouching]);
  return isTouching;
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/Scrollbar.tsx






/**
 * Scrollbar component, should be used via a layout components like the FlatList
 */
function Scrollbar({
  scrollingContainerRef,
  stopCheckingForScroll,
  alwaysVisible,
  horizontal = false,
  floating,
  stopTrackingScrollDimensions,
  darkTheme,
  minimalTheme,
  backgroundRole,
  className
}) {
  const isPointerMouse = useIsPointerInputMouse();
  const isPointerNotMouse = (0,react_facet_src.useFacetMap)(isMouse => !isMouse, [], [isPointerMouse]);
  const safeZone = useSafeZone();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPointerMouse
  }, /*#__PURE__*/react.createElement(MouseScrollbar_MouseScrollbar, {
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    safeZonePadding: safeZone.bottom,
    floating: floating,
    stopTrackingScrollDimensions: stopTrackingScrollDimensions,
    darkTheme: darkTheme,
    minimalTheme: minimalTheme,
    backgroundRole: backgroundRole,
    className: className
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPointerNotMouse
  }, /*#__PURE__*/react.createElement(AutoHidingScrollbar_AutoHidingScrollbar, {
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    safeZonePadding: safeZone.bottom,
    alwaysVisible: alwaysVisible
  })));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ScrollView_ScrollView = ({"wrapper":"UedOa","wrapperFlexShrink":"LZJCZ","ScrollView":"bXCZP","focusBorder":"cQvwc","emptyFocusable":"YEgzg","ScrollViewHorizontal":"NsGay","safetyPaddings":"ekhCp","safetyPaddingsHorizontal":"n60Ng","content":"OnsGF","scrollBlocker":"WFE9a","contentPaddings":"SIgu2","horizontalContent":"ze6YH","spinnerPlaceholder":"Cp7QN","animateOpacity":"Il2HF","borderedSpinner":"rxEL1","paddedSpinner":"s31Ag","hidden":"t0Ytw","hiddenContent":"AV6LH"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spinner/Spinner.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spinner = ({"spinner":"Dpj6m"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Spinner/Spinner.tsx



/**
 * For screenshot tests animations need to be disabled. We also want to make sure that the fixture image
 * not imported into production builds.
 */

const animation =  false ? 0 : __webpack_require__(84984);
function Spinner_Spinner() {
  return /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: animation,
    className: Spinner.spinner,
    imageRendering: "pixelated"
  });
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useNarrateText.ts



// `useNarrateText` is a way of reading to the user events that are global
// and happen just once. The goal of `useNarrateText` is to be able to
// narrate something imperatively outside of the current narration node
// context. It could evolve in the future into a system for handling notifications.
// An example is dragging an item from the inventory to a crafting section, or switching a
// switch on and off.
const useNarrateText_useNarrateText = ({
  interruptible = true,
  playInBackground = false,
  profanityFilterContext = {
    outOfGame: true,
    inGame: true
  },
  required = false
} = {}) => {
  const narrateTimeoutRef = (0,react.useRef)();
  const {
    readText
  } = (0,react.useContext)(narrationDriverContext);
  const narrateText = (0,react.useCallback)(narration => {
    narrateTimeoutRef.current = setTimeout(() => {
      readText(narration, profanityFilterContext, interruptible, required, playInBackground);
    }, NARRATION_DEBOUNCE_DELAY);
  }, [readText, profanityFilterContext, interruptible, required, playInBackground]);
  const preventNarrateText = (0,react.useCallback)(() => {
    if (narrateTimeoutRef.current) {
      clearTimeout(narrateTimeoutRef.current);
    }
  }, []);
  return {
    narrateText,
    preventNarrateText
  };
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/ScrollView/ScrollView.tsx

















const Wrapper = ({
  children,
  loading,
  scrollingContainerRef,
  stopCheckingForScroll,
  renderTracker,
  alwaysVisible,
  horizontal = false,
  floating,
  stopTrackingScrollDimensions,
  darkTheme,
  minimalTheme,
  padSpinnerVertically,
  spinnerBackgroundColor,
  autofocus,
  gamepadIndex,
  showSpinnerBorder,
  showFocusOutline,
  spinnerIdRef,
  flexShrinkWrapper,
  scrollbarBackgroundRole,
  scrollbarClassName
}) => {
  const focusContainerClassNames = (0,react_facet_src.useFacetMap)(isLastInputFocus => classnames_default()({
    [ScrollView_ScrollView.focusBorder]: isLastInputFocus && showFocusOutline,
    [focusClass]: isLastInputFocus && showFocusOutline
  }), [showFocusOutline], [useIsLastInputFocus()]);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ScrollView_ScrollView.wrapper, {
      [ScrollView_ScrollView.wrapperFlexShrink]: flexShrinkWrapper
    })
  }, /*#__PURE__*/react.createElement(SpinnerPlaceholder, {
    gamepadIndex: gamepadIndex,
    autofocus: autofocus,
    hidden: (0,react_facet_src.useFacetMap)(loading => loading == null ? true : !loading, [], [loading]),
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically,
    spinnerBackgroundColor: spinnerBackgroundColor,
    showBorder: showSpinnerBorder,
    nodeIdRef: spinnerIdRef
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)((loading, animationEnabled) => classnames_default()(horizontal ? ScrollView_ScrollView.ScrollViewHorizontal : ScrollView_ScrollView.ScrollView, horizontal ? ScrollView_ScrollView.safetyPaddingsHorizontal : ScrollView_ScrollView.safetyPaddings, {
      [ScrollView_ScrollView.hiddenContent]: loading,
      [ScrollView_ScrollView.animateOpacity]: animationEnabled
    }), [horizontal], [loading, useScreenAnimationEnabled()])
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: focusContainerClassNames
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  })), children, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(loading => loading == null ? true : !loading, [], [loading])
  }, /*#__PURE__*/react.createElement(Scrollbar, {
    floating: floating,
    stopTrackingScrollDimensions: stopTrackingScrollDimensions,
    horizontal: horizontal,
    scrollingContainerRef: scrollingContainerRef,
    stopCheckingForScroll: stopCheckingForScroll,
    alwaysVisible: alwaysVisible,
    darkTheme: darkTheme,
    minimalTheme: minimalTheme,
    backgroundRole: scrollbarBackgroundRole,
    className: scrollbarClassName
  }))));
};

const fallbackGamepadAPI = {
  navigate: () => {},
  focusedId: (0,react_facet_src.createFacet)({
    initialValue: ''
  })
};

function useFocusFirstFocusableAfterLoading(loadingFacet, // Reference to a wrapping container for the child content
nodeIdRef, spinnerIdRef, autofocus) {
  const isNarrationEnabled = useNarrationEnabled(); // This context is only available with the legacy gamepad navigation.

  const maybeGamepadAPI = useGamepadAPI();
  const gamepadAPI = maybeGamepadAPI !== null && maybeGamepadAPI !== void 0 ? maybeGamepadAPI : fallbackGamepadAPI;
  const listenForLoadingFinished = (0,react.useRef)(true);
  (0,react_facet_src.useFacetEffect)((loading, currentFocusId) => {
    // If we are not yet listening for loading changes and loading is true
    // we set the listenForLoadingChanges ref to true to indicate that we
    // want to know when loading becomes false.
    if (listenForLoadingFinished.current == false && loading) {
      listenForLoadingFinished.current = true;
    } // We just want to run this  block the first time loading goes from true to false.


    if (!loading && listenForLoadingFinished.current) {
      listenForLoadingFinished.current = false;

      if ( // If the user wasn't focusing anything at all and this should be autofocused
      currentFocusId == null && nodeIdRef.current != null && autofocus || // Or if user was focused on the spinner for this ScrollView
      currentFocusId != null && currentFocusId === spinnerIdRef.current && nodeIdRef.current != null) {
        return gamepadAPI.navigate(nodeIdRef.current);
      }
    }
  }, [isNarrationEnabled, gamepadAPI, spinnerIdRef, nodeIdRef, autofocus], [loadingFacet, gamepadAPI.focusedId]);
}

const ScrollView_ScrollView_ScrollView = ({
  children,
  loading,
  renderTracker,
  gamepadIndex,
  scrollIntoViewAlign = 'center',
  scrollIntoView = true,
  scrollIntoViewSpeedFactor,
  defaultFocusedChildBehavior,
  autofocusFocusable,
  horizontal = false,
  innerRef,
  floating,
  stopTrackingScrollDimensions,
  darkTheme,
  minimalTheme,
  padSpinnerVertically,
  spinnerBackgroundColor,
  disableScrolling,
  showSpinnerBorder,
  stopCheckingForScroll,
  emptyFocusableGamepadAlias,
  emptyFocusableNarrationText,
  nodeIdRef,
  autofocus = false,
  gamepadAlias,
  delegateFocusByAlias,
  flexShrinkWrapper,
  scrollbarBackgroundRole,
  scrollbarClassName
}) => {
  const localRef = (0,react.useRef)(null);
  const ref = innerRef || localRef;
  const [alwaysVisibleAutoHidingScrollbar, setAlwaysVisibleAutoHidingScrollbar] = (0,react.useState)(false);
  const loadingFacet = (0,react_facet_src.useFacetWrap)(loading);
  const scrollable = useHasScrollbar(ref, horizontal, floating || stopTrackingScrollDimensions);
  const isNarrationEnabled = useNarrationEnabled();
  const GamepadContainer = horizontal ? GamepadRow_GamepadRow : GamepadColumn_GamepadColumn; // Used to focus the first thing within the GamePadContainer after the loading is completed

  const localIdRef = (0,react.useRef)();
  const idRef = nodeIdRef !== null && nodeIdRef !== void 0 ? nodeIdRef : localIdRef;
  const spinnerIdRef = (0,react.useRef)();
  useFocusFirstFocusableAfterLoading(loadingFacet, idRef, spinnerIdRef, autofocus);
  const isScrollingDisabledFacet = (0,react_facet_src.useFacetWrap)(disableScrolling !== null && disableScrolling !== void 0 ? disableScrolling : false);
  const contentClassNames = (0,react_facet_src.useFacetMap)(isScrollingDisabled => classnames_default()(horizontal ? ScrollView_ScrollView.horizontalContent : ScrollView_ScrollView.content, isScrollingDisabled ? ScrollView_ScrollView.scrollBlocker : null, ScrollView_ScrollView.contentPaddings, horizontal ? ScrollView_ScrollView.safetyPaddingsHorizontal : ScrollView_ScrollView.safetyPaddings), [horizontal], [isScrollingDisabledFacet]);
  const [hasChildFocusable, setHasChildFocusable] = (0,react_facet_src.useFacetState)(false);
  const mountEmptyFocusable = (0,react_facet_src.useFacetMap)((hasChildFocusable, scrollable) => isNarrationEnabled && !hasChildFocusable || !hasChildFocusable && scrollable, [isNarrationEnabled], [hasChildFocusable, scrollable]);
  return (
    /*#__PURE__*/
    // Set a flag if we contain any focusable children
    react.createElement(InteractivePrimitiveMountCallback.Provider, {
      value: (0,react.useCallback)(() => setHasChildFocusable(true), [setHasChildFocusable])
    }, /*#__PURE__*/react.createElement(InteractiveSiblingState.Provider, {
      value: hasChildFocusable
    }, /*#__PURE__*/react.createElement(Wrapper, {
      flexShrinkWrapper: flexShrinkWrapper,
      floating: floating,
      stopTrackingScrollDimensions: stopTrackingScrollDimensions,
      horizontal: horizontal,
      scrollingContainerRef: ref,
      stopCheckingForScroll: stopCheckingForScroll,
      loading: loadingFacet,
      renderTracker: renderTracker,
      alwaysVisible: alwaysVisibleAutoHidingScrollbar,
      darkTheme: darkTheme,
      minimalTheme: minimalTheme,
      padSpinnerVertically: padSpinnerVertically,
      spinnerBackgroundColor: spinnerBackgroundColor,
      showSpinnerBorder: showSpinnerBorder,
      showFocusOutline: alwaysVisibleAutoHidingScrollbar && floating === true,
      autofocus: autofocus,
      gamepadIndex: gamepadIndex,
      spinnerIdRef: spinnerIdRef,
      scrollbarBackgroundRole: scrollbarBackgroundRole,
      scrollbarClassName: scrollbarClassName
    }, /*#__PURE__*/react.createElement("fast-div", {
      className: contentClassNames,
      ref: ref,
      "data-testid": "scroll-view"
    }, /*#__PURE__*/react.createElement(GamepadContainer, {
      disabled: (0,react_facet_src.useFacetUnwrap)(loading) === true,
      scrollIntoView: scrollIntoView,
      scrollIntoViewAlign: scrollIntoViewAlign,
      scrollWithAnalog: true,
      scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
      gamepadIndex: gamepadIndex,
      defaultFocusedChildBehavior: defaultFocusedChildBehavior,
      scrollRef: ref,
      scrollAxis: horizontal ? ScrollAxis.HORIZONTAL : ScrollAxis.VERTICAL,
      nodeIdRef: idRef,
      alias: gamepadAlias,
      defaultFocusedChildAlias: delegateFocusByAlias
    }, children, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: mountEmptyFocusable
    }, /*#__PURE__*/react.createElement(EmptyFocusable, {
      autofocus: !!autofocusFocusable,
      onFocusChanged: setAlwaysVisibleAutoHidingScrollbar,
      gamepadAlias: emptyFocusableGamepadAlias,
      narrationText: emptyFocusableNarrationText
    })))))))
  );
};
const DEFAULT_SPINNER_BG_COLOR = 'rgba(0, 0, 0, 0.4)';

function SpinnerPlaceholder({
  gamepadIndex,
  autofocus,
  hidden,
  renderTracker,
  spinnerBackgroundColor,
  padSpinnerVertically,
  showBorder = true,
  nodeIdRef
}) {
  const {
    t
  } = useLocalization_useLocalization('ScrollView');
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const [hasFocus, setHasFocus] = (0,react_facet_src.useFacetState)(false);
  const hiddenValue = (0,react_facet_src.useFacetUnwrap)(hidden);
  const animationEnabled = (0,react_facet_src.useFacetUnwrap)(useScreenAnimationEnabled());
  const visible = hiddenValue === react_facet_src.NO_VALUE ? true : !hiddenValue; // This var is a snapshot of the hidden value on the first render
  // It allows us to fire the renderTracker if Spinner/TransitionPrimitive is never mounted (no loading state)

  const wasSpinnerNeverMounted = (0,react.useRef)((0,react_facet_src.useFacetRef)(hidden).current); // We need to know if the spinner has focus so we can narrate 'Loading' again after X seconds.

  const repeatLoadingAfterMs = 10000;
  (0,react_facet_src.useFacetEffect)((isHidden, hasFocus) => {
    let intervalId;

    if (!isHidden && hasFocus) {
      intervalId = setInterval(narrateText.bind(null, t('.loadingState')), repeatLoadingAfterMs);
    } else if (intervalId != null) {
      clearInterval(intervalId);
    }

    return () => intervalId != null && clearInterval(intervalId);
  }, [narrateText, t, repeatLoadingAfterMs], [hidden, hasFocus]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(TransitionPrimitive, {
    visible: visible,
    timeout: 500
  }, status => {
    return /*#__PURE__*/react.createElement(react.Fragment, null, status !== 'exited' && /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      autofocus: autofocus,
      gamepadIndex: gamepadIndex,
      narrationText: [t('.narrationScrollViewComponentType'), t('.loadingState')].join(' . '),
      className: classnames_default()(ScrollView_ScrollView.spinnerPlaceholder, {
        [ScrollView_ScrollView.paddedSpinner]: padSpinnerVertically,
        [ScrollView_ScrollView.hidden]: status === 'exiting',
        [ScrollView_ScrollView.borderedSpinner]: showBorder,
        [ScrollView_ScrollView.animateOpacity]: animationEnabled === true
      }),
      classNameFocused: focusClass,
      onFocusChanged: setHasFocus,
      onHoverChanged: setHasFocus,
      style: {
        backgroundColor: spinnerBackgroundColor !== null && spinnerBackgroundColor !== void 0 ? spinnerBackgroundColor : DEFAULT_SPINNER_BG_COLOR
      },
      inputLegend: false,
      onClick: () => {},
      nodeIdRef: nodeIdRef
    }, /*#__PURE__*/react.createElement(Focus_Focus, {
      inset: true
    }), /*#__PURE__*/react.createElement(Spinner_Spinner, null)), renderTracker && renderTracker(status === 'exited'));
  }), (wasSpinnerNeverMounted.current === true || wasSpinnerNeverMounted.current == null) && renderTracker && renderTracker(true));
}

const ScrollView_noop = () => {};

const EmptyFocusable = ({
  autofocus,
  onFocusChanged,
  gamepadAlias,
  narrationText = false
}) => {
  return (
    /*#__PURE__*/

    /**
     * We wrap this empty focusable in a InteractivePrimitiveMountCallback to catch the
     * callback. The ScrollView wraps itself in a InteractivePrimitiveMountCallback so it
     * can detect if any children are focusable and adjust the narration/focusability
     * accordingly. We do not want this focusable to have any affect on that behavior.
     */
    react.createElement(InteractivePrimitiveMountCallback.Provider, {
      value: ScrollView_noop
    }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      className: ScrollView_ScrollView.emptyFocusable,
      gamepadIndex: 0,
      onClick: ScrollView_noop,
      autofocus: autofocus,
      onFocusChanged: onFocusChanged,
      inputLegend: false,
      gamepadAlias: gamepadAlias,
      narrationText: narrationText
    }))
  );
};
/**
 * Can be used to receive a callback if InteractivePrimitives are nested within a ScrollView.
 * Doesn't have many use cases, but can be useful when setting up narration with composable content.
 */


const SiblingState = ({
  callback
}) => {
  const hasSiblings = useHasInteractiveSiblings();
  (0,react_facet_src.useFacetEffect)(hasSiblings => {
    callback(hasSiblings);
  }, [callback], [hasSiblings]);
  return null;
};

ScrollView_ScrollView_ScrollView.SiblingState = SiblingState;
ScrollView_ScrollView_ScrollView.useHasScrollbar = useHasScrollbar;
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/useShortcut.tsx





function useGlobalShortcut(gamepad, onClick) {
  useShortcut(gamepad, onClick, 'global');
}
function useParentShortcut(gamepad, onClick) {
  useShortcut(gamepad, onClick, 'parent');
}

function useShortcut(gamepad, onClick, scope) {
  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const id = (0,react.useMemo)(() => __generateId(), []);
  const api = (0,react.useContext)(GamepadAPIContext);
  const path = (0,react.useContext)(pathContext_PathContext);
  (0,react_facet_src.useFacetEffect)(gamepad => {
    const shortcut = {
      type: 'shortcut',
      scope,
      id,
      path,
      onClick,
      shortcut: gamepad.button,
      inputLegend: gamepad.inputLegend,
      disabled: gamepad.disabled || false
    };
    api.addOrUpdateNode(shortcut);
  }, [id, onClick, scope, api, path], [gamepadFacet]);
  (0,react.useEffect)(() => {
    api.runAddNodeEffect();
    return () => api.removeNode(id);
  }, [api, id]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/GlobalShortcut.tsx

function GlobalShortcut({
  options,
  onClick
}) {
  useGlobalShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/hooks/useShortcut.tsx



function useShortcut_useShortcut(gamepad, callback) {
  const gamepadFacet = (0,react_facet_src.useFacetWrap)(gamepad);
  const focusTreeAPIRef = (0,react.useContext)(focusTreeAPI_FocusTreeAPIContext);
  const path = (0,react.useContext)(PathContext);

  if (path.length === 0 && "production" === 'development') {}

  const parentId = path[path.length - 1];
  const gamepadValue = gamepadFacet.get();

  if (gamepadValue !== react_facet_src.NO_VALUE && !gamepadValue.disabled) {
    focusTreeAPIRef.current.putShortcut(parentId, gamepadValue.button, {
      callback,
      inputLegend: gamepadValue.inputLegend
    });
  } // @TODO global


  (0,react_facet_src.useFacetEffect)(gamepad => {
    const parentId = path[path.length - 1];

    if (!gamepad.disabled) {
      const focusTreeAPI = focusTreeAPIRef.current;
      focusTreeAPI.putShortcut(parentId, gamepad.button, {
        callback,
        inputLegend: gamepad.inputLegend
      });
      return () => {
        focusTreeAPI.removeShortcut(parentId, gamepad.button);
      };
    }
  }, [callback, focusTreeAPIRef, path], [gamepadFacet]);
}
;// CONCATENATED MODULE: ./packages/react-gamepad-visual/src/components/LandmarkShortcut.tsx

function LandmarkShortcut({
  options,
  onClick
}) {
  useShortcut_useShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/GlobalShortcut.tsx




function GlobalShortcut_GlobalShortcut(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(GlobalShortcut, props);
  }

  return /*#__PURE__*/react.createElement(LandmarkShortcut, props);
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/Column.tsx



function ColumnLegacy({
  options,
  children,
  scrollRef
}) {
  const gamepadAdapterVersion = (0,react.useContext)(gamepadAdapterContext);

  if (gamepadAdapterVersion.version === GamepadAdapterVersion.VISUAL) {
    return /*#__PURE__*/react.createElement(react.Fragment, null, children);
  }

  return /*#__PURE__*/react.createElement(ColumnLegacyInternal, {
    options: options,
    scrollRef: scrollRef
  }, children);
}
function ColumnLegacyInternal({
  options,
  children,
  scrollRef
}) {
  const Column = useColumn(options, scrollRef);
  return /*#__PURE__*/react.createElement(Column, null, children);
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/NarrationContext.tsx
function NarrationContext_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NarrationContext_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function NarrationContext_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const NarrationContext_noopString = () => '';

const NarrationContext_NarrationContext = (_ref) => {
  let {
    children,
    shouldSkipParent = []
  } = _ref,
      props = NarrationContext_objectWithoutProperties(_ref, ["children", "shouldSkipParent"]);

  const textFacet = (0,react_facet_src.useFacetWrap)('text' in props ? props.text : '');
  const idFacet = (0,react_facet_src.useFacetWrap)('id' in props ? props.id : '');
  const getText = 'getText' in props ? props.getText : NarrationContext_noopString;
  const {
    narrationPutNode,
    narrationPutNodeWithIdAndCallback
  } = useNarrationPutNode();
  const [fullPathNarrationId, setFullPathNarrationId] = (0,react_facet_src.useFacetState)('');
  const unObserve = (0,react.useRef)();
  (0,react.useMemo)(() => {
    var _unObserve$current;

    (_unObserve$current = unObserve.current) === null || _unObserve$current === void 0 ? void 0 : _unObserve$current.call(unObserve);
    unObserve.current = (0,react_facet_src.multiObserve)((text, id) => {
      if (id != null && id !== '') {
        setFullPathNarrationId(narrationPutNodeWithIdAndCallback(id, getText, shouldSkipParent));
      } else {
        setFullPathNarrationId(narrationPutNode(text, shouldSkipParent));
      }
    }, [textFacet, idFacet]);
  }, [textFacet, idFacet, getText, narrationPutNode, narrationPutNodeWithIdAndCallback, shouldSkipParent, setFullPathNarrationId]);
  (0,react.useEffect)(() => () => {
    var _unObserve$current2;

    (_unObserve$current2 = unObserve.current) === null || _unObserve$current2 === void 0 ? void 0 : _unObserve$current2.call(unObserve);
  }, []);
  return /*#__PURE__*/react.createElement(NarrationContextProvider, {
    value: fullPathNarrationId
  }, children);
};
;// CONCATENATED MODULE: ./packages/ui/src/Modal/Modal.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Modal_Modal = ({"container":"icsZi","hide":"yLSeP","textContent":"qXm9P","paragraphsWrapper":"MHiRD","paragraphPadding":"Q3Zed","wordWrap":"BPMWS","centerText":"ZWBi0","listTextContent":"kxZXz","contentScrollable":"GHU0b","buttons":"kc2Fb","buttonsHorizontal":"IVSIi","wrapper":"UvzEX","overlay":"VT1Tw","progress":"OGKKM","spinner":"YkW5u"});
;// CONCATENATED MODULE: ./packages/ui/src/Typography/Typography.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Typography_Typography = ({"center":"IaGhJ","right":"XEoek","left":"W1NXQ","verticalCenter":"JEzgR","Typography":"OIwR8","header1":"jtuPO","header2":"ZSfsQ","header3":"jxr27","header4A":"B6E4l","header4B":"Iu9d0","header5A":"u3V3F","header5B":"Z9bmJ","sectionHeader":"kjlCa","subtitle1":"PyPJl","subtitle2":"gVtt_","body":"vNlW4","paragraphs":"NQiUU","captionTiny":"UNxMi","captionShort":"_He_E","captionLong":"yhCRL","editorCaption":"UwZQy","editorHeader":"X2EMQ","primaryButton":"l6rf0","secondaryButton":"vWcLh","destructiveButton":"P1L1T","shadow":"MIuXl","fontWeightNormal":"RcOKE","fontWeightBold":"j4N5u","fontWeightBolder":"g8JjQ","fontWeightLighter":"uN1hk","fontWeightInitial":"qKtfZ","fontWeightInherit":"EDaTS","whiteSpaceNormal":"JbbH7","whiteSpaceNoWrap":"dI4g4","whiteSpacePre":"wbZka","whiteSpacePreWrap":"_FWvz"});
;// CONCATENATED MODULE: ./packages/minecraft-formatting-codes-renderer/src/tokens.ts
let Style;

(function (Style) {
  Style[Style["REGULAR"] = 0] = "REGULAR";
  Style[Style["OBFUSCATED"] = 1] = "OBFUSCATED";
})(Style || (Style = {}));

const OBFUSCATED_CODE = '§k';
const tokens_styles = {
  [OBFUSCATED_CODE]: Style.OBFUSCATED
};
const colors = {
  '§0': {
    foreground: '#000000',
    background: '#000000'
  },
  '§1': {
    foreground: '#0000AA',
    background: '#00002A'
  },
  '§2': {
    foreground: '#00AA00',
    background: '#002A00'
  },
  '§3': {
    foreground: '#00AAAA',
    background: '#002A2A'
  },
  '§4': {
    foreground: '#AA0000',
    background: '#2A0000'
  },
  '§5': {
    foreground: '#AA00AA',
    background: '#2A002A'
  },
  '§6': {
    foreground: '#FFAA00',
    background: '#402A00'
  },
  '§7': {
    foreground: '#AAAAAA',
    background: '#2A2A2A'
  },
  '§8': {
    foreground: '#555555',
    background: '#151515'
  },
  '§9': {
    foreground: '#5555FF',
    background: '#15153F'
  },
  '§a': {
    foreground: '#55FF55',
    background: '#153F15'
  },
  '§b': {
    foreground: '#55FFFF',
    background: '#153F3F'
  },
  '§c': {
    foreground: '#FF5555',
    background: '#3F1515'
  },
  '§d': {
    foreground: '#FF55FF',
    background: '#3F153F'
  },
  '§e': {
    foreground: '#FFFF55',
    background: '#3F3F15'
  },
  '§f': {
    foreground: '#FFFFFF',
    background: '#3F3F3F'
  },
  '§g': {
    foreground: '#DDD605',
    background: '#373501'
  },
  '§h': {
    foreground: '#E3D4D1',
    background: '#383534'
  },
  '§i': {
    foreground: '#CECACA',
    background: '#333232'
  },
  '§j': {
    foreground: '#443A3B',
    background: '#110E0E'
  },
  '§m': {
    foreground: '#971607',
    background: '#250501'
  },
  '§n': {
    foreground: '#B4684D',
    background: '#2D1A13'
  },
  '§p': {
    foreground: '#DEB12D',
    background: '#372C0B'
  },
  '§q': {
    foreground: '#47A036',
    background: '#04280D'
  },
  '§s': {
    foreground: '#2CBAA8',
    background: '#0B2E2A'
  },
  '§t': {
    foreground: '#21497B',
    background: '#08121E'
  },
  '§u': {
    foreground: '#9A5CC6',
    background: '#261731'
  }
};
;// CONCATENATED MODULE: ./packages/minecraft-formatting-codes-renderer/src/index.ts

const CODE_RESET = '§r';
const CODE_BOLD = '§l';
const CODE_ITALIC = '§o'; // In Gameface we need the regular expression with the 'g' for replace to replace multiple occurrences.
// Please re-test on the game if this is changed.

const UNSUPPORTED_CODES = new RegExp(`(${CODE_BOLD})|(${CODE_ITALIC})`, 'g');

const obfuscate = (text, start, end) => {
  let newString = '';

  for (let index = 0; index < text.length; index++) {
    // ignores the two characters that started the obfuscation
    if (index >= start && index < start + 2) continue;
    newString += index >= start && index < end ? '.' : text[index];
  }

  return newString;
};

const removeUnsupportedFormatting = text => {
  return text.replace(UNSUPPORTED_CODES, '');
};

/**
 * Takes a string and a root HTML paragraph that will be used as a container for the formatted elements
 * @param text
 * @param root paragraph element
 * @returns cleanup function that removes all rendered elements from the root
 */
const renderMinecraftFormattingCodes = (text, root) => {
  // flag used to optimize most cases where there is no formatting in the text
  let unformatted = true; // flag to preemptively track unsupported codes, so we only try to remove them if needed

  let hasUnsupportedFormattingCodes = false; // current styles pending rendering

  let obfuscated = false;
  let currentColor = [0, null]; // list of DOM nodes that must be removed on cleanup

  const domNodes = [];

  const renderCurrentColor = index => {
    const [startIndex, color] = currentColor;
    let substring = text.slice(startIndex, index);

    if (hasUnsupportedFormattingCodes) {
      substring = removeUnsupportedFormatting(substring);
    }

    if (substring.length !== 0) {
      substring = obfuscated != false ? obfuscate(substring, obfuscated - startIndex, substring.length) : substring;

      if (color != null) {
        const colorElement = document.createElement('span');
        colorElement.style.color = color.foreground;
        colorElement.style.textShadow = `0.2rem 0.2rem 0rem ${color.background}`;
        colorElement.appendChild(document.createTextNode(substring));
        root.appendChild(colorElement);
        domNodes.push(colorElement);
      } else {
        const textElement = document.createTextNode(substring);
        root.appendChild(textElement);
        domNodes.push(textElement);
      }
    }

    hasUnsupportedFormattingCodes = false;
  };
  /**
   * The implementation works by going through every character in the string, looking for formatting codes
   * and then keeping track of the current color format to be applied once we switched to a new format or reset.
   */


  for (let index = 0; index < text.length; index++) {
    const char = text[index];
    const code = `${char}${text[index + 1]}`;
    const newColor = colors[code];

    if (newColor != null) {
      renderCurrentColor(index);
      index += 1;
      currentColor = [index + 1, newColor];
      unformatted = false;
    }

    if (code === OBFUSCATED_CODE) {
      obfuscated = index;
      index += 1;
      unformatted = false;
    }

    if (code === CODE_RESET) {
      renderCurrentColor(index);
      index += 1;
      currentColor = [index + 1, null];
      obfuscated = false;
      unformatted = false;
    }

    if (code === CODE_BOLD || code === CODE_ITALIC) {
      hasUnsupportedFormattingCodes = true;
      unformatted = false;
    }
  } // optimization to just create a simple text node if no formatting was found in the text


  if (unformatted) {
    const textElement = document.createTextNode(text);
    root.appendChild(textElement);
    domNodes.push(textElement);
  } else {
    renderCurrentColor(text.length);
  }

  return () => {
    domNodes.forEach(node => {
      root.removeChild(node);
    });
  };
};
;// CONCATENATED MODULE: ./packages/ui/src/Typography/Typography.tsx
function Typography_extends() { Typography_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Typography_extends.apply(this, arguments); }








const ALL_TYPOGRAPHY_TYPES = (/* unused pure expression or super */ null && (['header1', 'header2', 'header3', 'header4A', 'header4B', 'header5A', 'header5B', 'paragraphs', 'primaryButton', 'secondaryButton', 'captionTiny', 'captionShort', 'captionLong', 'subtitle1', 'subtitle2', 'body', 'destructiveButton', 'editorCaption', 'editorHeader']));
let FontWeight;

(function (FontWeight) {
  FontWeight[FontWeight["Normal"] = 0] = "Normal";
  FontWeight[FontWeight["Bold"] = 1] = "Bold";
  FontWeight[FontWeight["Bolder"] = 2] = "Bolder";
  FontWeight[FontWeight["Lighter"] = 3] = "Lighter";
  FontWeight[FontWeight["Initial"] = 4] = "Initial";
  FontWeight[FontWeight["Inherit"] = 5] = "Inherit";
})(FontWeight || (FontWeight = {}));

const FONT_WEIGHT_STYLES = {
  [FontWeight.Normal]: [Typography_Typography.fontWeightNormal],
  [FontWeight.Bold]: [Typography_Typography.fontWeightBold],
  [FontWeight.Bolder]: [Typography_Typography.fontWeightBolder],
  [FontWeight.Lighter]: [Typography_Typography.fontWeightLighter],
  [FontWeight.Initial]: [Typography_Typography.fontWeightInitial],
  [FontWeight.Inherit]: [Typography_Typography.fontWeightInherit]
};
const WHITE_SPACE_STYLES = {
  normal: [Typography_Typography.whiteSpaceNormal],
  nowrap: [Typography_Typography.whiteSpaceNoWrap],
  pre: [Typography_Typography.whiteSpacePre],
  preWrap: [Typography_Typography.whiteSpacePreWrap]
};
function Typography_Typography_Typography({
  children,
  role = 'inherit',
  interactive,
  disableable,
  variant,
  align,
  verticalAlign = 'top',
  type,
  shadow,
  tag,
  fontWeight,
  shouldNarrate,
  whiteSpace,
  innerRef
}) {
  const alignFacet = (0,react_facet_src.useFacetWrap)(align);
  const shadowFacet = (0,react_facet_src.useFacetWrap)(shadow);
  const typeFacet = (0,react_facet_src.useFacetWrap)(type);
  const verticalAlignFacet = (0,react_facet_src.useFacetWrap)(verticalAlign);
  const fontWeightFacet = (0,react_facet_src.useFacetWrap)(fontWeight);
  const whiteSpaceFacet = (0,react_facet_src.useFacetWrap)(whiteSpace);
  const roleFacet = (0,react_facet_src.useFacetWrap)(role);
  const variantFacet = (0,react_facet_src.useFacetWrap)(variant);
  const interactiveFacet = (0,react_facet_src.useFacetWrap)(interactive);
  const disableableFacet = (0,react_facet_src.useFacetWrap)(disableable);
  const pseudoSelectorsFacet = (0,react_facet_src.useFacetMap)((interactive, disableable) => {
    if (interactive === true) {
      return [INTERACTIVE];
    }

    const pseudoSelectors = [BASE];

    if (disableable) {
      pseudoSelectors.push(DISABLE);
    }

    return pseudoSelectors;
  }, [], [interactiveFacet, disableableFacet]);
  const semanticColors = hooks_useSemanticColors();
  const Element = tag ? tag : type === 'paragraphs' ? 'p' : 'div';
  const classNameFacet = (0,react_facet_src.useFacetMap)((shadow, align, type, verticalAlign, fontWeight, whiteSpace, role, variant, pseudoSelectors) => {
    // These classnames are used explicitly
    // for stylelint plugin/no-unused-selectors static check
    const typeStyle = type ? Typography_Typography[type] : undefined;
    const alignStyle = {
      [Typography_Typography.center]: align === 'center',
      [Typography_Typography.right]: align === 'right',
      [Typography_Typography.left]: align === 'left',
      [Typography_Typography.verticalCenter]: verticalAlign === 'center'
    };
    const fontWeightStyle = fontWeight ? FONT_WEIGHT_STYLES[fontWeight] : undefined;
    const whiteSpaceStyle = whiteSpace ? WHITE_SPACE_STYLES[whiteSpace] : undefined;
    const shadowStyle = {
      [Typography_Typography.shadow]: shadow
    };
    const semanticTextColors = pseudoSelectors.map(pseudo => semanticColors[role].text[pseudo]);
    return classnames_default()(Typography_Typography.Typography, typeStyle, alignStyle, shadowStyle, fontWeightStyle, whiteSpaceStyle, semanticTextColors, variant);
  }, [semanticColors], [shadowFacet, alignFacet, typeFacet, verticalAlignFacet, fontWeightFacet, whiteSpaceFacet, roleFacet, variantFacet, pseudoSelectorsFacet]);
  const narrateProps = shouldNarrate === true ? {
    ['data-narrate']: true
  } : {};

  if ((0,react_facet_src.isFacet)(children)) {
    if (Element === 'div') {
      return /*#__PURE__*/react.createElement("fast-div", Typography_extends({
        ref: innerRef,
        className: classNameFacet
      }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
        text: children
      }));
    }

    if (Element === 'p') {
      return /*#__PURE__*/react.createElement("fast-p", Typography_extends({
        ref: innerRef,
        className: classNameFacet
      }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
        text: children
      }));
    }

    return /*#__PURE__*/react.createElement("fast-span", Typography_extends({
      ref: innerRef,
      className: classNameFacet
    }, narrateProps), /*#__PURE__*/react.createElement("fast-text", {
      text: children
    }));
  }

  if (Element === 'div') {
    return /*#__PURE__*/react.createElement("fast-div", Typography_extends({
      ref: innerRef,
      className: classNameFacet
    }, narrateProps), children);
  }

  if (Element === 'p') {
    return /*#__PURE__*/react.createElement("fast-p", Typography_extends({
      ref: innerRef,
      className: classNameFacet
    }, narrateProps), children);
  }

  return /*#__PURE__*/react.createElement("fast-span", Typography_extends({
    ref: innerRef,
    className: classNameFacet
  }, narrateProps), children);
}

const TypographyList = ({
  items
}) => {
  const itemsFacet = (0,react_facet_src.useFacetWrap)(items);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: itemsFacet
  }, (item, index) => {
    return /*#__PURE__*/react.createElement(TypographyListInner, {
      items: itemsFacet,
      item: item,
      index: index
    });
  }));
};

const TypographyListInner = ({
  items,
  item,
  index
}) => {
  const showSpacing = (0,react_facet_src.useFacetMap)(items => items.length - 1 !== index, [index], [items]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(TypographyListItem, {
    text: item
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSpacing
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
};

const TypographyListItem = ({
  text
}) => {
  const textWithBullet = (0,react_facet_src.useFacetMap)(text => `• ${text}`, [], [text]);
  return /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    align: "left"
  }, textWithBullet);
};
/**
 * Supports Minecraft Formatting Codes
 * https://minecraft.fandom.com/wiki/Formatting_codes
 */


const TypographyFormattingCodes = ({
  children,
  type,
  shadow,
  align
}) => {
  const ref = (0,react.useRef)(null);
  (0,react_facet_src.useFacetEffect)(text => {
    const element = ref.current;
    if (element == null) return; // https://docs.coherent-labs.com/cpp-gameface/what_is_gfp/htmlfeaturesupport/#experimental-inline-layout-for-paragraph-elements

    element.setAttribute('cohinline', '');
    return renderMinecraftFormattingCodes(`${text}`, element);
  }, [], [(0,react_facet_src.useFacetWrap)(children)]);
  return /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: type,
    shadow: shadow,
    align: align,
    innerRef: ref,
    tag: "p"
  });
};

Typography_Typography_Typography.FontWeight = FontWeight;
Typography_Typography_Typography.List = TypographyList;
Typography_Typography_Typography.FormattingCodes = TypographyFormattingCodes;
;// CONCATENATED MODULE: ./packages/ui/src/Checkbox/Checkbox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Checkbox = ({"Checkbox":"tIO8N","main":"jw1g3","textWrapper":"GSYTw","small":"sSJaW","description":"vEsZy"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/images/checkGrey.png
const checkGrey_namespaceObject = __webpack_require__.p + "assets/checkGrey-a9d8c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/IconCheckGrey.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCheckGrey = ({"iconCheckGrey":"SBc3u"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckGrey/IconCheckGrey.tsx
function IconCheckGrey_extends() { IconCheckGrey_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconCheckGrey_extends.apply(this, arguments); }

function IconCheckGrey_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconCheckGrey_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconCheckGrey_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconCheckGrey_IconCheckGrey = (_ref) => {
  let {
    className
  } = _ref,
      props = IconCheckGrey_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconCheckGrey.iconCheckGrey, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconCheckGrey_extends({}, props, {
    className: classNames,
    src: checkGrey_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/images/checkWhite.png
const checkWhite_namespaceObject = __webpack_require__.p + "assets/checkWhite-bcfbf.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/IconCheckWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCheckWhite = ({"iconCheckWhite":"ycpq0"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCheckWhite/IconCheckWhite.tsx
function IconCheckWhite_extends() { IconCheckWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconCheckWhite_extends.apply(this, arguments); }

function IconCheckWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconCheckWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconCheckWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconCheckWhite_IconCheckWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconCheckWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconCheckWhite.iconCheckWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconCheckWhite_extends({}, props, {
    className: classNames,
    src: checkWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseCheckbox/BaseCheckbox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseCheckbox = ({"box":"r3OGg","boxCheck":"em21X","boxDisabled":"h2XVN"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseCheckbox/BaseCheckbox.tsx









function BaseCheckbox_BaseCheckbox({
  value,
  disabled,
  gamepad,
  narrationText,
  onClick,
  soundEffectPressed,
  checkedRole = 'primary',
  uncheckedRole = 'neutral50'
}) {
  const semanticColorsChecked = hooks_useSemanticColors(checkedRole);
  const semanticColorsUnchecked = hooks_useSemanticColors(uncheckedRole);
  const semanticSounds = useSemanticSounds('inherit');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const onClickHandler = (0,react_facet_src.useFacetCallback)(value => () => onClick === null || onClick === void 0 ? void 0 : onClick(!value), [onClick], [valueFacet]);
  const boxClassName = (0,react_facet_src.useFacetMap)(value => {
    return classnames_default()(BaseCheckbox.box, value ? [semanticColorsChecked.background.interactive, semanticColorsChecked.border.interactive] : [semanticColorsUnchecked.background.interactive, semanticColorsUnchecked.border.interactive]);
  }, [semanticColorsChecked, semanticColorsUnchecked], [valueFacet]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    narrationText: narrationText,
    isInteractive: typeof onClick === 'function',
    gamepadIndex: gamepad.index,
    classNameFocused: focusClass,
    classNameDisabled: BaseCheckbox.boxDisabled,
    disabled: disabled,
    onClick: onClickHandler,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: boxClassName
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    disabled: disabled
  }), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    disabled: disabled
  }), /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(value => value ? 'flex' : 'none', [], [valueFacet])
    },
    className: BaseCheckbox.boxCheck
  }, /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(disabled => disabled ? 'flex' : 'none', [], [disabledFacet])
    }
  }, /*#__PURE__*/react.createElement(IconCheckGrey_IconCheckGrey, null)), /*#__PURE__*/react.createElement("fast-div", {
    style: {
      display: (0,react_facet_src.useFacetMap)(disabled => !disabled ? 'flex' : 'none', [], [disabledFacet])
    }
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null)))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Checkbox/Checkbox.tsx











const Checkbox_noop = () => {};

function Checkbox_Checkbox({
  gamepad,
  onChange = Checkbox_noop,
  value,
  title,
  description,
  disabled,
  small = false,
  soundEffectPressed,
  wrapperRole = 'neutral'
}) {
  const semanticColors = hooks_useSemanticColors(wrapperRole);
  const semanticSounds = useSemanticSounds(wrapperRole);
  const titleFacet = (0,react_facet_src.useFacetWrap)(title);
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description !== null && description !== void 0 ? description : '');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const onClick = (0,react_facet_src.useFacetCallback)(value => () => onChange(!value), [onChange], [valueFacet]);
  const {
    t
  } = useLocalization_useLocalization('Checkbox');
  const narrationText = (0,react_facet_src.useFacetMap)((value, title, description) => [t('.elementType'), title, description, value ? t('.labelChecked') : t('.labelUnChecked')].join(' . '), [t], [valueFacet, titleFacet, descriptionFacet]);
  const className = (0,react_facet_src.useFacetWrap)(classnames_default()(Checkbox.Checkbox, semanticColors.background.base, {
    [Checkbox.small]: small
  }));
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: wrapperRole
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: className,
    inputLegend: t('.toggle'),
    gamepadIndex: gamepad.index,
    onClick: onClick,
    disabled: disabledFacet,
    narrationText: narrationText,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle,
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: wrapperRole,
    effect: "bevel",
    left: false,
    right: false
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: Checkbox.main
  }, /*#__PURE__*/react.createElement(BaseCheckbox_BaseCheckbox, {
    value: valueFacet,
    narrationText: false,
    disabled: disabledFacet,
    gamepad: gamepad
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Checkbox.textWrapper)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: wrapperRole // Setting text to sub role dimmer when disabled is not ideal, but is needed in order to retro fit the semantic tokens
    ,
    variant: (0,react_facet_src.useFacetMap)(disabled => disabled ? 'dimmer' : undefined, [], [disabledFacet])
  }, titleFacet), Boolean(description) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Checkbox.description)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: wrapperRole,
    variant: "dimmer"
  }, descriptionFacet)))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
}
;// CONCATENATED MODULE: ./packages/react-gamepad-legacy/src/ParentShortcut.tsx

function ParentShortcut({
  options,
  onClick
}) {
  useParentShortcut(options, onClick);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-gamepad/src/ParentShortcut.tsx




function ParentShortcut_ParentShortcut(props) {
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return /*#__PURE__*/react.createElement(ParentShortcut, props);
  }

  return /*#__PURE__*/react.createElement(LandmarkShortcut, props);
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/images/magnifyingGlass.png
const magnifyingGlass_namespaceObject = __webpack_require__.p + "assets/magnifyingGlass-52f96.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/IconMagnifyingGlass.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconMagnifyingGlass = ({"iconMagnifyingGlass":"TmKO0"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconMagnifyingGlass/IconMagnifyingGlass.tsx
function IconMagnifyingGlass_extends() { IconMagnifyingGlass_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconMagnifyingGlass_extends.apply(this, arguments); }

function IconMagnifyingGlass_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconMagnifyingGlass_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconMagnifyingGlass_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconMagnifyingGlass_IconMagnifyingGlass = (_ref) => {
  let {
    className
  } = _ref,
      props = IconMagnifyingGlass_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconMagnifyingGlass.iconMagnifyingGlass, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconMagnifyingGlass_extends({}, props, {
    className: classNames,
    src: magnifyingGlass_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-primitive/src/EllipsisPrimitive/EllipsisPrimitive.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const EllipsisPrimitive_EllipsisPrimitive = ({"ellipsis":"nTLvV","browser":"tkVAm"});
;// CONCATENATED MODULE: ./packages/ui-primitive/src/EllipsisPrimitive/EllipsisPrimitive.tsx




const EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive = ({
  children,
  innerRef,
  className
}) => {
  if ((0,react_facet_src.isFacet)(children)) {
    return /*#__PURE__*/react.createElement("fast-div", {
      ref: innerRef,
      className: classnames_default()(EllipsisPrimitive_EllipsisPrimitive.ellipsis,  false ? 0 : '', className)
    }, /*#__PURE__*/react.createElement("fast-text", {
      text: children
    }));
  }

  return /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: classnames_default()(EllipsisPrimitive_EllipsisPrimitive.ellipsis,  false ? 0 : '', className)
  }, children);
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/InputChangesOverride/InputChangesOverride.ts

const InputChangesOverride_context = (0,react.createContext)(null);
const useInputChangesOverride = () => (0,react.useContext)(InputChangesOverride_context);
const InputChangesOverrideProvider = InputChangesOverride_context.Provider;
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const component_BaseTextField = ({"textFieldWrapper":"ZyW_9","textField":"d9dd2","textFieldWrapperShadow":"oC3bl","textFieldBrowserOnly":"PZ6ir","textFieldType":"uHy0P","textFieldPlaceholder":"YuTSL","textFieldTextArea":"DYvK2","disabled":"ezdmG","placeholderAdjustedWithIcon":"_08EUe","textFieldContentWrapper":"v2fnz","textFieldIcon":"b4wn_","textFieldClearInteractive":"mHHfZ"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseTextField/component/BaseTextField.tsx














let BaseTextField_PlaceholderIcon;

(function (PlaceholderIcon) {
  PlaceholderIcon[PlaceholderIcon["MagnifyingGlass"] = 0] = "MagnifyingGlass";
})(BaseTextField_PlaceholderIcon || (BaseTextField_PlaceholderIcon = {}));

const getPlaceholderIcon = placeholderIcon => {
  switch (placeholderIcon) {
    case BaseTextField_PlaceholderIcon.MagnifyingGlass:
      return /*#__PURE__*/react.createElement(IconMagnifyingGlass_IconMagnifyingGlass, null);

    default:
      return /*#__PURE__*/react.createElement(IconMagnifyingGlass_IconMagnifyingGlass, null);
  }
};

function BaseTextField_BaseTextField(props) {
  const {
    autofocus,
    gamepadAlias,
    gamepadIndex,
    value,
    disabled = false,
    label,
    className,
    // We set the default maxLength value to 32000 as this is the maximum number of characters that the user can enter in the virtual keyboard on Xbox
    // https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/reference/system/xgameui/functions/xgameuitextentryopen
    maxLength,
    narrationText,
    onBlur,
    onFocus,
    onHover,
    onKeyDown,
    onKeyUp,
    onChange,
    onSelectedChange,
    placeholder = '',
    rows = 1,
    shouldBlurOnEnter,
    shouldBlurOnEscape,
    onTab,
    isNumber,
    placeholderIcon,
    showClearOptionWhenValueExists,
    onClear,
    hasShadow = true,
    role = 'neutral80'
  } = props;
  const {
    t
  } = useLocalization_useLocalization('BaseTextField');
  const [isFocusedFacet, setIsFocusedFacet] = (0,react_facet_src.useFacetState)(false);
  const [isSelectedFacet, setIsSelectedFacet] = (0,react_facet_src.useFacetState)(false);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledValue = (0,react_facet_src.useFacetUnwrap)(disabled);
  const {
    narrateText,
    preventNarrateText
  } = useNarrateText_useNarrateText();
  const stateOverrideFacet = (0,react_facet_src.useFacetWrap)(useInputStateOverride());
  const inputChangesOverride = useInputChangesOverride();
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const inputTypeFacet = (0,react_facet_src.useFacetMap)(isNumber => isNumber ? 'number' : 'text', [], [(0,react_facet_src.useFacetWrap)(isNumber)]);
  const autofocusRef = (0,react.useRef)(autofocus);
  const semanticColors = hooks_useSemanticColors(role);
  const variants = useSemanticVariants();
  const ref = (0,react.useRef)(null);
  const previousFocusState = (0,react.useRef)(false); // When the TextField becomes focused the role and text field label should be read as a hint

  (0,react_facet_src.useFacetEffect)((focused, label) => {
    // The ref is used to prevent the narrateText to fire on every char entry on touch
    // The software keyboard loses and regains focus for each char, triggering this effect again and again
    if (focused && !previousFocusState.current) {
      previousFocusState.current = true;
      narrateText(`${t('.selected')} . ${t('.hint', [`${label}`])}`);
    } else if (!focused) {
      previousFocusState.current = false;
    }
  }, [narrateText, t], [isFocusedFacet, (0,react_facet_src.useFacetWrap)(label !== null && label !== void 0 ? label : '')]);
  (0,react.useEffect)(() => {
    if (!ref.current) return;

    if (autofocusRef.current) {
      ref.current.focus();
    }
  }, []);
  const onKeyboardEvent = useKeyboardEventCallbacks();
  const handleGlobalChange = (0,react.useCallback)(inputChanges => {
    if (ref.current && document.activeElement === ref.current) {
      const narration = inputChangesToNarration(ref.current.value, inputChanges !== null && inputChanges !== void 0 ? inputChanges : inputChangesOverride, t);
      preventNarrateText();

      if (narration != null) {
        narrateText(narration);
      }

      onChange && onChange(ref.current.value, inputChanges !== null && inputChanges !== void 0 ? inputChanges : inputChangesOverride);
    }
  }, [onChange, inputChangesOverride, narrateText, t, preventNarrateText]);
  const handleTab = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      onTab && onTab();
    }
  }, [onTab]);
  const handleSelected = (0,react.useCallback)(selected => {
    setIsSelectedFacet(selected);
    onSelectedChange && onSelectedChange(selected);
  }, [setIsSelectedFacet, onSelectedChange]);
  const handleBlur = (0,react.useCallback)(reselect => {
    if (ref.current) {
      setIsFocusedFacet(false);

      if (onBlur != null) {
        // This handler sets the value of the text field, both by manipulating the dom and by calling the onChange handler.
        // This is unfortunately currently needed since the virtual keyboard integration sets the value of the dom element
        // directly when submitting a value. If we would in a validation in the onBlur handler have used a setter of the facet
        // holding the current value instead, then setting it back to the current facet value would not trigger a change and
        // the input would keep the invalid value, even though the facet will have the correct value.
        const setValue = (newValue = '') => {
          if (ref.current) {
            ref.current.value = newValue;

            if (onChange != null) {
              onChange(newValue, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange());
            }
          }
        };

        onBlur(ref.current.value, setValue);
      }

      if (Boolean(reselect)) {
        handleSelected(true);
      } else {
        handleSelected(false);
      }
    }
  }, [onBlur, setIsFocusedFacet, handleSelected, onChange, inputChangesOverride]);
  const handleDismissed = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      ref.current.blur();
      handleBlur(true);
    }
  }, [handleBlur]);
  const handleSubmit = (0,react.useCallback)(() => {
    if (ref.current && document.activeElement === ref.current) {
      handleDismissed();
    }
  }, [handleDismissed]);
  (0,react.useEffect)(() => {
    if (!onKeyboardEvent) return;
    const cleanupCallbacks = [onKeyboardEvent.changedCB(handleGlobalChange), onKeyboardEvent.tabbedCB(handleTab), onKeyboardEvent.submittedCB(handleSubmit), onKeyboardEvent.dismissedCB(handleDismissed)];
    return () => {
      cleanupCallbacks.forEach(cb => cb());
    };
  }, [onKeyboardEvent, handleGlobalChange, handleDismissed, handleTab, handleSubmit]);
  const handleClick = (0,react.useCallback)(() => {
    if (!ref.current) return;
    ref.current.focus();
  }, []);
  const handleKeyUp = (0,react.useCallback)(event => {
    onKeyUp && onKeyUp(event); // Don't prevent narration if the user is initially focusing the field

    if (!previousFocusState.current) {
      if ('target' in event) {
        const narration = inputChangesToNarration(event.target.value, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange(), t);
        preventNarrateText();

        if (narration != null) {
          narrateText(narration);
        }
      }
    }

    onChange && onChange(event.target.value, inputChangesOverride !== null && inputChangesOverride !== void 0 ? inputChangesOverride : createEmptyTextInputChange());
  }, [onChange, onKeyUp, inputChangesOverride, t, narrateText, preventNarrateText]);
  const inputClassName = (0,react_facet_src.useFacetMap)((isFocused, isSelected, stateOverride, classNameValue) => {
    return classnames_default()(component_BaseTextField.textField, component_BaseTextField.textFieldType, semanticColors.border.interactive, semanticColors.text.interactive, semanticColors.caret.base, classNameValue, {
      [component_BaseTextField.textFieldBrowserOnly]: "gameface" === 'browser',
      [component_BaseTextField.textFieldFocused]: stateOverride && stateOverride.focused || isFocused,
      [component_BaseTextField.disabled]: disabledValue,
      [component_BaseTextField.textFieldTextArea]: rows > 1
    });
  }, [disabledValue, rows, semanticColors], [isFocusedFacet, isSelectedFacet, stateOverrideFacet, classNameFacet]);
  const focusedClass = (0,react_facet_src.useFacetMap)((isFocused, isSelected, stateOverride) => {
    return classnames_default()({
      [focusClass]: stateOverride && stateOverride.focused || isSelected && !isFocused
    });
  }, [], [isFocusedFacet, isSelectedFacet, stateOverrideFacet]);
  const handleKeyDown = (0,react.useCallback)(event => {
    if (!ref.current) return;

    if (event.keyCode === KeyboardKey.ESCAPE && document.activeElement === ref.current) {
      if (shouldBlurOnEscape) {
        // Deselect on ESCAPE key down as in legacy Bedrock fields
        ref.current.blur();
        handleBlur(true);
        event.stopPropagation();
      }
    } else if (event.keyCode === KeyboardKey.ENTER && document.activeElement === ref.current && rows === 1) {
      if (shouldBlurOnEnter) {
        // Deselect on ENTER key down if not multiline as in legacy Bedrock fields
        // setTimeout is here to not let the gamepad click handler to refocus the field immediately
        setTimeout(() => {
          ref.current && ref.current.blur();
          handleBlur(true);
        }, 0);
        event.preventDefault();
      }
    }
  }, [rows, shouldBlurOnEnter, shouldBlurOnEscape, handleBlur]);
  const handleFocus = (0,react.useCallback)(() => {
    setIsFocusedFacet(true);
    onFocus && onFocus();
    handleSelected(true);
  }, [onFocus, setIsFocusedFacet, handleSelected]);
  const gamepadFacet = (0,react_facet_src.useFacetMap)(isFocused => ({
    button: types_ButtonType.B,
    inputLegend: t('.deselect'),
    disabled: !isFocused
  }), [t], [isFocusedFacet]);
  const isValueNotNullOrEmptyFacet = (0,react_facet_src.useFacetMap)(value => {
    return value != null && value !== '';
  }, [], [valueFacet]);
  const placeholderDisplay = (0,react_facet_src.useFacetMap)((value, isFocused) => {
    return (value == null || value === '') && !isFocused ? 'flex' : 'none';
  }, [], [valueFacet, isFocusedFacet]);
  const placeholderElement = /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(component_BaseTextField.textFieldType, component_BaseTextField.textFieldPlaceholder, semanticColors.text.interactive, variants.dimmest, {
      [component_BaseTextField.placeholderAdjustedWithIcon]: placeholderIcon != null
    }),
    style: {
      display: placeholderDisplay
    }
  }, placeholderIcon != null ? /*#__PURE__*/react.createElement("div", {
    className: component_BaseTextField.textFieldContentWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: component_BaseTextField.textFieldIcon
  }, getPlaceholderIcon(placeholderIcon)), /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, placeholder)) : /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, placeholder));
  const inputElement = rows > 1 ? /*#__PURE__*/react.createElement("fast-textarea", {
    ref: ref,
    rows: rows,
    className: inputClassName,
    maxLength: maxLength,
    value: valueFacet,
    onFocus: handleFocus,
    onKeyDown: onKeyDown,
    onKeyUp: handleKeyUp,
    onBlur: () => {
      handleBlur(false);
    }
  }) : /*#__PURE__*/react.createElement("fast-input", {
    ref: ref,
    type: inputTypeFacet,
    className: inputClassName,
    maxLength: maxLength,
    value: valueFacet,
    onFocus: handleFocus,
    onKeyDown: onKeyDown,
    onKeyUp: handleKeyUp,
    onBlur: () => {
      handleBlur(false);
    }
  });

  const content = () => {
    if (disabledValue !== react_facet_src.NO_VALUE && disabledValue) {
      return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
        className: classnames_default()(component_BaseTextField.textFieldWrapper, semanticColors.background.interactive, {
          [component_BaseTextField.disabled]: disabledValue
        }),
        "data-testid": props['data-testid'],
        key: "disabled",
        narrationText: narrationText,
        inputLegend: false,
        disabled: true,
        gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
        onFocusChanged: handleSelected,
        onKeyDown: handleKeyDown,
        onClick: handleClick,
        gamepadAlias: gamepadAlias
      }, /*#__PURE__*/react.createElement("div", {
        className: classnames_default()(hasShadow ? semanticColors.shadow.interactive : undefined, {
          [component_BaseTextField.textFieldWrapperShadow]: hasShadow
        })
      }), placeholderElement, /*#__PURE__*/react.createElement("fast-div", {
        className: inputClassName
      }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, valueFacet)));
    }

    return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      key: "enabled",
      className: classnames_default()(component_BaseTextField.textFieldWrapper, semanticColors.background.base, semanticColors.background.disable),
      "data-testid": props['data-testid'],
      narrationText: narrationText,
      gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
      inputLegend: t('.select'),
      onFocusChanged: handleSelected,
      classNameFocused: focusedClass,
      onKeyDown: handleKeyDown,
      onClick: handleClick,
      gamepadAlias: gamepadAlias,
      onHoverChanged: onHover
    }, /*#__PURE__*/react.createElement("div", {
      className: classnames_default()(hasShadow ? semanticColors.shadow.interactive : undefined, {
        [component_BaseTextField.textFieldWrapperShadow]: hasShadow
      })
    }), placeholderElement, inputElement, /*#__PURE__*/react.createElement(Focus_Focus, {
      role: role
    }), showClearOptionWhenValueExists && /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isValueNotNullOrEmptyFacet
    }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      className: component_BaseTextField.textFieldClearInteractive,
      gamepadIndex: 0,
      narrationText: false,
      inputLegend: '',
      onClick: () => onClear != null && onClear()
    }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null))));
  };

  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: gamepadFacet,
    onClick: () => {
      if (ref.current && document.activeElement === ref.current) {
        ref.current.blur();
        handleBlur(true);
      }
    }
  }), content());
}

const inputChangesToNarration = (value, inputChanges, t) => {
  const added = inputChanges.addedChars.split('').join(' ');
  const removed = inputChanges.removedChars.split('').join(' ');
  const invalid = inputChanges.invalidChars.split('').join(' ');
  const invalidText = invalid !== '' ? ` ${invalid} ${t('.invalidNarration')}` : '';
  const valueWithPause = value.length !== 0 ? ` . . ${value}` : '';

  if (added !== '') {
    if (removed !== '') {
      return `${removed} ${t('.replacedNarration')} ${added}${invalidText}${valueWithPause}`;
    }

    return `${added} ${t('.addedNarration')}${invalidText}${valueWithPause}`;
  }

  if (removed !== '') {
    return `${removed} ${t('.removedNarration')}${valueWithPause}`;
  }

  return null;
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/Panel.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Panel_Panel = ({"Panel":"eUpFO","compactPanel":"lMcuz","transparent":"oTQSA","panelFocus":"H7Hc9"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/Panel.tsx
function Panel_extends() { Panel_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Panel_extends.apply(this, arguments); }

function Panel_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Panel_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Panel_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }











function Panel_Panel_Panel(_ref) {
  let {
    children,
    isTransparent,
    compact = false,
    focusable = false,
    narrationText = false,
    inputLegend = false,
    shouldDisplayFocus = true,
    onClick,
    gamepadIndex,
    role = 'neutral',
    disabled
  } = _ref,
      rest = Panel_objectWithoutProperties(_ref, ["children", "isTransparent", "compact", "focusable", "narrationText", "inputLegend", "shouldDisplayFocus", "onClick", "gamepadIndex", "role", "disabled"]);

  const focusableFacet = (0,react_facet_src.useFacetWrap)(focusable);
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)(narrationText);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const {
    background
  } = hooks_useSemanticColors(role);
  const panelTokens = useSemanticComponentTokens('panel', role);
  const hasTexture = panelTokens.main.base != null;
  const isTransparentFacet = (0,react_facet_src.useFacetWrap)(isTransparent);
  const className = (0,react_facet_src.useFacetMap)(transparent => {
    return classnames_default()(Panel_Panel.Panel, {
      [Panel_Panel.transparent]: transparent,
      [Panel_Panel.compactPanel]: compact
    }, background.base, panelTokens.main.base, panelTokens.main.hover);
  }, [compact, background, panelTokens], [isTransparentFacet]);
  const classNameFocused = (0,react_facet_src.useFacetMap)(className => classnames_default()(className, focusClass), [], [className]);
  const content = /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, !compact && !hasTexture && /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    effect: "bevel",
    left: false,
    right: false
  }), !compact && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), children, !compact && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }));
  const isMountedFacet = (0,react_facet_src.useFacetMap)((focusable, narrationText, disabled) => onClick != null && disabled !== true || focusable === true && narrationText != null, [onClick], [focusableFacet, narrationTextFacet, disabledFacet]);
  const shouldNotDisplayFocusFacet = (0,react_facet_src.useFacetMap)(shouldDisplayFocus => !shouldDisplayFocus, [], [(0,react_facet_src.useFacetWrap)(shouldDisplayFocus)]);
  const narrationTextCleaned = (0,react_facet_src.useFacetMap)(narrationText => narrationText == false ? '' : narrationText, [], [narrationTextFacet]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationTextCleaned
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, Panel_extends({
    isInteractive: isMountedFacet,
    gamepadIndex: gamepadIndex,
    className: className,
    classNameFocused: classNameFocused,
    narrationText: false,
    inputLegend: inputLegend,
    onClick: onClick !== null && onClick !== void 0 ? onClick : Panel_noop
  }, rest), content, /*#__PURE__*/react.createElement(Focus_Focus, {
    className: Panel_Panel.panelFocus,
    interactive: false,
    disabled: shouldNotDisplayFocusFacet,
    role: role
  })));
}

function Panel_noop() {}
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelLabel.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Panel_PanelLabel = ({"panelLabel":"i_2FG"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelLabel.tsx





function PanelLabel_PanelLabel({
  children,
  disabled,
  role = 'inherit',
  className
}) {
  const {
    text
  } = hooks_useSemanticColors(role);
  const modifiers = useSemanticModifiers();
  const variants = useSemanticVariants();
  const childrenFacet = (0,react_facet_src.useFacetWrap)(children);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const classNameFacet = (0,react_facet_src.useFacetWrap)(className);
  const labelClassName = (0,react_facet_src.useFacetMap)((isDisabled, className) => // Setting text to sub role dimmer when disabled is not ideal, but is needed in order to retro fit the semantic tokens
  classnames_default()(Panel_PanelLabel.panelLabel, text.base, {
    [modifiers.disabled]: isDisabled,
    [variants.dimmer]: isDisabled
  }, className), [modifiers, text, variants], [disabledFacet, classNameFacet]);
  return /*#__PURE__*/react.createElement("fast-span", {
    className: labelClassName
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: childrenFacet
  }));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelDescription.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PanelDescription = ({"panelDescription":"rycle"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Panel/PanelDescription.tsx





const PanelDescription_PanelDescription = ({
  children,
  disabled,
  role = 'inherit'
}) => {
  const {
    text
  } = hooks_useSemanticColors(role);
  const variants = useSemanticVariants();
  const modifiers = useSemanticModifiers();
  const childrenFacet = (0,react_facet_src.useFacetWrap)(children);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const className = (0,react_facet_src.useFacetMap)(isDisabled => classnames_default()(PanelDescription.panelDescription, text.base, variants.dimmer, {
    [modifiers.disabled]: isDisabled
  }), [modifiers, text, variants], [disabledFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: className
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: childrenFacet
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWrapper.tsx




function TextFieldWrapper({
  disabled,
  label: labelFacet,
  description,
  children,
  gamepadIndex,
  transparent,
  disabledNarrationText
}) {
  const isNarrationEnabled = useNarrationEnabled();
  const panelIsFocusable = (0,react_facet_src.useFacetMap)(disabled => disabled && isNarrationEnabled, [isNarrationEnabled], [disabled]);
  const narrationText = (0,react_facet_src.useFacetMap)((disabled, disabledNarrationText) => disabled && disabledNarrationText ? disabledNarrationText : '', [], [disabled, (0,react_facet_src.useFacetWrap)(disabledNarrationText !== null && disabledNarrationText !== void 0 ? disabledNarrationText : '')]);
  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    focusable: panelIsFocusable,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    isTransparent: transparent,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, labelFacet), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, {
    disabled: disabled
  }, description));
}
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Button_Button = ({"labelContainer":"dGKbF","container":"Mc7_w","focused":"f98RG","elevated":"LtoW3","elevatedAndPressed":"fYLl1","image":"f84oF","imageWithChildren":"sdLtc"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pressable = ({"box":"ZFCMh","elevated":"gm_hk","elevatedAndPressed":"_63rL","horizontal":"z1z73","raised":"jUUof","boxBorder":"S54bt","shine":"NMcbo","shineText":"OdSfJ","bottomOffset":"h4_9h"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Pressable/Pressable.tsx
function Pressable_extends() { Pressable_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Pressable_extends.apply(this, arguments); }








function Pressable_BoxBorder(props) {
  const propsRef = (0,react.useRef)(props);
  propsRef.current = props;
  const className = classnames_default()(Pressable.box, Pressable.boxBorder, propsRef.current.className != null ? propsRef.current.className : undefined);
  const classNameFocused = classnames_default()(focusClass, propsRef.current.classNameFocused != null ? propsRef.current.classNameFocused : undefined);
  const classNameHovered = classnames_default()(propsRef.current.classNameHovered != null ? propsRef.current.classNameHovered : undefined);
  const classNamePressed = classnames_default()(propsRef.current.classNamePressed != null ? propsRef.current.classNamePressed : undefined);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, Pressable_extends({
    autofocus: propsRef.current.autofocus,
    disabled: propsRef.current.disabled,
    disableScrollIntoView: propsRef.current.disableScrollIntoView,
    className: className,
    "data-testid": propsRef.current['data-testid'],
    classNameFocused: classNameFocused,
    classNameHovered: classNameHovered,
    classNamePressed: classNamePressed,
    classNameDisabled: propsRef.current.classNameDisabled,
    delayedClick: propsRef.current.delayedClick,
    gamepadAlias: propsRef.current.gamepadAlias,
    gamepadIndex: propsRef.current.gamepadIndex,
    inputLegend: propsRef.current.inputLegend,
    innerRef: propsRef.current.innerRef,
    onClick: propsRef.current.onClick,
    onFocusChanged: propsRef.current.onFocusChanged,
    onHoverChanged: propsRef.current.onHoverChanged,
    onPressChanged: propsRef.current.onPressChanged,
    soundEffectHovered: propsRef.current.soundEffectHovered,
    soundEffectFocused: propsRef.current.soundEffectFocused,
    soundEffectPressed: propsRef.current.soundEffectPressed,
    pressDuration: propsRef.current.pressDuration
  }, 'narrationText' in propsRef.current ? {
    narrationText: propsRef.current.narrationText
  } : {
    getNarrationText: propsRef.current.getNarrationText,
    narrationId: propsRef.current.narrationId
  }), props.children);
}
function Pressable_Pressable(props) {
  var _propsRef$current$cla, _propsRef$current$cla2, _propsRef$current$sou, _propsRef$current$sou2, _propsRef$current$sou3, _propsRef$current$ref;

  const propsRef = (0,react.useRef)(props);
  propsRef.current = props;
  const interactivePrimitiveRef = (0,react.useRef)(null);
  const classNameElevated = (_propsRef$current$cla = propsRef.current.classNameElevated) !== null && _propsRef$current$cla !== void 0 ? _propsRef$current$cla : Pressable.elevated;
  const {
    shadow,
    background,
    text,
    border
  } = hooks_useSemanticColors(propsRef.current.variant);
  const semanticSounds = useSemanticSounds(propsRef.current.variant);
  const pressableTokens = useSemanticComponentTokens('pressable', propsRef.current.variant);
  const hasTexture = pressableTokens.main.interactive != null;
  const classNameElevatedAndPressed = classnames_default()({
    [(_propsRef$current$cla2 = propsRef.current.classNameElevatedAndPressed) !== null && _propsRef$current$cla2 !== void 0 ? _propsRef$current$cla2 : Pressable.elevatedAndPressed]: propsRef.current.shouldNotDepressWhenPressed !== true
  });
  const className = classnames_default()(shadow.interactive, border.interactive, pressableTokens.main.interactive, {
    [classNameElevated]: propsRef.current.isElevated,
    [Pressable.horizontal]: propsRef.current.horizontal
  });
  const classNameShine = classnames_default()(Pressable.shine, Pressable.shineBackground, Pressable.shineText, propsRef.current.className != null ? propsRef.current.className : undefined, hasTexture ? undefined : background.interactive, text.interactive);
  const classNameFocused = classnames_default()(focusClass, propsRef.current.classNameFocused);
  return /*#__PURE__*/react.createElement(Pressable_BoxBorder, Pressable_extends({
    autofocus: propsRef.current.autofocus,
    disabled: propsRef.current.disabled,
    disableScrollIntoView: propsRef.current.disableScrollIntoView,
    className: className,
    classNameFocused: classNameFocused,
    classNameHovered: propsRef.current.classNameHovered,
    "data-testid": propsRef.current['data-testid'],
    classNamePressed: propsRef.current.isElevated ? classNameElevatedAndPressed : undefined,
    delayedClick: propsRef.current.delayedClick,
    gamepadAlias: propsRef.current.gamepadAlias,
    gamepadIndex: propsRef.current.gamepadIndex,
    innerRef: interactivePrimitiveRef,
    inputLegend: propsRef.current.inputLegend,
    onClick: propsRef.current.onClick,
    onFocusChanged: propsRef.current.onFocusChanged,
    onHoverChanged: propsRef.current.onHoverChanged,
    soundEffectHovered: (_propsRef$current$sou = propsRef.current.soundEffectHovered) !== null && _propsRef$current$sou !== void 0 ? _propsRef$current$sou : semanticSounds.hover,
    soundEffectFocused: (_propsRef$current$sou2 = propsRef.current.soundEffectFocused) !== null && _propsRef$current$sou2 !== void 0 ? _propsRef$current$sou2 : semanticSounds.focus,
    soundEffectPressed: (_propsRef$current$sou3 = propsRef.current.soundEffectPressed) !== null && _propsRef$current$sou3 !== void 0 ? _propsRef$current$sou3 : semanticSounds.press,
    pressDuration: propsRef.current.pressDuration
  }, 'narrationText' in propsRef.current ? {
    narrationText: propsRef.current.narrationText
  } : {
    getNarrationText: propsRef.current.getNarrationText,
    narrationId: propsRef.current.narrationId
  }), !hasTexture && (propsRef.current.focusStateOnElevatedFace ? /*#__PURE__*/react.createElement("div", {
    className: Pressable.bottomOffset
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: propsRef.current.variant,
    disabled: propsRef.current.disabled
  })) : /*#__PURE__*/react.createElement(Focus_Focus, {
    role: propsRef.current.variant,
    disabled: propsRef.current.disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classNameShine,
    style: propsRef.current.height != null ? {
      height: `${propsRef.current.height}rem`
    } : undefined
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, Pressable_extends({
    effect: propsRef.current.reflection,
    disabled: hasTexture || propsRef.current.disabled,
    role: propsRef.current.variant
  }, (_propsRef$current$ref = propsRef.current.reflectionConfig) !== null && _propsRef$current$ref !== void 0 ? _propsRef$current$ref : {})), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Pressable.raised, Pressable.shine)
  }, props.children)));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/MaybeIcon/MaybeIcon.tsx
function MaybeIcon_extends() { MaybeIcon_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return MaybeIcon_extends.apply(this, arguments); }

function MaybeIcon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = MaybeIcon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function MaybeIcon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





const unwrapFacetComponent = componentFacet => props => {
  const Component = (0,react_facet_src.useFacetUnwrap)(componentFacet);
  return Component === react_facet_src.NO_VALUE ? null : /*#__PURE__*/react.createElement(Component, props);
};

function MaybeIcon(_ref) {
  let {
    imageSource,
    icon
  } = _ref,
      props = MaybeIcon_objectWithoutProperties(_ref, ["imageSource", "icon"]);

  const imageSourceFacet = (0,react_facet_src.useFacetWrap)(imageSource);
  const iconFacet = (0,react_facet_src.useFacetWrap)(icon);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: imageSourceFacet
  }, imageSource => /*#__PURE__*/react.createElement(Image_Image_Image, MaybeIcon_extends({
    imageRendering: "pixelated"
  }, props, {
    src: imageSource
  }))), /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: iconFacet
  }, iconFacetData => {
    const Icon = unwrapFacetComponent(iconFacetData);
    return /*#__PURE__*/react.createElement(Icon, props);
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Button/Button.tsx








const Button_noop = () => {};

const getType = variant => {
  switch (variant) {
    case 'primary':
    case 'secondary':
      return 'secondaryButton';

    case 'destructive':
      return 'destructiveButton';

    default:
      return 'primaryButton';
  }
};

const Button_Button_Button = props => {
  const {
    children,
    variant = 'secondary',
    Icon,
    imgSrc,
    onClick = Button_noop,
    narrationPrefix: accessibilityPrefix = children,
    narrationSuffix: accessibilitySuffix = '',
    disabled,
    soundEffectPressed,
    soundEffectHovered,
    soundEffectFocused,
    delayedClick,
    horizontal,
    linebreak = false,
    isElevated = true,
    autofocus,
    gamepadIndex = 0,
    gamepadAlias,
    disableScrollIntoView,
    inputLegend,
    onFocusChanged,
    disabledTextOverride
  } = props;
  const {
    t
  } = useLocalization_useLocalization('Button');
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const hasShadowFacet = (0,react_facet_src.useFacetMap)(disabled => variant === 'hero' && !disabled, [variant], [disabledFacet]);
  const narrationText = (0,react_facet_src.useFacetMap)((prefix, suffix) => `${prefix} . ${t('.button')} . ${suffix}`, [t], [(0,react_facet_src.useFacetWrap)(accessibilityPrefix), (0,react_facet_src.useFacetWrap)(accessibilitySuffix)]);
  const role = variant !== 'hero' ? variant : 'primary';
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    isElevated: isElevated,
    delayedClick: delayedClick,
    narrationText: narrationText,
    className: Button_Button.container,
    "data-testid": props['data-testid'],
    classNameHovered: Button_Button.hovered,
    classNameFocused: Button_Button.focused,
    classNamePressed: Button_Button.pressed,
    classNameElevated: Button_Button.elevated,
    classNameElevatedAndPressed: Button_Button.elevatedAndPressed,
    disabled: disabled,
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    disableScrollIntoView: disableScrollIntoView,
    onClick: onClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    soundEffectFocused: soundEffectFocused,
    horizontal: horizontal,
    variant: role,
    onFocusChanged: onFocusChanged
  }, /*#__PURE__*/react.createElement(Button_ButtonContent, {
    buttonVariant: variant,
    imgSrc: imgSrc,
    Icon: Icon,
    linebreak: linebreak,
    disabledTextOverride: disabledTextOverride,
    role: role,
    hasShadow: hasShadowFacet
  }, children));
};
const Button_ButtonContent = props => {
  const {
    children,
    buttonVariant = 'secondary',
    typeVariant = undefined,
    Icon,
    imgSrc,
    linebreak = false,
    disabledTextOverride,
    role,
    hasShadow
  } = props;
  const hasChildren = children != null;
  return /*#__PURE__*/react.createElement("fast-div", {
    className: Button_Button.labelContainer
  }, /*#__PURE__*/react.createElement(MaybeIcon, {
    icon: Icon,
    imageSource: imgSrc,
    className: hasChildren ? Button_Button.imageWithChildren : Button_Button.image
  }), hasChildren && /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: linebreak ? 'center' : undefined,
    type: getType(buttonVariant),
    role: role,
    variant: typeVariant,
    shadow: hasShadow,
    children: linebreak ? // Don't wrap this in a fragment or it breaks when rendering facet children
    disabledTextOverride !== null && disabledTextOverride !== void 0 ? disabledTextOverride : children : /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, disabledTextOverride !== null && disabledTextOverride !== void 0 ? disabledTextOverride : children),
    interactive: true
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWithButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TextFieldWithButton = ({"textFieldWithButtonWrapper":"L6uh_","textFieldWithButtonInput":"XpDm4","textFieldWithButtonButtonWrapper":"JA_ZQ"});
;// CONCATENATED MODULE: ./packages/ui/src/useAnimation/animations.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const animations = ({"shake":"NFMf6","shakeAnimation":"o50Eb"});
;// CONCATENATED MODULE: ./packages/ui/src/useAnimation/useAnimation.ts



let AnimationType;

(function (AnimationType) {
  AnimationType[AnimationType["HORIZONTAL_SHAKE"] = 0] = "HORIZONTAL_SHAKE";
})(AnimationType || (AnimationType = {}));

const useAnimation_animations = {
  [AnimationType.HORIZONTAL_SHAKE]: {
    className: animations.shake,
    duration: 200
  }
};
const NO_ANIMATION_CLASSNAME = '';
function useAnimation(type = AnimationType.HORIZONTAL_SHAKE) {
  const [classNameFacet, setClassNameFacet] = (0,react_facet_src.useFacetState)(NO_ANIMATION_CLASSNAME);
  const timeoutRef = (0,react.useRef)();
  const trigger = (0,react.useCallback)(() => {
    const animation = useAnimation_animations[type];
    setClassNameFacet(animation.className);
    timeoutRef.current = setTimeout(() => {
      setClassNameFacet(NO_ANIMATION_CLASSNAME);
    }, animation.duration);
  }, [type, setClassNameFacet]);
  (0,react.useEffect)(() => () => clearTimeout(timeoutRef.current), []);
  return [trigger, classNameFacet];
}
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldValidation.ts
let TextFieldValidationResult;

(function (TextFieldValidationResult) {
  TextFieldValidationResult[TextFieldValidationResult["VALID"] = 0] = "VALID";
  TextFieldValidationResult[TextFieldValidationResult["INVALID"] = 1] = "INVALID";
})(TextFieldValidationResult || (TextFieldValidationResult = {}));
;// CONCATENATED MODULE: ./packages/ui/src/TextField/narration.ts

// Helper function for ordering the narration of disabled text input
function useDisabledNarration(t, label, value, description, placeholder, // Used to narrate more context on how to enable the text field
disabledNarrationSuffix) {
  return (0,react_facet_src.useFacetMap)((label, value, description, disabledNarrationSuffix) => [label, t('.narrationComponentType'), t('.disabled'), value || placeholder != null && placeholder || t('.empty'), description, disabledNarrationSuffix].filter(token => token != null).join(' - '), [t, placeholder], [label, value, description, (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '')]);
} // Helper function for ordering the narration of text input

function useNarration(t, label, value, description, placeholder) {
  return (0,react_facet_src.useFacetMap)((label, value, description) => [label, t('.narrationComponentType'), value || placeholder != null && placeholder || t('.empty'), description].filter(token => token != null).join(' - '), [t, placeholder], [label, value, description]);
}
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextFieldWithButton.tsx
function TextFieldWithButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = TextFieldWithButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function TextFieldWithButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }














const TextFieldWithButton_noop = () => {};
/**
 * TextFieldWithButton
 * -
 * This component shares similarities with the default TextField, with the addition
 * of a secondary Button after the input. We could abstract out the facets/narration
 * to avoid code duplication, but I think that will be over-engineering the problem
 * given that the behaviour of the component may need to differ from the default
 * TextField in the future.
 */


function TextFieldWithButton_TextFieldWithButton({
  autofocus,
  gamepadAlias,
  value,
  disabled = false,
  label,
  maxLength,
  onChange = TextFieldWithButton_noop,
  onBlur,
  placeholder,
  description = '',
  rows = 1,
  gamepadIndex,
  // Button narration hint that is more descriptive than the field label
  buttonNarrationHint,
  // Used to narrate more context on why this component is disabled
  disabledNarrationSuffix,
  isNumber,
  textDisabled = false,
  buttonText,
  buttonInputLegend = '',
  buttonDisabled = false,
  buttonOnClick = TextFieldWithButton_noop,
  soundEffectButtonPressed,
  buttonVariant = 'secondary'
}) {
  const {
    t
  } = useLocalization_useLocalization('TextField');
  const {
    t: t2
  } = useLocalization_useLocalization('TextFieldWithButton');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledNarrationSuffixFacet = (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '');
  const narrationEnabled = useNarrationEnabled();
  const labelFacet = (0,react_facet_src.useFacetWrap)(label);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description);
  const descriptionWithNavigationHint = (0,react_facet_src.useFacetMap)(description => `${description} . ${t2('.navigationHint')}`, [t2], [descriptionFacet]);
  const textDisabledFacet = (0,react_facet_src.useFacetWrap)(textDisabled);
  const buttonDisabledFacet = (0,react_facet_src.useFacetWrap)(buttonDisabled);
  const [triggerShakeAnimation, animationClassName] = useAnimation(AnimationType.HORIZONTAL_SHAKE);
  const ref = (0,react.useRef)(null);
  const narrationTextFacet = useNarration(t, labelFacet, valueFacet, descriptionWithNavigationHint, placeholder);
  const disabledNarration = useDisabledNarration(t, labelFacet, valueFacet, descriptionWithNavigationHint, placeholder, disabledNarrationSuffixFacet);
  const rowOptions = (0,react_facet_src.useFacetMap)(disabled => ({
    index: gamepadIndex,
    disabled: narrationEnabled && disabled,
    defaultFocusedChildBehavior: 'first'
  }), [narrationEnabled, gamepadIndex], [disabledFacet]);
  const onBlurHandler = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      const validationResult = onBlur(value, setValue);

      switch (validationResult) {
        case TextFieldValidationResult.INVALID:
          triggerShakeAnimation();
      }
    }
  }, [onBlur, triggerShakeAnimation]);
  return /*#__PURE__*/react.createElement(TextFieldWrapper, {
    disabled: disabledFacet,
    label: labelFacet,
    gamepadIndex: gamepadIndex,
    description: descriptionFacet,
    disabledNarrationText: disabledNarration
  }, /*#__PURE__*/react.createElement(MaybeRow, {
    scrollRef: ref,
    options: rowOptions,
    disabled: disabledFacet
  }, /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonInput
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    className: animationClassName,
    autofocus: autofocus,
    placeholder: placeholder,
    disabled: (0,react_facet_src.useFacetMap)((textDisabled, disabled) => textDisabled || disabled, [], [textDisabledFacet, disabledFacet]),
    label: labelFacet,
    gamepadAlias: gamepadAlias,
    gamepadIndex: 0,
    maxLength: maxLength,
    narrationText: narrationTextFacet,
    value: value,
    onChange: onChange,
    onBlur: onBlurHandler,
    isNumber: isNumber,
    rows: rows,
    shouldBlurOnEnter: true,
    shouldBlurOnEscape: true
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: TextFieldWithButton.textFieldWithButtonButtonWrapper
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: buttonInputLegend,
    disabled: (0,react_facet_src.useFacetMap)((buttonDisabled, disabled) => buttonDisabled || disabled, [], [buttonDisabledFacet, disabledFacet]),
    onClick: buttonOnClick,
    soundEffectPressed: soundEffectButtonPressed,
    narrationSuffix: buttonNarrationHint,
    variant: buttonVariant
  }, buttonText)))));
}

const MaybeRow = (_ref) => {
  let {
    children,
    disabled
  } = _ref,
      props = TextFieldWithButton_objectWithoutProperties(_ref, ["children", "disabled"]);

  const isNarrationEnabled = useNarrationEnabled();
  const disabledValue = (0,react_facet_src.useFacetUnwrap)(disabled) === true;
  return isNarrationEnabled || disabledValue === false ? /*#__PURE__*/react.createElement(Row_RowLegacy, props, children) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
};
;// CONCATENATED MODULE: ./packages/ui/src/TextField/TextField.tsx










const TextField_noop = () => {};

function TextField_TextField({
  autofocus,
  gamepadAlias,
  value,
  disabled = false,
  // We set the default maxLength value to 32000 as this is the maximum number of characters that the user can enter in the virtual keyboard on Xbox
  // https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/reference/system/xgameui/functions/xgameuitextentryopen
  maxLength,
  onChange = TextField_noop,
  onBlur,
  placeholder,
  description = '',
  label,
  rows = 1,
  gamepadIndex,
  disabledNarrationSuffix,
  isNumber,
  transparent
}) {
  const {
    t
  } = useLocalization_useLocalization('TextField');
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledNarrationSuffixFacet = (0,react_facet_src.useFacetWrap)(disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '');
  const descriptionFacet = (0,react_facet_src.useFacetWrap)(description);
  const labelFacet = (0,react_facet_src.useFacetWrap)(label);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const transparentFacet = (0,react_facet_src.useFacetWrap)(transparent);
  const [triggerShakeAnimation, animationClassName] = useAnimation(AnimationType.HORIZONTAL_SHAKE);
  const narrationTextFacet = useNarration(t, labelFacet, valueFacet, descriptionFacet, placeholder);
  const disabledNarration = useDisabledNarration(t, labelFacet, valueFacet, descriptionFacet, placeholder, disabledNarrationSuffixFacet);
  const onBlurHandler = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      const validationResult = onBlur(value, setValue);

      switch (validationResult) {
        case TextFieldValidationResult.INVALID:
          triggerShakeAnimation();
      }
    }
  }, [onBlur, triggerShakeAnimation]);
  return /*#__PURE__*/react.createElement(TextFieldWrapper, {
    disabled: disabledFacet,
    label: labelFacet,
    gamepadIndex: gamepadIndex,
    description: descriptionFacet,
    transparent: transparentFacet // The disabled narration in the TextFieldWrapper allows the user to listen to all relevant
    // field information even though the inner TextField is not interactive
    ,
    disabledNarrationText: disabledNarration
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    className: animationClassName,
    autofocus: autofocus,
    placeholder: placeholder,
    disabled: disabled,
    label: labelFacet,
    gamepadAlias: gamepadAlias,
    gamepadIndex: gamepadIndex,
    maxLength: maxLength,
    narrationText: narrationTextFacet,
    value: value,
    onChange: onChange,
    rows: rows,
    onBlur: onBlurHandler,
    isNumber: isNumber,
    shouldBlurOnEnter: true,
    shouldBlurOnEscape: true
  }));
}
TextField_TextField.WithButton = TextFieldWithButton_TextFieldWithButton;
TextField_TextField.ValidationResult = TextFieldValidationResult;
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ProgressBar_ProgressBar = ({"progressBarWrapper":"q6zFV","progressBar":"oOBki","tall":"f6wZX"});
;// CONCATENATED MODULE: ./packages/ui/src/ProgressBar/ProgressBar.tsx





/**
 * Base types
 */

function ProgressBar_ProgressBar_ProgressBar({
  percentage,
  tall = false,
  // Hardcoding the hex value below, because vars don't work with inline styles in Gameface
  fillColor = '#2e6be5',
  fillColorThresholds,
  fillComplement = false
}) {
  const percentageFacet = (0,react_facet_src.useFacetWrap)(percentage);
  const tallFacet = (0,react_facet_src.useFacetWrap)(tall);

  if ((percentage < 0 || percentage > 1) && "production" !== 'test') {
    console.warn('Percentage needs to be a valid number from 0 to 1');
  }

  const thresholdsSorted = (0,react.useMemo)(() => fillColorThresholds != null ? Object.keys(fillColorThresholds).map(x => x).sort((a, b) => a > b ? 1 : -1) : undefined, [fillColorThresholds]);
  const barBackgroundColor = (0,react_facet_src.useFacetMap)((fillColor, percentage) => {
    // If there are no thresholds, use the given fillColor
    if (thresholdsSorted == null || fillColorThresholds == null) {
      return fillColor;
    } // If there are no thresholds, return the default color.


    if (thresholdsSorted.length === 0) {
      console.warn('Empty thresholds object passed to ProgressBar.');
      return fillColor;
    } // Loop down all the thresholds until we find one we're
    // higher than, then use that color.


    for (let i = thresholdsSorted.length; i >= 0; i--) {
      if (percentage >= thresholdsSorted[i]) {
        return fillColorThresholds[thresholdsSorted[i]];
      }
    } // If the percentage was never greater than any of the thresholds, return the default fillColor.


    return fillColor;
  }, [fillColorThresholds, thresholdsSorted], [(0,react_facet_src.useFacetWrap)(fillColor), percentageFacet]);
  const fillComplementColorValue = (0,react_facet_src.useFacetMap)(fillComplementColor => {
    if (typeof fillComplementColor === 'string') {
      return fillComplementColor;
    }

    return fillComplementColor === true ? '#ffb366' : undefined;
  }, [], [(0,react_facet_src.useFacetWrap)(fillComplement)]); // if the complement is not filled, reverse the reflection to give the "empty" appearance

  const reverse = (0,react_facet_src.useFacetUnwrap)(fillComplement) === false;
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(tall => classnames_default()(ProgressBar_ProgressBar.progressBarWrapper, {
      [ProgressBar_ProgressBar.tall]: tall
    }), [], [tallFacet]),
    style: {
      backgroundColor: fillComplementColorValue
    }
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    thin: true,
    reversed: reverse
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(tall => classnames_default()(ProgressBar_ProgressBar.progressBar, {
      [ProgressBar_ProgressBar.tall]: tall
    }), [], [tallFacet]),
    style: {
      width: (0,react_facet_src.useFacetMap)(percentage => `${Math.max(Math.min(Math.round(percentage * 100), 100), 0)}%`, [], [percentageFacet]),
      backgroundColor: barBackgroundColor
    }
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    thin: true,
    right: false
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend_InputLegend = ({"InputLegend":"FGHxt","hidden":"mdtlU"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Wrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputLegend_Wrapper = ({"Custom":"_iCp3","background":"Lh0_R","wrapper":"HvYsi","leftContainer":"gB3x9","rightContainer":"Gehqy"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/constants.ts
const constants_INPUT_LEGEND_BASE_HEIGHT = 4;
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Wrapper.tsx







function InputLegendWrapper({
  safeZone: safeZoneOverride,
  left,
  right,
  role = 'inherit'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  const inputLegendTokens = useSemanticComponentTokens('inputLegend', role);
  const textureClassNames = inputLegendTokens.sideContainer;
  const hasTexture = textureClassNames.interactive != null;
  const originalSafeZone = useSafeZone();
  const safeZone = safeZoneOverride || originalSafeZone;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(InputLegend_Wrapper.Custom, semanticColors.text.base),
    style: {
      height: `calc(${constants_INPUT_LEGEND_BASE_HEIGHT}rem + ${safeZone.bottom}px)`
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(InputLegend_Wrapper.background, !hasTexture ? semanticColors.background.base : undefined)
  }), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: role,
    effect: "specular",
    thin: true,
    left: false,
    right: false,
    bottom: false
  }), /*#__PURE__*/react.createElement("div", {
    className: InputLegend_Wrapper.wrapper,
    style: {
      height: `${constants_INPUT_LEGEND_BASE_HEIGHT}rem`,
      paddingRight: safeZone.right + 'px',
      paddingLeft: safeZone.left + 'px'
    }
  }, left != null ? /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(InputLegend_Wrapper.leftContainer, textureClassNames.interactive)
  }, left) : null, right != null ? /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(InputLegend_Wrapper.rightContainer, textureClassNames.interactive)
  }, right) : null));
}
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/Space.tsx






function InputLegendSpace({
  extraSpace,
  addSafeZone = true
}) {
  const wrapperClassName = (0,react_facet_src.useFacetMap)(isGamepad => classnames_default()(InputLegend_InputLegend.wrapper, {
    [InputLegend_InputLegend.hidden]: !isGamepad
  }), [], [useIsFocusInputGamepad()]);
  const safeZone = useSafeZone();
  const addSafeZoneFacet = (0,react_facet_src.useFacetWrap)(addSafeZone);
  const height = (0,react_facet_src.useFacetMap)(addSafeZone => addSafeZone ? `calc(${constants_INPUT_LEGEND_BASE_HEIGHT}rem + ${safeZone.bottom}px)` : `${constants_INPUT_LEGEND_BASE_HEIGHT}rem`, [safeZone], [addSafeZoneFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: wrapperClassName
  }, /*#__PURE__*/react.createElement("fast-div", {
    style: {
      height
    }
  }), extraSpace);
}
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/XboxIcons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const XboxIcons = ({"XboxButtonA":"OHrZ8","small":"vMjA2","XboxButtonB":"fg2E4","XboxButtonX":"iQyId","XboxButtonY":"pxPk9","XboxButtonStart":"oDCN0","XboxButtonLT":"WyyoK","XboxButtonRT":"aOFj8","XboxButtonLB":"GS50F","XboxButtonRB":"mKs6r","XboxButtonLeft":"pDhLW","XboxButtonRight":"wK3Xd","XboxButtonUp":"nlvNB","XboxButtonDown":"J9MtE","XboxButtonSelect":"QvCIw","XboxButtonL3":"Fqdok","XboxButtonR3":"yqVFC","XboxButtonLS":"v0Ce5","XboxButtonRS":"i4uVO","large":"aItg1","iconSize":"liriy","ABXY":"VLERn","triggers":"UoTWb","bumpers":"l5n3u","flatTriggers":"_U_vn","dButton":"xN6WQ","startXbox":"eVmaS","toggleViewXbox":"RjcUU","stick":"eMLrL"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/XboxImages/index.ts



const XboxImages = {
  [types_ButtonType.A]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonA, XboxIcons.ABXY),
  [types_ButtonType.B]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonB, XboxIcons.ABXY),
  [types_ButtonType.X]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonX, XboxIcons.ABXY),
  [types_ButtonType.Y]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonY, XboxIcons.ABXY),
  [types_ButtonType.START]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonStart, XboxIcons.startXbox),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLT, XboxIcons.triggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRT, XboxIcons.triggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLB, XboxIcons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRB, XboxIcons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLeft, XboxIcons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRight, XboxIcons.dButton),
  [types_ButtonType.UP]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonUp, XboxIcons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonDown, XboxIcons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonSelect, XboxIcons.toggleViewXbox),
  [types_ButtonType.L3]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonL3, XboxIcons.stick),
  [types_ButtonType.R3]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonR3, XboxIcons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonLS, XboxIcons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(XboxIcons.iconSize, XboxIcons.XboxButtonRS, XboxIcons.stick),
  ['large']: XboxIcons.large,
  ['small']: XboxIcons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/PS4Icons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS4Icons = ({"PS4ButtonA":"saRDS","small":"VqfCS","PS4ButtonB":"fq1Wt","PS4ButtonX":"KeNau","PS4ButtonY":"e7md4","PS4ButtonStart":"kqt1L","PS4ButtonLT":"DckFK","PS4ButtonRT":"RYAZU","PS4ButtonLB":"U6swu","PS4ButtonRB":"G58dQ","PS4ButtonLeft":"huNm8","PS4ButtonRight":"JHI_T","PS4ButtonUp":"dkG8m","PS4ButtonDown":"xESXG","PS4ButtonTouchpad":"Ep0S5","PS4ButtonL3":"Khy_Q","PS4ButtonR3":"W_0vF","PS4ButtonLS":"JoHy1","PS4ButtonRS":"xI7dX","large":"OQ6xf","iconSize":"YQeSi","ABXY":"at3wP","triggers":"z4huI","bumpers":"hjYMG","flatTriggers":"bSrtd","dButton":"pdEm6","optionsPS4":"TvAgE","sharePS4":"TbNT7","stick":"FkFaw"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS4Images/index.ts



const PS4Images = {
  [types_ButtonType.A]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonA, PS4Icons.ABXY),
  [types_ButtonType.B]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonB, PS4Icons.ABXY),
  [types_ButtonType.X]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonX, PS4Icons.ABXY),
  [types_ButtonType.Y]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonY, PS4Icons.ABXY),
  [types_ButtonType.START]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonStart, PS4Icons.optionsPS4),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLT, PS4Icons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRT, PS4Icons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLB, PS4Icons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRB, PS4Icons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLeft, PS4Icons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRight, PS4Icons.dButton),
  [types_ButtonType.UP]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonUp, PS4Icons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonDown, PS4Icons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonTouchpad, PS4Icons.sharePS4),
  [types_ButtonType.L3]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonL3, PS4Icons.stick),
  [types_ButtonType.R3]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonR3, PS4Icons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonLS, PS4Icons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(PS4Icons.iconSize, PS4Icons.PS4ButtonRS, PS4Icons.stick),
  ['large']: PS4Icons.large,
  ['small']: PS4Icons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/PS5Icons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PS5Icons = ({"PS5ButtonA":"s5WBf","small":"z6TF3","PS5ButtonB":"Kv7uC","PS5ButtonX":"kYWOu","PS5ButtonY":"WtpwV","PS5ButtonStart":"lACg4","PS5ButtonLT":"wxIDB","PS5ButtonRT":"X2Vmd","PS5ButtonLB":"tHBmF","PS5ButtonRB":"n1nsL","PS5ButtonLeft":"FOhDs","PS5ButtonRight":"xALny","PS5ButtonUp":"h2Qqa","PS5ButtonDown":"f8TY5","PS5ButtonTouchpad":"f2Ygw","PS5ButtonL3":"qxa8S","PS5ButtonR3":"KhF5i","PS5ButtonLS":"lEWFT","PS5ButtonRS":"GcMtB","large":"YG8U4","iconSize":"oYpoG","ABXY":"rgQQy","triggers":"HSGw6","bumpers":"NHxos","flatTriggers":"bWa3v","dButton":"bkeIb","optionsPS5":"M2OrT","sharePS5":"M_q6y","stick":"EtpTm"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PS5Images/index.ts



const PS5Images = {
  [types_ButtonType.A]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonA, PS5Icons.ABXY),
  [types_ButtonType.B]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonB, PS5Icons.ABXY),
  [types_ButtonType.X]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonX, PS5Icons.ABXY),
  [types_ButtonType.Y]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonY, PS5Icons.ABXY),
  [types_ButtonType.START]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonStart, PS5Icons.optionsPS5),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLT, PS5Icons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRT, PS5Icons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLB, PS5Icons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRB, PS5Icons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLeft, PS5Icons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRight, PS5Icons.dButton),
  [types_ButtonType.UP]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonUp, PS5Icons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonDown, PS5Icons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonTouchpad, PS5Icons.sharePS5),
  [types_ButtonType.L3]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonL3, PS5Icons.stick),
  [types_ButtonType.R3]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonR3, PS5Icons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonLS, PS5Icons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(PS5Icons.iconSize, PS5Icons.PS5ButtonRS, PS5Icons.stick),
  ['large']: PS5Icons.large,
  ['small']: PS5Icons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/NintendoIcons.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NintendoIcons = ({"NintendoButtonA":"qRaP6","small":"P1SbE","NintendoButtonB":"AI6pj","NintendoButtonX":"_MHws","NintendoButtonY":"B5rVg","NintendoButtonStart":"sp3nW","NintendoButtonLT":"Vdaoj","NintendoButtonRT":"_O7W7","NintendoButtonLB":"oQWb_","NintendoButtonRB":"u1YVo","NintendoButtonLeft":"tkRUh","NintendoButtonRight":"e3hRs","NintendoButtonUp":"znMgA","NintendoButtonDown":"Ghttt","NintendoButtonSelect":"jyA7I","NintendoButtonL3":"ejTg5","NintendoButtonR3":"wIh1n","NintendoButtonLS":"uxDU0","NintendoButtonRS":"RBEvC","iconSize":"K_Ucb","ABXY":"MC54K","triggers":"BXc9M","bumpers":"Yh8am","flatTriggers":"f12Q1","dButton":"chFOJ","homeNintendo":"lfQSn","minusNintendo":"gnCaZ","stick":"ApnkV","large":"h7tik"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/NintendoImages/index.ts



const NintendoImages = {
  [types_ButtonType.A]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonA, NintendoIcons.ABXY),
  [types_ButtonType.B]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonB, NintendoIcons.ABXY),
  [types_ButtonType.X]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonX, NintendoIcons.ABXY),
  [types_ButtonType.Y]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonY, NintendoIcons.ABXY),
  [types_ButtonType.START]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonStart, NintendoIcons.homeNintendo),
  [types_ButtonType.LEFT_TRIGGER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLT, NintendoIcons.flatTriggers),
  [types_ButtonType.RIGHT_TRIGGER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRT, NintendoIcons.flatTriggers),
  [types_ButtonType.LEFT_BUMPER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLB, NintendoIcons.bumpers),
  [types_ButtonType.RIGHT_BUMPER]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRB, NintendoIcons.bumpers),
  [types_ButtonType.LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLeft, NintendoIcons.dButton),
  [types_ButtonType.RIGHT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRight, NintendoIcons.dButton),
  [types_ButtonType.UP]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonUp, NintendoIcons.dButton),
  [types_ButtonType.DOWN]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonDown, NintendoIcons.dButton),
  [types_ButtonType.SELECT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonSelect, NintendoIcons.minusNintendo),
  [types_ButtonType.L3]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonL3, NintendoIcons.stick),
  [types_ButtonType.R3]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonR3, NintendoIcons.stick),
  [types_ButtonType.LEFT_ANALOG_LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonLS, NintendoIcons.stick),
  [types_ButtonType.RIGHT_ANALOG_LEFT]: classnames_default()(NintendoIcons.iconSize, NintendoIcons.NintendoButtonRS, NintendoIcons.stick),
  ['large']: NintendoIcons.large,
  ['small']: NintendoIcons.small
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Gamepad.tsx








function ButtonIconGamepad({
  button,
  theme = 'light'
}) {
  const platformSelected = usePlatformSelected();
  const buttonFacet = (0,react_facet_src.useFacetWrap)(button);
  const buttonClassnames = (0,react_facet_src.useFacetMap)((buttonValue, platformSelected) => {
    const platformAssets = mapPlatformEnumToImages(platformSelected);

    if (!platformAssets[buttonValue]) {
      return '';
    }

    return classnames_default()(platformAssets[buttonValue], {
      [platformAssets['large']]: theme === 'large',
      [platformAssets['small']]: theme === 'small'
    });
  }, [theme], [buttonFacet, platformSelected]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: buttonClassnames
  });
}

const mapPlatformEnumToImages = platform => {
  if (platform === Platform.XBOX) {
    return XboxImages;
  }

  if (platform === Platform.PS4) {
    return PS4Images;
  }

  if (platform === Platform.PS5) {
    return PS5Images;
  }

  if (platform === Platform.NX_HANDHELD || platform === Platform.NX_TV) {
    return NintendoImages;
  }

  return XboxImages;
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Keyboard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Keyboard = ({"ButtonIconKeyboard":"bWVyX"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/PCImages.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PCImages = ({"KeyboardKeyW":"auvwE","small":"roch1","KeyboardKeyA":"tBb_V","KeyboardKeyV":"iCLcl","KeyboardKeyS":"YOlJ6","KeyboardKeyT":"oMhZB","KeyboardKeyD":"VyL1w","KeyboardKeyQ":"tafjE","KeyboardKeyZ":"Hoaaj","KeyboardKeyE":"tpVOe","KeyboardKeyM":"Drtqa","KeyboardKeyR":"Zb3UU","KeyboardKeyX":"QxQ1Y","KeyboardKeyY":"QrQyh","KeyboardKeyF":"q9B4F","KeyboardKeyC":"tz71H","KeyboardKey1":"cuPgL","KeyboardKey2":"e5wNF","KeyboardKey3":"ppvtq","KeyboardKey4":"Y81IB","KeyboardKey5":"m3hWH","KeyboardKey6":"_2osj","KeyboardKey7":"GKXym","KeyboardKey8":"czhOA","KeyboardKey9":"qHgTt","KeyboardKey0":"TbhIT","KeyboardKeyUp":"b7nKj","KeyboardKeyRight":"Lz1in","KeyboardKeyDown":"j_BNz","KeyboardKeyLeft":"OE2P1","KeyboardKeyESC":"Smnr0","KeyboardKeyBracketOpen":"uSqYm","KeyboardKeyBracketClose":"ekxWu","KeyboardKeyTab":"w8Ue4","KeyboardKeyShift":"PnyQi","KeyboardKeyEnter":"DaFVW","KeyboardKeySpace":"s89WE","KeyboardKeyCtrl":"sWwMn","darkTheme":"XJCBH","KeyboardKeyMouseLeft":"JqJ5A","KeyboardKeyMouseRight":"P_s1j","KeyboardKeyMouseCenter":"SWSY_","KeyboardKeyMouseScroll":"m3IeL","KeyboardKeyMouse":"T27KG","ButtonIconKeyboardKey":"G7Zxr","large":"Gnnm7","ButtonIconKeyboardSpecialKey":"PITVu","ButtonIconKeyboardMouseButton":"SRDuY"});
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/PCImages/index.ts



const PCImages_PCImages = {
  [KeyboardKey.TAB]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyTab, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.ENTER]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyEnter, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.SHIFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyShift, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.ESCAPE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyESC, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.SPACE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeySpace, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.CTRL]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyCtrl, PCImages.ButtonIconKeyboardSpecialKey),
  [KeyboardKey.BRACKET_OPEN]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyBracketOpen),
  [KeyboardKey.BRACKET_CLOSE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyBracketClose),
  [KeyboardKey.UP]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyUp),
  [KeyboardKey.RIGHT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyRight),
  [KeyboardKey.DOWN]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyDown),
  [KeyboardKey.LEFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyLeft),
  [KeyboardKey.KEY_0]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey0),
  [KeyboardKey.KEY_1]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey1),
  [KeyboardKey.KEY_2]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey2),
  [KeyboardKey.KEY_3]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey3),
  [KeyboardKey.KEY_4]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey4),
  [KeyboardKey.KEY_5]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey5),
  [KeyboardKey.KEY_6]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey6),
  [KeyboardKey.KEY_7]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey7),
  [KeyboardKey.KEY_8]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey8),
  [KeyboardKey.KEY_9]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKey9),
  [KeyboardKey.KEY_A]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyA),
  [KeyboardKey.KEY_C]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyC),
  [KeyboardKey.KEY_D]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyD),
  [KeyboardKey.KEY_E]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyE),
  [KeyboardKey.KEY_F]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyF),
  [KeyboardKey.KEY_M]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyM),
  [KeyboardKey.KEY_Q]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyQ),
  [KeyboardKey.KEY_R]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyR),
  [KeyboardKey.KEY_S]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyS),
  [KeyboardKey.KEY_T]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyT),
  [KeyboardKey.KEY_V]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyV),
  [KeyboardKey.KEY_W]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyW),
  [KeyboardKey.KEY_X]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyX),
  [KeyboardKey.KEY_Y]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyY),
  [KeyboardKey.KEY_Z]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyZ),
  [KeyboardKey.MOUSE_MOVEMENT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouse, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_LEFT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseLeft, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_MIDDLE]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseCenter, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_BUTTON_RIGHT]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseRight, PCImages.ButtonIconKeyboardMouseButton),
  [KeyboardKey.MOUSE_WHEEL]: classnames_default()(PCImages.ButtonIconKeyboardKey, PCImages.KeyboardKeyMouseScroll, PCImages.ButtonIconKeyboardMouseButton),
  [-2]: PCImages.large,
  // large icon sizing
  [-3]: PCImages.small // small icon sizing

};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/Keyboard.tsx





const ButtonIconKeyboard = ({
  keyCode,
  theme = 'light'
}) => {
  const keyCodeFacet = (0,react_facet_src.useFacetWrap)(keyCode);
  const classnameFacet = (0,react_facet_src.useFacetMap)(keyCode => {
    return PCImages_PCImages[keyCode] != null ? classnames_default()(PCImages_PCImages[keyCode], {
      [PCImages_PCImages[-2]]: theme === 'large',
      [PCImages_PCImages[-3]]: theme === 'small'
    }) : Keyboard.ButtonIconKeyboard;
  }, [theme], [keyCodeFacet]);
  const textFacet = (0,react_facet_src.useFacetMap)(keyCode => {
    return PCImages_PCImages[keyCode] == null ? String.fromCharCode(keyCode) : '';
  }, [], [keyCodeFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classnameFacet
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: textFacet
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/ButtonIcon/index.ts


const ButtonIcon = {
  Gamepad: ButtonIconGamepad,
  Keyboard: ButtonIconKeyboard
};
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputHint.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputHint = ({"InputHint":"r2rQH","hovered":"LJ0gR","hintKeyBox":"X7C6X","pressed":"MMiKH","hintGutter":"lX5qc","hidden":"Ob6kp"});
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputHint.tsx







function InputHint_InputHint(props) {
  const inputLegendTokens = useSemanticComponentTokens('inputLegend', 'inherit');
  const {
    label,
    hidden = false,
    onClick,
    onHoverChanged
  } = props;
  const classNames = (0,react_facet_src.useFacetMap)(isHidden => classnames_default()(InputHint.InputHint, inputLegendTokens.inputHint.interactive, {
    [InputHint.hidden]: isHidden
  }), [inputLegendTokens], [(0,react_facet_src.useFacetWrap)(hidden)]);
  const content = /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: InputHint.hintKeyBox
  }, 'button' in props ? /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: props.button,
    theme: "light"
  }) : /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: props.keyCode,
    theme: "light"
  })), /*#__PURE__*/react.createElement("div", {
    className: InputHint.hintGutter
  }), /*#__PURE__*/react.createElement("fast-text", {
    text: label
  }));

  if (onClick) {
    return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
      gamepadIndex: 0,
      narrationText: label,
      inputLegend: label,
      onHoverChanged: onHoverChanged,
      onClick: onClick,
      className: classNames,
      classNameHovered: InputHint.hovered,
      classNamePressed: InputHint.pressed,
      nonFocusable: true
    }, content);
  }

  return /*#__PURE__*/react.createElement("fast-div", {
    className: classNames
  }, content);
}
;// CONCATENATED MODULE: ./packages/ui/src/InputLegend/InputLegend.tsx









const InputLegend_INPUT_LEGEND_BASE_HEIGHT = 4;
function InputLegend_InputLegend_InputLegend({
  shouldDisplayKeyboard,
  isClickable = false,
  role = 'neutral100'
}) {
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(KeyboardInputLegend, {
    isClickable: isClickable,
    visible: (0,react_facet_src.useFacetMap)(isKeyboard => isKeyboard && !!shouldDisplayKeyboard, [shouldDisplayKeyboard], [useIsFocusInputKeyboard()])
  }), /*#__PURE__*/react.createElement(GamepadInputLegend, {
    isClickable: isClickable,
    visible: useIsFocusInputGamepad()
  }));
}

function KeyboardInputLegend({
  isClickable,
  visible
}) {
  const buttonMapFacet = useButtonMap();
  const swapABButtons = (0,react_facet_src.useFacetMap)(({
    swapABButtons
  }) => swapABButtons, [], [buttonMapFacet]);
  const swapXYButtons = (0,react_facet_src.useFacetMap)(({
    swapXYButtons
  }) => swapXYButtons, [], [buttonMapFacet]);
  const inputLegends = useAvailableInputLegends();
  const callback = useInputLegendCallback();
  const [keyboardGamepadMapFacet] = useKeyboardGamepadMap();
  const keyboardGamepadMapValue = (0,react_facet_src.useFacetUnwrap)(keyboardGamepadMapFacet);
  const keyboardGamepadMap = keyboardGamepadMapValue === react_facet_src.NO_VALUE ? DEFAULT_KEYBOARD_GAMEPAD_MAP : keyboardGamepadMapValue;
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(visible => visible ? InputLegend_InputLegend.InputLegend : InputLegend_InputLegend.hidden, [], [visible])
  }, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Wrapper, {
    left: /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: (0,react_facet_src.useFacetMap)(swapABButtons => keyboardGamepadMap[swapABButtons ? types_ButtonType.A : types_ButtonType.B][0], [keyboardGamepadMap], [swapABButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT;

        return (_inputLegends$ButtonT = inputLegends[types_ButtonType.B]) !== null && _inputLegends$ButtonT !== void 0 ? _inputLegends$ButtonT : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.B) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.B] != null, [], [inputLegends])
    }),
    right: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.LEFT][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT2;

        return (_inputLegends$ButtonT2 = inputLegends[types_ButtonType.LEFT]) !== null && _inputLegends$ButtonT2 !== void 0 ? _inputLegends$ButtonT2 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.LEFT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.LEFT] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.RIGHT][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT3;

        return (_inputLegends$ButtonT3 = inputLegends[types_ButtonType.RIGHT]) !== null && _inputLegends$ButtonT3 !== void 0 ? _inputLegends$ButtonT3 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.RIGHT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.RIGHT] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.UP][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT4;

        return (_inputLegends$ButtonT4 = inputLegends[types_ButtonType.UP]) !== null && _inputLegends$ButtonT4 !== void 0 ? _inputLegends$ButtonT4 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.UP) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.UP] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.DOWN][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT5;

        return (_inputLegends$ButtonT5 = inputLegends[types_ButtonType.DOWN]) !== null && _inputLegends$ButtonT5 !== void 0 ? _inputLegends$ButtonT5 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.DOWN) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.DOWN] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: (0,react_facet_src.useFacetMap)(swapXYButtons => keyboardGamepadMap[swapXYButtons ? types_ButtonType.Y : types_ButtonType.X][0], [keyboardGamepadMap], [swapXYButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT6;

        return (_inputLegends$ButtonT6 = inputLegends[types_ButtonType.X]) !== null && _inputLegends$ButtonT6 !== void 0 ? _inputLegends$ButtonT6 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.X) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.X] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: (0,react_facet_src.useFacetMap)(swapXYButtons => keyboardGamepadMap[swapXYButtons ? types_ButtonType.X : types_ButtonType.Y][0], [keyboardGamepadMap], [swapXYButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT7;

        return (_inputLegends$ButtonT7 = inputLegends[types_ButtonType.Y]) !== null && _inputLegends$ButtonT7 !== void 0 ? _inputLegends$ButtonT7 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.Y) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.Y] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: keyboardGamepadMap[types_ButtonType.START][0],
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT8;

        return (_inputLegends$ButtonT8 = inputLegends[types_ButtonType.START]) !== null && _inputLegends$ButtonT8 !== void 0 ? _inputLegends$ButtonT8 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.START) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.START] != null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      keyCode: (0,react_facet_src.useFacetMap)(swapABButtons => keyboardGamepadMap[swapABButtons ? types_ButtonType.B : types_ButtonType.A][0], [keyboardGamepadMap], [swapABButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT9;

        return (_inputLegends$ButtonT9 = inputLegends[types_ButtonType.A]) !== null && _inputLegends$ButtonT9 !== void 0 ? _inputLegends$ButtonT9 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.A] != null, [], [inputLegends])
    }))
  }));
}

function GamepadInputLegend({
  isClickable,
  visible
}) {
  const buttonMapFacet = useButtonMap();
  const swapABButtons = (0,react_facet_src.useFacetMap)(({
    swapABButtons
  }) => swapABButtons, [], [buttonMapFacet]);
  const swapXYButtons = (0,react_facet_src.useFacetMap)(({
    swapXYButtons
  }) => swapXYButtons, [], [buttonMapFacet]);
  const inputLegends = useAvailableInputLegends();
  const callback = useInputLegendCallback();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(visible => visible ? InputLegend_InputLegend.InputLegend : InputLegend_InputLegend.hidden, [], [visible])
  }, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Wrapper, {
    left: /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: (0,react_facet_src.useFacetMap)(swapABButtons => swapABButtons ? types_ButtonType.A : types_ButtonType.B, [], [swapABButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT10;

        return (_inputLegends$ButtonT10 = inputLegends[types_ButtonType.B]) !== null && _inputLegends$ButtonT10 !== void 0 ? _inputLegends$ButtonT10 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.B] == null, [], [inputLegends])
    }),
    right: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.LEFT,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT11;

        return (_inputLegends$ButtonT11 = inputLegends[types_ButtonType.LEFT]) !== null && _inputLegends$ButtonT11 !== void 0 ? _inputLegends$ButtonT11 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.LEFT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.LEFT] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.RIGHT,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT12;

        return (_inputLegends$ButtonT12 = inputLegends[types_ButtonType.RIGHT]) !== null && _inputLegends$ButtonT12 !== void 0 ? _inputLegends$ButtonT12 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.RIGHT) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.RIGHT] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.UP,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT13;

        return (_inputLegends$ButtonT13 = inputLegends[types_ButtonType.UP]) !== null && _inputLegends$ButtonT13 !== void 0 ? _inputLegends$ButtonT13 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.UP) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.UP] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.DOWN,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT14;

        return (_inputLegends$ButtonT14 = inputLegends[types_ButtonType.DOWN]) !== null && _inputLegends$ButtonT14 !== void 0 ? _inputLegends$ButtonT14 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.DOWN) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.DOWN] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: (0,react_facet_src.useFacetMap)(swapXYButtons => swapXYButtons ? types_ButtonType.Y : types_ButtonType.X, [], [swapXYButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT15;

        return (_inputLegends$ButtonT15 = inputLegends[types_ButtonType.X]) !== null && _inputLegends$ButtonT15 !== void 0 ? _inputLegends$ButtonT15 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.X) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.X] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: (0,react_facet_src.useFacetMap)(swapXYButtons => swapXYButtons ? types_ButtonType.X : types_ButtonType.Y, [], [swapXYButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT16;

        return (_inputLegends$ButtonT16 = inputLegends[types_ButtonType.Y]) !== null && _inputLegends$ButtonT16 !== void 0 ? _inputLegends$ButtonT16 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.Y) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.Y] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: (0,react_facet_src.useFacetMap)(swapABButtons => swapABButtons ? types_ButtonType.B : types_ButtonType.A, [], [swapABButtons]),
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT17;

        return (_inputLegends$ButtonT17 = inputLegends[types_ButtonType.A]) !== null && _inputLegends$ButtonT17 !== void 0 ? _inputLegends$ButtonT17 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.A) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.A] == null, [], [inputLegends])
    }), /*#__PURE__*/react.createElement(InputHint_InputHint, {
      button: types_ButtonType.START,
      label: (0,react_facet_src.useFacetMap)(inputLegends => {
        var _inputLegends$ButtonT18;

        return (_inputLegends$ButtonT18 = inputLegends[types_ButtonType.START]) !== null && _inputLegends$ButtonT18 !== void 0 ? _inputLegends$ButtonT18 : '';
      }, [], [inputLegends]),
      onClick: isClickable ? () => callback === null || callback === void 0 ? void 0 : callback(types_ButtonType.START) : undefined,
      hidden: (0,react_facet_src.useFacetMap)(inputLegends => inputLegends[types_ButtonType.START] == null, [], [inputLegends])
    }))
  }));
}

InputLegend_InputLegend_InputLegend.displayName = 'InputLegend';
InputLegend_InputLegend_InputLegend.Wrapper = InputLegendWrapper;
InputLegend_InputLegend_InputLegend.InputHint = InputHint_InputHint;
InputLegend_InputLegend_InputLegend.Space = InputLegendSpace;
;// CONCATENATED MODULE: ./packages/ui/src/Modal/Modal.tsx
function Modal_extends() { Modal_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Modal_extends.apply(this, arguments); }

/**
 * Narration for modals with children that are added/removed dynamically will not
 * work entirely correct. This is planned to be addressed at a later date.
 * More info: https://github.com/Mojang/minecraft-ui/pull/3278#discussion_r854986350
 */
















const preventEventPropagation = e => {
  e.stopPropagation();
};

const Modal_noop = () => {};
/**
 * ModalManagerProvider
 * -
 * Handles focus states when moving through multiple modals.
 * It currently only supports a one directional flow (so no going back to previous modals).
 *
 * onMount can be used to keep track of which Modals are mounted so we can manage
 * focusable state when going between them.
 *
 * isModalVisible can be used to inform parts of the app whether or not
 * they're behind a modal so they can do things like disable GlobalShortcuts.
 */


const ModalMountContext = (0,react.createContext)({
  isModalVisible: (0,react_facet_src.createFacet)({
    initialValue: false
  }),
  onMount: () => Modal_noop
});

function useOnModalMount(defaultFocusAlias) {
  const {
    onMount
  } = (0,react.useContext)(ModalMountContext);
  (0,react.useEffect)(() => onMount(defaultFocusAlias), [onMount, defaultFocusAlias]);
}

function useIsAnyModalVisible() {
  return (0,react.useContext)(ModalMountContext).isModalVisible;
}

function ModalFocusManagerProvider({
  children
}) {
  const [isModalVisible, setIsModalVisible] = (0,react_facet_src.useFacetState)(false);
  const value = (0,react.useMemo)(() => ({
    isModalVisible,
    onMount: () => {
      setIsModalVisible(true); // Unmount

      return () => {
        setIsModalVisible(false);
      };
    }
  }), [isModalVisible, setIsModalVisible]);
  return /*#__PURE__*/react.createElement(ModalMountContext.Provider, {
    value: value
  }, children);
}
/**
 * Modal Narration
 */


const ModalNarrationApi = (0,react.createContext)({
  getId: () => 0,
  set: () => {}
});

const useModalNarrationApi = () => (0,react.useContext)(ModalNarrationApi);

const ModalTitleText = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: ''
}));

const useModalTitleText = () => (0,react.useContext)(ModalTitleText);

const ModalBodyText = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: ''
}));

const useModalBodyText = () => (0,react.useContext)(ModalBodyText);
/**
 * Modal
 */


function Modal_Modal_Modal({
  children,
  defaultFocusAlias,
  narrationId,
  overlay = true,
  onOverlayClick,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization_useLocalization('Modal');
  const childId = (0,react.useRef)(0);
  const [narrationText, setNarrationText] = (0,react_facet_src.useFacetState)([]);
  const semanticColors = hooks_useSemanticColors(role);
  const [initialNarrationText, setInitialNarrationText] = (0,react_facet_src.useFacetState)('');
  const initialNarrationTextRef = (0,react_facet_src.useFacetRef)(initialNarrationText); // Keep a constantly updated reference to the body text. In situations where the
  // Modal.Content has no InteractivePrimitives, this body copy will be used as
  // a NarrationContext wrapper on Modal.Content.

  const bodyNarrationText = (0,react_facet_src.useFacetMap)(text => {
    const cleaned = text.filter(str => str.length > 0);
    const withComponentType = cleaned.slice(1);
    const result = withComponentType.join(' . ');
    return result;
  }, [], [narrationText]); // Take a snapshot of the body text on initial mount for initial contextual narration

  (0,react_facet_src.useFacetEffect)(text => {
    const cleaned = text.filter(str => str.length > 0);
    const withComponentType = [cleaned[0], t('.narrationModalComponentType'), ...cleaned.slice(1)];
    const result = withComponentType.join(' . ');
    setInitialNarrationText(result);
  }, [setInitialNarrationText, t], [narrationText]);
  const ref = (0,react.useRef)(null);
  const titleText = (0,react_facet_src.useFacetMemo)(text => text[0], [], [narrationText]);
  useOnModalMount();
  const getNarrationText = (0,react.useCallback)(() => initialNarrationTextRef.current !== react_facet_src.NO_VALUE ? initialNarrationTextRef.current : '', [initialNarrationTextRef]);
  const ConditionalOverlay = overlay ? Modal_Modal_Modal.Overlay : react.Fragment;
  const overlayProps = overlay ? {
    onClick: onOverlayClick
  } : {};
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(ConditionalOverlay, overlayProps, /*#__PURE__*/react.createElement(ModalTitleText.Provider, {
    value: titleText
  }, /*#__PURE__*/react.createElement(ModalBodyText.Provider, {
    value: bodyNarrationText
  }, /*#__PURE__*/react.createElement(ModalNarrationApi.Provider, {
    value: (0,react.useMemo)(() => ({
      getId: () => childId.current++,
      set: (childId, text) => setNarrationText(prev => {
        if (prev === react_facet_src.NO_VALUE) {
          return []; // Shouldn't ever happen as we default to an array
        }

        prev[childId] = text === false ? '' : text;
        return prev;
      })
    }), [setNarrationText])
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    getText: getNarrationText,
    id: `modal-${narrationId}`
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(Modal_Modal.container, semanticColors.border.base),
    onClick: preventEventPropagation
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    shouldBindFocus: true,
    delegateFocusByAlias: defaultFocusAlias,
    delegateFocusFromMemory: true
  }, children))))))));
}
/**
 * This hook should be used on child Modal components (eg. Modal.Text) to
 * help configure the narration text. It receives a unique id from the Modal
 * and uses this as an key to set the narration text at a higher level.
 */

const useSetModalNarrationText = (text, throttleThresholdMs = 0) => {
  const modalNarrationApi = useModalNarrationApi();
  const [id, setId] = (0,react_facet_src.useFacetState)(react_facet_src.NO_VALUE); // Get a unique id for this child

  (0,react.useEffect)(() => {
    // Exit early if we have an id (shouldn't happen)
    if (id.get() != react_facet_src.NO_VALUE) return;
    setId(modalNarrationApi.getId());
  }, [id, setId, modalNarrationApi]);
  const updatedAt = (0,react.useRef)(); // Set the narration text against our unique id

  (0,react_facet_src.useFacetEffect)((id, text) => {
    if (updatedAt.current == null || Date.now() - updatedAt.current > throttleThresholdMs) {
      modalNarrationApi.set(id, text);
      updatedAt.current = Date.now();
    }
  }, [modalNarrationApi, throttleThresholdMs], [id, (0,react_facet_src.useFacetWrap)(text)]);
};
/**
 * Modal Header
 */


const ModalHeader = ({
  children,
  onBack,
  onClose,
  closeButtonGamepadAlias,
  hideCloseButton,
  role = 'neutral'
}) => {
  var _hideCloseButton, _ref;

  // Set up narration context in Modal
  useSetModalNarrationText(children);
  const closeInputLegend = TitleBar_TitleBar.Buttons.Close.useLocalization().t('.inputLegend');
  const backInputLegend = TitleBar_TitleBar.Buttons.Back.useLocalization().t('.inputLegend');
  hideCloseButton = (0,react_facet_src.useFacetWrap)((_hideCloseButton = hideCloseButton) !== null && _hideCloseButton !== void 0 ? _hideCloseButton : false);
  const closeButtonWrapperClass = (0,react_facet_src.useFacetMap)(hideCloseButton => hideCloseButton ? Modal_Modal.hide : '', [], [hideCloseButton]);
  const shortcutOptions = (0,react_facet_src.useFacetMap)(hideCloseButton => ({
    button: types_ButtonType.B,
    inputLegend: onBack != null ? backInputLegend : closeInputLegend,
    disabled: hideCloseButton === true || onClose == null
  }), [onBack, onClose, closeInputLegend, backInputLegend], [hideCloseButton]);
  const closeButtonInputLegend = (0,react_facet_src.useFacetMap)(hideCloseButton => hideCloseButton ? false : closeInputLegend, [closeInputLegend], [hideCloseButton]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: shortcutOptions,
    onClick: (_ref = onBack !== null && onBack !== void 0 ? onBack : onClose) !== null && _ref !== void 0 ? _ref : Modal_noop
  }), /*#__PURE__*/react.createElement(TitleBar_TitleBar, {
    role: role,
    gamepadIndex: -2,
    left: onBack && /*#__PURE__*/react.createElement(TitleBar_TitleBar.Buttons.Back.Component, {
      onClick: onBack,
      gamepadIndex: 0
    }),
    right: onClose && /*#__PURE__*/react.createElement("fast-div", {
      className: closeButtonWrapperClass
    }, /*#__PURE__*/react.createElement(TitleBar_TitleBar.Buttons.Close.Component, {
      onClick: onClose,
      gamepadIndex: 1,
      inputLegend: closeButtonInputLegend,
      gamepadAlias: closeButtonGamepadAlias
    }))
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, children))));
};
/**
 * Modal Text
 */


const ModalText = ({
  image,
  children,
  gamepadIndex,
  narrationText,
  center = false
}) => {
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(narrationText);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText,
    className: classnames_default()(Modal_Modal.textContent, {
      [Modal_Modal.centerText]: center
    }),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), image == null ? null : /*#__PURE__*/react.createElement(react.Fragment, null, image, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement("span", {
    className: Modal_Modal.wordWrap
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: center ? 'center' : 'left'
  }, children)));
};
/**
 * Modal Paragraph
 */


const ModalParagraphs = ({
  children,
  narrationText,
  spaceBetweenParagraphs = 5,
  gamepadIndex,
  center
}) => {
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(narrationText); // Filter out conditionally rendered paragraphs passed in as false

  const filteredChildren = children.filter(child => child);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText,
    className: Modal_Modal.paragraphsWrapper,
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), filteredChildren.map((child, index) => /*#__PURE__*/react.createElement(react.Fragment, {
    key: index
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.paragraphPadding, Modal_Modal.wordWrap, {
      [Modal_Modal.centerText]: center
    })
  }, child), spaceBetweenParagraphs != null && index < filteredChildren.length - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: spaceBetweenParagraphs
  }))));
};
/**
 * Modal List
 */


const ModalList = ({
  items,
  gamepadIndex
}) => {
  return /*#__PURE__*/react.createElement(MaybeColumn, {
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: items
  }, (item, index) => {
    return /*#__PURE__*/react.createElement(ModalListInner, {
      items: items,
      item: item,
      index: index
    });
  })));
};

const ModalListInner = ({
  items,
  item,
  index
}) => {
  const showSpacing = (0,react_facet_src.useFacetMap)(items => items.length - 1 !== index, [index], [items]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ModalListItem, {
    gamepadIndex: index,
    text: item
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSpacing
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
};

const MaybeColumn = ({
  children,
  gamepadIndex
}) => {
  const hasInteractiveSibling = (0,react_facet_src.useFacetUnwrap)(useHasInteractiveSiblings());
  return hasInteractiveSibling === true ? /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: gamepadIndex
    }
  }, children) : /*#__PURE__*/react.createElement(react.Fragment, null, children);
};

const ModalListItem = ({
  gamepadIndex,
  text
}) => {
  const textWithBullet = (0,react_facet_src.useFacetMap)(text => `• ${text}`, [], [text]);
  const hasInteractiveSibling = useHasInteractiveSiblings(); // Set up narration context in Modal

  useSetModalNarrationText(text);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: hasInteractiveSibling,
    gamepadIndex: gamepadIndex,
    narrationText: text,
    className: Modal_Modal.listTextContent
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, textWithBullet));
};
/**
 * Modal Content
 */


const Content = ({
  children,
  gamepadAlias,
  scrollable = true,
  role = 'neutral80',
  scrollbarBackgroundRole,
  scrollbarClassName,
  className
}) => {
  const modalTitleText = useModalTitleText();
  const modalBodyText = useModalBodyText();
  const [hasChildInteractivePrimitives, setHasChildInteractivePrimitives] = (0,react.useState)(false);
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: modalTitleText
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticColors.background.base, semanticColors.text.base, className, {
      [Modal_Modal.contentScrollable]: scrollable
    })
  }, scrollable ? /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: -1,
    floating: true,
    emptyFocusableGamepadAlias: gamepadAlias,
    emptyFocusableNarrationText: hasChildInteractivePrimitives ? '' : modalBodyText,
    scrollbarBackgroundRole: scrollbarBackgroundRole,
    scrollbarClassName: scrollbarClassName
  }, children, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView.SiblingState, {
    callback: setHasChildInteractivePrimitives
  })) : children));
};
/**
 * Modal Buttons
 */


const Modal_Buttons = ({
  children,
  horizontal = false,
  role = 'inherit',
  header
}) => {
  const GamepadContainer = horizontal ? GamepadRow_GamepadRow : GamepadColumn_GamepadColumn;
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement(GamepadContainer, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1000
  }, header, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.buttons, semanticColors.background.base, {
      [Modal_Modal.buttonsHorizontal]: horizontal
    })
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    left: false,
    right: false
  }), children));
};
/**
 * Modal Overlay
 */


const Overlay = ({
  onClick,
  children,
  role = 'inherit'
}) => {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Modal_Modal.overlay, semanticColors.overlay.base),
    onClick: onClick
  }, /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.wrapper
  }, children, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null)));
};
/**
 * Modal Progress
 */


function ModalProgress({
  percentage
}) {
  const {
    t
  } = useLocalization_useLocalization('Modal');
  const percentageFacet = (0,react_facet_src.useFacetWrap)(percentage);
  const percentageText = (0,react_facet_src.useFacetMap)(percentageValue => t('.progressPercentage', [`${Math.round(percentageValue * 100)}`]), [t], [percentageFacet]); // Set up narration context in Modal

  useSetModalNarrationText(percentageText, 2000);
  return /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.progress
  }, /*#__PURE__*/react.createElement(ProgressBar_ProgressBar_ProgressBar, {
    percentage: percentageFacet
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, percentageText));
}
/**
 * Modal Spinner
 */


const ModalSpinner = () => {
  return /*#__PURE__*/react.createElement("div", {
    className: Modal_Modal.spinner
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null));
};
/**
 * Modal Checkbox
 */


const ModalCheckbox = props => {
  var _props$gamepadIndex;

  return /*#__PURE__*/react.createElement(Checkbox_Checkbox, Modal_extends({}, props, {
    gamepad: {
      index: (_props$gamepadIndex = props.gamepadIndex) !== null && _props$gamepadIndex !== void 0 ? _props$gamepadIndex : 0
    },
    small: true
  }));
};
/**
 * Modal Text Field
 */


const ModalTextField = props => {
  return /*#__PURE__*/react.createElement(TextField_TextField, Modal_extends({}, props, {
    transparent: true
  }));
};

Modal_Modal_Modal.Header = ModalHeader;
Modal_Modal_Modal.Text = ModalText;
Modal_Modal_Modal.Paragraphs = ModalParagraphs;
Modal_Modal_Modal.List = ModalList;
Modal_Modal_Modal.Content = Content;
Modal_Modal_Modal.Buttons = Modal_Buttons;
Modal_Modal_Modal.Overlay = Overlay;
Modal_Modal_Modal.Progress = ModalProgress;
Modal_Modal_Modal.Spinner = ModalSpinner;
Modal_Modal_Modal.Checkbox = ModalCheckbox;
Modal_Modal_Modal.TextField = ModalTextField;
Modal_Modal_Modal.FocusManager = ModalFocusManagerProvider;
Modal_Modal_Modal.useIsAnyModalVisible = useIsAnyModalVisible;
;// CONCATENATED MODULE: ./packages/engine/src/trigger.ts

/**
 * Internal method to trigger engine events. Only use it if you know exactly what you are doing.
 *
 * You most likely can solve your problem by using just Facets instead.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

const trigger_trigger = (type, ...args) => {
  return engine.trigger(type, ...args);
};
;// CONCATENATED MODULE: ./packages/engine/src/FunctionalTestsInstrumentation.tsx








var InputMode;

(function (InputMode) {
  InputMode[InputMode["Undefined"] = 0] = "Undefined";
  InputMode[InputMode["Mouse"] = 1] = "Mouse";
  InputMode[InputMode["Touch"] = 2] = "Touch";
  InputMode[InputMode["GamePad"] = 3] = "GamePad";
  InputMode[InputMode["MotionController"] = 4] = "MotionController";
  InputMode[InputMode["Count"] = 5] = "Count";
})(InputMode || (InputMode = {}));

const inputModeInputMethodMap = new Map([[InputMode.Mouse, types_InputMethod.MOUSE], [InputMode.Touch, types_InputMethod.TOUCH], [InputMode.GamePad, types_InputMethod.GAMEPAD], [InputMode.MotionController, types_InputMethod.MOTION]]);

const getBoundingBox = element => {
  const bounds = element.getBoundingClientRect();
  return {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height,
    __Type: 'core.BoundingBox'
  };
};

const getDomElement = testId => {
  var _element$textContent;

  const element = document.querySelector(`[data-testid="${testId}"]`);
  return element == null ? null : {
    testId,
    textContent: (_element$textContent = element.textContent) !== null && _element$textContent !== void 0 ? _element$textContent : '',
    bounds: getBoundingBox(element),
    __Type: 'core.DomElement'
  };
};
/**
 * Used to initialize the functional test API used on the backend side to
 * be able to query the DOM for information to make test assertions on.
 * Returns a ready status once the infrastructure is initialized.
 */


const FunctionalTestsInstrumentation = ({
  children
}) => {
  const getFocusedId = useGetFocusedId();
  const inputFacetRef = useFacetRef(useSharedFacet(inputFacet));
  /**
   * Converts focusedId to a string to make the C++ type easier
   */

  const getFocusedIdAsString = useCallback(() => {
    const focusedId = getFocusedId();
    return focusedId != null ? `${focusedId}` : undefined;
  }, [getFocusedId]);
  useEffect(() => {
    const cleanupCallbacks = [onReturnValueEvent('core:test:getFocusedId', getFocusedIdAsString), onReturnValueEvent('core:test:getElement', getDomElement),
    /**
     * THIS IS NOT A PATTERN WE WANT TO REPLICATE IN THE FUTURE
     *
     * This was a custom event introduced to allow overriding the value of a shared facet.
     *
     * The pattern we want to promote in the future is to instead just have the shared
     * facet contain the "fake value" instead. The shared facet values are already controlled by
     * the engine.
     */
    onEvent('core:test:setInputMode', inputMode => {
      const inputFacet = inputFacetRef.current;
      if (inputFacet == NO_VALUE) return;
      const currentInputType = inputModeInputMethodMap.get(inputMode);

      if (currentInputType == null) {
        console.warn(`Unable to map input method: ${inputMode}`);
        return;
      }

      const overriddenInputFacet = {
        acceptInputFromAllControllers: inputFacet.acceptInputFromAllControllers,
        gameControllerId: inputFacet.gameControllerId,
        swapABButtons: inputFacet.swapABButtons,
        swapXYButtons: inputFacet.swapXYButtons,
        currentInputType: currentInputType
      }; // Trigger another engine event to simulate as if the InputFacet have changed
      // to the desired overwritten value.

      trigger(`facet:updated:${INPUT_FACET}`, overriddenInputFacet);
    })];
    return () => cleanupCallbacks.forEach(cb => cb());
  }, [inputFacetRef, getFocusedIdAsString]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, children);
};
;// CONCATENATED MODULE: ./packages/engine/src/Application.tsx























function Application({
  children,
  defaultRoute,
  developmentTranslations,
  errorComponent,
  gamepadAdapterVersion = GamepadAdapterVersion.LEGACY,
  scalingMode = 'default',
  keyboardGamepadMap = DEFAULT_KEYBOARD_GAMEPAD_MAP,
  isInputLegendClickable,
  semanticCollection,
  sharedFacetDriver = requestFacet,
  deviceInformationOptions = {},
  shouldUseNarrationQueueSystem = false
}) {
  /**
   * Only enable the Test Infrastructure if needed
   */
  const MaybeFunctionalTestsInstrumentation =  false ? 0 : react.Fragment;
  /**
   * Event that notifies the backend engine that the Switch was unable to match any route.
   *
   * This is currently used by backend to consider the frontend to be in an "idle state".
   *
   * When a Gameface screen goes into this "idle state", the backend can safely stop updating it,
   * until a new route is pushed.
   *
   * For more information check the ticket, and pull requests.
   * - https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/930195
   */

  const handleNotFound = (0,react.useCallback)(() => {
    engineWrapper_engine.trigger('core:routing:not-found');
  }, []);
  return /*#__PURE__*/react.createElement(SemanticCollectionsManager, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: semanticCollection
  }, /*#__PURE__*/react.createElement(react_facet_src.SharedFacetDriverProvider, {
    value: sharedFacetDriver
  }, /*#__PURE__*/react.createElement(GamepadAdapterProvider, {
    version: gamepadAdapterVersion
  }, /*#__PURE__*/react.createElement(LocalizationEngineProvider, {
    developmentTranslations: developmentTranslations
  }, /*#__PURE__*/react.createElement(ControllerSpecificButtonTranslationsProvider, null, /*#__PURE__*/react.createElement(GamepadPolyfillInitializer, null, /*#__PURE__*/react.createElement(DeviceInformationEngineProvider, deviceInformationOptions, /*#__PURE__*/react.createElement(SplitScreenEngineProvider, null, /*#__PURE__*/react.createElement(SafeZoneEngineProvider, null, /*#__PURE__*/react.createElement(FeatureFlagsEngineProvider, null, /*#__PURE__*/react.createElement(SoundEngineProvider, null, /*#__PURE__*/react.createElement(UIEngineProvider, {
    scalingMode: scalingMode
  }, /*#__PURE__*/react.createElement(ErrorBoundary, {
    errorComponent: errorComponent
  }, /*#__PURE__*/react.createElement(TextFieldEngineProvider, null, /*#__PURE__*/react.createElement(RouterEngineProvider, {
    keyboardGamepadMap: keyboardGamepadMap,
    isInputLegendClickable: isInputLegendClickable
  }, /*#__PURE__*/react.createElement(NarratorEngineProvider, {
    shouldUseQueueSystem: shouldUseNarrationQueueSystem
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.FocusManager, null, /*#__PURE__*/react.createElement(RenderTrackingEngineProvider, null, /*#__PURE__*/react.createElement(ModalManager, null, /*#__PURE__*/react.createElement(MaybeFunctionalTestsInstrumentation, null, /*#__PURE__*/react.createElement(Switch, {
    onNotFound: handleNotFound
  }, [...react.Children.toArray(children),
  /*#__PURE__*/
  // Switch needs to have Redirect or Route as its direct children
  react.createElement(Redirect, {
    from: "/",
    to: defaultRoute,
    key: "default-redirect"
  })]))))))))))))))))))))));
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/defineFakeFacet.ts

function defineFakeFacet(facetName, fakeConstructor) {
  const update = data => {
    // Delay updating the facet state until the next frame to better mimic how state changes works in the real engine
    requestAnimationFrame(() => engine.trigger(`facet:updated:${facetName}`, data));
  };

  const onError = errorCode => {
    engine.trigger(`facet:error:${facetName}`, errorCode);
  };

  engine.on('facet:request', facets => {
    if (facets.indexOf(facetName) !== -1) {
      // Delay the result of the facet request to the next frame to simulate the real engine behavior
      requestAnimationFrame(() => {
        fakeConstructor(update, onError);
      });
    }
  });
}
;// CONCATENATED MODULE: ./packages/engine/src/facets/performanceSharedFacet.ts

/**
 * Shared facet used for performance measurements.
 */

const PERFORMANCE_SHARED_FACET = 'core.performanceFacet';
/**
 * We don't want to have this exposed as a regular sharedFacet, since we will used this Facet on performance test screens,
 * where we usually don't have any FacetProvider infrastructure.
 */

const observePerformanceSharedFacet = update => {
  const updateEventName = `facet:updated:${PERFORMANCE_SHARED_FACET}`;
  engine.on(updateEventName, update);
  engine.trigger('facet:request', [PERFORMANCE_SHARED_FACET]);
  return () => {
    engine.off(updateEventName, update);
  };
};
;// CONCATENATED MODULE: ./packages/engine/src/facets/socialFacet.ts

const SOCIAL_FACET = 'core.social';
/**
 * React Hook that requests the facet
 */

const socialFacet = (0,react_facet_src.sharedFacet)(SOCIAL_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/user.ts

const USER_FACET = 'core.user';
/**
 * React Hook that requests the facet
 */

const userFacet = (0,react_facet_src.facet)(USER_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/facets/vrModeSharedFacet.ts

let VRMode;

(function (VRMode) {
  VRMode[VRMode["NoVR"] = 0] = "NoVR";
  VRMode[VRMode["VRFull3DWorld"] = 1] = "VRFull3DWorld";
  VRMode[VRMode["VRVirtual2DScreen"] = 2] = "VRVirtual2DScreen";
})(VRMode || (VRMode = {}));

const VR_MODE_SHARED_FACET = 'core.vrMode';
const vrModeSharedFacet = (0,react_facet_src.sharedFacet)(VR_MODE_SHARED_FACET);
;// CONCATENATED MODULE: ./packages/engine/src/render.ts

const render = (element, container) => {
  return (0,react_facet_src.render)(element, container);
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/animationFacet.ts
const animationFacetDefaultState = {
  screenAnimationEnabled: true,
  shouldFlipOrigin: false
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/customScalingFacet.ts
const customScalingDefaultState = {
  scalingModeOverride: undefined,
  fixedGuiScaleModifier: 0,
  MIN_FIXED_GUI_SCALE_MODIFIER: -3,
  MAX_FIXED_GUI_SCALE_MODIFIER: 4,
  guiAccessibilityScaling: false
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/setup/utils.ts



let detectInputInitialized = false;
const onMouseHandlers = (/* unused pure expression or super */ null && ([]));
const onTouchHandlers = (/* unused pure expression or super */ null && ([]));
const onGamepadHandlers = (/* unused pure expression or super */ null && ([]));

const initializeDetectInput = () => {
  detectInputInitialized = true; // Setup touch detection
  // We keep track of the time stamp of the last touchend event since it will also trigger
  // a mousedown event and we want to avoid calling the detect mouse handlers in those cases.

  let timeStampLastTouchEndEvent = -1;

  const shouldIgnoreMouseEvent = event => timeStampLastTouchEndEvent === event.timeStamp;

  const touchDetected = () => {
    onTouchHandlers.forEach(handler => handler());
  };

  const handleTouchEnd = event => {
    timeStampLastTouchEndEvent = event.timeStamp;
    touchDetected();
  };

  window.addEventListener('touchstart', touchDetected);
  window.addEventListener('touchend', handleTouchEnd); // Setup mouse detection

  const mouseDetected = event => {
    if (shouldIgnoreMouseEvent(event)) {
      return;
    }

    onMouseHandlers.forEach(handler => handler());
  };

  window.addEventListener('mousemove', mouseDetected);
  window.addEventListener('mousedown', mouseDetected);
  window.addEventListener('wheel', mouseDetected); // Setup gamepad detection

  let cleanupGamepadPolyfill = () => undefined;

  if (!isPolyfillInitialized()) {
    cleanupGamepadPolyfill = initializePolyfill();
  }

  const cleanupGamepad = onGamepadInput(gamepads => {
    onGamepadHandlers.forEach(handler => handler(gamepads));
  }); // Clean up handlers ("beforeunload" only works in the browser, not in the player)

  window.addEventListener('beforeunload', () => {
    window.removeEventListener('touchstart', touchDetected);
    window.removeEventListener('touchend', handleTouchEnd);
    window.removeEventListener('mousemove', mouseDetected);
    window.removeEventListener('mousedown', mouseDetected);
    window.removeEventListener('wheel', mouseDetected);
    cleanupGamepad();
    cleanupGamepadPolyfill();
  });
};

const utils_detectInput = ({
  onMouse,
  onTouch,
  onGamepad
}) => {
  if (!detectInputInitialized) initializeDetectInput();
  onMouseHandlers.push(onMouse);
  onTouchHandlers.push(onTouch);
  onGamepadHandlers.push(onGamepad);
}; // Not by any means a complete way of checking if this is a touch device, but good enough for our fake facets
// The gameface player is always exposing ontouchstart, but we are only running the player for desktop, so setting it to false in that case.

const IS_TOUCH_DEVICE =  false && 0;
const DEFAULT_PLATFORM = IS_TOUCH_DEVICE ? Platform.IOS : Platform.WIN32;
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/deviceInformationFacet.ts


function deviceInformationFacet_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function deviceInformationFacet_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { deviceInformationFacet_ownKeys(Object(source), true).forEach(function (key) { deviceInformationFacet_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { deviceInformationFacet_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function deviceInformationFacet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




const GUI_SCALE_VALUES = [1, 2, 3, 4, 5, 6, 7, 8];

function getDefaultSupportedInputMethods(platform = DEFAULT_PLATFORM) {
  switch (platform) {
    case Platform.IOS:
    case Platform.GOOGLE:
    case Platform.AMAZON_HANDHELD:
      return [types_InputMethod.TOUCH, types_InputMethod.GAMEPAD, types_InputMethod.MOUSE];

    case Platform.NX_TV:
      return [types_InputMethod.GAMEPAD];

    case Platform.NX_HANDHELD:
      return [types_InputMethod.GAMEPAD, types_InputMethod.TOUCH];

    case Platform.UWP:
    case Platform.XBOX:
    case Platform.PS4:
    case Platform.GEARVR:
    case Platform.AMAZON_TV:
    case Platform.PS5:
    case Platform.WIN32:
    case Platform.MACOS:
    default:
      return [types_InputMethod.GAMEPAD, types_InputMethod.MOUSE];
  }
}

const deviceInformationFacetDefaultState = {
  inputMethods: getDefaultSupportedInputMethods(),
  platform: DEFAULT_PLATFORM,
  arvrPlatform: ARVRPlatform.ARVR_None,
  isLowMemoryDevice: false,
  guiScaleModifier: 0,
  guiScaleBase: getGuiScaleIndexForLargeScreen(window.innerWidth, window.innerHeight),
  pixelsPerMillimeter: 3.779527559,
  // 96dpi,
  displayWidth: 1920,
  displayHeight: 1080,
  storageSize: Math.pow(1024, 4),
  storageUsed: Math.pow(1024, 4) * 0.75,
  isStorageFull: false,
  isStorageLow: false,
  storageType: StorageType.NONE,
  isUsingAlternativeStorage: false,
  isOnline: true
};
const deviceInformationFacetLowStorageState = deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
  isStorageLow: true
});
function deviceInformationFacetWithPlatform(platform) {
  return deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
    platform: platform
  });
}
const deviceInformationAppDataFacetState = deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
  storageType: StorageType.APPDATA
});
const deviceInformationExternalStorageFacetState = deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
  storageType: StorageType.EXTERNAL
});
const deviceInformationFacetOffline = deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), {}, {
  isOnline: false
});
const deviceInformationSharedFacetCustomState = overrides => deviceInformationFacet_objectSpread(deviceInformationFacet_objectSpread({}, deviceInformationFacetDefaultState), overrides);
function deviceInformationSharedFacetFactory(proxy, {
  storageSize,
  storageUsed,
  isStorageFull,
  isStorageLow
} = deviceInformationFacetDefaultState) {
  Object.assign(proxy, _clone(deviceInformationFacetDefaultState));
  window.addEventListener('resize', () => {
    proxy.guiScaleBase = getGuiScaleIndexForLargeScreen(window.innerWidth, window.innerHeight);
  });
  proxy.storageSize = storageSize !== null && storageSize !== void 0 ? storageSize : proxy.storageSize;
  proxy.storageUsed = storageUsed !== null && storageUsed !== void 0 ? storageUsed : proxy.storageUsed;
  proxy.isStorageFull = isStorageFull !== null && isStorageFull !== void 0 ? isStorageFull : proxy.isStorageFull;
  proxy.isStorageLow = isStorageLow !== null && isStorageLow !== void 0 ? isStorageLow : proxy.isStorageLow;
  detectInput({
    onMouse: () => {
      if (!proxy.inputMethods.includes(InputMethod.MOUSE)) {
        proxy.inputMethods.push(InputMethod.MOUSE);
      }
    },
    onTouch: () => {
      if (!proxy.inputMethods.includes(InputMethod.TOUCH)) {
        proxy.inputMethods.push(InputMethod.TOUCH);
      }
    },
    onGamepad: () => {
      if (!proxy.inputMethods.includes(InputMethod.GAMEPAD)) {
        proxy.inputMethods.push(InputMethod.GAMEPAD);
      }
    }
  });
  return proxy;
}

function getGuiScaleIndexForLargeScreen(width, height) {
  const widthNeeded = 376;
  const heightNeeded = 250;
  const widthScale = width / widthNeeded;
  const heightScale = height / heightNeeded; // This will ensure we are using an allowed GUI SCALE.  It will clamp to the biggest available GUI SCALE that is smaller or equal to the desired one

  const index = getGuiScaleIndex(Math.min(heightScale, widthScale));
  const scale = GUI_SCALE_VALUES[index];
  return scale;
}

function getGuiScaleIndex(scale) {
  let scaleIndex = 0;
  const guiScaleSize = GUI_SCALE_VALUES.length;

  for (let index = 0; index < guiScaleSize; ++index) {
    if (resolveGuiScale(index) > scale) {
      break;
    }

    scaleIndex = index;
  }

  return scaleIndex;
}

function resolveGuiScale(index) {
  const clampedIndex = Math.min(GUI_SCALE_VALUES.length - 1, Math.max(0, index));
  return GUI_SCALE_VALUES[clampedIndex];
}
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/featureFlagsFacet.ts

const featureFlagsFacetDefaultState = {
  flags: ['vanilla.achievementsReward', 'vanilla.editor.enableUI', 'vanilla.serverTab', UNLOCKS_RECIPES_FEATURE_FLAG, 'vanilla.friendsDrawer', 'vanilla.debugDrawer', 'core.hasRealmsEnabled', 'vanilla.playScreenRealmsTab']
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/inputFacet.ts

const inputFacetDefaultState = {
  acceptInputFromAllControllers: true,
  gameControllerId: '0',
  swapABButtons: false,
  swapXYButtons: false,
  currentInputType: types_InputMethod.GAMEPAD
};
// EXTERNAL MODULE: ./node_modules/printf/lib/printf.js
var printf = __webpack_require__(15523);
var printf_default = /*#__PURE__*/__webpack_require__.n(printf);
;// CONCATENATED MODULE: ./packages/engine/src/developmentTranslations.ts
function getDevelopmentTranslation(key) {
  var _window$__globalDevCo;

  /**
   * Global variable containing all the development translations
   * It is populated via the Webpack loader configured to handle translatinos.json files
   */
  const translations = (_window$__globalDevCo = window.__globalDevCoreUITranslations) !== null && _window$__globalDevCo !== void 0 ? _window$__globalDevCo : {};
  return translations[key];
}
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/localeFacet.ts


const localeFacetDefaultState = {
  locale: 'en_US',

  formatDate(timestampInSeconds) {
    const date = new Date(timestampInSeconds * 1000);
    return `${date.toLocaleDateString()}`;
  },

  translate(key) {
    const translation = getDevelopmentTranslation(key);

    if (translation == null) {
      console.error(`Missing translation for key "${key}"`);
      return key;
    }

    return translation;
  },

  translateWithParameters(key, params) {
    const translation = getDevelopmentTranslation(key);

    if (translation == null) {
      console.error(`Missing translation for key "${key}"`);
      return key;
    }

    return printf_default()(translation, ...params);
  }

};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/safeZoneFacet.ts
const safeZoneFacetDefaultState = {
  safeAreaX: 1,
  safeAreaY: 1,
  screenPositionX: 0,
  screenPositionY: 0
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/splitScreenFacet.ts

const splitScreenFacetDefaultState = {
  numActivePlayers: 1,
  splitScreenPosition: 0,
  splitScreenDirection: SplitScreen_SplitScreenDirection.HORIZONTAL
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/images/templateAlex.png
const templateAlex_namespaceObject = __webpack_require__.p + "assets/templateAlex-f66e6.png";
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/userFacet.ts

const userFacetDefaultState = {
  userName: 'Alex',
  profilePictureUrl: templateAlex_namespaceObject
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/vrMode.ts

const vrModeSharedFacetDefaultState = {
  mode: VRMode.NoVR
};
const vrModeSharedFacetRealityState = {
  mode: VRMode.VRFull3DWorld
};
;// CONCATENATED MODULE: ./packages/engine/src/dev/fixtures/index.ts










;// CONCATENATED MODULE: ./packages/engine/src/index.ts






















 // NOTE: This is fine to export as long as fixtures doesn't define fake facets globally






// Used for testing

// EXTERNAL MODULE: ./games/vanilla/translations/src/en_US.lang
var en_US = __webpack_require__(14290);
var en_US_default = /*#__PURE__*/__webpack_require__.n(en_US);
// EXTERNAL MODULE: ./games/vanilla/translations/src/editor/en_US.lang
var editor_en_US = __webpack_require__(25752);
var editor_en_US_default = /*#__PURE__*/__webpack_require__.n(editor_en_US);
// EXTERNAL MODULE: ./packages/ui/src/uiTranslations/en_US.lang
var uiTranslations_en_US = __webpack_require__(89592);
var uiTranslations_en_US_default = /*#__PURE__*/__webpack_require__.n(uiTranslations_en_US);
// EXTERNAL MODULE: ./packages/ui-internal/src/uiInternalTranslations/en_US.lang
var uiInternalTranslations_en_US = __webpack_require__(62052);
var uiInternalTranslations_en_US_default = /*#__PURE__*/__webpack_require__.n(uiInternalTranslations_en_US);
;// CONCATENATED MODULE: ./games/vanilla/translations/src/index.ts
function src_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function src_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { src_ownKeys(Object(source), true).forEach(function (key) { src_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { src_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






const vanillaTranslations = src_objectSpread(src_objectSpread({}, (en_US_default())), (editor_en_US_default()));

const allTranslationsUsedByVanilla = src_objectSpread(src_objectSpread(src_objectSpread({}, vanillaTranslations), (uiTranslations_en_US_default())), (uiInternalTranslations_en_US_default()));


;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useTimeout.tsx

/**
 * Hook that returns false and waits for a given duration before returning true.
 * Can be cancelled by passing true to the shouldCancel parameter.
 */

function useTimeout(shouldCancel, duration) {
  const [hasTimedOut, setTimedOut] = (0,react_facet_src.useFacetState)(false);
  (0,react_facet_src.useFacetEffect)(shouldCancel => {
    if (shouldCancel) return;
    const timeout = setTimeout(() => {
      setTimedOut(true);
    }, duration);
    return () => {
      clearTimeout(timeout);
    };
  }, [duration, setTimedOut], [shouldCancel]);
  return hasTimedOut;
}
;// CONCATENATED MODULE: ./packages/react-render-tracking/src/RenderTrackingEvent.tsx




/**
 * Used to fire a contentful (the page is starting to show something) or meaningful (the page is useable) paint event.
 */
function RenderTrackingEvent_RenderTrackingEvent({
  type,
  renderingCompleted
}) {
  const renderTrackingApi = useRenderTrackingApi();
  const isRouteActive = useRouteActive();
  const renderingCompletedFacet = (0,react_facet_src.useFacetWrap)(renderingCompleted);
  (0,react_facet_src.useFacetEffect)((isRouteActive, renderingCompleted) => {
    if (!renderingCompleted || !isRouteActive) return; // We fire this after a frame to allow for any
    // <RenderTrackingDelay> components to initialise

    const rafId = requestAnimationFrame(() => {
      if (type === 'contentful') {
        renderTrackingApi.contentfulPaint();
      } else {
        renderTrackingApi.meaningfulPaint();
      }
    });
    return () => {
      cancelAnimationFrame(rafId);
    };
  }, [renderTrackingApi, type], [isRouteActive, renderingCompletedFacet]);
  return null;
}
;// CONCATENATED MODULE: ./packages/react-feature-flag/src/useFeatureFlag.tsx

function useFeatureFlag(featureFlag) {
  const flags = useFlags(); // Disable lint check because we actually want each value in the array
  // eslint-disable-next-line react-hooks/exhaustive-deps

  return flags.indexOf(featureFlag) != -1;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/emptyStatesAllCompleted.png
const emptyStatesAllCompleted_namespaceObject = __webpack_require__.p + "assets/emptyStatesAllCompleted-0fcd8.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/emptyStatesNoProgress.png
const emptyStatesNoProgress_namespaceObject = __webpack_require__.p + "assets/emptyStatesNoProgress-02663.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/images/error-message.png
const error_message_namespaceObject = __webpack_require__.p + "assets/error-message-1ee9c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useImageBreakpoint.ts

/**
 * Given a wide column value, a narrow column value and the image width in px,
 * it calls useIsWindowNarrow with the screen pixel value for when to break from wide to narrow
 *
 * Note that this function is currently only handling one case!
 *
 * @param wide amount of columns
 * @param narrow amount of columns
 * @param width image width in px
 * @returns if the image should use the narrow style
 */

const useImageBreakpoint = ({
  wide,
  narrow,
  width
}) => {
  let imageBreakpoint;
  if (wide === 8 && (narrow === 6 || narrow === 5) && width >= 220 && width <= 260) imageBreakpoint = 102;else {
    console.warn('useImageBreakpoint() is being used for an unhandled scenario. You should add a case for this, or you might not need to use getImageBreakpoint() at all.');
    imageBreakpoint = 70;
  }
  return useIsWindowNarrow(imageBreakpoint);
};
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/find.ts
function find_find(array, f) {
  for (let i = 0; i < array.length; i++) {
    if (f(array[i], i, array)) {
      return array[i];
    }
  }
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/achievementsFacet.ts


const ACHIEVEMENTS_FACET = 'vanilla.achievements';
/**
 * Feature flag to enable rendering of achievements rewards
 * Currently Persona work is not completed, we will enable this once that is done.
 * https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/333996
 */

const REWARD_FEATURE_FLAG = 'vanilla.achievementsReward';
let achievementsFacet_AchievementFacetStatus;

(function (AchievementFacetStatus) {
  AchievementFacetStatus[AchievementFacetStatus["LOADING"] = 0] = "LOADING";
  AchievementFacetStatus[AchievementFacetStatus["LOADED"] = 1] = "LOADED";
})(achievementsFacet_AchievementFacetStatus || (achievementsFacet_AchievementFacetStatus = {}));

const achievementsFacet = (0,react_facet_src.sharedFacet)(ACHIEVEMENTS_FACET);
const groupedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return groupAchievements(achievementsData.data.achievements);
}, [achievementsFacet]);
const lockedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return filterLocked(achievementsData.data.achievements);
}, [achievementsFacet]);
const lockedOrInProgressAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return filterLockedOrInProgress(achievementsData.data.achievements);
}, [achievementsFacet]);
const completedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return sortCompleted(achievementsData.data.achievements);
}, [achievementsFacet]);
const isAchievementsLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status === achievementsFacet_AchievementFacetStatus.LOADED;
}, [achievementsFacet]);
const achievementDetailSelector = (0,react_facet_src.sharedDynamicSelector)(id => [(facet, isLoaded) => {
  const achievement = find_find(facet.data.achievements, achievement => achievement.id === id);
  return {
    isLoaded,
    achievement
  };
}, [achievementsFacet, isAchievementsLoadedSelector]]);
const achievementsSummarySelector = (0,react_facet_src.sharedSelector)(facet => {
  const summary = {
    loaded: facet.status === achievementsFacet_AchievementFacetStatus.LOADED,
    unlocked: facet.data.achievementsUnlocked,
    total: facet.data.maxAchievements,
    inProgressCount: facet.data.achievements.filter(isAchievementInProgress).length,
    rewardsTotal: countRewards(facet.data.achievements),
    rewardsUnlocked: countUnlockedRewards(facet.data.achievements),
    gamerScore: facet.data.currentGamerScore,
    maxGamerScore: facet.data.maxGamerScore,
    hoursPlayed: facet.data.hoursPlayed
  };
  return summary;
}, [achievementsFacet], react_facet_src.shallowObjectEqualityCheck);
function isAchievementInProgress(achievement) {
  return achievement.isLocked && achievement.progress > 0;
}
function isAchievementCompleted(achievement) {
  return !achievement.isLocked;
}
function isAchievementLockedOrInProgress(achievement) {
  return achievement.isLocked;
}
function isAchievementLocked(achievement) {
  return achievement.isLocked && !achievement.progress;
}
function isAchievementRewardOwned(achievement) {
  return !!(!achievement.isLocked || achievement.isRewardOwned);
}
function countUnlockedRewards(achievements) {
  return achievements.filter(achievement => achievement.hasReward && isAchievementRewardOwned(achievement)).length;
}
function countRewards(achievements) {
  return achievements.filter(achievement => achievement.hasReward).length;
}
function sortCompleted(achievements) {
  return achievements.filter(isAchievementCompleted).sort(compareByDateUnlockedDescending);
}
function filterLocked(achievements) {
  return achievements.filter(isAchievementLocked);
}
function filterLockedOrInProgress(achievements) {
  return achievements.filter(isAchievementLockedOrInProgress).sort(compareProgressDescending);
}
function groupAchievements(achievements) {
  const inProgress = [];
  const completedUnsorted = [];
  const lockedUnsorted = [];
  const suggested = [];
  achievements.forEach(achievement => {
    if (isAchievementLocked(achievement)) {
      lockedUnsorted.push(achievement);
      suggested.push(achievement);
    } else if (isAchievementCompleted(achievement)) {
      completedUnsorted.push(achievement);
    } else {
      inProgress.push(achievement);
      suggested.push(achievement);
    }
  }); // Sorts the inProgress array in-place

  inProgress.sort(compareProgressDescending);
  suggested.sort(compareBySuggestedOrderDescending);
  const locked = lockedUnsorted;
  const completed = sortCompleted(completedUnsorted);
  return {
    inProgress,
    locked,
    completed,
    suggested
  };
}
/**
 * Compare two achievements progress.
 * Considers achievements with rewards first than those without.
 */

function compareProgressDescending(achievementA, achievementB) {
  if (!achievementA.hasReward && achievementB.hasReward) {
    return 1;
  }

  if (achievementA.hasReward && !achievementB.hasReward) {
    return -1;
  }

  if (achievementA.progress < achievementB.progress) {
    return 1;
  }

  if (achievementA.progress > achievementB.progress) {
    return -1;
  }

  return 0;
}
/**
 * Compare two achievements by completed date. Latest first.
 */

function compareByDateUnlockedDescending(achievementA, achievementB) {
  if (achievementA.dateUnlocked < achievementB.dateUnlocked) {
    return 1;
  }

  if (achievementA.dateUnlocked > achievementB.dateUnlocked) {
    return -1;
  }

  return 0;
}
function compareBySuggestedOrderDescending(achievementA, achievementB) {
  return achievementA.suggestedOrder - achievementB.suggestedOrder;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/buildSettingsFacet.ts

const BUILD_SETTINGS_FACET = 'vanilla.buildSettings';
const buildSettingsFacet = (0,react_facet_src.sharedFacet)(BUILD_SETTINGS_FACET);
const isDevBuildSelector = (0,react_facet_src.sharedSelector)(facet => facet.isDevBuild, [buildSettingsFacet]);
const isEduBuildSelector = (0,react_facet_src.sharedSelector)(facet => facet.isEduBuild, [buildSettingsFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/clipboardFacet.ts

const CLIPBOARD_FACET = 'vanilla.clipboard';
const clipboardFacet_clipboardFacet = (0,react_facet_src.sharedFacet)(CLIPBOARD_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/compareGameVersions.ts
// returns < 0 if lhs is older than rhs, > 0 if lhs is newer, and 0 if they are equal
function compareGameVersions(lhs, rhs) {
  if (lhs.major - rhs.major !== 0) {
    return lhs.major - rhs.major;
  }

  if (lhs.minor - rhs.minor !== 0) {
    return lhs.minor - rhs.minor;
  }

  if (lhs.patch - rhs.patch !== 0) {
    return lhs.patch - rhs.patch;
  }

  if (lhs.revision - rhs.revision !== 0) {
    return lhs.revision - rhs.revision;
  }

  return 0;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/createNewWorldFacet.ts

let DifficultyEnum;

(function (DifficultyEnum) {
  DifficultyEnum[DifficultyEnum["PEACEFUL"] = 0] = "PEACEFUL";
  DifficultyEnum[DifficultyEnum["EASY"] = 1] = "EASY";
  DifficultyEnum[DifficultyEnum["NORMAL"] = 2] = "NORMAL";
  DifficultyEnum[DifficultyEnum["HARD"] = 3] = "HARD";
})(DifficultyEnum || (DifficultyEnum = {}));

let DaylightCycleEnum;

(function (DaylightCycleEnum) {
  DaylightCycleEnum[DaylightCycleEnum["NORMAL"] = 0] = "NORMAL";
  DaylightCycleEnum[DaylightCycleEnum["ALWAYS_DAY"] = 1] = "ALWAYS_DAY";
  DaylightCycleEnum[DaylightCycleEnum["LOCK_TIME"] = 2] = "LOCK_TIME";
})(DaylightCycleEnum || (DaylightCycleEnum = {}));

let ExperimentalFeatureCategory;

(function (ExperimentalFeatureCategory) {
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["GAMEPLAY"] = 0] = "GAMEPLAY";
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["ADD_ON_CREATORS"] = 1] = "ADD_ON_CREATORS";
  ExperimentalFeatureCategory[ExperimentalFeatureCategory["INTERNAL_TESTS"] = 2] = "INTERNAL_TESTS";
})(ExperimentalFeatureCategory || (ExperimentalFeatureCategory = {}));

let GeneralMultiplayerWarningStateEnum;

(function (GeneralMultiplayerWarningStateEnum) {
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["NONE"] = 0] = "NONE";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["CHECK_INTERNET_CONNECTION"] = 1] = "CHECK_INTERNET_CONNECTION";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION"] = 2] = "DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY"] = 3] = "LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY"] = 4] = "MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED"] = 5] = "MULTIPLAYER_PRIVILEGES_BLOCKED";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE"] = 6] = "MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["CROSS_PLATFORM_DISABLED"] = 7] = "CROSS_PLATFORM_DISABLED";
  GeneralMultiplayerWarningStateEnum[GeneralMultiplayerWarningStateEnum["NON_MULTIPLAYER_SKIN_EQUIPPED"] = 8] = "NON_MULTIPLAYER_SKIN_EQUIPPED";
})(GeneralMultiplayerWarningStateEnum || (GeneralMultiplayerWarningStateEnum = {}));

let CreateOnRealmsError;

(function (CreateOnRealmsError) {
  CreateOnRealmsError[CreateOnRealmsError["UNASSIGNED_DEV_VERSION"] = 0] = "UNASSIGNED_DEV_VERSION";
  CreateOnRealmsError[CreateOnRealmsError["MEMBER_OF_TOO_MANY_REALMS"] = 1] = "MEMBER_OF_TOO_MANY_REALMS";
  CreateOnRealmsError[CreateOnRealmsError["CANNOT_CONNECT_TO_REALM"] = 2] = "CANNOT_CONNECT_TO_REALM";
  CreateOnRealmsError[CreateOnRealmsError["CROSS_PLATFORM_RESTRICTED"] = 3] = "CROSS_PLATFORM_RESTRICTED";
  CreateOnRealmsError[CreateOnRealmsError["UNKNOWN"] = 4] = "UNKNOWN";
})(CreateOnRealmsError || (CreateOnRealmsError = {}));

let CreateWorldError;

(function (CreateWorldError) {
  CreateWorldError[CreateWorldError["NOT_ENOUGH_STORAGE"] = 0] = "NOT_ENOUGH_STORAGE";
})(CreateWorldError || (CreateWorldError = {}));

let PlayerAccess;

(function (PlayerAccess) {
  PlayerAccess[PlayerAccess["INVITED"] = 1] = "INVITED";
  PlayerAccess[PlayerAccess["FRIENDS"] = 2] = "FRIENDS";
  PlayerAccess[PlayerAccess["FRIENDS_OF_FRIENDS"] = 3] = "FRIENDS_OF_FRIENDS";
})(PlayerAccess || (PlayerAccess = {}));

let PlayerPermissions;

(function (PlayerPermissions) {
  PlayerPermissions[PlayerPermissions["VISITOR"] = 0] = "VISITOR";
  PlayerPermissions[PlayerPermissions["MEMBER"] = 1] = "MEMBER";
  PlayerPermissions[PlayerPermissions["OPERATOR"] = 2] = "OPERATOR";
})(PlayerPermissions || (PlayerPermissions = {}));

const CREATE_NEW_WORLD_FACET = 'vanilla.createNewWorld';
/**
 * @deprecated This facet will be phased out in favor of EditWorldFacet and other facets
 */

const createNewWorldFacet = (0,react_facet_src.sharedFacet)(CREATE_NEW_WORLD_FACET);
const isEditorWorldSelector = (0,react_facet_src.sharedSelector)(facet => facet.isEditorWorld, [createNewWorldFacet]);
const scriptingCodingSettingsSelector = (0,react_facet_src.sharedSelector)(facet => facet.worldCreationData.scriptingCoding, [createNewWorldFacet]);
const betaFeatureToggledFacet = (0,react_facet_src.createFacet)({
  initialValue: {
    userTriedToActivateToggle: false,
    doSetToggleValue: () => {},
    userHasAcceptedBetaFeatures: false
  }
});
const ENABLE_CREATE_WORLD_GRAY_BUTTON = 'vanilla.useGrayCreateOnRealmsButton';
;// CONCATENATED MODULE: ./games/vanilla/engine/src/createPreviewRealmFacet.ts
 // This enum needs to be kept in sync with:
// Mojang/MinecraftPe: handheld/src-client/common/client/gui/oreui/binding/facets/vanilla/OreUICreatePreviewRealmFacet.h

let CreatePreviewRealmFromSubscriptionResult;

(function (CreatePreviewRealmFromSubscriptionResult) {
  CreatePreviewRealmFromSubscriptionResult[CreatePreviewRealmFromSubscriptionResult["CreatingPreviewRealm"] = 0] = "CreatingPreviewRealm";
  CreatePreviewRealmFromSubscriptionResult[CreatePreviewRealmFromSubscriptionResult["SuccessfullyCreatedPreviewRealm"] = 1] = "SuccessfullyCreatedPreviewRealm";
  CreatePreviewRealmFromSubscriptionResult[CreatePreviewRealmFromSubscriptionResult["RetrievingCreatedPreviewRealm"] = 2] = "RetrievingCreatedPreviewRealm";
  CreatePreviewRealmFromSubscriptionResult[CreatePreviewRealmFromSubscriptionResult["FailedToCreatePreviewRealm"] = 3] = "FailedToCreatePreviewRealm";
})(CreatePreviewRealmFromSubscriptionResult || (CreatePreviewRealmFromSubscriptionResult = {}));

const CREATE_PREVIEW_REALM_FACET = 'vanilla.createPreviewRealmFacet';
const createPreviewRealmFacet = (0,react_facet_src.sharedFacet)(CREATE_PREVIEW_REALM_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/debugSettingsFacet.ts

const DEBUG_SETTINGS_FACET = 'vanilla.debugSettings';
const debugSettingsFacet = (0,react_facet_src.sharedFacet)(DEBUG_SETTINGS_FACET);
let BiomeDimension;

(function (BiomeDimension) {
  BiomeDimension[BiomeDimension["OVERWORLD"] = 0] = "OVERWORLD";
  BiomeDimension[BiomeDimension["NETHER"] = 1] = "NETHER";
})(BiomeDimension || (BiomeDimension = {}));
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldEditorFacet.ts

let ReadWorldError;

(function (ReadWorldError) {
  ReadWorldError[ReadWorldError["IncorrectWorldId"] = 0] = "IncorrectWorldId";
  ReadWorldError[ReadWorldError["UnexpectedError"] = 1] = "UnexpectedError";
})(ReadWorldError || (ReadWorldError = {}));

let WriteWorldError;

(function (WriteWorldError) {
  WriteWorldError[WriteWorldError["IncorrectWorldId"] = 0] = "IncorrectWorldId";
  WriteWorldError[WriteWorldError["UnableToCreateWorldDirectoryPath"] = 1] = "UnableToCreateWorldDirectoryPath";
  WriteWorldError[WriteWorldError["UnableToCreateResourcePackDirectoryPath"] = 2] = "UnableToCreateResourcePackDirectoryPath";
  WriteWorldError[WriteWorldError["UnableToCreateBehaviorDirectoryPath"] = 3] = "UnableToCreateBehaviorDirectoryPath";
  WriteWorldError[WriteWorldError["InsufficientDiskSpace"] = 4] = "InsufficientDiskSpace";
  WriteWorldError[WriteWorldError["UnknownError"] = 5] = "UnknownError";
})(WriteWorldError || (WriteWorldError = {}));

const WORLD_EDITOR_FACET = 'vanilla.worldEditor';
const worldEditorFacet = (0,react_facet_src.sharedFacet)(WORLD_EDITOR_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/externalServerWorldListFacet.ts

let ExternalServerWorldOperationError;

(function (ExternalServerWorldOperationError) {
  ExternalServerWorldOperationError[ExternalServerWorldOperationError["NameIsEmpty"] = 0] = "NameIsEmpty";
  ExternalServerWorldOperationError[ExternalServerWorldOperationError["AddressIsEmpty"] = 1] = "AddressIsEmpty";
  ExternalServerWorldOperationError[ExternalServerWorldOperationError["InvalidPortNumber"] = 2] = "InvalidPortNumber";
  ExternalServerWorldOperationError[ExternalServerWorldOperationError["UnknownError"] = 3] = "UnknownError";
  ExternalServerWorldOperationError[ExternalServerWorldOperationError["IdNotFound"] = 4] = "IdNotFound";
})(ExternalServerWorldOperationError || (ExternalServerWorldOperationError = {}));

const EXTERNAL_SERVER_WORLD_LIST_FACET = 'vanilla.externalServerWorldList';
const externalServerWorldListFacet_externalServerWorldListFacet = (0,react_facet_src.sharedFacet)(EXTERNAL_SERVER_WORLD_LIST_FACET);
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/slice.ts
// FIXME remove this once gameface supports slice on all platforms
function slice(oldArray, start, end) {
  let length = oldArray == null ? 0 : oldArray.length;

  if (!length) {
    return [];
  }

  start = start == null ? 0 : start;
  end = end == null ? length : end;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  let index = -1;
  const newArray = new Array(length);

  while (++index < length) {
    newArray[index] = oldArray[index + start];
  }

  return newArray;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/friendsListFacet.ts


let PlayerTitleHistory;

(function (PlayerTitleHistory) {
  PlayerTitleHistory[PlayerTitleHistory["Unknown"] = 0] = "Unknown";
  PlayerTitleHistory[PlayerTitleHistory["NotPlayed"] = 1] = "NotPlayed";
  PlayerTitleHistory[PlayerTitleHistory["HasPlayed"] = 2] = "HasPlayed";
})(PlayerTitleHistory || (PlayerTitleHistory = {}));

const FRIENDS_LIST_FACET = 'vanilla.friendsListFacet';
const friendsListFacet_friendsListFacet = (0,react_facet_src.sharedFacet)(FRIENDS_LIST_FACET);
/**
 * Compare two online friends by if they are joinable or not. Joinable should bubble to the top.
 */

function sortOnlineFriends(friendsOnline) {
  // Using a copy of the original array to avoid mutating the original
  const friends = slice(friendsOnline, 0);
  return friends.sort(compareByJoinabledDescending);
}

function compareByJoinabledDescending(friendOnlineA, friendOnlineB) {
  if (friendOnlineA.playingOnServerId == null && friendOnlineB.playingOnServerId != null) {
    return 1;
  }

  if (friendOnlineA.playingOnServerId != null && friendOnlineB.playingOnServerId == null) {
    return -1;
  }

  return 0;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/friendsManagerFacet.ts

const FRIENDS_MANAGER_FACET = 'vanilla.friendsManagerFacet';
const friendsManagerFacet = (0,react_facet_src.sharedFacet)(FRIENDS_MANAGER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/featureFlags.ts
/**
 * Feature Flags - For any Vanilla specific feature flags.
 * --
 * Keeping these in one location makes it easier to
 * track them down and clean them up in the future.
 */
const FeatureFlag = {
  // If enabled, this will show the work in progress friends drawer content.
  FriendsDrawer: 'vanilla.friendsDrawer',
  NewPlayScreenWithoutTemplateButton: 'vanilla.ab.newPlayScreenWithoutTemplateButton',
  // If enabled, this shows the Debug Drawer on release builds
  DebugDrawer: 'vanilla.debugDrawer',
  // If this flag is enabled, then Realms is available on the current build (eg. preview)
  // It's not a property on a dedicated shared facet because it will eventually just
  // be true by default for all builds.
  HasRealmsEnabled: 'core.hasRealmsEnabled',
  // If enabled, this shows the Realms tab on the Play Screen instead of the Under Construction message
  PlayScreenRealmsTab: 'vanilla.playScreenRealmsTab'
};
;// CONCATENATED MODULE: ./games/vanilla/engine/src/inboxFacet.ts

const INBOX_FACET = 'vanilla.inbox'; // One week in seconds

const ONE_WEEK = 604800;
let InvitationType;

(function (InvitationType) {
  InvitationType[InvitationType["NONE"] = 0] = "NONE";
  InvitationType[InvitationType["REALMS"] = 1] = "REALMS";
  InvitationType[InvitationType["GAME"] = 2] = "GAME";
})(InvitationType || (InvitationType = {}));

let InvitationStatus;

(function (InvitationStatus) {
  InvitationStatus[InvitationStatus["NONE"] = 0] = "NONE";
  InvitationStatus[InvitationStatus["ACCEPTED"] = 1] = "ACCEPTED";
  InvitationStatus[InvitationStatus["REJECTED"] = 2] = "REJECTED";
  InvitationStatus[InvitationStatus["EXPIRED"] = 3] = "EXPIRED";
  InvitationStatus[InvitationStatus["JOIN"] = 5] = "JOIN";
})(InvitationStatus || (InvitationStatus = {}));

let InboxMessageType;

(function (InboxMessageType) {
  InboxMessageType[InboxMessageType["NEWS"] = 0] = "NEWS";
  InboxMessageType[InboxMessageType["INVITES"] = 1] = "INVITES";
  InboxMessageType[InboxMessageType["REALMS"] = 2] = "REALMS";
})(InboxMessageType || (InboxMessageType = {}));

let InboxTemplate;

(function (InboxTemplate) {
  InboxTemplate["NONE"] = "Unknown";
  InboxTemplate["IMAGETEXT"] = "ImageText";
  InboxTemplate["IMAGETNAILCTA"] = "ImageThumbnailCTA";
  InboxTemplate["HEROIMAGECTA"] = "HeroImageCTA";
})(InboxTemplate || (InboxTemplate = {}));

function categoryDataToStringValue(value) {
  switch (value) {
    case InboxMessageType.NEWS:
      return 'news';

    case InboxMessageType.INVITES:
      return 'invites';

    case InboxMessageType.REALMS:
      return 'realms';
  }
}
function stringValueCategoryToData(value) {
  switch (value) {
    case 'news':
      return InboxMessageType.NEWS;

    case 'invites':
      return InboxMessageType.INVITES;

    case 'realms':
      return InboxMessageType.REALMS;
  }
}
function groupMessageData(inboxMessages, categoryUnreadMessages) {
  var _categoryUnreadMessag, _categoryUnreadMessag2, _categoryUnreadMessag3;

  const newsData = {
    recent: [],
    history: []
  };
  const invitesData = {
    recent: [],
    history: []
  };
  const realmsData = {
    recent: [],
    history: []
  };
  const unreadInvitesCount = (_categoryUnreadMessag = categoryUnreadMessages.INVITES) !== null && _categoryUnreadMessag !== void 0 ? _categoryUnreadMessag : 0;
  const unreadRealmsCount = (_categoryUnreadMessag2 = categoryUnreadMessages.REALMS) !== null && _categoryUnreadMessag2 !== void 0 ? _categoryUnreadMessag2 : 0;
  const unreadNewsCount = (_categoryUnreadMessag3 = categoryUnreadMessages.NEWS) !== null && _categoryUnreadMessag3 !== void 0 ? _categoryUnreadMessag3 : 0;
  inboxMessages.forEach(message => {
    const today = msToDays(Date.now());
    const dateRecieved = secondsToDays(message.dateReceived);
    const isRecent = today - dateRecieved <= secondsToDays(ONE_WEEK);

    switch (message.announcementType) {
      case InboxMessageType.NEWS:
        {
          if (isRecent) {
            newsData.recent.push(message);
          } else {
            newsData.history.push(message);
          }

          break;
        }

      case InboxMessageType.INVITES:
        {
          if (isRecent) {
            invitesData.recent.push(message);
          } else {
            invitesData.history.push(message);
          }

          break;
        }

      case InboxMessageType.REALMS:
        {
          if (isRecent) {
            realmsData.recent.push(message);
          } else {
            realmsData.history.push(message);
          }

          break;
        }
    }
  });
  return {
    newsData,
    unreadNewsCount,
    invitesData,
    unreadInvitesCount,
    realmsData,
    unreadRealmsCount
  };
}
const inboxSharedFacet = (0,react_facet_src.sharedFacet)(INBOX_FACET);
const categorizedMessagesSelector = (0,react_facet_src.sharedSelector)(inbox => {
  return groupMessageData(inbox.inboxMessages, inbox.categoryUnreadMessages);
}, [inboxSharedFacet]);
const inboxSettingsSelector = (0,react_facet_src.sharedSelector)(inbox => {
  return inbox.settings;
}, [inboxSharedFacet]);
function secondsToDays(seconds) {
  return Math.floor(seconds / 60 / 60 / 24);
}
function msToDays(ms) {
  return secondsToDays(Math.floor(ms / 1000));
}
// EXTERNAL MODULE: ./games/vanilla/engine/src/levelDataBindings.ts
var levelDataBindings = __webpack_require__(35107);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/localization.ts




function localization_useLocalization(namespace) {
  const {
    translationPrefix,
    translate,
    formatDate
  } = (0,react.useContext)(LocalizationContext); // isEduBuild does not change after initialization

  const isEduBuild = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(isEduBuildSelector));
  const localization = (0,react.useMemo)(() => {
    const t = (key, params) => {
      var _result, _result2;

      let result = null;
      const completeKey = generateLocKey(translationPrefix, namespace, key);

      if (isEduBuild === true) {
        const eduCompleteKey = `${completeKey}.edu`;
        result = translate(eduCompleteKey, params);

        if (result == eduCompleteKey) {
          result = null;
        }
      }

      result = (_result = result) !== null && _result !== void 0 ? _result : translate(completeKey, params);

      if (!result && "real" == 'fake') {}

      return (_result2 = result) !== null && _result2 !== void 0 ? _result2 : completeKey;
    };

    return {
      f: formatDate,
      t
    };
  }, [isEduBuild, translationPrefix, namespace, translate, formatDate]);
  return localization;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/localScreenshotsFacet.ts

const LOCAL_SCREENSHOTS_FACET = 'vanilla.realmsStories.localScreenshots';
const localScreenshotsFacet = (0,react_facet_src.sharedFacet)(LOCAL_SCREENSHOTS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/localWorldListFacet.ts

const LOCAL_WORLD_LIST_FACET = 'vanilla.localWorldList';
const localWorldListFacet = (0,react_facet_src.sharedFacet)(LOCAL_WORLD_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/marketplaceSuggestionsFacet.ts
 // The way that the data driven marketplace page works is that you have to
// provide the title and page id of where you want to end up, and this
// information depends on where we're routing _from_.
//
// This GetMorePacksData interface is a way to make this state accessible to the
// JavaScript code so that these dynamic route query paramers can be accessed.
//
// The reason this can't be done from the backend is because the code that
// handles the routing doesn't know any details about the page we're currently
// on, and its the marketplace suggestions that determine which data driven
// page we should navigate to.

const MARKETPLACE_SUGGESTIONS_FACET = 'vanilla.marketplaceSuggestions';
const marketplaceSuggestionsFacet = (0,react_facet_src.sharedFacet)(MARKETPLACE_SUGGESTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/networkWorldDetailsFacet.ts

const NETWORK_WORLD_DETAILS_FACET = 'vanilla.networkWorldDetails';
const networkWorldDetailsFacet_networkWorldDetailsSharedFacet = (0,react_facet_src.sharedFacet)(NETWORK_WORLD_DETAILS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/networkWorldJoinerFacet.ts

let JoinServerWorldResult;

(function (JoinServerWorldResult) {
  JoinServerWorldResult[JoinServerWorldResult["OK"] = 0] = "OK";
  JoinServerWorldResult[JoinServerWorldResult["InvalidUserError"] = 1] = "InvalidUserError";
  JoinServerWorldResult[JoinServerWorldResult["NoInternetError"] = 2] = "NoInternetError";
  JoinServerWorldResult[JoinServerWorldResult["UserNeedsToBeSignedInError"] = 3] = "UserNeedsToBeSignedInError";
  JoinServerWorldResult[JoinServerWorldResult["BlockedByPlatformError"] = 4] = "BlockedByPlatformError";
  JoinServerWorldResult[JoinServerWorldResult["BlockedByXBLError"] = 5] = "BlockedByXBLError";
  JoinServerWorldResult[JoinServerWorldResult["BlockedByVersionError"] = 6] = "BlockedByVersionError";
  JoinServerWorldResult[JoinServerWorldResult["UserBannedError"] = 7] = "UserBannedError";
  JoinServerWorldResult[JoinServerWorldResult["ThirdPartyBadIPError"] = 8] = "ThirdPartyBadIPError";
  JoinServerWorldResult[JoinServerWorldResult["ThirdPartyNoServerOrServerLockedError"] = 9] = "ThirdPartyNoServerOrServerLockedError";
  JoinServerWorldResult[JoinServerWorldResult["UnknownError"] = 10] = "UnknownError";
})(JoinServerWorldResult || (JoinServerWorldResult = {}));

let JoinRealmWorldResult;

(function (JoinRealmWorldResult) {
  JoinRealmWorldResult[JoinRealmWorldResult["Ok"] = 0] = "Ok";
  JoinRealmWorldResult[JoinRealmWorldResult["StartupAlreadyInProgress"] = 1] = "StartupAlreadyInProgress";
  JoinRealmWorldResult[JoinRealmWorldResult["RealmIDConversionFailed"] = 2] = "RealmIDConversionFailed";
  JoinRealmWorldResult[JoinRealmWorldResult["MultiplayerLockedByPlatform"] = 3] = "MultiplayerLockedByPlatform";
  JoinRealmWorldResult[JoinRealmWorldResult["PlatformRestrictsMultiplayer"] = 4] = "PlatformRestrictsMultiplayer";
  JoinRealmWorldResult[JoinRealmWorldResult["NoMultiplayerPermission"] = 5] = "NoMultiplayerPermission";
  JoinRealmWorldResult[JoinRealmWorldResult["RealmsNotInitialized"] = 6] = "RealmsNotInitialized";
  JoinRealmWorldResult[JoinRealmWorldResult["EditorModeEnabled"] = 7] = "EditorModeEnabled";
  JoinRealmWorldResult[JoinRealmWorldResult["NoWifi"] = 8] = "NoWifi";
  JoinRealmWorldResult[JoinRealmWorldResult["WarningLowDiskSpace"] = 9] = "WarningLowDiskSpace";
  JoinRealmWorldResult[JoinRealmWorldResult["InvalidCrossPlatformMultiplayerSkin"] = 10] = "InvalidCrossPlatformMultiplayerSkin";
  JoinRealmWorldResult[JoinRealmWorldResult["UnexpectedError"] = 11] = "UnexpectedError";
  JoinRealmWorldResult[JoinRealmWorldResult["UnassignedDevVersion"] = 12] = "UnassignedDevVersion";
  JoinRealmWorldResult[JoinRealmWorldResult["MemberOfTooManyRealms"] = 13] = "MemberOfTooManyRealms";
  JoinRealmWorldResult[JoinRealmWorldResult["CannotConnectToRealm"] = 14] = "CannotConnectToRealm";
  JoinRealmWorldResult[JoinRealmWorldResult["UnknownError"] = 15] = "UnknownError";
})(JoinRealmWorldResult || (JoinRealmWorldResult = {}));

const NETWORK_WORLD_JOINER_FACET = 'vanilla.networkWorldJoiner';
const networkWorldJoinerFacet = (0,react_facet_src.sharedFacet)(NETWORK_WORLD_JOINER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/notificationOptionsFacet.ts

const NOTIFICATION_OPTIONS_FACET = 'vanilla.notificationOptions';
const notificationOptionsFacet_notificationOptionsFacet = (0,react_facet_src.sharedFacet)(NOTIFICATION_OPTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/notificationsFacet.ts

const NOTIFICATIONS_FACET = 'vanilla.notifications';
const notificationsFacet_notificationsFacet = (0,react_facet_src.sharedFacet)(NOTIFICATIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/optionsFacet.ts
 // the order of this enum should synch with NewInteractionModel enum in minecraftpe

let TouchControlSchemeEnum;

(function (TouchControlSchemeEnum) {
  TouchControlSchemeEnum[TouchControlSchemeEnum["TOUCH"] = 0] = "TOUCH";
  TouchControlSchemeEnum[TouchControlSchemeEnum["CROSSHAIR"] = 1] = "CROSSHAIR";
  TouchControlSchemeEnum[TouchControlSchemeEnum["CLASSIC"] = 2] = "CLASSIC";
})(TouchControlSchemeEnum || (TouchControlSchemeEnum = {}));

const OPTIONS_FACET = 'vanilla.options';
const optionsFacet = (0,react_facet_src.sharedFacet)(OPTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerSocialManagerFacet.ts

const PLAYER_SOCIAL_MANAGER_FACET = 'vanilla.playerSocialManager';
const playerSocialManagerFacet_playerSocialManagerFacet = (0,react_facet_src.sharedFacet)(PLAYER_SOCIAL_MANAGER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerAchievementsFacet.ts



const PLAYER_ACHIEVEMENTS_FACET = 'vanilla.playerAchievements';
const playerAchievementsFacet_playerAchievementsFacet = (0,react_facet_src.sharedFacet)(PLAYER_ACHIEVEMENTS_FACET);
const playerAchievementsFacet_isPlayerAchievementsLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status === achievementsFacet_AchievementFacetStatus.LOADED;
}, [playerAchievementsFacet_playerAchievementsFacet]);
const playerAchievementDetailSelector = (0,react_facet_src.sharedDynamicSelector)(id => [(facet, isLoaded) => {
  const achievement = find_find(facet.data.achievements, achievement => achievement.id === id);
  return {
    isLoaded,
    achievement
  };
}, [playerAchievementsFacet_playerAchievementsFacet, playerAchievementsFacet_isPlayerAchievementsLoadedSelector]]);
const playerAchievementsFacet_playerGroupedAchievementsSelector = (0,react_facet_src.sharedSelector)(achievementsData => {
  return groupAchievements(achievementsData.data.achievements);
}, [playerAchievementsFacet_playerAchievementsFacet]);
const playerAchievementsFacet_playerAchievementsSummarySelector = (0,react_facet_src.sharedSelector)(facet => {
  const summary = {
    loaded: facet.status === achievementsFacet_AchievementFacetStatus.LOADED,
    unlocked: facet.data.achievementsUnlocked,
    total: facet.data.maxAchievements,
    inProgressCount: facet.data.achievements.filter(isAchievementInProgress).length,
    rewardsTotal: countRewards(facet.data.achievements),
    rewardsUnlocked: countUnlockedRewards(facet.data.achievements),
    gamerScore: facet.data.currentGamerScore,
    maxGamerScore: facet.data.maxGamerScore,
    hoursPlayed: facet.data.hoursPlayed
  };
  return summary;
}, [playerAchievementsFacet_playerAchievementsFacet], react_facet_src.shallowObjectEqualityCheck);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerMessagingServiceFacet.ts


const PLAYER_MESSAGING_SERVICE_FACET = 'vanilla.playermessagingservice';
let PlayerMessagingServiceFacetStatus;

(function (PlayerMessagingServiceFacetStatus) {
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["LOADING"] = 0] = "LOADING";
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["IMAGE_RETRIEVAL"] = 1] = "IMAGE_RETRIEVAL";
  PlayerMessagingServiceFacetStatus[PlayerMessagingServiceFacetStatus["LOADED"] = 2] = "LOADED";
})(PlayerMessagingServiceFacetStatus || (PlayerMessagingServiceFacetStatus = {}));

const playerMessagingServiceFacet = (0,react_facet_src.sharedFacet)(PLAYER_MESSAGING_SERVICE_FACET);
const applyReportClick = (0,react_facet_src.sharedSelector)(facet => facet.reportClick.bind(facet), [playerMessagingServiceFacet]);
const applyReportDismiss = (0,react_facet_src.sharedSelector)(facet => facet.reportDismiss.bind(facet), [playerMessagingServiceFacet]);
const isMessagingLoadedSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.status != PlayerMessagingServiceFacetStatus.LOADING;
}, [playerMessagingServiceFacet]);
const messageDetailSelector = (0,react_facet_src.sharedDynamicSelector)(id => [(facet, isLoaded) => {
  const message = find_find(facet.data.messages, message => message.id === id);
  return {
    isLoaded,
    message
  };
}, [playerMessagingServiceFacet, isMessagingLoadedSelector]]);

function filterMessagesSurface(messages, surface) {
  return messages.filter(message => message.surface == surface);
}

const messagesBySurfaceSelector = (0,react_facet_src.sharedDynamicSelector)(surface => [(facet, isLoaded) => {
  const messages = filterMessagesSurface(facet.data.messages, surface);
  return {
    isLoaded,
    messages
  };
}, [playerMessagingServiceFacet, isMessagingLoadedSelector]]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerProfileFacet.ts

let playerProfileFacet_PlayerRelation;

(function (PlayerRelation) {
  PlayerRelation[PlayerRelation["Self"] = 0] = "Self";
  PlayerRelation[PlayerRelation["Friend"] = 1] = "Friend";
  PlayerRelation[PlayerRelation["Following"] = 2] = "Following";
  PlayerRelation[PlayerRelation["Follower"] = 3] = "Follower";
  PlayerRelation[PlayerRelation["Stranger"] = 4] = "Stranger";
})(playerProfileFacet_PlayerRelation || (playerProfileFacet_PlayerRelation = {}));

const PLAYER_PROFILE_FACET = 'vanilla.playerProfile';
const playerProfileFacet_playerProfileFacet = (0,react_facet_src.sharedFacet)(PLAYER_PROFILE_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerReportFacet.ts

const PLAYER_REPORT_FACET = 'vanilla.playerReport';
const playerReportFacet = (0,react_facet_src.sharedFacet)(PLAYER_REPORT_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/unpairedRealmsListFacet.ts
 // This is identical to the realmsListFacet.ts, but we don't have
// a pattern to share types across facets yet.
// This enum should be kept in sync with the C++ side:
// Minecraftpe::handheld\src\common\server\commands\PlayerPermissionLevel.h

var PlayerPermissionLevel;

(function (PlayerPermissionLevel) {
  PlayerPermissionLevel[PlayerPermissionLevel["Visitor"] = 0] = "Visitor";
  PlayerPermissionLevel[PlayerPermissionLevel["Member"] = 1] = "Member";
  PlayerPermissionLevel[PlayerPermissionLevel["Operator"] = 2] = "Operator";
  PlayerPermissionLevel[PlayerPermissionLevel["Custom"] = 3] = "Custom";
})(PlayerPermissionLevel || (PlayerPermissionLevel = {}));

const UNPAIRED_REALMS_LIST_FACET = 'vanilla.unpairedRealmsListFacet';
const unpairedRealmsListFacet = (0,react_facet_src.sharedFacet)(UNPAIRED_REALMS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/privacyAndOnlineSafetyFacet.ts

const PRIVACY_AND_ONLINE_SAFETY_FACET = 'vanilla.privacyAndOnlineSafetyFacet';
const privacyAndOnlineSafetyFacet = (0,react_facet_src.sharedFacet)(PRIVACY_AND_ONLINE_SAFETY_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/profanityFilterFacet.ts

const PROFANITY_FILTER_FACET = 'vanilla.profanityFilter';
const profanityFilterFacet = (0,react_facet_src.sharedFacet)(PROFANITY_FILTER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmActionsFacet.ts

const REALM_ACTIONS_FACET = 'vanilla.realmsStories.actions';
const realmActionsFacet = (0,react_facet_src.sharedFacet)(REALM_ACTIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmDataFacet.ts

const REALM_DATA_FACET = 'vanilla.realmsStories.realmData';
const realmDataFacet = (0,react_facet_src.sharedFacet)(REALM_DATA_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmListFacet.ts


/**
 * @deprecated use typings from realmsListFacet.ts instead
 */
const REALM_LIST_FACET = 'vanilla.RealmListFacet';
/**
 * @deprecated use typings from realmsListFacet.ts instead
 */

const realmListFacet = (0,react_facet_src.sharedFacet)(REALM_LIST_FACET);
/**
 * @deprecated use typings from realmsListFacet.ts instead
 */

const activeRealmsSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.realms.filter(realm => realm.isInitialized && realm.isOwner && !realm.expired);
}, [realmListFacet]);
/**
 * @deprecated use typings from realmsListFacet.ts instead
 */

const activeUnpairedParentRealmsSelector = (0,react_facet_src.sharedSelector)(facet => {
  return facet.unpairedParentRealms.filter(realm => realm.isInitialized && realm.isOwner && !realm.expired);
}, [realmListFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmsListFacet.ts

// This is identical to the unpairedRealmsListFacet.ts, but we don't have
// a pattern to share types across facets yet.
// This enum should be kept in sync with the C++ side:
// Minecraftpe::handheld\src\common\server\commands\PlayerPermissionLevel.h
let realmsListFacet_PlayerPermissionLevel;

(function (PlayerPermissionLevel) {
  PlayerPermissionLevel[PlayerPermissionLevel["Visitor"] = 0] = "Visitor";
  PlayerPermissionLevel[PlayerPermissionLevel["Member"] = 1] = "Member";
  PlayerPermissionLevel[PlayerPermissionLevel["Operator"] = 2] = "Operator";
  PlayerPermissionLevel[PlayerPermissionLevel["Custom"] = 3] = "Custom";
})(realmsListFacet_PlayerPermissionLevel || (realmsListFacet_PlayerPermissionLevel = {}));

const REALMS_LIST_FACET = 'vanilla.realmsListFacet';
const realmsListFacet = (0,react_facet_src.sharedFacet)(REALMS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmPersistentDataFacet.ts
 // Enum of options for filtering realm players.

let RealmMemberFilterOption; // Enum of options for sorting realm players.

(function (RealmMemberFilterOption) {
  RealmMemberFilterOption[RealmMemberFilterOption["All"] = 0] = "All";
  RealmMemberFilterOption[RealmMemberFilterOption["Online"] = 1] = "Online";
  RealmMemberFilterOption[RealmMemberFilterOption["OptedIn"] = 2] = "OptedIn";
  RealmMemberFilterOption[RealmMemberFilterOption["OptedOut"] = 3] = "OptedOut";
})(RealmMemberFilterOption || (RealmMemberFilterOption = {}));

let RealmMemberSortOption; // The data in this interface is read/write

(function (RealmMemberSortOption) {
  RealmMemberSortOption[RealmMemberSortOption["MostRecent"] = 0] = "MostRecent";
  RealmMemberSortOption[RealmMemberSortOption["AlphabeticalAscending"] = 1] = "AlphabeticalAscending";
  RealmMemberSortOption[RealmMemberSortOption["AlphabeticalDescending"] = 2] = "AlphabeticalDescending";
  RealmMemberSortOption[RealmMemberSortOption["LeastRecent"] = 3] = "LeastRecent";
})(RealmMemberSortOption || (RealmMemberSortOption = {}));

const REALM_PERSISTENT_DATA_FACET = 'vanilla.realmsStories.persistentData';
const realmPersistentDataFacet = (0,react_facet_src.sharedFacet)(REALM_PERSISTENT_DATA_FACET);
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/localeCompare.ts
function localeCompare(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmPlayersFacet.ts


let RealmPlayerRoleEnum;

(function (RealmPlayerRoleEnum) {
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["NONMEMBER"] = -1] = "NONMEMBER";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["VISITOR"] = 0] = "VISITOR";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["MEMBER"] = 1] = "MEMBER";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["OPERATOR"] = 2] = "OPERATOR";
  RealmPlayerRoleEnum[RealmPlayerRoleEnum["OWNER"] = 3] = "OWNER";
})(RealmPlayerRoleEnum || (RealmPlayerRoleEnum = {}));

const REALM_PLAYERS_FACET = 'vanilla.realmsStories.players';
const realmPlayersFacet = (0,react_facet_src.sharedFacet)(REALM_PLAYERS_FACET); // Sorting Methods

function sortRealmPlayerGamerTagAlphabeticallyAscending(players) {
  return players.sort(compareGamerTagAlphabeticallyAscending);
}
function compareGamerTagAlphabeticallyAscending(memberA, memberB) {
  const gamerTagA = memberA.gamerTag.toLocaleLowerCase();
  const gamerTagB = memberB.gamerTag.toLocaleLowerCase();
  return localeCompare(gamerTagA, gamerTagB);
}
function sortRealmPlayerGamerTagAlphabeticallyDescending(players) {
  return players.sort(compareGamerTagAlphabeticallyDescending);
}
function compareGamerTagAlphabeticallyDescending(memberA, memberB) {
  return compareGamerTagAlphabeticallyAscending(memberB, memberA);
}
function sortRealmPlayerByMostRecent(players) {
  return players.sort(comparePlayerLastLoginDescending);
}
function comparePlayerLastLoginDescending(playerA, playerB) {
  const lastSeenA = playerA.isOnline ? Number.MAX_VALUE : playerA.lastSeenTime;
  const lastSeenB = playerB.isOnline ? Number.MAX_VALUE : playerB.lastSeenTime;

  if (lastSeenA === lastSeenB) {
    return compareGamerTagAlphabeticallyAscending(playerA, playerB);
  }

  return lastSeenB - lastSeenA;
}
function sortRealmPlayerByLeastActive(players) {
  return players.sort(comparePlayerLastLoginAscending);
}
function comparePlayerLastLoginAscending(playerA, playerB) {
  return comparePlayerLastLoginDescending(playerB, playerA);
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmSessionsFacet.ts

const REALM_SESSIONS_FACET = 'vanilla.realmsStories.sessions';
const sessionsFacet = (0,react_facet_src.sharedFacet)(REALM_SESSIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmSlotsFacet.ts

const REALM_SLOTS_FACET = 'vanilla.realmSlots';
const realmSlotsFacet = (0,react_facet_src.sharedFacet)(REALM_SLOTS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmStoriesPostsFacet.ts

const REALM_STORIES_POSTS_FACET = 'vanilla.realmsStories.stories';
const realmStoriesPostsFacet = (0,react_facet_src.sharedFacet)(REALM_STORIES_POSTS_FACET);
/**
 * Helper function for setting Realms Stories posts as viewed on changing tab/page or otherwise navigating away from story feed
 * @param stories The stories to mark as viewed internally (generally all stories visible in RealmStoriesPostsFacet)
 */

function setRealmStoriesPostsAsViewed(stories) {
  stories.forEach(story => {
    story.hasViewed = true;
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmStoriesSettingsFacet.ts

let optInState;

(function (optInState) {
  optInState[optInState["OptedIn"] = 0] = "OptedIn";
  optInState[optInState["OptedOut"] = 1] = "OptedOut";
  optInState[optInState["None"] = 2] = "None";
})(optInState || (optInState = {}));

let fetchStatus;

(function (fetchStatus) {
  fetchStatus[fetchStatus["Idle"] = 0] = "Idle";
  fetchStatus[fetchStatus["InProgress"] = 1] = "InProgress";
  fetchStatus[fetchStatus["Success"] = 2] = "Success";
  fetchStatus[fetchStatus["InternalError"] = 3] = "InternalError";
  fetchStatus[fetchStatus["FetchFailed"] = 4] = "FetchFailed";
  fetchStatus[fetchStatus["RateLimit"] = 5] = "RateLimit";
})(fetchStatus || (fetchStatus = {}));

let postStatus;

(function (postStatus) {
  postStatus[postStatus["Idle"] = 0] = "Idle";
  postStatus[postStatus["InProgress"] = 1] = "InProgress";
  postStatus[postStatus["Success"] = 2] = "Success";
  postStatus[postStatus["InputInvalid"] = 3] = "InputInvalid";
  postStatus[postStatus["InternalError"] = 4] = "InternalError";
  postStatus[postStatus["Uploading"] = 5] = "Uploading";
  postStatus[postStatus["UploadFailed"] = 6] = "UploadFailed";
  postStatus[postStatus["PostingFailed"] = 7] = "PostingFailed";
  postStatus[postStatus["RateLimit"] = 8] = "RateLimit";
})(postStatus || (postStatus = {}));

const REALM_STORIES_SETTINGS_FACET = 'vanilla.realmsStories.settings';
const realmStoriesSettingsFacet = (0,react_facet_src.sharedFacet)(REALM_STORIES_SETTINGS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmStoryCommentsFacet.ts

const STORY_COMMENTS_FACET = 'vanilla.realmsStories.comments';
const storyCommentsFacet = (0,react_facet_src.sharedFacet)(STORY_COMMENTS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmWorldUploaderFacet.ts

let UploadToRealmsError;

(function (UploadToRealmsError) {
  UploadToRealmsError[UploadToRealmsError["ActionAlreadyInProgress"] = 0] = "ActionAlreadyInProgress";
  UploadToRealmsError[UploadToRealmsError["CannotSaveWorld"] = 1] = "CannotSaveWorld";
  UploadToRealmsError[UploadToRealmsError["InvalidWorldId"] = 2] = "InvalidWorldId";
  UploadToRealmsError[UploadToRealmsError["Generic"] = 3] = "Generic";
  UploadToRealmsError[UploadToRealmsError["TooManyRealms"] = 4] = "TooManyRealms";
  UploadToRealmsError[UploadToRealmsError["InvalidRealmName"] = 5] = "InvalidRealmName";
  UploadToRealmsError[UploadToRealmsError["InvalidResponse"] = 6] = "InvalidResponse";
  UploadToRealmsError[UploadToRealmsError["UnknownError"] = 7] = "UnknownError";
})(UploadToRealmsError || (UploadToRealmsError = {}));

const REALM_WORLD_UPLOADER_FACET = 'vanilla.RealmWorldUploaderFacet';
const realmWorldUploaderFacet = (0,react_facet_src.sharedFacet)(REALM_WORLD_UPLOADER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/recentlyPlayedWithListFacet.ts

const RECENTLY_PLAYED_WITH_LIST_FACET = 'vanilla.recentlyPlayedWithList';
const recentlyPlayedWithListFacet_recentlyPlayedWithListFacet = (0,react_facet_src.sharedFacet)(RECENTLY_PLAYED_WITH_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/followersListFacet.ts

const FOLLOWERS_LIST_FACET = 'vanilla.followersList';
const followersListFacet_followersListFacet = (0,react_facet_src.sharedFacet)(FOLLOWERS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/realmMembersListFacet.ts

const REALM_MEMBERS_LIST_FACET = 'vanilla.realmMembersList';
const realmMembersListFacet_realmMembersListFacet = (0,react_facet_src.sharedFacet)(REALM_MEMBERS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/mutualFriendsListFacet.ts

const MUTUAL_FRIENDS_LIST_FACET = 'vanilla.mutualFriendsList';
const mutualFriendsListFacet_mutualFriendsListFacet = (0,react_facet_src.sharedFacet)(MUTUAL_FRIENDS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/familyMembersListFacet.ts

const FAMILY_MEMBERS_LIST_FACET = 'vanilla.familyMembersList';
const familyMembersListFacet_familyMembersListFacet = (0,react_facet_src.sharedFacet)(FAMILY_MEMBERS_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/resourcePacksFacet.ts

let resourcePacksFacet_ResourcePacksFacetStatus; // Original prompt interface for download modal
// Intended to be deprecated when the above becomes mainstream

(function (ResourcePacksFacetStatus) {
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["Idle"] = 0] = "Idle";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["CheckingResourcePacks"] = 1] = "CheckingResourcePacks";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["StartDownload"] = 2] = "StartDownload";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["DownloadingResourcePacks"] = 3] = "DownloadingResourcePacks";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["ActivateDownloadedPack"] = 4] = "ActivateDownloadedPack";
  ResourcePacksFacetStatus[ResourcePacksFacetStatus["WaitingForPrompt"] = 5] = "WaitingForPrompt";
})(resourcePacksFacet_ResourcePacksFacetStatus || (resourcePacksFacet_ResourcePacksFacetStatus = {}));

const RESOURCE_PACKS_FACET = 'vanilla.resourcePacks';
/**
 * @deprecated This facet will be phased out in favor of WorldPackagesFacet
 */

const resourcePacksFacet = (0,react_facet_src.sharedFacet)(RESOURCE_PACKS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/screenTechStackFacet.ts

let ScreenName;

(function (ScreenName) {
  ScreenName["PlayScreen"] = "/play";
  ScreenName["EditWorldScreen"] = "/edit-world";
})(ScreenName || (ScreenName = {}));

let UITechStack;

(function (UITechStack) {
  UITechStack[UITechStack["JsonUI"] = 0] = "JsonUI";
  UITechStack[UITechStack["OreUI"] = 1] = "OreUI";
})(UITechStack || (UITechStack = {}));

const SCREEN_TECH_STACK_FACET = 'vanilla.screenTechStack';
const screenTechStackFacet = (0,react_facet_src.sharedFacet)(SCREEN_TECH_STACK_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/seedTemplateFacet.ts

const SEED_TEMPLATES_FACET = 'vanilla.seedTemplates';
const seedTemplatesFacet = (0,react_facet_src.sharedFacet)(SEED_TEMPLATES_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/simulationDistanceFacet.ts

const SIMULATION_DISTANCE_FACET = 'vanilla.simulationDistanceOptions';
const simulationDistanceFacet = (0,react_facet_src.sharedFacet)(SIMULATION_DISTANCE_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/telemetryFacet.ts

const TELEMETRY_FACET = 'vanilla.telemetry';
const telemetryFacet = (0,react_facet_src.sharedFacet)(TELEMETRY_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/thirdPartyWorldListFacet.ts

const THIRD_PARTY_WORLD_LIST_FACET = 'vanilla.thirdPartyWorldList';
const thirdPartyWorldListFacet_thirdPartyWorldListFacet = (0,react_facet_src.sharedFacet)(THIRD_PARTY_WORLD_LIST_FACET);
const SERVER_TAB_FEATURE_FLAG = 'vanilla.serverTab';
;// CONCATENATED MODULE: ./games/vanilla/engine/src/types.ts
let types_PromptActionVariant; // Intended to be the primary prompt interface

(function (PromptActionVariant) {
  PromptActionVariant[PromptActionVariant["Primary"] = 0] = "Primary";
  PromptActionVariant[PromptActionVariant["Secondary"] = 1] = "Secondary";
})(types_PromptActionVariant || (types_PromptActionVariant = {}));

// Argument for `/tabbed-upsell`
let TabbedUpsellScreenDefaultTab;

(function (TabbedUpsellScreenDefaultTab) {
  TabbedUpsellScreenDefaultTab["MINECRAFT"] = "minecraft";
  TabbedUpsellScreenDefaultTab["XBL"] = "xbl";
  TabbedUpsellScreenDefaultTab["ACHIEVEMENTS"] = "achievements";
  TabbedUpsellScreenDefaultTab["MULTIPLAYER"] = "multiplayer";
  TabbedUpsellScreenDefaultTab["SERVER"] = "server";
  TabbedUpsellScreenDefaultTab["STORE"] = "store";
  TabbedUpsellScreenDefaultTab["CREATIVE"] = "creative";
  TabbedUpsellScreenDefaultTab["PACKS"] = "packs";
  TabbedUpsellScreenDefaultTab["SEEDS"] = "seeds";
})(TabbedUpsellScreenDefaultTab || (TabbedUpsellScreenDefaultTab = {}));

let GameMode;

(function (GameMode) {
  GameMode[GameMode["UNKNOWN"] = -1] = "UNKNOWN";
  GameMode[GameMode["SURVIVAL"] = 0] = "SURVIVAL";
  GameMode[GameMode["CREATIVE"] = 1] = "CREATIVE";
  GameMode[GameMode["ADVENTURE"] = 2] = "ADVENTURE";
})(GameMode || (GameMode = {}));

let types_NetworkWorldType;

(function (NetworkWorldType) {
  NetworkWorldType[NetworkWorldType["thirdParty"] = 0] = "thirdParty";
  NetworkWorldType[NetworkWorldType["external"] = 1] = "external";
  NetworkWorldType[NetworkWorldType["other"] = 2] = "other";
})(types_NetworkWorldType || (types_NetworkWorldType = {}));

let WorldPingStatus;

(function (WorldPingStatus) {
  WorldPingStatus[WorldPingStatus["Unavailable"] = 0] = "Unavailable";
  WorldPingStatus[WorldPingStatus["Low"] = 1] = "Low";
  WorldPingStatus[WorldPingStatus["Medium"] = 2] = "Medium";
  WorldPingStatus[WorldPingStatus["High"] = 3] = "High";
})(WorldPingStatus || (WorldPingStatus = {}));

let types_AsyncStatefulFunctionState;
/**
 * @deprecated
 *
 * For functions that both has progress and that can fail, prefer exposing a
 * progress-property and an error-property directly on the Facet.
 *
 * ```
 * interface BananaBoatFacet {
 *   sendBananaBoat(): void
 *   sendBananaBoatProgress: float
 *   sendBananaBoatError?: BananaBoatError
 * }
 * ```
 */

(function (AsyncStatefulFunctionState) {
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["Idle"] = 0] = "Idle";
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["InProgress"] = 1] = "InProgress";
  AsyncStatefulFunctionState[AsyncStatefulFunctionState["Completed"] = 2] = "Completed";
})(types_AsyncStatefulFunctionState || (types_AsyncStatefulFunctionState = {}));

/**
 * @deprecated Consider using `FetchStatus` instead.
 */
let FetchResult;
/**
 * @deprecated Consider using `PostStatus` instead.
 */

(function (FetchResult) {
  FetchResult[FetchResult["SUCCESS"] = 0] = "SUCCESS";
  FetchResult[FetchResult["INTERNAL_ERROR"] = 1] = "INTERNAL_ERROR";
  FetchResult[FetchResult["FETCH_FAILED"] = 2] = "FETCH_FAILED";
})(FetchResult || (FetchResult = {}));

let PostResult;
/**
 * Data structure for data that loads over several frames.
 */

(function (PostResult) {
  PostResult[PostResult["SUCCESS"] = 0] = "SUCCESS";
  PostResult[PostResult["INPUT_INVALID"] = 1] = "INPUT_INVALID";
  PostResult[PostResult["INTERNAL_ERROR"] = 2] = "INTERNAL_ERROR";
  PostResult[PostResult["UPLOAD_FAILED"] = 3] = "UPLOAD_FAILED";
})(PostResult || (PostResult = {}));

// Enum of return statuses of realms stories fetch methods.
let FetchStatus; // Enum of return statuses of realms stories post methods.

(function (FetchStatus) {
  FetchStatus[FetchStatus["Idle"] = 0] = "Idle";
  FetchStatus[FetchStatus["InProgress"] = 1] = "InProgress";
  FetchStatus[FetchStatus["Success"] = 2] = "Success";
  FetchStatus[FetchStatus["InternalError"] = 3] = "InternalError";
  FetchStatus[FetchStatus["FetchFailed"] = 4] = "FetchFailed";
  FetchStatus[FetchStatus["RateLimit"] = 5] = "RateLimit";
})(FetchStatus || (FetchStatus = {}));

let PostStatus;

(function (PostStatus) {
  PostStatus[PostStatus["Idle"] = 0] = "Idle";
  PostStatus[PostStatus["InProgress"] = 1] = "InProgress";
  PostStatus[PostStatus["Success"] = 2] = "Success";
  PostStatus[PostStatus["InputInvalid"] = 3] = "InputInvalid";
  PostStatus[PostStatus["InternalError"] = 4] = "InternalError";
  PostStatus[PostStatus["Uploading"] = 5] = "Uploading";
  PostStatus[PostStatus["UploadFailed"] = 6] = "UploadFailed";
  PostStatus[PostStatus["PostingFailed"] = 7] = "PostingFailed";
  PostStatus[PostStatus["RateLimit"] = 8] = "RateLimit";
})(PostStatus || (PostStatus = {}));
;// CONCATENATED MODULE: ./games/vanilla/engine/src/userAccountFacet.ts
 //The order of this enum should match the PostSignInAction enum in Minecraftpe's UserAccountFacet.h

let PostSignInAction;

(function (PostSignInAction) {
  PostSignInAction[PostSignInAction["DO_NOTHING"] = 0] = "DO_NOTHING";
  PostSignInAction[PostSignInAction["SAVE_ENTITLEMENTS"] = 1] = "SAVE_ENTITLEMENTS";
})(PostSignInAction || (PostSignInAction = {}));

const USER_ACCOUNT_FACET = 'vanilla.userAccount';
const userAccountFacet = (0,react_facet_src.sharedFacet)(USER_ACCOUNT_FACET);
const isTrialAccountSelector = (0,react_facet_src.sharedSelector)(facet => facet.isTrialAccount, [userAccountFacet]);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/vanillaFeatureFlags.ts
//Vanilla feature flags
const DISABLE_ANIMATED_SIGN_IN_SCREENS = 'vanilla.disableAnimatedSignInScreens';
;// CONCATENATED MODULE: ./games/vanilla/engine/src/webBrowserFacet.ts

let WebBrowserLink;

(function (WebBrowserLink) {
  WebBrowserLink[WebBrowserLink["NewWorldCreationFeedbackPage"] = 0] = "NewWorldCreationFeedbackPage";
  WebBrowserLink[WebBrowserLink["PlayScreenFeedbackPage"] = 1] = "PlayScreenFeedbackPage";
  WebBrowserLink[WebBrowserLink["EditWorldScreenFeedbackPage"] = 2] = "EditWorldScreenFeedbackPage";
  WebBrowserLink[WebBrowserLink["DeathScreenFeedbackPage"] = 3] = "DeathScreenFeedbackPage";
  WebBrowserLink[WebBrowserLink["RealmsSafetyPage"] = 4] = "RealmsSafetyPage";
  WebBrowserLink[WebBrowserLink["BannedHelpPage"] = 6] = "BannedHelpPage";
  WebBrowserLink[WebBrowserLink["ParentPermissionHelpPage"] = 5] = "ParentPermissionHelpPage";
  WebBrowserLink[WebBrowserLink["NintendoSwitchTechnicalSupportPage"] = 7] = "NintendoSwitchTechnicalSupportPage";
})(WebBrowserLink || (WebBrowserLink = {}));

const WEB_BROWSER_FACET = 'vanilla.webBrowserFacet';
const webBrowserFacet = (0,react_facet_src.sharedFacet)(WEB_BROWSER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldCloudSyncFacet.ts
 // This enum needs to be kept in sync with:
// Mojang/MinecraftPe: handheld/src-client/common/client/world/IWorldCloudSyncer.h

let WorldCloudSyncResult;

(function (WorldCloudSyncResult) {
  WorldCloudSyncResult[WorldCloudSyncResult["Ok"] = 0] = "Ok";
  WorldCloudSyncResult[WorldCloudSyncResult["Unsupported"] = 1] = "Unsupported";
  WorldCloudSyncResult[WorldCloudSyncResult["WorldNotCloudStored"] = 2] = "WorldNotCloudStored";
  WorldCloudSyncResult[WorldCloudSyncResult["UnableToGetManifest"] = 3] = "UnableToGetManifest";
  WorldCloudSyncResult[WorldCloudSyncResult["UnableToSyncWorld"] = 4] = "UnableToSyncWorld";
})(WorldCloudSyncResult || (WorldCloudSyncResult = {}));

const WORLD_CLOUD_SYNC_FACET = 'vanilla.worldCloudSyncFacet';
const worldCloudSyncFacet = (0,react_facet_src.sharedFacet)(WORLD_CLOUD_SYNC_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldStartupFacet.ts

let StartLocalWorldResult;

(function (StartLocalWorldResult) {
  StartLocalWorldResult[StartLocalWorldResult["Ok"] = 0] = "Ok";
  StartLocalWorldResult[StartLocalWorldResult["WorldNotInLevelList"] = 1] = "WorldNotInLevelList";
  StartLocalWorldResult[StartLocalWorldResult["StartupAlreadyInProgress"] = 2] = "StartupAlreadyInProgress";
  StartLocalWorldResult[StartLocalWorldResult["GameServerStarterNotReady"] = 3] = "GameServerStarterNotReady";
  StartLocalWorldResult[StartLocalWorldResult["MissingDlcDependencies"] = 4] = "MissingDlcDependencies";
  StartLocalWorldResult[StartLocalWorldResult["UnknownError"] = 5] = "UnknownError";
})(StartLocalWorldResult || (StartLocalWorldResult = {}));

let BackupResult;

(function (BackupResult) {
  BackupResult[BackupResult["Ok"] = 0] = "Ok";
  BackupResult[BackupResult["IncorrectWorldId"] = 1] = "IncorrectWorldId";
  BackupResult[BackupResult["InsufficientDiskSpace"] = 2] = "InsufficientDiskSpace";
  BackupResult[BackupResult["UnknownError"] = 3] = "UnknownError";
})(BackupResult || (BackupResult = {}));

const WORLD_STARTUP_FACET = 'vanilla.worldStartup';
const worldStartupFacet = (0,react_facet_src.sharedFacet)(WORLD_STARTUP_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldTemplateListFacet.ts

const WORLD_TEMPLATE_LIST_FACET = 'vanilla.worldTemplateList';
const worldTemplateListFacet = (0,react_facet_src.sharedFacet)(WORLD_TEMPLATE_LIST_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldTransferFacet.ts

// This enum should be synced with:
// 	MinecraftPe::handheld/src-client/common/client/world/WorldTransferer.h
let WorldTransferResult;

(function (WorldTransferResult) {
  WorldTransferResult[WorldTransferResult["Success"] = 0] = "Success";
  WorldTransferResult[WorldTransferResult["FailureUnknown"] = 1] = "FailureUnknown";
  WorldTransferResult[WorldTransferResult["FailureNoFile"] = 2] = "FailureNoFile";
  WorldTransferResult[WorldTransferResult["FailureZipError"] = 3] = "FailureZipError";
  WorldTransferResult[WorldTransferResult["FailurePremiumContent"] = 4] = "FailurePremiumContent";
  WorldTransferResult[WorldTransferResult["FailureEditionMismatch"] = 5] = "FailureEditionMismatch";
  WorldTransferResult[WorldTransferResult["FailureEditorMismatch"] = 6] = "FailureEditorMismatch";
  WorldTransferResult[WorldTransferResult["UnsupportedPlatform"] = 7] = "UnsupportedPlatform";
  WorldTransferResult[WorldTransferResult["AlreadyInProgress"] = 8] = "AlreadyInProgress";
  WorldTransferResult[WorldTransferResult["InterruptedByUser"] = 9] = "InterruptedByUser";
})(WorldTransferResult || (WorldTransferResult = {}));

const WORLD_TRANSFER_FACET = 'vanilla.worldTransfer';
const worldTransferFacet = (0,react_facet_src.sharedFacet)(WORLD_TRANSFER_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldOperationsFacet.ts

let DuplicateWorldError;

(function (DuplicateWorldError) {
  DuplicateWorldError[DuplicateWorldError["Ok"] = 0] = "Ok";
  DuplicateWorldError[DuplicateWorldError["IncorrectWorldId"] = 1] = "IncorrectWorldId";
  DuplicateWorldError[DuplicateWorldError["InsufficientDiskSpace"] = 2] = "InsufficientDiskSpace";
  DuplicateWorldError[DuplicateWorldError["UnknownError"] = 3] = "UnknownError";
})(DuplicateWorldError || (DuplicateWorldError = {}));

let ExportWorldResult;

(function (ExportWorldResult) {
  ExportWorldResult[ExportWorldResult["Ok"] = 0] = "Ok";
  ExportWorldResult[ExportWorldResult["IncorrectWorldId"] = 1] = "IncorrectWorldId";
  ExportWorldResult[ExportWorldResult["NeedToRemoveVRHeadset"] = 2] = "NeedToRemoveVRHeadset";
  ExportWorldResult[ExportWorldResult["NoFile"] = 3] = "NoFile";
  ExportWorldResult[ExportWorldResult["ZipError"] = 4] = "ZipError";
  ExportWorldResult[ExportWorldResult["PremiumContent"] = 5] = "PremiumContent";
  ExportWorldResult[ExportWorldResult["EditionMismatch"] = 6] = "EditionMismatch";
  ExportWorldResult[ExportWorldResult["EditorMismatch"] = 7] = "EditorMismatch";
  ExportWorldResult[ExportWorldResult["ZipDepthError"] = 8] = "ZipDepthError";
  ExportWorldResult[ExportWorldResult["UnknownError"] = 9] = "UnknownError";
})(ExportWorldResult || (ExportWorldResult = {}));

let ClearPlayerDataType;

(function (ClearPlayerDataType) {
  ClearPlayerDataType[ClearPlayerDataType["SkipLocalUser"] = 0] = "SkipLocalUser";
  ClearPlayerDataType[ClearPlayerDataType["IncludeLocalUser"] = 1] = "IncludeLocalUser";
})(ClearPlayerDataType || (ClearPlayerDataType = {}));

let ExportWorldStatus;

(function (ExportWorldStatus) {
  ExportWorldStatus[ExportWorldStatus["Idle"] = 0] = "Idle";
  ExportWorldStatus[ExportWorldStatus["SelectingFileDestination"] = 1] = "SelectingFileDestination";
  ExportWorldStatus[ExportWorldStatus["Exporting"] = 2] = "Exporting";
})(ExportWorldStatus || (ExportWorldStatus = {}));

let StartClearPlayerDataError;

(function (StartClearPlayerDataError) {
  StartClearPlayerDataError[StartClearPlayerDataError["FailedToOpenDatabase"] = 0] = "FailedToOpenDatabase";
})(StartClearPlayerDataError || (StartClearPlayerDataError = {}));

const WORLD_OPERATIONS_FACET = 'vanilla.worldOperations';
const worldOperationsFacet = (0,react_facet_src.sharedFacet)(WORLD_OPERATIONS_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/worldPackagesFacet.ts

let PackType;

(function (PackType) {
  PackType[PackType["None"] = 0] = "None";
  PackType[PackType["World"] = 1] = "World";
  PackType[PackType["WorldTemplate"] = 2] = "WorldTemplate";
  PackType[PackType["Resource"] = 3] = "Resource";
  PackType[PackType["Behavior"] = 4] = "Behavior";
  PackType[PackType["Skin"] = 5] = "Skin";
  PackType[PackType["ItemCollection"] = 6] = "ItemCollection";
})(PackType || (PackType = {}));

let PackDownloadStatus;

(function (PackDownloadStatus) {
  PackDownloadStatus[PackDownloadStatus["Idle"] = 0] = "Idle";
  PackDownloadStatus[PackDownloadStatus["Downloading"] = 1] = "Downloading";
  PackDownloadStatus[PackDownloadStatus["Importing"] = 2] = "Importing";
  PackDownloadStatus[PackDownloadStatus["Completed"] = 3] = "Completed";
})(PackDownloadStatus || (PackDownloadStatus = {}));

let PackActionError;

(function (PackActionError) {
  PackActionError[PackActionError["InvalidContentType"] = 0] = "InvalidContentType";
  PackActionError[PackActionError["InvalidPackId"] = 1] = "InvalidPackId";
  PackActionError[PackActionError["InvalidWorldId"] = 2] = "InvalidWorldId";
  PackActionError[PackActionError["ContentTierIncompatible"] = 3] = "ContentTierIncompatible";
  PackActionError[PackActionError["ContentTierIncompatibleMemory"] = 4] = "ContentTierIncompatibleMemory";
  PackActionError[PackActionError["ContentTierIncompatibleRayTracing"] = 5] = "ContentTierIncompatibleRayTracing";
  PackActionError[PackActionError["PackDataWarning"] = 6] = "PackDataWarning";
  PackActionError[PackActionError["PackDependencyWarning"] = 7] = "PackDependencyWarning";
  PackActionError[PackActionError["PackSelectErrorNoStore"] = 8] = "PackSelectErrorNoStore";
  PackActionError[PackActionError["PackSelectErrorRequiredDependency"] = 9] = "PackSelectErrorRequiredDependency";
  PackActionError[PackActionError["NoPackAccess"] = 10] = "NoPackAccess";
  PackActionError[PackActionError["UnownedContent"] = 11] = "UnownedContent";
  PackActionError[PackActionError["NeedToDownloadPack"] = 12] = "NeedToDownloadPack";
  PackActionError[PackActionError["UnsupportedFileFormat"] = 13] = "UnsupportedFileFormat";
  PackActionError[PackActionError["IncompletePack"] = 14] = "IncompletePack";
  PackActionError[PackActionError["NoManifest"] = 15] = "NoManifest";
  PackActionError[PackActionError["MissingProperty"] = 16] = "MissingProperty";
  PackActionError[PackActionError["WrongTypeProperty"] = 17] = "WrongTypeProperty";
  PackActionError[PackActionError["EmptyProperty"] = 18] = "EmptyProperty";
  PackActionError[PackActionError["InvalidProperty"] = 19] = "InvalidProperty";
  PackActionError[PackActionError["MalformedPropertyUUID"] = 20] = "MalformedPropertyUUID";
  PackActionError[PackActionError["MalformedPropertyVERSION"] = 21] = "MalformedPropertyVERSION";
  PackActionError[PackActionError["DuplicateUUID"] = 22] = "DuplicateUUID";
  PackActionError[PackActionError["InvalidJSON"] = 23] = "InvalidJSON";
  PackActionError[PackActionError["MissingModules"] = 24] = "MissingModules";
  PackActionError[PackActionError["MultipleModules"] = 25] = "MultipleModules";
  PackActionError[PackActionError["UnsupportedFormatVersion"] = 26] = "UnsupportedFormatVersion";
  PackActionError[PackActionError["VersionTooHigh"] = 27] = "VersionTooHigh";
  PackActionError[PackActionError["VersionTooLow"] = 28] = "VersionTooLow";
  PackActionError[PackActionError["UnexpectedError"] = 29] = "UnexpectedError";
})(PackActionError || (PackActionError = {}));

let PackDownloadError;

(function (PackDownloadError) {
  PackDownloadError[PackDownloadError["HasPendingOrActiveImports"] = 0] = "HasPendingOrActiveImports";
  PackDownloadError[PackDownloadError["HasUnownedPacks"] = 1] = "HasUnownedPacks";
  PackDownloadError[PackDownloadError["RealmsPlusEnded"] = 2] = "RealmsPlusEnded";
  PackDownloadError[PackDownloadError["MissingDlcDependencies"] = 3] = "MissingDlcDependencies";
  PackDownloadError[PackDownloadError["MissingDlcWorldTemplate"] = 4] = "MissingDlcWorldTemplate";
  PackDownloadError[PackDownloadError["NoInternet"] = 5] = "NoInternet";
  PackDownloadError[PackDownloadError["HasPerformanceIssues"] = 6] = "HasPerformanceIssues";
  PackDownloadError[PackDownloadError["NotEnoughDiskSpace"] = 7] = "NotEnoughDiskSpace";
  PackDownloadError[PackDownloadError["WifiRequiredYetNotAccessible"] = 8] = "WifiRequiredYetNotAccessible";
  PackDownloadError[PackDownloadError["MissingRequiredWorldTemplateRequestUserApproval"] = 9] = "MissingRequiredWorldTemplateRequestUserApproval";
  PackDownloadError[PackDownloadError["InvalidPack"] = 10] = "InvalidPack";
  PackDownloadError[PackDownloadError["InvalidWorld"] = 11] = "InvalidWorld";
  PackDownloadError[PackDownloadError["UnexpectedError"] = 12] = "UnexpectedError";
})(PackDownloadError || (PackDownloadError = {}));

const WORLD_PACKAGES_FACET = 'vanilla.worldPackages';
const worldPackagesFacet = (0,react_facet_src.sharedFacet)(WORLD_PACKAGES_FACET);
;// CONCATENATED MODULE: ./games/vanilla/engine/src/index.ts
































































;// CONCATENATED MODULE: ./packages/ui/src/GlassPane/GlassPane.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const GlassPane_GlassPane = ({"glassPane":"mneRL"});
;// CONCATENATED MODULE: ./packages/ui/src/GlassPane/GlassPane.tsx




function GlassPane_GlassPane_GlassPane({
  onClick,
  innerRef,
  children,
  role = 'neutral50'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  const glassPaneClassNames = classnames_default()(GlassPane_GlassPane.glassPane, semanticColors.overlay.base);
  return children != null ? /*#__PURE__*/react.createElement("div", {
    onClick: onClick,
    className: glassPaneClassNames,
    ref: innerRef
  }, children) : /*#__PURE__*/react.createElement("div", {
    onClick: onClick,
    className: glassPaneClassNames,
    ref: innerRef
  });
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBarLayout.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBarLayout_NavigationBarLayout = ({"NavigationBarLayout":"JAtEp","NavigationBarLayoutChildrenWrapper":"jCHoJ","NavigationBarLayoutChildren":"LH19k"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NavigationBar = ({"NavigationBar":"KfhFh","NavigationBarShadow":"V4fHo","NavigationBarDropShadow":"twp35","center":"S9tQ7","left":"C0sd8","right":"m2lNR","NavigationBarSafeZoneWrapper":"xCDda"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBar/NavigationBar.tsx





function NavigationBar_NavigationBar({
  left,
  center,
  right,
  safeZone,
  innerRef,
  role = 'neutral20',
  showDropShadow = true
}) {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBar, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      paddingTop: safeZone && safeZone.top + 'px',
      paddingRight: safeZone && safeZone.right + 'px',
      paddingLeft: safeZone && safeZone.left + 'px'
    }
  }, /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: NavigationBar.NavigationBarSafeZoneWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.left
  }, left), /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.center
  }, center), /*#__PURE__*/react.createElement("div", {
    className: NavigationBar.right
  }, right)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    top: false,
    right: false,
    left: false,
    role: role
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBarShadow, semanticColors.shadow.base)
  }), showDropShadow && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(NavigationBar.NavigationBarDropShadow)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    role: role,
    top: false,
    right: false,
    left: false
  }))));
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/images/arrowBack.png
const arrowBack_namespaceObject = __webpack_require__.p + "assets/arrowBack-b77b1.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/images/arrowBackDisabled.png
const arrowBackDisabled_namespaceObject = __webpack_require__.p + "assets/arrowBackDisabled-df022.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowBack = ({"iconArrowBack":"WLynF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowBack/IconArrowBack.tsx
function IconArrowBack_extends() { IconArrowBack_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowBack_extends.apply(this, arguments); }

function IconArrowBack_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowBack_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowBack_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








const IconArrowBack_IconArrowBack = (_ref) => {
  let {
    className,
    disabled
  } = _ref,
      props = IconArrowBack_objectWithoutProperties(_ref, ["className", "disabled"]);

  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false);
  const classNames = useCombinedClassNames(IconArrowBack.iconArrowBack, className);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: disabledFacet
  }, /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowBack_extends({}, props, {
    className: classNames,
    src: arrowBackDisabled_namespaceObject,
    imageRendering: "pixelated"
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: disabledFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowBack_extends({}, props, {
    className: classNames,
    src: arrowBack_namespaceObject,
    imageRendering: "pixelated"
  }))));
};
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackButton = ({"emptySpace":"QZTxX"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/BackButton/BackButton.tsx










function BackButton_BackButton({
  onClick,
  disabled,
  showEmptySpaceWhenGamepad = false,
  role = 'inherit',
  hint = ''
}) {
  const isPointerSupported = useIsPointerSupported();
  const isFocusInputGamepad = useIsFocusInputGamepad();
  const showBackButton = (0,react_facet_src.useFacetMap)((isPointerInputSupported, isFocusInputGamepad) => isPointerInputSupported || !isFocusInputGamepad, [], [isPointerSupported, isFocusInputGamepad]);
  const showEmptySpace = (0,react_facet_src.useFacetMap)(showBackButton => showEmptySpaceWhenGamepad && !showBackButton, [showEmptySpaceWhenGamepad], [showBackButton]);
  const {
    t
  } = useLocalization_useLocalization('BackButton');
  const shortcutOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.B,
    inputLegend: t('.back'),
    disabled: isAnyModalVisible
  }), [t], [Modal_Modal_Modal.useIsAnyModalVisible()]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: shortcutOptions,
    onClick: onClick
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showBackButton
  }, /*#__PURE__*/react.createElement(DefaultBackButton, {
    onClick: onClick,
    disabled: disabled,
    role: role,
    hint: hint
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showEmptySpace
  }, /*#__PURE__*/react.createElement("div", {
    className: BackButton.emptySpace
  })));
}

function DefaultBackButton({
  onClick,
  disabled,
  role = 'inherit',
  hint = ''
}) {
  const {
    t
  } = useLocalization_useLocalization('BackButton');
  const semanticSounds = useSemanticSounds(role);
  return /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    narrationText: [t('.narrationGoBack'), t('.narrationComponentType'), hint].join(' . '),
    gamepadIndex: 0,
    inputLegend: t('.back'),
    onClick: onClick,
    disabled: disabled,
    soundEffectPressed: semanticSounds.press,
    role: role,
    testId: "navigation-bar-layout-back-button"
  }, /*#__PURE__*/react.createElement(IconArrowBack_IconArrowBack, null));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/images/filter.png
const filter_namespaceObject = __webpack_require__.p + "assets/filter-93196.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/images/hamburger.png
const hamburger_namespaceObject = __webpack_require__.p + "assets/hamburger-3fe0f.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuButton = ({"icon":"w6_7m"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/MenuButton/MenuButton.tsx








function MenuButton_MenuButton({
  onClick,
  selected,
  disabled,
  type = 'hamburger',
  gamepadIndex,
  role = 'inherit',
  narrationText
}) {
  const {
    t
  } = useLocalization_useLocalization('NavigationBarLayout.MenuButton');
  return /*#__PURE__*/react.createElement(react.Fragment, null, type === 'hamburger' && /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: {
      button: types_ButtonType.START,
      inputLegend: t('.inputLegend')
    },
    onClick: onClick
  }), /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    disabled: disabled,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.inputLegend'),
    narrationText: narrationText !== null && narrationText !== void 0 ? narrationText : t('.narration'),
    onClick: onClick,
    role: role,
    selected: selected
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: MenuButton.icon,
    imageRendering: "pixelated",
    src: type === 'filter' ? filter_namespaceObject : hamburger_namespaceObject
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/DebugButton/images/debug-icon.png
const debug_icon_namespaceObject = __webpack_require__.p + "assets/debug-icon-df18b.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/DebugButton/DebugButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DebugButton = ({"icon":"QQfwv"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/DebugButton/DebugButton.tsx






function DebugButton_DebugButton({
  onClick,
  selected,
  disabled,
  gamepadIndex,
  role = 'inherit',
  narrationText
}) {
  const {
    t
  } = useLocalization_useLocalization('NavigationBarLayout.DebugButton');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    disabled: disabled,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.inputLegend'),
    narrationText: narrationText !== null && narrationText !== void 0 ? narrationText : t('.narration'),
    onClick: onClick,
    role: role,
    selected: selected
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: DebugButton.icon,
    imageRendering: "pixelated",
    src: debug_icon_namespaceObject
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/CollapsableSideBar/CollapsableSideBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const CollapsableSideBar = ({"collapsableSideBar":"G1xD7","collapsableSideBarDark":"deJBY","collapsed":"eknQ4","borderRight":"sJUSR","borderLeft":"d5YO7","floatingRight":"b8Law","floatingLeft":"efBI4"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/CollapsableSideBar/CollapsableSideBar.tsx






function CollapsableSideBar_CollapsableSideBar({
  children,
  collapsed = false,
  floating = false,
  onDismiss,
  gamepadIndex,
  align = 'left'
}) {
  const ref = (0,react.useRef)(null);
  const handleOnClick = (0,react.useCallback)(event => {
    event.stopPropagation();
  }, []);
  const collapsableSideBar = /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      defaultFocusedChildBehavior: 'remember',
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    onClick: handleOnClick,
    className: classnames_default()({
      [CollapsableSideBar.collapsed]: collapsed,
      [CollapsableSideBar.collapsableSideBar]: align === 'left',
      [CollapsableSideBar.collapsableSideBarDark]: align === 'right',
      [CollapsableSideBar.borderRight]: align === 'left',
      [CollapsableSideBar.borderLeft]: align === 'right'
    })
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, children)));
  return floating ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [CollapsableSideBar.floatingRight]: align === 'right',
      [CollapsableSideBar.floatingLeft]: align === 'left',
      [CollapsableSideBar.collapsed]: collapsed
    })
  }, collapsableSideBar), !collapsed && /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, {
    onClick: onDismiss
  })) : collapsableSideBar;
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/FriendsButton/images/navbar-friends-icon-1.png
const navbar_friends_icon_1_namespaceObject = __webpack_require__.p + "assets/navbar-friends-icon-1-42130.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/FriendsButton/images/navbar-friends-icon-2.png
const navbar_friends_icon_2_namespaceObject = __webpack_require__.p + "assets/navbar-friends-icon-2-6a99b.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/FriendsButton/images/navbar-friends-icon-3.png
const navbar_friends_icon_3_namespaceObject = __webpack_require__.p + "assets/navbar-friends-icon-3-1fd21.png";
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/FriendsButton/FriendsButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const FriendsButton = ({"navButton":"r5Ne9","icon":"GNMZ6","iconWrapper":"s2NCr"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/FriendsButton/FriendsButton.tsx









const iconRng = Math.floor(Math.random() * 10);
const RandomIconAsset = // Static asset for test environments
 false ? 0 : // 10% chance
iconRng === 1 ? navbar_friends_icon_3_namespaceObject : // 10% chance
iconRng === 2 ? navbar_friends_icon_2_namespaceObject : // 80% chance
navbar_friends_icon_1_namespaceObject;
function FriendsButton_FriendsButton({
  onClick,
  disabled,
  gamepadIndex,
  role = 'inherit',
  friendsOnline
}) {
  const {
    t
  } = useLocalization_useLocalization('NavigationBarLayout.FriendsButton');
  return /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    className: FriendsButton.navButton,
    disabled: disabled,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.inputLegend'),
    narrationText: t('.narration'),
    onClick: onClick,
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: FriendsButton.iconWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: FriendsButton.icon,
    src: RandomIconAsset,
    imageRendering: "pixelated"
  }), friendsOnline != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, "(", /*#__PURE__*/react.createElement("fast-text", {
    text: friendsOnline
  }), ")"))));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/Divider/Divider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Divider = ({"divider":"JP2CP"});
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/Divider/Divider.tsx



function Divider_Divider() {
  return /*#__PURE__*/react.createElement("div", {
    className: Divider.divider
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    right: false,
    top: false,
    bottom: false,
    reversed: true
  }), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular",
    left: false,
    top: false,
    bottom: false,
    reversed: true
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/NavigationBarLayout/NavigationBarLayout.tsx

















function NavigationBarLayout_NavigationBarLayout_NavigationBarLayout({
  children,
  collapsedLeftSidebar = true,
  collapsedRightSidebar = true,
  onToggleCollapsedLeftSidebar = NavigationBarLayout_noop,
  onToggleCollapsedRightSidebar = NavigationBarLayout_noop,
  innerRef,
  left,
  center,
  right,
  leftSidebar,
  rightSidebar,
  onBackButton,
  backButtonDisabled,
  footer,
  narrationText,
  navigationBarRole,
  navigationBarShowDropShadow = true,
  delegateByAlias,
  gamepadAlias,
  shouldNotDelegateToContent = false,
  defaultFocusedChildBehavior: defaultFocusedChildBehaviorProp
}) {
  const narrationTextFacet = (0,react_facet_src.useFacetMap)(text => text !== null && text !== void 0 ? text : '', [], [(0,react_facet_src.useFacetWrap)(narrationText)]);
  const safeZone = useSafeZone();
  const isNarrow = useIsWindowNarrow();
  const ref = (0,react.useRef)(null);
  const navigationBarRef = (0,react.useRef)(null);
  const defaultInnerRef = (0,react.useRef)(null);
  const footerRef = (0,react.useRef)(null);
  const {
    version: gamepadAdapterVersion
  } = useGamepadAdapter();
  const defaultFocusedChildBehavior = gamepadAdapterVersion === GamepadAdapterVersion.VISUAL ? defaultFocusedChildBehaviorProp : !collapsedRightSidebar ? 'last' : 'first';
  const {
    t: bt
  } = useLocalization_useLocalization('BackButton');
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationTextFacet
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    scrollRef: innerRef || defaultInnerRef,
    defaultFocusedChildBehavior: "remember",
    defaultFocusedChildAlias: shouldNotDelegateToContent ? undefined : gamepadAlias,
    gamepadIndex: 0
  }, onBackButton && /*#__PURE__*/react.createElement(LandmarkShortcut, {
    onClick: onBackButton,
    options: {
      button: types_ButtonType.B,
      inputLegend: bt('.back')
    }
  }), /*#__PURE__*/react.createElement("div", {
    ref: innerRef || defaultInnerRef,
    className: NavigationBarLayout_NavigationBarLayout.NavigationBarLayout
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: navigationBarRef,
    defaultFocusedChildBehavior: "remember",
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(NavigationBar_NavigationBar, {
    innerRef: navigationBarRef,
    left: /*#__PURE__*/react.createElement(react.Fragment, null, onBackButton && /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.BackButton, {
      disabled: backButtonDisabled,
      onClick: onBackButton
    }), left, isNarrow && leftSidebar != null && /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.MenuButton, {
      selected: !collapsedLeftSidebar,
      onClick: onToggleCollapsedLeftSidebar,
      gamepadIndex: 0
    })),
    center: center,
    right: /*#__PURE__*/react.createElement(react.Fragment, null, right, rightSidebar != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.MenuButton, {
      type: "filter",
      selected: !collapsedRightSidebar,
      onClick: onToggleCollapsedRightSidebar,
      gamepadIndex: 1
    }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 3
    }))),
    safeZone: safeZone,
    role: navigationBarRole,
    showDropShadow: navigationBarShowDropShadow
  })), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: ref,
    gamepadIndex: 1,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior,
    defaultFocusedChildAlias: delegateByAlias,
    alias: gamepadAlias
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: NavigationBarLayout_NavigationBarLayout.NavigationBarLayoutChildrenWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: NavigationBarLayout_NavigationBarLayout.NavigationBarLayoutChildren,
    style: {
      left: safeZone.left + 'px',
      right: safeZone.right + 'px',
      bottom: safeZone.bottom + 'px'
    }
  }, leftSidebar != null && /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0,
    disabled: collapsedLeftSidebar && isNarrow
  }, /*#__PURE__*/react.createElement(CollapsableSideBar_CollapsableSideBar, {
    align: "left",
    onDismiss: onToggleCollapsedLeftSidebar,
    floating: isNarrow,
    collapsed: isNarrow && collapsedLeftSidebar,
    gamepadIndex: 0
  }, leftSidebar)), /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1,
    disabled: !collapsedLeftSidebar && isNarrow && Boolean(leftSidebar)
  }, children), rightSidebar != null && /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 2,
    disabled: collapsedRightSidebar
  }, /*#__PURE__*/react.createElement(CollapsableSideBar_CollapsableSideBar, {
    align: "right",
    onDismiss: onToggleCollapsedRightSidebar,
    floating: isNarrow,
    collapsed: collapsedRightSidebar,
    gamepadIndex: 0
  }, rightSidebar))))), footer != null ? /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: footerRef,
    gamepadIndex: 2,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, footer) : null)));
}
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.displayName = 'NavigationBarLayout';
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.BackButton = BackButton_BackButton;
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.MenuButton = MenuButton_MenuButton;
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.FriendsButton = FriendsButton_FriendsButton;
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.DebugButton = DebugButton_DebugButton;
NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.Divider = Divider_Divider;

const NavigationBarLayout_noop = () => {};
;// CONCATENATED MODULE: ./packages/ui/src/Grid/Grid.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Grid_Grid = ({"grid":"ntKoM","fullScreen":"zoAa3","row":"RdcBM","column":"HC8D1","centerContentVertically":"hMR_2","gridGutters":"ff9nb","gridTablet":"U7wpy","gridNarrow":"QkM5F","rowFullHeight":"RLVUP","size0":"QfUEI","size1":"Utxph","size2":"Dg54A","size3":"MMNOr","size4":"vkrmB","size5":"Vg8dV","size6":"prur7","size7":"PbjpE","size8":"KbazU","size9":"M3EqJ","size10":"sjbd3","size11":"Pp_FL","size12":"tylz3","sizeNarrow0":"ms6DS","sizeNarrow1":"JOyPB","sizeNarrow2":"LG4ow","sizeNarrow3":"jyNdx","sizeNarrow4":"fgAuI","sizeNarrow5":"lGz_T","sizeNarrow6":"drXOL","sizeNarrow7":"VDLgd","sizeNarrow8":"A06Gv"});
;// CONCATENATED MODULE: ./packages/ui/src/Grid/Grid.tsx







const Column = props => {
  const {
    disabled,
    wideSize,
    narrowSize,
    innerRef
  } = props;
  const sizeStyle = classnames_default()(Grid_Grid[`size${wideSize}`], Grid_Grid[`sizeNarrow${narrowSize}`]);
  const className = classnames_default()(Grid_Grid.column, sizeStyle);

  if ('gamepadIndex' in props) {
    return /*#__PURE__*/react.createElement(ColumnLegacy, {
      options: {
        index: props.gamepadIndex,
        disabled
      }
    }, /*#__PURE__*/react.createElement("div", {
      className: className
    }, props.children));
  } // Column used as a spacer


  return /*#__PURE__*/react.createElement("div", {
    ref: innerRef,
    className: className
  });
};

function Row(props) {
  const {
    children,
    disabled,
    fullHeight,
    className,
    innerRef
  } = props;
  const classNames = (0,dist.useFacetMap)(className => classnames_default()(Grid_Grid.row, className, {
    [Grid_Grid.rowFullHeight]: fullHeight
  }), [fullHeight], [(0,dist.useFacetWrap)(className !== null && className !== void 0 ? className : '')]);
  const maxWidth = (0,react.useContext)(maxWidthContext);

  if ('gamepadIndex' in props) {
    return /*#__PURE__*/react.createElement(Row_RowLegacy, {
      options: {
        index: props.gamepadIndex,
        disabled
      }
    }, /*#__PURE__*/react.createElement("fast-div", {
      ref: innerRef,
      className: classNames,
      style: {
        maxWidth: `${maxWidth}rem`
      }
    }, children));
  }

  return /*#__PURE__*/react.createElement("fast-div", {
    ref: innerRef,
    className: classNames
  }, children);
}

function Grid_Grid_Grid({
  children,
  narrowBreakpointWidth,
  noGutters = false,
  centerContentVertically,
  maxWidth = DEFAULT_MAX_WIDTH,
  nonFullScreen = false
}) {
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint(narrowBreakpointWidth);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Grid_Grid.grid, {
      [Grid_Grid.gridNarrow]: breakpoint === 'narrow',
      [Grid_Grid.gridTablet]: breakpoint === 'tablet',
      [Grid_Grid.gridGutters]: breakpoint === 'desktop' || !noGutters,
      [Grid_Grid.centerContentVertically]: centerContentVertically,
      [Grid_Grid.fullScreen]: !nonFullScreen
    })
  }, /*#__PURE__*/react.createElement(maxWidthContext.Provider, {
    value: maxWidth
  }, children));
}
const DEFAULT_MAX_WIDTH = 128;
/**
 * Max Width is a Grid configuration, but it needs to be applied at the Row level.
 * So, we use a context.
 */

const maxWidthContext = (0,react.createContext)(DEFAULT_MAX_WIDTH);
Grid_Grid_Grid.displayName = 'Grid';
Grid_Grid_Grid.Column = Column;
Grid_Grid_Grid.Row = Row;
;// CONCATENATED MODULE: ./packages/react-gamepad/src/useSetFocusedId.tsx



const src_useSetFocusedId_useSetFocusedId = () => {
  const setFocusedIdLegacy = useSetFocusedId_useSetFocusedId();
  const setFocusedIdVisual = setFocusedId_useSetFocusedId();
  const {
    version: gamepadVersion
  } = useGamepadAdapter();

  if (gamepadVersion === GamepadAdapterVersion.LEGACY) {
    return setFocusedIdLegacy;
  }

  return setFocusedIdVisual;
};
;// CONCATENATED MODULE: ./packages/ui/src/EmptyStateMessage/EmptyStateMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const EmptyStateMessage = ({"EmptyStateMessage":"dST3K","EmptyStateMessageBorderless":"iBeh_","singleButtonContainer":"PIvFb","twoButtonContainer":"JJ32W","tripleButtonContainer":"WDNdm","errorIllustration":"uGDPm"});
;// CONCATENATED MODULE: ./packages/ui/src/EmptyStateMessage/EmptyStateMessage.tsx














function useFocusButton(buttons, autofocus) {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  (0,react_facet_src.useFacetEffect)(buttons => {
    if (!autofocus) {
      return;
    }

    const buttonToFocus = buttons.find(b => b === null || b === void 0 ? void 0 : b.gamepadAlias);

    if ((buttonToFocus === null || buttonToFocus === void 0 ? void 0 : buttonToFocus.gamepadAlias) != null) {
      setFocusedId(buttonToFocus.gamepadAlias);
    }
  }, [autofocus, setFocusedId], [buttons]);
}

function EmptyStateButton({
  item,
  autofocus,
  gamepadIndex,
  numberOfSiblings,
  horizontal,
  linebreak
}) {
  const {
    t
  } = useLocalization_useLocalization('EmptyStateMessage');
  const onClick = (0,react_facet_src.useFacetCallback)(item => item.onClick, [], [item]);
  const inputLegend = (0,react_facet_src.useFacetMap)(item => {
    var _item$inputLegend;

    return (_item$inputLegend = item.inputLegend) !== null && _item$inputLegend !== void 0 ? _item$inputLegend : t('.buttonSelectInputLegend');
  }, [t], [item]);
  const text = (0,react_facet_src.useFacetMap)(item => item.text, [], [item]);
  const imgSrc = (0,react_facet_src.useFacetMap)(item => item.imgSrc, [], [item]);
  const isLastButton = (0,react_facet_src.useFacetMap)(numberOfSiblings => gamepadIndex === numberOfSiblings - 1, [gamepadIndex], [numberOfSiblings]); // Leaving these unwrapped until the underlying Pressable/Button components
  // are updated to accept FacetProp types for these props

  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(item => {
    var _item$variant;

    return (_item$variant = item.variant) !== null && _item$variant !== void 0 ? _item$variant : 'secondary';
  }, [], [item]));
  const gamepadAlias = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(item => item.gamepadAlias, [], [item]));
  const horizontalUnwrapped = (0,react_facet_src.useFacetUnwrap)(horizontal);
  const linebreakUnwrapped = (0,react_facet_src.useFacetUnwrap)(linebreak);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    linebreak: linebreakUnwrapped === true,
    horizontal: horizontalUnwrapped === true,
    delayedClick: true,
    variant: variant == react_facet_src.NO_VALUE ? 'secondary' : variant,
    onClick: onClick,
    inputLegend: inputLegend,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias == react_facet_src.NO_VALUE ? undefined : gamepadAlias,
    gamepadIndex: gamepadIndex,
    imgSrc: imgSrc
  }, text), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLastButton,
    condition: false
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  })));
}

function EmptyStateButtons(props) {
  const {
    buttons,
    autofocus,
    gamepadIndex
  } = props;
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const numberOfButtons = (0,react_facet_src.useFacetMap)(buttons => buttons.length, [], [buttons]);
  const isMoreThanOneButton = (0,react_facet_src.useFacetMap)(numberOfButtons => numberOfButtons > 1, [], [numberOfButtons]);
  const shouldLinebreak = (0,react_facet_src.useFacetMap)( // If there are three buttons on a wide/medium viewport, then linebreak.
  // Don't linebreak lots of buttons on narrow viewport as they can easily
  // overflow when the buttons get too small.
  numberOfButtons => numberOfButtons <= 2 || numberOfButtons > 2 && !(breakpoint === 'narrow'), [breakpoint], [numberOfButtons]);
  useFocusButton(buttons, autofocus);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(numberOfButtons => numberOfButtons === 1 ? EmptyStateMessage.singleButtonContainer : numberOfButtons === 2 ? EmptyStateMessage.twoButtonContainer : EmptyStateMessage.tripleButtonContainer, [], [numberOfButtons])
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (item, index) => /*#__PURE__*/react.createElement(EmptyStateButton, {
    linebreak: shouldLinebreak,
    horizontal: isMoreThanOneButton,
    item: item,
    gamepadIndex: index,
    autofocus: autofocus,
    numberOfSiblings: numberOfButtons
  })))));
} // A helper type for ensuring that we receive either the text prop, the title
// prop, or both. The component requires at least one of them.


function EmptyStateMessage_EmptyStateMessage({
  gamepadIndex,
  title,
  text,
  imgSrc,
  imgClass,
  buttons: buttonsFacetProp,
  autofocus,
  borderless = false,
  gamepadAlias,
  role = 'neutral80'
}) {
  const {
    t
  } = useLocalization_useLocalization('EmptyStateMessage');
  const imgSrcFacet = (0,react_facet_src.useFacetWrap)(imgSrc);
  const semanticColors = hooks_useSemanticColors(role);
  const className = classnames_default()(EmptyStateMessage.EmptyStateMessage, semanticColors.background.base, semanticColors.border.base, {
    [EmptyStateMessage.EmptyStateMessageBorderless]: borderless
  });
  const buttons = (0,react_facet_src.useFacetWrap)(buttonsFacetProp !== null && buttonsFacetProp !== void 0 ? buttonsFacetProp : []);
  const hasButton = (0,react_facet_src.useFacetMap)(buttons => buttons != null && buttons.length > 0, [], [buttons]);
  const wrappedText = (0,react_facet_src.useFacetWrap)(text !== null && text !== void 0 ? text : '');
  const wrappedTitle = (0,react_facet_src.useFacetWrap)(title !== null && title !== void 0 ? title : '');
  const narrationText = (0,react_facet_src.useFacetMap)( // If there is a button, we instead narrate the title when it's focused, then
  // the button, and then the text (via the Button's narrationSuffix prop)
  (title, text) => `${title} . ${t('.narrationTextBlock')} . ${text}`, [t], [wrappedTitle, wrappedText]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: (0,react_facet_src.useFacetMap)(hasButton => !hasButton, [], [hasButton]),
    className: className,
    classNameFocused: focusClass,
    gamepadIndex: gamepadIndex,
    narrationText: false,
    autofocus: autofocus,
    gamepadAlias: gamepadAlias
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "secondaryButton",
    role: role,
    align: "center"
  }, wrappedTitle), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(imgSrc => imgSrc != null, [], [imgSrcFacet])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    src: imgSrc,
    className: imgClass
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }))), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: role,
    variant: "dimmest",
    align: "center"
  }, wrappedText), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasButton
  }, /*#__PURE__*/react.createElement(EmptyStateButtons, {
    buttons: buttons,
    gamepadIndex: gamepadIndex,
    autofocus: autofocus
  }))));
}
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TabBar_TabBar = ({"tabBar":"skOQQ","tab":"vaqPZ","tabContainer":"d2Oi5","outerTab":"nYWhJ","tabEdge":"y6Sow","tabPressed":"Asqnc","indicator":"osEZN","tabFocused":"Fd_3e","hintContainerLeft":"kNiYk","hintContainerRight":"QmvqS","hintLeftKey":"UbMe_","hintRightKey":"psX5S","contentContainer":"vQ853","condensed":"zgD8j","hidden":"XlhDT","bumperHintWrapper":"z4iyJ"});
;// CONCATENATED MODULE: ./packages/ui/src/TabBar/TabBar.tsx

















function TabBar_TabBar_TabBar({
  tabs,
  gamepadIndex,
  gamepadAliasNamespace,
  value,
  onChange,
  narrationTitle,
  enableGamepadShortcuts,
  onTabHoveredSoundEffect,
  onTabPressedSoundEffect,
  isCondensed = false,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization_useLocalization('TabBar');
  const ref = (0,react.useRef)(null);
  const enableGamepadShortcutsFacet = (0,react_facet_src.useFacetWrap)(enableGamepadShortcuts !== null && enableGamepadShortcuts !== void 0 ? enableGamepadShortcuts : false);
  const tabsFacet = (0,react_facet_src.useFacetWrap)(tabs);
  const tabsLength = (0,react_facet_src.useFacetMap)(tabs => tabs.length, [], [tabsFacet]);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const narrationTextFacet = (0,react_facet_src.useFacetMap)(title => {
    return `${t('.narrationGroup', [title])}`;
  }, [t], [(0,react_facet_src.useFacetWrap)(narrationTitle)]);
  const semanticSounds = useSemanticSounds(role);
  const triggerSoundEffect = useSoundEffectTrigger();
  const onChangeWithSound = (0,react_facet_src.useFacetCallback)((pressedSoundEffect, currentValue) => (value, usingGamepadShortcut) => {
    if (currentValue === value) {
      return;
    }

    const soundEffect = pressedSoundEffect !== null && pressedSoundEffect !== void 0 ? pressedSoundEffect : semanticSounds.toggle;

    if (soundEffect != null) {
      triggerSoundEffect(soundEffect);
    }

    onChange(value, usingGamepadShortcut);
  }, [onChange, semanticSounds.toggle, triggerSoundEffect], [(0,react_facet_src.useFacetWrap)(onTabPressedSoundEffect), valueFacet]);
  const rowOptions = (0,react_facet_src.useFacetMap)(value => {
    const options = {
      index: gamepadIndex,
      defaultFocusedChildBehavior: 'remember',
      defaultFocusedChildAlias: getFocusAlias(gamepadAliasNamespace, value == null ? '' : value)
    };
    return options;
  }, [gamepadIndex, gamepadAliasNamespace], [valueFacet]); // Tab label, tab, selected | not selected, x of y

  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationTextFacet
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: rowOptions,
    scrollRef: ref
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: TabBar_TabBar.tabBar
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tabsFacet
  }, (tab, index) => /*#__PURE__*/react.createElement(Tab, {
    gamepadAliasNamespace: gamepadAliasNamespace,
    key: `tab_${index}`,
    index: index,
    length: tabsLength,
    tab: tab,
    selectedTab: valueFacet,
    onChange: onChangeWithSound,
    onTabHoveredSoundEffect: onTabHoveredSoundEffect,
    isCondensed: isCondensed
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: enableGamepadShortcutsFacet
  }, /*#__PURE__*/react.createElement(BumperHints, {
    value: valueFacet,
    onChange: onChangeWithSound,
    tabs: tabsFacet
  })))));
}

const BumperHints = function ({
  value,
  tabs,
  onChange
}) {
  const isFocusInputGamepad = useIsFocusInputGamepad();
  const isFocusInputKeyboard = useIsFocusInputKeyboard();
  const isFocusInputAvailable = useIsFocusInputAvailable();
  const tabIndexToValue = (0,react_facet_src.useFacetCallback)(tabs => selectedIndex => {
    return tabs[selectedIndex].value;
  }, [], [tabs]);
  const tabValueToIndex = (0,react_facet_src.useFacetCallback)(tabs => newValue => {
    return tabs.findIndex(({
      value
    }) => value === newValue);
  }, [], [tabs]);
  const selectedIndex = (0,react_facet_src.useFacetMap)(value => tabValueToIndex(value), [tabValueToIndex], [value]);
  const leftBumperPress = (0,react_facet_src.useFacetCallback)(selectedIndex => () => {
    const newSelectedIndex = selectedIndex - 1;

    if (newSelectedIndex > -1) {
      const result = tabIndexToValue(newSelectedIndex);

      if (result !== react_facet_src.NO_VALUE) {
        onChange(result, true);
      }
    }
  }, [tabIndexToValue, onChange], [selectedIndex]);
  const rightBumperPress = (0,react_facet_src.useFacetCallback)((tabs, selectedIndex) => () => {
    const newSelectedIndex = selectedIndex + 1;

    if (newSelectedIndex < tabs.length) {
      const result = tabIndexToValue(newSelectedIndex);

      if (result !== react_facet_src.NO_VALUE) {
        onChange(result, true);
      }
    }
  }, [tabIndexToValue, onChange], [tabs, selectedIndex]);
  const isAnyModalVisible = Modal_Modal_Modal.useIsAnyModalVisible();
  const leftBumperOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.LEFT_BUMPER,
    disabled: isAnyModalVisible
  }), [], [isAnyModalVisible]);
  const rightBumperOptions = (0,react_facet_src.useFacetMap)(isAnyModalVisible => ({
    button: types_ButtonType.RIGHT_BUMPER,
    disabled: isAnyModalVisible
  }), [], [isAnyModalVisible]);
  const gamepadBumperClassName = (0,react_facet_src.useFacetMap)(isGamepad => isGamepad ? TabBar_TabBar.bumperHintWrapper : `${TabBar_TabBar.bumperHintWrapper} ${TabBar_TabBar.hidden}`, [], [isFocusInputGamepad]);
  const keyboardBumperClassName = (0,react_facet_src.useFacetMap)(isKeyboard => isKeyboard ? TabBar_TabBar.bumperHintWrapper : `${TabBar_TabBar.bumperHintWrapper} ${TabBar_TabBar.hidden}`, [], [isFocusInputKeyboard]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isFocusInputAvailable
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: leftBumperOptions,
    onClick: leftBumperPress
  }), /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: rightBumperOptions,
    onClick: rightBumperPress
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: gamepadBumperClassName
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.hintContainerLeft
  }, /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: types_ButtonType.LEFT_BUMPER
  })), /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.hintContainerRight
  }, /*#__PURE__*/react.createElement(ButtonIcon.Gamepad, {
    button: types_ButtonType.RIGHT_BUMPER
  }))), /*#__PURE__*/react.createElement("fast-div", {
    className: keyboardBumperClassName
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.hintLeftKey
  }, /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: KeyboardKey.KEY_Q
  })), /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.hintRightKey
  }, /*#__PURE__*/react.createElement(ButtonIcon.Keyboard, {
    keyCode: KeyboardKey.KEY_E
  })))));
};

function Tab({
  gamepadAliasNamespace,
  selectedTab,
  onChange,
  index,
  length,
  tab,
  onTabHoveredSoundEffect,
  onTabPressedSoundEffect,
  isCondensed = false,
  role = 'neutral'
}) {
  const {
    t
  } = useLocalization_useLocalization('TabBar');
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const semanticColors = hooks_useSemanticColors(role);
  const modifiers = useSemanticModifiers();
  const isSelected = (0,react_facet_src.useFacetMap)((selected, tab) => selected === tab.value, [], [selectedTab, tab]);
  const selected = (0,react_facet_src.useFacetUnwrap)(isSelected);
  const narrationText = (0,react_facet_src.useFacetMap)((tab, isSelected, length) => [tab.label, t('.narrationComponentType'), t('.selectedTab', [`${index + 1}`, `${length}`]), t(`.${isSelected ? 'selected' : 'notSelected'}`), tab.hint].filter(x => x).join(' . '), [index, t], [tab, isSelected, length]);
  const className = (0,react_facet_src.useFacetMap)(isSelected => {
    return classnames_default()(TabBar_TabBar.tab, semanticColors.background.interactive, semanticColors.border.base, {
      [TabBar_TabBar.condensed]: isCondensed,
      [modifiers.pressed]: isSelected,
      [TabBar_TabBar.tabPressed]: isSelected
    });
  }, [isCondensed, modifiers, semanticColors], [isSelected]);
  const onClick = (0,react_facet_src.useFacetCallback)(tab => () => {
    narrateText(t('.selected'));
    onChange(tab.value, false);
  }, [narrateText, onChange, t], [tab]);
  const gamepadAlias = (0,react_facet_src.useFacetMap)(tab => getFocusAlias(gamepadAliasNamespace, tab.value), [gamepadAliasNamespace], [tab]);
  const inputLegend = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? false : t('.open'), [t], [isSelected]);
  const icons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)((tab, isSelected) => tab.icons && /*#__PURE__*/react.createElement(react.Fragment, null, tab.icons[isSelected ? 'selected' : 'unselected'], /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })), [], [tab, isSelected]));
  const label = (0,react_facet_src.useFacetMap)(tab => tab.label, [], [tab]);

  if (selected === react_facet_src.NO_VALUE) {
    return null;
  }

  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: className,
    classNameFocused: classnames_default()(TabBar_TabBar.tabFocused, focusClass),
    classNamePressed: TabBar_TabBar.tabPressed,
    onClick: onClick,
    gamepadAlias: gamepadAlias,
    gamepadIndex: index,
    inputLegend: inputLegend,
    soundEffectHovered: onTabHoveredSoundEffect,
    soundEffectPressed: onTabPressedSoundEffect,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role
  }), /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.tabContainer
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: role
  }), /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.outerTab,
    style:  false ? 0 : {}
  }, /*#__PURE__*/react.createElement("div", {
    className: TabBar_TabBar.contentContainer
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: role,
    verticalAlign: "center",
    disableable: selected,
    interactive: !selected
  }, icons !== react_facet_src.NO_VALUE && icons != null && icons, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, label))))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TabBar_TabBar.tabEdge, semanticColors.shadow.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelected
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TabBar_TabBar.indicator, semanticColors.icon.base)
  })));
}

function getFocusAlias(gamepadAliasNamespace, value) {
  return `tab-bar-${gamepadAliasNamespace}-${value}`;
}

TabBar_TabBar_TabBar.getFocusAlias = getFocusAlias;
// EXTERNAL MODULE: ./node_modules/@react-facet/deferred-mount/dist/index.js
var deferred_mount_dist = __webpack_require__(1170);
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/filter.ts
function filter(array, f) {
  const result = [];

  for (let i = 0; i < array.length; i++) {
    if (f(array[i], i, array)) {
      result.push(array[i]);
    }
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/ui/src/SectionList/SectionList.tsx








function SectionList_SectionList({
  header,
  renderItem,
  renderSectionHeader,
  data,
  gamepadIndex,
  itemSeparator,
  sectionSeparator,
  loading = false,
  footer,
  renderTracker,
  padSpinnerVertically,
  gamepadAlias
}) {
  const isRenderingPaused = (0,deferred_mount_dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const nonEmptySectionsFacet = (0,react_facet_src.useFacetMap)(sections => filter(sections, section => section.data.length > 0), [], [dataFacet]);
  const loadingValueRaw = (0,react_facet_src.useFacetUnwrap)(loading);
  const loadingValue = loadingValueRaw !== react_facet_src.NO_VALUE ? loadingValueRaw : false;
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(ScrollViewContainer, {
    loading: loadingValue,
    gamepadIndex: gamepadIndex,
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically,
    gamepadAlias: gamepadAlias
  }, header != null && /*#__PURE__*/react.createElement(react.Fragment, null, header, itemSeparator), isRenderingPaused === false && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: nonEmptySectionsFacet
  }, (section, index) => /*#__PURE__*/react.createElement(Section, {
    headerPresent: header != null,
    section: section,
    sectionIndex: index,
    sections: nonEmptySectionsFacet,
    renderSectionHeader: renderSectionHeader,
    renderItem: renderItem,
    sectionSeparator: sectionSeparator
  })), footer));
}

function Section({
  headerPresent,
  section: sectionFacet,
  sectionIndex,
  sections,
  renderSectionHeader,
  renderItem,
  sectionSeparator,
  itemSeparator
}) {
  const dataFacet = (0,react_facet_src.useFacetMap)(section => section.data, [], [sectionFacet]);
  const countFacet = (0,react_facet_src.useFacetMap)(section => section.data.length, [], [sectionFacet]);
  const titleFacet = (0,react_facet_src.useFacetMap)(section => section.title, [], [sectionFacet]);
  const roleFacet = (0,react_facet_src.useFacetMap)(section => section.role, [], [sectionFacet]);
  const sectionHeader = renderSectionHeader(titleFacet, roleFacet);
  const {
    t
  } = useLocalization_useLocalization('SectionList'); // If a section list header is present, the gamepad (not narration!) section indexes start on +1

  const actualSectionIndex = headerPresent ? sectionIndex + 1 : sectionIndex;
  return (
    /*#__PURE__*/
    // We need a column wrapping each section so that the indexes from
    // the buttons of each section don't overlap
    react.createElement(ColumnLegacy, {
      options: {
        index: actualSectionIndex
      },
      key: actualSectionIndex
    }, /*#__PURE__*/react.createElement(NarrationContextFacetified, {
      text: (0,react_facet_src.useFacetMap)(sections => {
        const section = sections[sectionIndex];
        return [t('.groupNarration', [section.narrationTitle != null ? section.narrationTitle : section.title, `${sectionIndex + 1}`, `${sections.length}`]), `${section.narrationSuffix != null ? section.narrationSuffix : ''}`].join(' . ');
      }, [sectionIndex, t], [sections, sectionFacet])
    }, sectionIndex > 0 && sectionSeparator, sectionHeader, itemSeparator, /*#__PURE__*/react.createElement(react_facet_src.Map, {
      array: dataFacet
    }, (itemFacet, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && itemSeparator, renderItem({
      itemFacet,
      index,
      sectionIndex: actualSectionIndex,
      listLengthFacet: countFacet
    })))))
  );
}

const NarrationContextFacetified = ({
  text,
  children
}) => {
  var _useFacetUnwrap;

  const textValueRaw = (_useFacetUnwrap = (0,react_facet_src.useFacetUnwrap)(text)) !== null && _useFacetUnwrap !== void 0 ? _useFacetUnwrap : '';
  const textValue = textValueRaw !== react_facet_src.NO_VALUE ? textValueRaw : '';
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: textValue
  }, children);
};

function ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  renderTracker,
  padSpinnerVertically,
  gamepadAlias
}) {
  const isDeferringFacet = (0,deferred_mount_dist.useIsDeferring)();
  const isPaused = (0,deferred_mount_dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => loading || isDeferring || isPaused, [loading, isPaused], [isDeferringFacet]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    renderTracker: renderTracker,
    padSpinnerVertically: padSpinnerVertically,
    gamepadAlias: gamepadAlias,
    defaultFocusedChildBehavior: "remember"
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/ListHeader/ListHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListHeader_ListHeader = ({"tagHeaderWrapper":"YimiS","header":"uydZW","tag":"ZXwO7"});
;// CONCATENATED MODULE: ./packages/ui/src/ListHeader/ListHeader.tsx






const ListHeader_ListHeader_ListHeader = ({
  label = '',
  role = 'neutral'
}) => {
  const roleFacet = (0,react_facet_src.useFacetWrap)(role);
  const semanticColors = hooks_useSemanticColors();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: ListHeader_ListHeader.tagHeaderWrapper
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(role => classnames_default()(ListHeader_ListHeader.header, semanticColors[role].background.base, semanticColors[role].border.base, semanticColors[role].text.base), [semanticColors], [roleFacet])
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: role
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: label
  }))), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(role => classnames_default()(ListHeader_ListHeader.tag, semanticColors[role].background.base, semanticColors[role].border.base), [semanticColors], [roleFacet])
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/FlatList/FlatList.tsx




function FlatList_FlatList({
  loading,
  emptyMessage,
  header,
  renderItem,
  data,
  gamepadIndex,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  itemSeparator,
  footer,
  renderTracker,
  horizontal = false,
  padSpinnerVertically,
  scrollViewRef,
  gamepadAlias,
  delegateFocusByAlias,
  defaultFocusedChildBehavior
}) {
  const isRenderingPaused = (0,deferred_mount_dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const countFacet = (0,react_facet_src.useFacetMap)(data => data.length, [], [dataFacet]);
  const countValue = (0,react_facet_src.useFacetUnwrap)(countFacet);
  const loadingValueRaw = (0,react_facet_src.useFacetUnwrap)(loading);
  const loadingValue = loadingValueRaw !== react_facet_src.NO_VALUE ? loadingValueRaw : false;
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(FlatList_ScrollViewContainer, {
    padSpinnerVertically: padSpinnerVertically,
    loading: loadingValue,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal,
    scrollViewRef: scrollViewRef,
    gamepadAlias: gamepadAlias,
    delegateFocusByAlias: delegateFocusByAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, header != null && /*#__PURE__*/react.createElement(react.Fragment, null, header, itemSeparator), isRenderingPaused === false && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataFacet
  }, (item, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && itemSeparator, renderItem({
    itemFacet: item,
    index,
    listLengthFacet: countFacet
  }))),
  /**
   * We need to deffer the empty message, since the DeferredMountProvider will be waiting
   * for something to be mounted using DeferredMount so that it will run its process and complete
   * any deferred rendering
   *
   * Removing this would cause an spinner to be shown for all eternity.
   */
  countValue != null && countValue === 0 && /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, emptyMessage)), footer != null && /*#__PURE__*/react.createElement(react.Fragment, null, itemSeparator, footer)));
}
function FlatList_ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  renderTracker,
  horizontal,
  padSpinnerVertically,
  scrollViewRef,
  gamepadAlias,
  delegateFocusByAlias,
  defaultFocusedChildBehavior
}) {
  const isDeferringFacet = (0,deferred_mount_dist.useIsDeferring)();
  const isPaused = (0,deferred_mount_dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => loading || isDeferring || isPaused, [loading, isPaused], [isDeferringFacet]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    padSpinnerVertically: padSpinnerVertically,
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal,
    innerRef: scrollViewRef,
    gamepadAlias: gamepadAlias,
    delegateFocusByAlias: delegateFocusByAlias,
    defaultFocusedChildBehavior: defaultFocusedChildBehavior
  }, children);
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/progress.png
const progress_namespaceObject = __webpack_require__.p + "assets/progress-27e63.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/gamerscore.png
const gamerscore_namespaceObject = __webpack_require__.p + "assets/gamerscore-43cf3.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/clock.png
const clock_namespaceObject = __webpack_require__.p + "assets/clock-f02fd.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/rewards.png
const rewards_namespaceObject = __webpack_require__.p + "assets/rewards-1ac83.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle0.png
const bottle0_namespaceObject = __webpack_require__.p + "assets/bottle0-85a72.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle1.png
const bottle1_namespaceObject = __webpack_require__.p + "assets/bottle1-6d884.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle2.png
const bottle2_namespaceObject = __webpack_require__.p + "assets/bottle2-89b45.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle3.png
const bottle3_namespaceObject = __webpack_require__.p + "assets/bottle3-f280f.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle4.png
const bottle4_namespaceObject = __webpack_require__.p + "assets/bottle4-9d636.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle5.png
const bottle5_namespaceObject = __webpack_require__.p + "assets/bottle5-7a0bc.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle6.png
const bottle6_namespaceObject = __webpack_require__.p + "assets/bottle6-6d98c.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle7.png
const bottle7_namespaceObject = __webpack_require__.p + "assets/bottle7-7d4eb.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle8.png
const bottle8_namespaceObject = __webpack_require__.p + "assets/bottle8-e355d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/images/bottle9.png
const bottle9_namespaceObject = __webpack_require__.p + "assets/bottle9-1c23e.png";
;// CONCATENATED MODULE: ./packages/ui/src/Summary/Summary.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Summary = ({"summary":"i2Nr0","spinner":"NQGrD","spinnerHidden":"ejkbA","divider":"juifw","data":"dIbWH","dataText":"VHEDr"});
;// CONCATENATED MODULE: ./packages/ui/src/Summary/Summary.tsx








Summary_Summary.Data = function Data({
  value,
  label,
  icon
}) {
  const semanticColors = hooks_useSemanticColors('inherit');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.data, semanticColors.background.base)
  }, icon, /*#__PURE__*/react.createElement("div", {
    className: Summary.dataText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, label), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort"
  }, value)));
};

Summary_Summary.Divider = function Divider() {
  const semanticColors = hooks_useSemanticColors('inherit');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.divider, semanticColors.shadow.base)
  });
};

function Summary_Summary({
  children,
  role = 'neutral80'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.summary, semanticColors.background.base, semanticColors.border.base)
  }, children));
}

const SummarySpinner = ({
  hidden
}) => {
  return /*#__PURE__*/react.createElement(TransitionPrimitive, {
    visible: !hidden,
    timeout: 500
  }, status => /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Summary.spinner, {
      [Summary.spinnerHidden]: status === 'exited' || status === 'exiting' || status === 'unmounted'
    })
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null)));
};

Summary_Summary.displayName = 'Summary';
Summary_Summary.SummarySpinner = SummarySpinner;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/AchievementsSummary.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementsSummary = ({"icon":"nC7ze","iconWrapper":"XOt1L","featuredData":"xVp12","featuredDataUpper":"KtzUL","featuredDataUpperDescription":"bJlOL","innerfeaturedDataPercentage":"BH570","bottle":"HJp4C","loadingSummaryPlaceholder":"knzR5"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementsSummary/AchievementsSummary.tsx






















function getBottle(percentageUnlocked) {
  if (percentageUnlocked === 0) return bottle0_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 2) return bottle2_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 3) return bottle3_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 4) return bottle4_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 5) return bottle5_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 6) return bottle6_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 7) return bottle7_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 8) return bottle8_namespaceObject;
  if (Math.round(percentageUnlocked * 10) === 9 || Math.round(percentageUnlocked * 10) === 10) return bottle9_namespaceObject;
  return bottle1_namespaceObject;
}

function AchievementsSummary_AchievementsSummary({
  inProgress,
  achievementsUnlocked,
  achievementsTotal,
  rewardsUnlocked,
  rewardsTotal,
  gamerScore,
  gamerScoreTotal,
  hoursPlayed,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('AchievementsSummary');
  const hasRewards = rewardsTotal != null && rewardsTotal > 0;
  const hasRewardsUnlocked = rewardsUnlocked != null && rewardsUnlocked > 0;
  const gamerscore = `${gamerScore}` + '/' + `${gamerScoreTotal}`;
  const percentageUnlocked = achievementsTotal === 0 ? 0 : achievementsUnlocked / achievementsTotal;
  const presentationProcent = !!achievementsTotal && !!achievementsUnlocked && percentageUnlocked * 100 > 98 ? Math.floor(percentageUnlocked * 100) : Math.ceil(percentageUnlocked * 100);
  const narrationIsEnabled = useNarrationEnabled();
  const narrationText = [t('.narratorTextBlock'), t('.narratorSummary'), t('.narratorIndex', ['1', '4']), t('.narratorPercentage', [`${presentationProcent}`]), t('.narratorCompletedAchievements', [`${achievementsUnlocked}`, `${achievementsTotal}`]), t('.narratorInProgress', [`${inProgress}`]), hasRewardsUnlocked && hasRewards ? t('.narratorCompletedRewards', [`${rewardsUnlocked}`, `${rewardsTotal}`]) : '', t('.narratorGamerscore', [`${gamerScore}`, `${gamerScoreTotal}`]), t('.narratorTimePlayed', [`${hoursPlayed}`])];
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    inputLegend: false,
    className: '',
    autofocus: true,
    classNameHovered: '',
    classNameFocused: focusClass,
    classNamePressed: '',
    disabled: !narrationIsEnabled,
    gamepadIndex: gamepadIndex,
    narrationText: narrationText.join(' - '),
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    withoutBorders: true,
    disabled: !narrationIsEnabled
  }), /*#__PURE__*/react.createElement(Summary_Summary, null, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredData
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredDataUpper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    src: getBottle(percentageUnlocked),
    className: AchievementsSummary.bottle
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "header2",
    shadow: true
  }, presentationProcent), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "header3",
    shadow: true
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.innerfeaturedDataPercentage
  }, "%"))), /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.featuredDataUpperDescription
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort"
  }, t('.percentage', [`${achievementsUnlocked}`, `${achievementsTotal}`])))), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: progress_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.progress'),
    value: inProgress
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), hasRewards && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: rewards_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.rewards'),
    value: `${rewardsUnlocked !== null && rewardsUnlocked !== void 0 ? rewardsUnlocked : 0}` + '/' + `${rewardsTotal}`
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null)), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: gamerscore_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.gamerscore'),
    value: gamerscore
  }), /*#__PURE__*/react.createElement(Summary_Summary.Divider, null), /*#__PURE__*/react.createElement(Summary_Summary.Data, {
    icon: /*#__PURE__*/react.createElement("div", {
      className: AchievementsSummary.iconWrapper
    }, /*#__PURE__*/react.createElement(Image_Image_Image, {
      src: clock_namespaceObject,
      imageRendering: "pixelated",
      className: AchievementsSummary.icon
    })),
    label: t('.time'),
    value: t('.hoursPlayed', [`${hoursPlayed}`])
  })));
}

// When narration is enabled in combination with a gamepad, the summary should not be narrated until the facet is loaded. To avoid this, Loading not containing InteractivePrimitive is returned
function Loading({
  loading
}) {
  return /*#__PURE__*/react.createElement(Summary_Summary, null, /*#__PURE__*/react.createElement("div", {
    className: AchievementsSummary.loadingSummaryPlaceholder
  }, /*#__PURE__*/react.createElement(Summary_Summary.SummarySpinner, {
    hidden: !loading
  })));
}

AchievementsSummary_AchievementsSummary.displayName = 'AchievementsSummary';
AchievementsSummary_AchievementsSummary.Loading = Loading;
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemAction.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItemAction = ({"action":"XJnhR","rowCell":"fCKUR","alignStart":"eHDyK","alignCenter":"erMph","columnCell":"i8zR5"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemAction.tsx






function ListItemAction_ListItemAction({
  autofocus,
  children,
  onClick,
  inputLegend,
  narrationText,
  gamepadAlias,
  soundEffectPressed,
  onFocusChanged,
  onHoverChanged,
  gamepadIndex = 0,
  role = 'neutral'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  const semanticSounds = useSemanticSounds(role);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(ListItemAction.action, semanticColors.background.interactive, semanticColors.text.base),
    classNameFocused: focusClass,
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel"
  }), children));
}
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/context/tall.tsx

const tallContext = (0,react.createContext)(false);
const useTallListItem = () => (0,react.useContext)(tallContext);
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ActionShortcut.tsx



function ActionShortcut({
  onClick,
  shortcut,
  inputLegend
}) {
  const inputLegendFacet = (0,react_facet_src.useFacetWrap)(inputLegend);
  return /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: (0,react_facet_src.useFacetMap)(inputLegend => ({
      button: shortcut,
      inputLegend
    }), [shortcut], [inputLegendFacet]),
    onClick: onClick
  });
}
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemAdditionalAction.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItemAdditionalAction = ({"additionalAction":"TxpPs","fitContent":"zNQoR","tallAdditionalAction":"hxjUN"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemAdditionalAction.tsx









function ListItemAdditionalAction_ListItemAdditionalAction({
  children,
  onClick,
  onGamepadClick,
  onUp,
  onDown,
  onLeft,
  onRight,
  onMouseDown,
  shortcut,
  inputLegend,
  narrationText,
  gamepadAlias,
  hidden = false,
  fitContent = false,
  gamepadIndex = 0,
  innerRef,
  touchDetectionDelay,
  soundEffectPressed,
  role = 'neutral',
  isSelected = false
}) {
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  const tall = useTallListItem();
  const semanticColors = hooks_useSemanticColors(role);
  const semanticSounds = useSemanticSounds(role);
  const modifiers = useSemanticModifiers();
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hiddenFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, shortcut != null && /*#__PURE__*/react.createElement(ActionShortcut, {
    onClick: onClick,
    shortcut: shortcut,
    inputLegend: inputLegend
  }), /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: classnames_default()(ListItemAdditionalAction.additionalAction, semanticColors.background.interactive, {
      [ListItemAdditionalAction.fitContent]: fitContent,
      [ListItemAdditionalAction.tallAdditionalAction]: tall,
      [modifiers.selected]: isSelected
    }),
    touchDetectionDelay: touchDetectionDelay,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press,
    classNameFocused: focusClass,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    onClick: onClick,
    onGamepadClick: onGamepadClick,
    onUp: onUp,
    onDown: onDown,
    onLeft: onLeft,
    onRight: onRight,
    onMouseDown: onMouseDown,
    narrationText: narrationText,
    innerRef: innerRef
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel"
  }), children)));
}
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemMain.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItemMain = ({"main":"Mmtqs"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemMain.tsx


function ListItemMain_ListItemMain({
  children
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: ListItemMain.main
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemCell.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItemCell = ({"rowCell":"KFyBZ","alignStart":"zfW8v","alignCenter":"CGp5V","columnCell":"Gqi8v","cell":"WdNXT"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemCell.tsx



function ListItemCell_ListItemCell({
  children,
  direction = 'column',
  align = 'end'
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ListItemCell.cell, {
      [ListItemCell.rowCell]: direction === 'row',
      [ListItemCell.columnCell]: direction === 'column',
      [ListItemCell.alignStart]: align === 'start',
      [ListItemCell.alignCenter]: align === 'center'
    })
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/images/pingGreen.png
const pingGreen_namespaceObject = __webpack_require__.p + "assets/pingGreen-7f77c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/IconPingGreen.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingGreen = ({"iconPingGreen":"V0B0o"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingGreen/IconPingGreen.tsx
function IconPingGreen_extends() { IconPingGreen_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconPingGreen_extends.apply(this, arguments); }

function IconPingGreen_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconPingGreen_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconPingGreen_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconPingGreen_IconPingGreen = (_ref) => {
  let {
    className
  } = _ref,
      props = IconPingGreen_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconPingGreen.iconPingGreen, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconPingGreen_extends({}, props, {
    className: classNames,
    src: pingGreen_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/images/pingRed.png
const pingRed_namespaceObject = __webpack_require__.p + "assets/pingRed-9496c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/IconPingRed.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingRed = ({"iconPingRed":"DeSbe"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingRed/IconPingRed.tsx
function IconPingRed_extends() { IconPingRed_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconPingRed_extends.apply(this, arguments); }

function IconPingRed_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconPingRed_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconPingRed_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconPingRed_IconPingRed = (_ref) => {
  let {
    className
  } = _ref,
      props = IconPingRed_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconPingRed.iconPingRed, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconPingRed_extends({}, props, {
    className: classNames,
    src: pingRed_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/images/pingYellow.png
const pingYellow_namespaceObject = __webpack_require__.p + "assets/pingYellow-f7a5a.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/IconPingYellow.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPingYellow = ({"iconPingYellow":"HxqCq"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPingYellow/IconPingYellow.tsx
function IconPingYellow_extends() { IconPingYellow_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconPingYellow_extends.apply(this, arguments); }

function IconPingYellow_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconPingYellow_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconPingYellow_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconPingYellow_IconPingYellow = (_ref) => {
  let {
    className
  } = _ref,
      props = IconPingYellow_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconPingYellow.iconPingYellow, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconPingYellow_extends({}, props, {
    className: classNames,
    src: pingYellow_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItemIcon = ({"icon":"mUN2d"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItemIcon.tsx





const getIcon = type => {
  switch (type) {
    case 'green':
      return /*#__PURE__*/react.createElement(IconPingGreen_IconPingGreen, null);

    case 'red':
      return /*#__PURE__*/react.createElement(IconPingRed_IconPingRed, null);

    case 'yellow':
      return /*#__PURE__*/react.createElement(IconPingYellow_IconPingYellow, null);
  }
};

function ListItemIcon_ListItemIcon({
  iconType,
  typographyType,
  role = 'inherit',
  text
}) {
  const icon = getIcon(iconType);
  return /*#__PURE__*/react.createElement("div", {
    className: ListItemIcon.icon
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: typographyType,
    role: role,
    variant: "dimmer"
  }, text), icon);
}
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItem_ListItem = ({"listItem":"YtiPa","tall":"sPd5G","small":"FA0TJ"});
;// CONCATENATED MODULE: ./packages/ui/src/ListItem/ListItem.tsx
















/**
 * ListItem root component.
 * It can defer the rendering of its children when used in a SectionList, FlatList or a context with DeferredMountProvider.
 */
function ListItem_ListItem_ListItem({
  tall = false,
  small = false,
  children,
  isFocusable = false,
  narrationText,
  gamepadAlias,
  gamepadIndex,
  innerRef,
  defaultFocusedChildBehavior,
  role = 'neutral80'
}) {
  const gamepadIndexFacet = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  const defaultFocusedChildBehaviorFacet = (0,react_facet_src.useFacetWrap)(defaultFocusedChildBehavior);
  const semanticColors = hooks_useSemanticColors(role);
  const narrationTextFacet = (0,react_facet_src.useFacetWrap)(narrationText !== null && narrationText !== void 0 ? narrationText : false);
  const rowOptions = (0,react_facet_src.useFacetMap)((gamepadIndex, defaultFocusedChildBehavior) => ({
    index: gamepadIndex,
    defaultFocusedChildBehavior
  }), [], [gamepadIndexFacet, defaultFocusedChildBehaviorFacet]);
  return /*#__PURE__*/react.createElement(tallContext.Provider, {
    value: tall
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isFocusable,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(ListItem_ListItem.listItem, semanticColors.border.base, semanticColors.text.base, semanticColors.background.base, {
      [ListItem_ListItem.tall]: tall,
      [ListItem_ListItem.small]: small,
      [ListItem_ListItem.inert]: isFocusable
    }),
    innerRef: innerRef,
    classNameFocused: focusClass,
    gamepadIndex: gamepadIndex,
    inputLegend: false,
    narrationText: narrationTextFacet
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, isFocusable ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Focus_Focus, null), children) : /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: rowOptions
  }, children)))));
}
ListItem_ListItem_ListItem.Action = ListItemAction_ListItemAction;
ListItem_ListItem_ListItem.AdditionalAction = ListItemAdditionalAction_ListItemAdditionalAction;
ListItem_ListItem_ListItem.Main = ListItemMain_ListItemMain;
ListItem_ListItem_ListItem.Cell = ListItemCell_ListItemCell;
ListItem_ListItem_ListItem.Icon = ListItemIcon_ListItemIcon;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/AchievementListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementListItem_AchievementListItem = ({"gamerPointsWrapper":"RRHee","imageGamerPoints":"qMjzA","rewardImg":"wfNbX","lockedIcon":"Wi8gq","rewardImgCellUnlocked":"B60cn","rewardImgCellLocked":"tAQd5","rewardLockedOverlay":"HK9NP","achievement":"tdDq6","achievementLocked":"YsHy2","frame":"Wz_PE","rewardWrapper":"cy_7D"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/locked.png
const locked_namespaceObject = __webpack_require__.p + "assets/locked-b7e1e.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/gamerscoreGrey.png
const gamerscoreGrey_namespaceObject = __webpack_require__.p + "assets/gamerscoreGrey-f5174.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/greyframe.png
const greyframe_namespaceObject = __webpack_require__.p + "assets/greyframe-dd39b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/unlockedFrame.png
const unlockedFrame_namespaceObject = __webpack_require__.p + "assets/unlockedFrame-f9ecc.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/placeholder.png
const placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-15b68.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/images/placeholderReward.png
const placeholderReward_namespaceObject = __webpack_require__.p + "assets/placeholderReward-5e651.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementListItem/AchievementListItem.tsx
















function AchievementListItem_AchievementListItem_AchievementListItem({
  item,
  gamepadAlias,
  onClick,
  index,
  listLength
}) {
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement(Action, {
    item: item,
    gamepadAlias: gamepadAlias,
    onClick: onClick,
    index: index,
    listLength: listLength
  }));
}
/**
 * Separated Action component so that it can be properly deferred by the ListItem (see its implementation)
 */

const Action = ({
  autofocus,
  item,
  gamepadAlias,
  onClick,
  index,
  listLength
}) => {
  const {
    t
  } = useLocalization_useLocalization('AchievementListItem');
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    narrationText: (0,react_facet_src.useFacetMap)((item, listLength) => [item.name, t('.siblingNarration', [`${index + 1}`, `${listLength}`]), item.progress !== 0 && item.progress > 0 && item.progress < 1 ? t('.percentageNarration', [`${Math.round(item.progress * 100)}`]) : '', t('.gamerscoreNarration', [`${item.gamerScore}`]), hasRewardFeatureFlag && item.hasReward ? item.isLocked ? t('.rewardLockedNarration') : t('.rewardUnlockedNarration') : '', item.description].join(' . '), [index, t, hasRewardFeatureFlag], [item, listLength]),
    inputLegend: t('.view'),
    onClick: onClick,
    gamepadAlias: gamepadAlias,
    autofocus: autofocus
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(item => classnames_default()(AchievementListItem_AchievementListItem.achievement, {
      [AchievementListItem_AchievementListItem.achievementLocked]: item.isLocked
    }), [], [item])
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem_AchievementListItem.frame,
    imageRendering: "pixelated",
    src: (0,react_facet_src.useFacetMap)(item => item.isLocked ? greyframe_namespaceObject : unlockedFrame_namespaceObject, [], [item])
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem_AchievementListItem.achievement,
    imageRendering: "pixelated",
    src: (0,react_facet_src.useFacetMap)(item => {
      var _item$image;

      return (_item$image = item.image) !== null && _item$image !== void 0 ? _item$image : placeholder_namespaceObject;
    }, [], [item])
  }))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.name, [], [item]))), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.description, [], [item]))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => !!item.progress && item.progress !== 1, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(ProgressBar_ProgressBar_ProgressBar, {
    percentage: (0,react_facet_src.useFacetMap)(item => item.progress, [], [item])
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => !!item.gamerScore, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementListItem_AchievementListItem.gamerPointsWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem_AchievementListItem.imageGamerPoints,
    src: gamerscoreGrey_namespaceObject,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, (0,react_facet_src.useFacetMap)(item => item.gamerScore, [], [item]))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => hasRewardFeatureFlag && item.hasReward, [hasRewardFeatureFlag], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementListItem_AchievementListItem.rewardWrapper
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(item => item.isLocked ? AchievementListItem_AchievementListItem.rewardImgCellLocked : AchievementListItem_AchievementListItem.rewardImgCellUnlocked, [], [item])
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.isLocked, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem_AchievementListItem.lockedIcon,
    imageRendering: "pixelated",
    src: locked_namespaceObject
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementListItem_AchievementListItem.rewardLockedOverlay
  }))), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: AchievementListItem_AchievementListItem.rewardImg,
    src: (0,react_facet_src.useFacetMap)(item => {
      var _item$rewardImage;

      return (_item$rewardImage = item.rewardImage) !== null && _item$rewardImage !== void 0 ? _item$rewardImage : placeholderReward_namespaceObject;
    }, [], [item])
  }))))));
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/components/Narration.tsx



const Narration = ({
  text
}) => {
  const textRaw = (0,react_facet_src.useFacetUnwrap)(text);
  const textData = textRaw !== react_facet_src.NO_VALUE ? textRaw : '';
  const {
    narrationPutNode
  } = useNarrationPutNode();
  const {
    narrateById
  } = useNarrateById();
  const narrationId = narrationPutNode(textData);
  (0,react.useEffect)(() => {
    narrateById(narrationId);
  }, [narrateById, narrationId]);
  return null;
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/TabWrapper.tsx






function TabWrapper_TabWrapper({
  component,
  tab
}) {
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const visible = params.tab === tab;
  const parentRouteActive = useRouteActive();
  const isRouteActive = (0,react_facet_src.useFacetMap)(parentRouteActive => visible && parentRouteActive, [visible], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: isRouteActive
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0,
    disabled: !visible
  }, /*#__PURE__*/react.createElement(RouteInstantTransition_RouteInstantTransition, {
    visible: visible,
    contentComponent: component,
    unmountOnExit: false
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/AchievementsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementsRoute = ({"completedAllAchievementsIllustration":"gfcZy","noAchievementsIllustration":"mueN0","errorImage":"oXeAA","errorImageBig":"r1UvO"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/AchievementsRoute.tsx



















const LOADING_TIMEOUT = 10000;
const LOADING_WARNING = 1500;
const tabAliasLookup = {
  all: 'all-tab-wrapper',
  locked: 'locked-tab-wrapper',
  completed: 'completed-tab-wrapper'
};
const AchievementsRoute_AchievementsRoute = () => {
  const glassPaneRef = (0,react.useRef)(null);
  const containerRef = (0,react.useRef)(null);
  const contentWrapperRef = (0,react.useRef)(null);
  const {
    t
  } = useLocalization_useLocalization('Achievements');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const hasLoadingFailedFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), LOADING_TIMEOUT);
  const loadingTakingTimeFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), LOADING_WARNING); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 260
  });
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, {
    innerRef: glassPaneRef
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.narration.title')
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((loadingTakingTime, hasLoadingFailed) => loadingTakingTime && !hasLoadingFailed, [], [loadingTakingTimeFacet, hasLoadingFailedFacet])
  }, /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  })), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: historyAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.title')),
    defaultFocusedChildBehavior: "remember",
    gamepadAlias: "achievements-layout-content",
    delegateByAlias: "achievments-wrapper"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: containerRef,
    alias: "achievments-wrapper",
    delegateFocusFromMemory: true,
    delegateFocusByAlias: 'achievements-content-wrapper'
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    innerRef: containerRef,
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((hasLoadingFailed, hasLoaded) => hasLoadingFailed && !hasLoaded, [], [hasLoadingFailedFacet, (0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    imgClass: narrowImage ? AchievementsRoute.errorImage : AchievementsRoute.errorImageBig,
    autofocus: true,
    gamepadAlias: "ach-load-error-empty-state",
    imgSrc: error_message_namespaceObject,
    gamepadIndex: 0,
    title: t('.errorMessageTitle'),
    text: t('.errorMessage')
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((hasLoadingFailed, hasLoaded) => !(hasLoadingFailed && !hasLoaded), [], [hasLoadingFailedFacet, (0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SummaryWrapper, null)), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 9,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Tabs, null), /*#__PURE__*/react.createElement(Landmark, {
    alias: 'achievements-content-wrapper',
    containerRef: contentWrapperRef
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: '1'
    },
    ref: contentWrapperRef
  }, /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: undefined,
    component: AllTab
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "locked",
    component: LockedTab
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "completed",
    component: CompletedTab
  }))))))))))));
};

const Tabs = () => {
  const {
    t
  } = useLocalization_useLocalization('Achievements');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const tabs = [{
    label: t('.all'),
    value: 'all'
  }, {
    label: t('.locked'),
    value: 'locked'
  }, {
    label: t('.completed'),
    value: 'completed'
  }];
  return /*#__PURE__*/react.createElement(TabBar_TabBar_TabBar, {
    gamepadAliasNamespace: "achievement-screen",
    gamepadIndex: 0,
    value: params.tab ? params.tab : 'all',
    onChange: newValue => {
      historyAPI.replace(`/achievements/${newValue !== 'all' ? newValue : ''}`);
    },
    tabs: tabs,
    enableGamepadShortcuts: true,
    narrationTitle: t('.narration.title')
  });
};

const AllTab = () => {
  const {
    t
  } = useLocalization_useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.all'), '2', '4']) + ' . ' + t('.narration.selected');
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    alias: tabAliasLookup.all,
    delegateFocusByAlias: "all-tab-content"
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: '1'
    },
    ref: ref
  }, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(SectionList_SectionList, {
    gamepadAlias: "all-tab-content",
    gamepadIndex: 1,
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    data: (0,react_facet_src.useFacetMap)(allAchievementsSorted => [{
      role: 'informativeTint',
      title: t('.inProgress'),
      data: allAchievementsSorted.inProgress
    }, {
      role: 'secondary',
      title: t('.locked'),
      data: allAchievementsSorted.locked
    }, {
      role: 'successTint',
      title: t('.completed'),
      data: allAchievementsSorted.completed
    }], [t], [(0,react_facet_src.useSharedFacet)(groupedAchievementsSelector)]),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })),
    sectionSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }),
    renderSectionHeader: (title, role) => /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
      role: role,
      label: title
    }),
    renderItem: ({
      itemFacet,
      index,
      sectionIndex,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      filterName: "all",
      item: itemFacet,
      index: index,
      sectionIndex: sectionIndex,
      listLength: listLengthFacet
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true
  }))));
};

const LockedTab = () => {
  const {
    t
  } = useLocalization_useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.locked'), '3', '4']) + ' . ' + t('.narration.selected');
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    alias: tabAliasLookup.locked,
    delegateFocusByAlias: "locked-tab-content"
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: '1'
    },
    ref: ref
  }, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(FlatList_FlatList, {
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    gamepadIndex: 1,
    gamepadAlias: "locked-tab-content",
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      imgClass: AchievementsRoute.completedAllAchievementsIllustration,
      autofocus: true,
      gamepadAlias: "ach-locked-empty-state",
      imgSrc: (0,react_facet_src.useFacetMap)(achievements => achievements.length === 0 ? emptyStatesAllCompleted_namespaceObject : undefined, [], [(0,react_facet_src.useSharedFacet)(lockedOrInProgressAchievementsSelector)]),
      gamepadIndex: 0,
      title: t('.lockedEmptyTitle'),
      text: t('.lockedEmptyText')
    }),
    data: (0,react_facet_src.useSharedFacet)(lockedOrInProgressAchievementsSelector),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })),
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      filterName: "locked",
      item: itemFacet,
      index: index,
      listLength: listLengthFacet
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true,
    defaultFocusedChildBehavior: "remember"
  }))));
};

const CompletedTab = () => {
  const {
    t
  } = useLocalization_useLocalization('Achievements');
  const narration = t('.narration.tab', [t('.completed'), '4', '4']) + ' . ' + t('.narration.selected');
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    alias: tabAliasLookup.completed,
    delegateFocusByAlias: "completed-tab-content"
  }, /*#__PURE__*/react.createElement("div", {
    style: {
      flex: '1'
    },
    ref: ref
  }, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(FlatList_FlatList, {
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    loading: (0,react_facet_src.useFacetMap)(loaded => !loaded, [], [(0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector)]),
    gamepadIndex: 1,
    gamepadAlias: "completed-tab-content",
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      imgClass: AchievementsRoute.noAchievementsIllustration,
      autofocus: true,
      gamepadAlias: "ach-completed-empty-state",
      imgSrc: (0,react_facet_src.useFacetMap)(achievements => achievements.length === 0 ? emptyStatesNoProgress_namespaceObject : undefined, [], [(0,react_facet_src.useSharedFacet)(completedAchievementsSelector)]),
      gamepadIndex: 0,
      title: t('.completedEmptyTitle'),
      text: t('.completedEmptyText')
    }),
    data: (0,react_facet_src.useSharedFacet)(completedAchievementsSelector),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })),
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/react.createElement(AchievementListItemWrapper, {
      item: itemFacet,
      index: index,
      listLength: listLengthFacet,
      filterName: "completed"
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true,
    defaultFocusedChildBehavior: "remember"
  }))));
};

const SummaryWrapper = () => {
  const summary = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(achievementsSummarySelector));
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  if (summary === react_facet_src.NO_VALUE) return null; // To avoid narrating the AchievementsSummary before the facet values have been received, a non interactive loading placeholder is returned until it is

  if (!summary.loaded) return /*#__PURE__*/react.createElement(AchievementsSummary_AchievementsSummary.Loading, {
    loading: !summary.loaded
  });
  return /*#__PURE__*/react.createElement(AchievementsSummary_AchievementsSummary, {
    gamepadIndex: 0,
    inProgress: summary.inProgressCount,
    achievementsUnlocked: summary.unlocked,
    achievementsTotal: summary.total,
    rewardsTotal: hasRewardFeatureFlag ? summary.rewardsTotal : 0,
    rewardsUnlocked: hasRewardFeatureFlag ? summary.rewardsUnlocked : undefined,
    gamerScore: summary.gamerScore,
    gamerScoreTotal: summary.maxGamerScore,
    hoursPlayed: summary.hoursPlayed
  });
};

const AchievementListItemWrapper = ({
  item,
  index,
  listLength,
  filterName
}) => {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  return /*#__PURE__*/react.createElement(AchievementListItem_AchievementListItem_AchievementListItem, {
    item: item,
    gamepadAlias: (0,react_facet_src.useFacetMap)(item => `achievement-${filterName}-${item.id}`, [filterName], [item]),
    onClick: (0,react_facet_src.useFacetCallback)(item => () => {
      historyAPI.push(`/achievement-detail/${item.id}`);
    }, [historyAPI], [item]),
    index: index,
    listLength: listLength
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementsRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/AchievementDetails.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementDetails = ({"achievementImage":"TKfnq","achievementImageContainer":"n2uci","achievementUnlocked":"hXgLU","achievementLocked":"sgJds","frame":"ERib5","details":"akZA4","textWrapper":"eXwnH","gamerscoreIcon":"GooYD"});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Images/locked.png
const Images_locked_namespaceObject = __webpack_require__.p + "assets/locked-b7e1e.png";
;// CONCATENATED MODULE: ./packages/ui/src/Window/Images/checkIcon.png
const checkIcon_namespaceObject = __webpack_require__.p + "assets/checkIcon-bcfbf.png";
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Window = ({"window":"xHU3n","transparent":"dDMcJ","header":"P3s5b","lockedIcon":"kLdrM","checkIcon":"X2i3D","date":"PoM_H","spinner":"xzfzB"});
;// CONCATENATED MODULE: ./packages/ui/src/Window/Window.tsx











function Header({
  children,
  variant,
  date
}) {
  const {
    f
  } = useLocalization_useLocalization('Window');
  const role = variant === 'completed' ? 'success' : 'neutral60';
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Window.header, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    className: classnames_default()({
      [Window.lockedIcon]: variant === 'locked',
      [Window.checkIcon]: variant === 'completed'
    }),
    src: variant === 'locked' ? Images_locked_namespaceObject : checkIcon_namespaceObject
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: role
  }, children), variant === 'completed' && date != null && /*#__PURE__*/react.createElement("div", {
    className: Window.date
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: role
  }, f.formatDate(date))));
}

function Window_Window({
  children,
  variant = 'locked',
  title,
  date,
  loading
}) {
  const semanticColors = hooks_useSemanticColors('neutral80');
  return !!loading ? /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Window.transparent, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(WindowSpinner, {
    className: semanticColors.overlay.base
  })) : /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Window.window, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(Header, {
    date: date,
    variant: variant
  }, title), children);
}

const WindowSpinner = ({
  className
}) => {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Window.spinner, className)
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null));
};
;// CONCATENATED MODULE: ./packages/ui/src/DescriptionList/DescriptionList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DescriptionList = ({"descriptionList":"hy23n","description":"VTr_m","progressWrapper":"ptFWK","percentageWrapper":"I0mfv"});
;// CONCATENATED MODULE: ./packages/ui/src/DescriptionList/DescriptionList.tsx








function DescriptionList_DescriptionList({
  children,
  role = 'neutral100'
}) {
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: DescriptionList.descriptionList
  }, children));
}

DescriptionList_DescriptionList.Pair = function Pair({
  label,
  value,
  icon
}) {
  const semanticColors = hooks_useSemanticColors('inherit');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.description, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, label), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, icon, value));
};

DescriptionList_DescriptionList.Progress = function Progress({
  label,
  value,
  total
}) {
  const {
    t
  } = useLocalization_useLocalization('DescriptionList');
  const semanticColors = hooks_useSemanticColors('inherit');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.progressWrapper, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DescriptionList.description)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, label !== null && label !== void 0 ? label : t('.progressLabel')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, value, "/", total)), /*#__PURE__*/react.createElement("div", {
    className: DescriptionList.percentageWrapper
  }, /*#__PURE__*/react.createElement(ProgressBar_ProgressBar_ProgressBar, {
    tall: true,
    percentage: value / total
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
};

DescriptionList_DescriptionList.displayName = 'DescriptionList';
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/gamerscoreIcon.png
const gamerscoreIcon_namespaceObject = __webpack_require__.p + "assets/gamerscoreIcon-0c23f.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/greyframe.png
const AchievementDetails_images_greyframe_namespaceObject = __webpack_require__.p + "assets/greyframe-dd39b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/unlockedBorder.png
const unlockedBorder_namespaceObject = __webpack_require__.p + "assets/unlockedBorder-2f13b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/images/placeholder.png
const AchievementDetails_images_placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-15b68.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementDetails/AchievementDetails.tsx













function AchievementDetails_AchievementDetails({
  title,
  description = '',
  image,
  gamerscore = 0,
  progress = 0,
  autofocus = false,
  progressTarget = 0,
  isLocked,
  dateUnlocked = 0,
  loading,
  completedOnAnotherPlatform,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('AchievementDetails');
  const narrationIsEnabled = useNarrationEnabled();
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    inputLegend: false,
    className: '',
    classNameHovered: '',
    classNameFocused: focusClass,
    classNamePressed: '',
    disabled: !narrationIsEnabled,
    autofocus: narrationIsEnabled && autofocus,
    gamepadIndex: gamepadIndex,
    narrationText: false,
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    withoutBorders: true,
    disabled: !narrationIsEnabled
  }), /*#__PURE__*/react.createElement(Window_Window, {
    loading: loading,
    title: isLocked ? t('.locked') : t('.completed'),
    variant: isLocked ? 'locked' : 'completed',
    date: dateUnlocked
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: "neutral"
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.details
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 5
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(AchievementDetails.achievementImageContainer, {
      [AchievementDetails.achievementLocked]: isLocked
    })
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: classnames_default()(AchievementDetails.achievementImage, AchievementDetails.frame),
    imageRendering: "pixelated",
    src: isLocked ? AchievementDetails_images_greyframe_namespaceObject : unlockedBorder_namespaceObject
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: classnames_default()(AchievementDetails.achievementImage),
    imageRendering: "pixelated",
    src: image !== null && image !== void 0 ? image : AchievementDetails_images_placeholder_namespaceObject
  }), !isLocked && /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.achievementUnlocked
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementDetails.textWrapper
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "header5B"
  }, title), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    variant: "dimmer"
  }, description)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 5
  }))), /*#__PURE__*/react.createElement(DescriptionList_DescriptionList, null, /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Pair, {
    label: t('.gamerscore'),
    value: `${gamerscore}`,
    icon: /*#__PURE__*/react.createElement(Image_Image_Image, {
      className: AchievementDetails.gamerscoreIcon,
      imageRendering: "pixelated",
      src: gamerscoreIcon_namespaceObject
    })
  }), completedOnAnotherPlatform && /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Pair, {
    label: t('.anotherPlatform'),
    value: t('.yes')
  }), progress && progress !== 0 && progress !== 1 ? /*#__PURE__*/react.createElement(DescriptionList_DescriptionList.Progress, {
    value: Math.round(progress * progressTarget),
    total: progressTarget
  }) : null)));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/AchievementReward.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AchievementReward = ({"reward":"tZxVg","innerReward":"SKSAr","rewardImage":"D98f5","rewardImageLocked":"CJ4sp","rewardImageBorder":"A2FSq","rewardImageBorderLocked":"ehHcI","rewardImageWrapper":"UzVku","lockedIcon":"yD_x4","unlockedIcon":"PCWpA","rewardText":"KAXsx","rewardHeader":"QcClj","buttonWrapper":"TAaUi"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/rewardUnlockedFrame.png
const rewardUnlockedFrame_namespaceObject = __webpack_require__.p + "assets/rewardUnlockedFrame-7f44b.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/rewardLockedFrame.png
const rewardLockedFrame_namespaceObject = __webpack_require__.p + "assets/rewardLockedFrame-35e6e.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/unlockedIconGrey.png
const unlockedIconGrey_namespaceObject = __webpack_require__.p + "assets/unlockedIconGrey-2939d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/images/lockedIconGrey.png
const lockedIconGrey_namespaceObject = __webpack_require__.p + "assets/lockedIconGrey-c2c6d.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/AchievementReward/AchievementReward.tsx













function AchievementReward_AchievementReward({
  image,
  title,
  isOwned,
  onClickView,
  role = 'neutral80',
  imageRole = 'neutral100'
}) {
  const {
    t
  } = useLocalization_useLocalization('AchievementReward');
  const semanticColors = hooks_useSemanticColors(role);
  const semanticColorsImage = hooks_useSemanticColors(imageRole);
  const rewardNarrationText = [isOwned ? t('.narration.rewardUnlocked') : t('.narration.rewardLocked'), title].join(' - ');
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: rewardNarrationText
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(AchievementReward.reward, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.innerReward
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardText
  }, /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardHeader
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, t('.reward'))), isOwned ? /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: unlockedIconGrey_namespaceObject,
    imageRendering: "pixelated",
    className: AchievementReward.unlockedIcon
  }) : /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: lockedIconGrey_namespaceObject,
    imageRendering: "pixelated",
    className: AchievementReward.lockedIcon
  })), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "center"
  }, title)), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.rewardImageWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    imageRendering: "pixelated",
    className: classnames_default()(AchievementReward.rewardImage, semanticColorsImage.background.base, {
      [AchievementReward.rewardImageLocked]: !isOwned
    })
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: isOwned ? rewardUnlockedFrame_namespaceObject : rewardLockedFrame_namespaceObject,
    imageRendering: "pixelated",
    className: isOwned ? AchievementReward.rewardImageBorder : AchievementReward.rewardImageBorderLocked
  })), /*#__PURE__*/react.createElement("div", {
    className: AchievementReward.buttonWrapper
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: onClickView,
    gamepadIndex: 0,
    gamepadAlias: "reward-button",
    inputLegend: t('.viewReward'),
    variant: "secondary"
  }, t('.viewReward')))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementDetailsRoute/AchievementDetailsRoute.tsx













const AchievementDetailsRoute_LOADING_TIMEOUT = 10000;
const AchievementDetailsRoute_LOADING_WARNING = 1500;

const getProgressNarrationText = ({
  isLocked,
  progress,
  progressTarget
}, t) => {
  const progressValue = Math.ceil(progress * progressTarget);
  const progressPercentage = Math.round(progress * 100);
  return isLocked && progress > 0 && progress < 1 ? [t('.narration.progress'), t('.narration.percentage', [`${progressValue}`, `${progressTarget}`]), `${progressPercentage}%`] : [];
};

const AchievementDetailsRoute = () => {
  const {
    t,
    f
  } = useLocalization_useLocalization('AchievementDetailsRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const hasRewardFeatureFlag = useFeatureFlag(REWARD_FEATURE_FLAG);
  const data = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(achievementDetailSelector(params.id)));
  const isLoaded = !!(data !== react_facet_src.NO_VALUE && data.isLoaded);
  const achievement = data === react_facet_src.NO_VALUE ? undefined : data.achievement;
  const hasLoadingFailedFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), AchievementDetailsRoute_LOADING_TIMEOUT);
  const loadingTakingTimeFacet = useTimeout((0,react_facet_src.useSharedFacet)(isAchievementsLoadedSelector), AchievementDetailsRoute_LOADING_WARNING);
  const hasLoadingFailed = (0,react_facet_src.useFacetUnwrap)(hasLoadingFailedFacet);
  const loadingTakingTime = (0,react_facet_src.useFacetUnwrap)(loadingTakingTimeFacet);
  const landmarkRef = (0,react.useRef)(null);
  const is404 = isLoaded && !achievement;
  (0,react.useEffect)(() => {
    if (is404) historyAPI.goBack();
  }, [is404, historyAPI]);
  const hasReward = Boolean(hasRewardFeatureFlag && achievement && achievement.rewardName != null && achievement.rewardImage);
  const narration = achievement != null ? [achievement.isLocked ? t('.narration.locked') : t('.narration.completed'), // Is the "not unlocked" value either 0 or negative?
  // dateUnlocked is not nullable currently, so we suppose "not unlocked" is 0 or negative
  achievement.dateUnlocked > 0 ? f.formatDate(achievement.dateUnlocked) : '', achievement.name, achievement.description, ...(achievement.gamerScore !== 0 ? [t('.narration.gamerscore'), `${achievement.gamerScore}`] : []), ...getProgressNarrationText(achievement, t)].join(' . ') : '';
  if (data === react_facet_src.NO_VALUE) return null;
  const completedOnAnotherPlatform = hasRewardFeatureFlag && achievement && achievement.hasReward && achievement.isRewardOwned && achievement.isLocked;
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.narration.title')
  }, (loadingTakingTime === react_facet_src.NO_VALUE ? false : loadingTakingTime) && (hasLoadingFailed === react_facet_src.NO_VALUE ? true : !hasLoadingFailed) && /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: isLoaded
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: historyAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.title')),
    defaultFocusedChildBehavior: "remember",
    gamepadAlias: 'achievements-details-layout-content' // If we dont have reward we want to provide an alias that wont match anything so that back button is focused by default
    ,
    delegateByAlias: 'achievements-details-wrapper',
    shouldNotDelegateToContent: !hasReward
  }, (hasLoadingFailed === react_facet_src.NO_VALUE ? false : hasLoadingFailed) ? /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: "ach-details-empty-state",
    gamepadIndex: 0,
    text: t('.errorMessage')
  })))) : /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: landmarkRef,
    delegateFocusFromMemory: true,
    alias: "achievements-details-wrapper",
    delegateFocusByAlias: "reward-wrapper"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    innerRef: landmarkRef,
    gamepadIndex: 0
  }, (!hasReward || !isLoaded) && /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: hasReward && isLoaded ? 5 : 6
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), achievement ? /*#__PURE__*/react.createElement(AchievementDetails_AchievementDetails, {
    loading: false,
    title: achievement.name,
    image: achievement.image,
    description: achievement.description,
    progress: achievement.progress,
    progressTarget: achievement.progressTarget,
    isLocked: achievement.isLocked,
    dateUnlocked: achievement.dateUnlocked,
    gamerscore: achievement.gamerScore,
    gamepadIndex: 0,
    completedOnAnotherPlatform: !!completedOnAnotherPlatform
  }) : /*#__PURE__*/react.createElement(AchievementDetails_AchievementDetails, {
    gamepadIndex: 0,
    loading: true
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null))), hasReward && achievement && achievement.rewardName != null && achievement.rewardImage != null && /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadAlias: "reward-wrapper",
    delegateFocusByAlias: "reward-button",
    gamepadIndex: 0,
    loading: !isLoaded
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(AchievementReward_AchievementReward, {
    title: achievement.rewardName,
    onClickView: () => {
      historyAPI.push(`/persona?itemId=${achievement.rewardId}`);
    },
    isOwned: isAchievementRewardOwned(achievement),
    image: achievement.rewardImage
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null))))))))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AchievementDetailsRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RenderDistanceWarningRoute/RenderDistanceWarningRoute.tsx








const RenderDistanceWarningRoute = () => {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const optionsWrapped = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const options = (0,react_facet_src.useFacetUnwrap)(optionsWrapped);
  const initialRenderDistance = (0,react.useRef)();
  const {
    t
  } = useLocalization_useLocalization('RenderDistanceWarningRoute');
  const isNarrationEnabled = useNarrationEnabled();
  const onUseRecommendedSettings = (0,react_facet_src.useFacetCallback)(options => () => {
    options.renderDistance = options.defaultRenderDistance;
    options.showRenderDistanceWarningModal = false;
    historyAPI.goBack();
  }, [historyAPI], [optionsWrapped]);
  const onUseCurrentSettings = (0,react_facet_src.useFacetCallback)(options => () => {
    options.showRenderDistanceWarningModal = false;
    historyAPI.goBack();
  }, [historyAPI], [optionsWrapped]);
  if (options == react_facet_src.NO_VALUE) return null; // Store initial value to prevent flicking to the new value after we update it

  if (initialRenderDistance.current == null) {
    initialRenderDistance.current = options.renderDistance;
  }

  const recommendedSettingsButtonLabel = [t('.useRecommendedSettingsButton'), t(options.defaultRenderDistance > 1 ? '.chunksPluralCaption' : '.chunksSingularCaption', [`${options.defaultRenderDistance}`])].join(' ');
  const currentSettingsChunkSuffix = initialRenderDistance.current > 1 ? '.chunksPluralCaption' : '.chunksSingularCaption';
  const currentSettingsButtonLabel = [t('.useCurrentSettingsButton'), t(currentSettingsChunkSuffix, [`${initialRenderDistance.current}`])].join(' ');
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: `${t('.title')}. ${t('.body1')}. ${t('.body2')}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: !isNarrationEnabled
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.body1')}. ${t('.body2')}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.body1')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.body2')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.confirmInputLegend'),
    variant: "primary",
    onClick: onUseRecommendedSettings
  }, recommendedSettingsButtonLabel), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: onUseCurrentSettings
  }, currentSettingsButtonLabel))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RenderDistanceWarningRoute/index.tsx

;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SideMenu_SideMenu = ({"sideMenu":"ktO0j","item":"vPqz2","listItem":"iWrTh","itemHovered":"rtKPV","itemSelected":"qaKqk","itemFocused":"B2m9T","focusOutline":"pwcli","itemMain":"_ooLj","itemCell":"Wfm8X","itemCellMarginEnd":"HwQXE","itemCellMarginStart":"OdjWP","divider":"OlLk0","footer":"H9jOa","fullHeight":"JppWl"});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const src_Divider_Divider = ({"divider":"Fk8ro","innerDivider":"TPz7W"});
;// CONCATENATED MODULE: ./packages/ui/src/Divider/Divider.tsx




function Divider_Divider_Divider({
  role = 'inherit'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  const variants = useSemanticVariants();
  return /*#__PURE__*/react.createElement("fast-div", {
    className: src_Divider_Divider.divider
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(src_Divider_Divider.innerDivider, semanticColors.bevel.base, variants.reversed)
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/SideMenu/SideMenu.tsx













function SideMenu_SideMenu_SideMenu({
  children,
  footer,
  gamepadIndex,
  loading,
  autofocus,
  scrollViewRef,
  role = 'neutral80',
  gamepadAlias,
  delegateFocusByAlias,
  hideInputLegendSpace = false,
  fullHeight = false,
  narrationPrefix = '',
  narrationRole = '',
  narrationSuffix = ''
}) {
  const ref = (0,react.useRef)(null);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const {
    t
  } = useLocalization_useLocalization('SideMenu');
  const semanticColors = hooks_useSemanticColors(role);
  const narrationText = (0,react_facet_src.useFacetMap)((prefix, role, suffix) => [prefix, role === '' ? t('.narrationRoleMenu') : role, suffix].filter(x => x).join(' . '), [t], [(0,react_facet_src.useFacetWrap)(narrationPrefix !== null && narrationPrefix !== void 0 ? narrationPrefix : ''), (0,react_facet_src.useFacetWrap)(narrationRole !== null && narrationRole !== void 0 ? narrationRole : ''), (0,react_facet_src.useFacetWrap)(narrationSuffix !== null && narrationSuffix !== void 0 ? narrationSuffix : '')]);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: gamepadIndex,
    floating: breakpoint !== 'desktop',
    defaultFocusedChildBehavior: "remember",
    loading: loading,
    autofocus: autofocus // gray80, but inline vars don't seem to work in GF player
    ,
    spinnerBackgroundColor: "#313233",
    innerRef: scrollViewRef,
    gamepadAlias: gamepadAlias,
    delegateFocusByAlias: delegateFocusByAlias
  }, breakpoint === 'desktop' && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(SideMenu_SideMenu.sideMenu, semanticColors.background.base, semanticColors.border.base, {
      [SideMenu_SideMenu.fullHeight]: fullHeight
    })
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), children, footer != null && /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement("div", {
    className: SideMenu_SideMenu.footer
  }, footer)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), hideInputLegendSpace ? null : /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })
  }))));
}
function Item({
  children,
  role = 'inherit'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SideMenu_SideMenu.item, semanticColors.background.base)
  }, children);
}
function SideMenu_ListItem({
  onSelect,
  children,
  selected,
  value,
  gamepadIndex,
  narrationText,
  inputLegend,
  soundEffectPressed,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization_useLocalization('SideMenu.ListItem');
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const index = (0,react.useContext)(ItemListIndex);
  const count = (0,react.useContext)(ItemListCount);
  const semanticColors = hooks_useSemanticColors(role);
  const semanticSounds = useSemanticSounds(role);
  const modifiers = useSemanticModifiers();
  const indexNarration = (0,react_facet_src.useFacetMap)(count => t('.narrationIndex', [`${index + 1}`, `${count}`]), [t, index], [count]);
  const narrationTextMapped = (0,react_facet_src.useFacetMap)((narrationText, selected, indexNarration) => `${narrationText} ${t('.narrationRoleMenuItem')} ${indexNarration} ${t(selected ? '.narrationSelected' : '.narrationUnselected')}`, [t], [narrationText, selected, indexNarration]);
  const soundEffectPressedFacet = (0,react_facet_src.useFacetMap)((soundEffectPressed, selected) => {
    return !selected ? soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle : undefined;
  }, [semanticSounds.toggle], [(0,react_facet_src.useFacetWrap)(soundEffectPressed), selected]);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: (0,react_facet_src.useFacetMap)(selected => {
      const semanticColorsList = selected ? [semanticColors.background.select, semanticColors.bevel.select] : [semanticColors.background.interactive, semanticColors.bevel.interactive];
      return classnames_default()(SideMenu_SideMenu.listItem, semanticColorsList, {
        [SideMenu_SideMenu.itemSelected]: selected,
        [modifiers.selected]: selected
      });
    }, [semanticColors, modifiers], [selected]),
    classNameFocused: classnames_default()(focusClass, SideMenu_SideMenu.itemFocused),
    classNameHovered: (0,react_facet_src.useFacetMap)(selected => selected ? undefined : SideMenu_SideMenu.itemHovered, [], [selected]),
    onClick: (0,react_facet_src.useFacetCallback)(value => () => {
      narrateText(t('.narrationSelected'));
      onSelect(value);
    }, [t, narrateText, onSelect], [value]),
    gamepadIndex: gamepadIndex,
    inputLegend: (0,react_facet_src.useFacetMap)(selected => selected ? false : inputLegend, [inputLegend], [selected]),
    soundEffectPressed: soundEffectPressedFacet,
    narrationText: narrationTextMapped
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    className: SideMenu_SideMenu.focusOutline
  }), children));
}

SideMenu_SideMenu_SideMenu.ItemMain = function ({
  children
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: SideMenu_SideMenu.itemMain
  }, children);
};

SideMenu_SideMenu_SideMenu.ItemCell = function ({
  children,
  margin = 'end'
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SideMenu_SideMenu.itemCell, {
      [SideMenu_SideMenu.itemCellMarginEnd]: margin === 'end',
      [SideMenu_SideMenu.itemCellMarginStart]: margin === 'start'
    })
  }, children);
};

SideMenu_SideMenu_SideMenu.Divider = function SideMenuDivider({
  label,
  role = 'inherit'
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    role: role,
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement("div", {
    className: SideMenu_SideMenu.divider
  }, label)), /*#__PURE__*/react.createElement(Divider_Divider_Divider, {
    role: role
  }));
};

const zeroFacet = (0,react_facet_src.createFacet)({
  initialValue: 0
});
const ItemListCount = (0,react.createContext)(zeroFacet);
const ItemListIndex = (0,react.createContext)(0);
function ItemList({
  items,
  renderItem,
  initialGamepadIndex
}) {
  return /*#__PURE__*/react.createElement(ItemListCount.Provider, {
    value: (0,react_facet_src.useFacetMap)(items => items.length, [], [items])
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: items
  }, (item, index) => {
    return /*#__PURE__*/react.createElement(ItemListIndex.Provider, {
      value: index
    }, renderItem({
      item,
      gamepadIndex: index + initialGamepadIndex
    }));
  }));
}
SideMenu_SideMenu_SideMenu.displayName = 'SideMenu';
SideMenu_SideMenu_SideMenu.ItemList = ItemList;
SideMenu_SideMenu_SideMenu.ListItem = SideMenu_ListItem;
SideMenu_SideMenu_SideMenu.Item = Item;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/advanced-icon.png
const advanced_icon_namespaceObject = __webpack_require__.p + "assets/advanced-icon-34af9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/experimental-features-icon.png
const experimental_features_icon_namespaceObject = __webpack_require__.p + "assets/experimental-features-icon-94de6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/cheats-icon.png
const cheats_icon_namespaceObject = __webpack_require__.p + "assets/cheats-icon-fa15a.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/debug-icon.png
const WorldSettingsSideMenu_images_debug_icon_namespaceObject = __webpack_require__.p + "assets/debug-icon-df18b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/general-icon.png
const general_icon_namespaceObject = __webpack_require__.p + "assets/general-icon-e1776.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/resource-packs-icon.png
const resource_packs_icon_namespaceObject = __webpack_require__.p + "assets/resource-packs-icon-17c91.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/multiplayer-icon.png
const multiplayer_icon_namespaceObject = __webpack_require__.p + "assets/multiplayer-icon-a3920.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/behaviour-packs-icon.png
const behaviour_packs_icon_namespaceObject = __webpack_require__.p + "assets/behaviour-packs-icon-cf4d9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/images/scripting-coding-icon.png
const scripting_coding_icon_namespaceObject = __webpack_require__.p + "assets/scripting-coding-icon-7fe30.png";
;// CONCATENATED MODULE: ./packages/semantic-tokens/src/common.ts
// Safe to import from both node and web



// EXTERNAL MODULE: ./games/vanilla/tokens/src/soundDefinitions.json
var soundDefinitions = __webpack_require__(52910);
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/soundDefinitions.fixtures.json
const soundDefinitions_fixtures_namespaceObject = {};
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/tokens.ts




const vanillaCollection = collectionCreator({
  id: 'vanilla',
  sound: {
    neutral: {
      reject: 'note.bass',
      press: 'random.click',
      contract: 'random.click',
      expand: 'random.click',
      toggle: 'random.click',
      lift: 'random.click',
      click: 'random.click'
    },
    primary: {
      press: 'tokens.vanilla.release'
    }
  },
  color: {
    neutral: {
      background: {
        default: palette.gray70,
        hovered: palette.gray60,
        pressed: palette.gray80,
        disabled: palette.gray30,
        selected: palette.gray80
      },
      text: {
        dimmer: {
          default: palette.gray30,
          disabled: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        },
        regular: {
          default: palette.white,
          disabled: palette.gray70
        }
      },
      shadow: {
        default: palette.gray80,
        disabled: palette.gray40
      },
      dropShadow: {
        default: palette.blackOpacity25
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray70
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      caret: {
        regular: {
          default: palette.green30
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      },
      outline: {
        default: palette.white
      },
      highlight: {
        default: 'transparent',
        hovered: palette.blackOpacity10
      },
      overlay: {
        default: palette.blackOpacity70
      }
    },
    neutral20: {
      background: {
        default: palette.gray20,
        hovered: palette.gray10,
        pressed: palette.gray30
      },
      shadow: {
        default: palette.gray40
      },
      text: {
        regular: {
          default: palette.gray100
        },
        dimmest: {
          default: palette.gray30
        }
      },
      icon: {
        regular: {
          default: palette.white
        }
      },
      outline: {
        default: palette.black
      },
      specular: {
        default: {
          top: palette.white,
          bottom: palette.whiteOpacity20
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      }
    },
    neutral50: {
      background: {
        default: palette.gray50,
        hovered: palette.gray40,
        pressed: palette.gray60
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      overlay: {
        default: palette.blackOpacity50
      }
    },
    neutral60: {
      background: {
        default: palette.gray60,
        hovered: palette.gray70,
        pressed: palette.gray80,
        disabled: palette.gray70
      },
      border: {
        dimmest: {
          default: palette.gray50
        }
      },
      text: {
        regular: {
          default: palette.white,
          disabled: palette.gray40
        }
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray40
        }
      }
    },
    neutral80: {
      background: {
        default: palette.gray80,
        hovered: palette.gray70,
        selected: palette.gray70,
        pressed: palette.gray90
      },
      shadow: {
        default: palette.gray90
      },
      text: {
        regular: {
          default: palette.white
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      },
      caret: {
        regular: {
          default: palette.green30
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity40
        },
        hovered: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity40
        },
        pressed: {
          top: palette.blackOpacity80,
          bottom: palette.whiteOpacity10
        },
        selected: {
          top: palette.blackOpacity40,
          bottom: palette.whiteOpacity10
        }
      },
      overlay: {
        default: palette.blackOpacity40
      }
    },
    neutral100: {
      background: {
        default: palette.gray100
      },
      text: {
        regular: {
          default: palette.white
        },
        dimmer: {
          default: palette.gray30
        },
        dimmest: {
          default: palette.gray40
        }
      }
    },
    primary: {
      background: {
        default: palette.green50,
        hovered: palette.green60,
        pressed: palette.green70
      },
      shadow: {
        default: palette.green70
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray40
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        },
        hovered: {
          top: palette.whiteOpacity40,
          bottom: palette.whiteOpacity30
        }
      }
    },
    primaryTint: {
      background: {
        default: palette.green30
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    secondary: {
      background: {
        default: palette.gray30,
        hovered: palette.gray40,
        pressed: palette.gray40
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      icon: {
        regular: {
          default: palette.gray100
        }
      },
      shadow: {
        default: palette.gray60
      },
      border: {
        regular: {
          default: palette.gray100
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity60,
          bottom: palette.whiteOpacity40
        },
        hovered: {
          top: palette.whiteOpacity80,
          bottom: palette.whiteOpacity60
        }
      }
    },
    success: {
      background: {
        default: palette.green50
      },
      text: {
        regular: {
          default: palette.white
        }
      }
    },
    successTint: {
      background: {
        default: palette.green10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informative: {
      background: {
        default: palette.blue20
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informativeTint: {
      background: {
        default: palette.blue10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    destructive: {
      background: {
        default: palette.red50,
        hovered: palette.red60,
        pressed: palette.red80
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      icon: {
        regular: {
          default: palette.white
        }
      },
      shadow: {
        default: palette.red80
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        },
        hovered: {
          top: palette.whiteOpacity50,
          bottom: palette.whiteOpacity40
        }
      }
    },
    destructiveTint: {
      background: {
        default: palette.red10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    notice: {
      background: {
        default: palette.orange20
      }
    },
    noticeTint: {
      background: {
        default: palette.yellow10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    dataViz01: {
      background: {
        default: '#42CCCC'
      }
    },
    dataViz02: {
      background: {
        default: palette.deepBlue20
      }
    },
    dataViz03: {
      background: {
        default: palette.orange10
      }
    },
    dataViz04: {
      background: {
        default: '#89DEF9'
      }
    },
    dataViz05: {
      background: {
        default: palette.green10
      }
    },
    dataViz06: {
      background: {
        default: '#F064B8'
      }
    },
    dataViz07: {
      background: {
        default: palette.yellow10
      }
    },
    dataVizLine: {
      background: {
        default: palette.gray30
      }
    },
    paper: {
      background: {
        default: palette.white
      },
      text: {
        regular: {
          default: palette.black,
          disabled: palette.gray70
        },
        dimmer: {
          default: palette.gray60
        }
      },
      icon: {
        regular: {
          default: palette.black,
          disabled: palette.gray70
        }
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      caret: {
        regular: {
          default: palette.black
        }
      },
      specular: {
        default: {
          top: palette.whiteOpacity20,
          bottom: palette.whiteOpacity10
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        }
      },
      outline: {
        default: palette.gray100
      },
      highlight: {
        default: 'transparent',
        hovered: palette.blackOpacity10
      }
    }
  }
});
const realmsCollection = collectionCreator({
  id: 'realms',
  sound: {
    secondary: {
      press: 'tokens.vanilla.release'
    }
  },
  color: {
    primary: {
      background: {
        default: palette.deepBlue50,
        hovered: palette.deepBlue60,
        pressed: palette.deepBlue70,
        disabled: palette.gray30
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      },
      overlay: {
        default: palette.deepBlueOpacity50
      },
      shadow: {
        default: palette.deepBlue70,
        disabled: palette.gray40
      },
      text: {
        regular: {
          default: palette.white,
          disabled: palette.gray70
        }
      },
      icon: {
        regular: {
          default: palette.white,
          disabled: palette.gray70
        }
      },
      specular: {
        default: {
          top: 'rgba(208, 131, 255, 0.5)',
          bottom: 'rgba(182, 81, 245, 0.4)'
        },
        hovered: {
          top: 'rgba(208, 131, 255, 0.7)',
          bottom: 'rgba(182, 81, 245, 0.6)'
        }
      },
      caret: {
        regular: {
          default: palette.black
        }
      },
      bevel: {
        default: {
          top: palette.whiteOpacity10,
          bottom: palette.blackOpacity30
        },
        selected: {
          top: 'rgba(5, 0, 41, 0.4)',
          bottom: 'rgba(208, 131, 255, 0.5)'
        },
        hovered: {
          top: 'rgba(5, 0, 41, 0.4)',
          bottom: 'rgba(208, 131, 255, 0.5)'
        },
        pressed: {
          top: 'rgba(5, 0, 41, 0.4)',
          bottom: 'rgba(208, 131, 255, 0.5)'
        }
      },
      outline: {
        default: palette.white
      }
    },
    primaryTint: {
      background: {
        default: palette.deepBlue10
      },
      text: {
        regular: {
          default: palette.gray100
        }
      },
      border: {
        regular: {
          default: palette.gray100
        }
      }
    },
    informative: {
      background: {
        default: palette.deepBlue20
      },
      text: {
        regular: {
          default: palette.white
        }
      },
      border: {
        regular: {
          default: palette.gray100,
          disabled: palette.gray50
        }
      }
    }
  }
});
const gameplayInputLegendCollection = collectionCreator({
  id: 'gameplayInputLegendCollection',
  color: {
    neutral100: {
      background: {
        default: 'none'
      },
      specular: {
        default: {
          top: 'none',
          bottom: 'none'
        }
      },
      text: {
        regular: {
          default: palette.white
        }
      }
    }
  }
});
;// CONCATENATED MODULE: ./games/vanilla/tokens/src/index.ts

;// CONCATENATED MODULE: ./packages/ui/src/Spritesheet/Spritesheet.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spritesheet = ({"Spritesheet":"c9joz","spritesheetAnimation":"ghQXH"});
;// CONCATENATED MODULE: ./packages/ui/src/Spritesheet/Spritesheet.tsx



function Spritesheet_Spritesheet(props) {
  const classNameFacet = (0,react_facet_src.useFacetWrap)(props.className);
  const classNameMapped = (0,react_facet_src.useFacetMap)((className = '') => `${Spritesheet.Spritesheet} ${className}`, [], [classNameFacet]);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(props.disabled);
  const pausedFacet = (0,react_facet_src.useFacetWrap)(props.paused);
  const display = (0,react_facet_src.useFacetMap)(isDisabled => isDisabled ? 'none' : 'flex', [], [disabledFacet]);
  const animationPlayState = (0,react_facet_src.useFacetMap)(isPaused => isPaused ? 'paused' : 'running', [], [pausedFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classNameMapped,
    style: {
      display,
      backgroundImage: `url(${props.src})`,
      animationPlayState,
      animationName: Spritesheet.spritesheetAnimation,
      animationDirection: props.animationDirection || 'normal',

      /**
       * Gameface currently doesn't support the steps(jump-mode) parameter
       * in animation-timing-function. This parameter is needed for us to see
       * the final frame of a spritesheet image. The suggested fix until then
       * is to just add an extra empty frame to the end of the spritesheet image.
       *
       * When jump-mode is eventually supported, we should use jump-none.
       */
      animationTimingFunction: `steps(${props.frames})`,
      animationIterationCount: typeof props.repeat === 'number' ? props.repeat.toString() : 'infinite',
      animationDuration: `${props.duration || 500}ms`,
      imageRendering: props.imageRendering,
      width: `calc(${props.width * 10 / (props.frames + 1)} * var(--base1Scale))`,
      height: `calc(${props.height * 10} * var(--base1Scale))`,
      backgroundSize: `calc(${props.width * 10} * var(--base1Scale)) calc(${props.height * 10} * var(--base1Scale))`
    }
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/IllustrativeMenuIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IllustrativeMenuIcon = ({"icon":"f2nZb","iconShineAnimation":"EvXg5"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/images/icon-highlight-spritesheet.png
const icon_highlight_spritesheet_namespaceObject = __webpack_require__.p + "assets/icon-highlight-spritesheet-87ec6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/IllustrativeMenuIcon.tsx






const IllustrativeMenuIcon_IllustrativeMenuIcon = ({
  iconSrc,
  selected
}) => /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Image_Image_Image, {
  src: iconSrc,
  className: IllustrativeMenuIcon.icon,
  imageRendering: "pixelated"
}), /*#__PURE__*/react.createElement("div", {
  className: IllustrativeMenuIcon.iconShineAnimation
}, /*#__PURE__*/react.createElement(Spritesheet_Spritesheet, {
  disabled: (0,react_facet_src.useFacetMap)(selected => !selected, [], [(0,react_facet_src.useFacetWrap)(selected !== null && selected !== void 0 ? selected : false)]),
  src: icon_highlight_spritesheet_namespaceObject,
  frames: 8,
  duration: 500,
  width: 21.6,
  height: 2.4,
  repeat: 1,
  imageRendering: 'pixelated'
})));
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/IllustrativeMenuIcon/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/context/WorldModeContext.ts

const WorldModeContext = react.createContext('create');
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/context/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/WorldSettingsSideMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldSettingsSideMenu = ({"border":"_chIi"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/WorldSettingsSideMenu.tsx
























const difficultyTranslationKeys = {
  [DifficultyEnum.PEACEFUL]: '.difficultyPeacefulLabel',
  [DifficultyEnum.EASY]: '.difficultyEasyLabel',
  [DifficultyEnum.NORMAL]: '.difficultyNormalLabel',
  [DifficultyEnum.HARD]: '.difficultyHardLabel'
};
const gameModeTranslationKeys = {
  [GameMode.ADVENTURE]: '.gameModeAdventureLabel',
  [GameMode.CREATIVE]: '.gameModeCreativeLabel',
  [GameMode.SURVIVAL]: '.gameModeSurvivalLabel',
  [GameMode.UNKNOWN]: '.gameModeUnknownLabel'
};

function getMenuItems(isDevBuild, isEduBuild) {
  const menuItems = [{
    label: '.generalTabLabel',
    image: general_icon_namespaceObject,
    value: 'general'
  }, {
    label: '.advancedTabLabel',
    image: advanced_icon_namespaceObject,
    value: 'advanced'
  }, {
    label: '.multiplayerTabLabel',
    image: multiplayer_icon_namespaceObject,
    value: 'multiplayer'
  }];

  if (isEduBuild) {
    menuItems.push({
      label: '.scriptingCodingTabLabel',
      image: scripting_coding_icon_namespaceObject,
      value: 'scripting-coding'
    });
  }

  menuItems.push({
    label: '.cheatsTabLabel',
    image: cheats_icon_namespaceObject,
    value: 'cheats'
  }, {
    label: '.resourcePacksTabLabel',
    image: resource_packs_icon_namespaceObject,
    value: 'resource-packs'
  }, {
    label: '.behaviorPacksTabLabel',
    image: behaviour_packs_icon_namespaceObject,
    value: 'behavior-packs'
  });

  if (!isEduBuild || isDevBuild) {
    menuItems.push({
      label: '.experimentalFeaturesTabLabel',
      image: experimental_features_icon_namespaceObject,
      value: 'experimental'
    });
  }

  if (isDevBuild) {
    menuItems.push({
      label: '.debugTabLabel',
      image: WorldSettingsSideMenu_images_debug_icon_namespaceObject,
      value: 'debug'
    });
  }

  return menuItems;
}

const MAIN_BUTTON = 'main-button';
const SECONDARY_BUTTON = 'secondary-button';
function WorldSettingsSideMenu_WorldSettingsSideMenu({
  onMainActionClick,
  onMainRealmsActionClick,
  worldPreviewImage,
  showSpinner,
  showRealmsButton,
  worldPacks,
  generalData
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const {
    t: t2
  } = localization_useLocalization('CreateNewWorld.general'); // the "create" button hint uses translations from the general tab

  const mode = (0,react.useContext)(WorldModeContext);
  const createLabel = t('.create');
  const createOnRealmLabel = t('.createOnRealm');
  const playLabel = t('.play');
  const transferToRealmsLabel = t('.playOnRealm');
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const heroButtonHint = (0,react_facet_src.useFacetMap)(generalData => {
    const gameMode = gameModeTranslationKeys[generalData.gameMode];
    const difficulty = difficultyTranslationKeys[generalData.difficulty];
    const worldName = generalData.worldName != '' ? generalData.worldName : t2('.worldNamePlaceholder');
    const translationKey = mode === 'edit' ? '.narrationPlayButtonHint' : '.narrationCreateButtonHint';
    return t(translationKey, [t2(gameMode), t2(difficulty), worldName]);
  }, [t, t2, mode], [generalData]);
  const grayCNWButton = useFeatureFlag(ENABLE_CREATE_WORLD_GRAY_BUTTON);
  const menuItems = (0,react_facet_src.useFacetMap)((isDevBuild, isEduBuild) => getMenuItems(isDevBuild, isEduBuild), [], [(0,react_facet_src.useSharedFacet)(isDevBuildSelector), (0,react_facet_src.useSharedFacet)(isEduBuildSelector)]);
  const scrollViewRef = (0,react.useRef)(null);
  const scrollToTop = (0,react.useCallback)(() => {
    if (scrollViewRef.current) {
      if (scrollViewRef.current.scrollHeight) {
        scrollViewRef.current.scrollTop = 0;
      } else {
        requestAnimationFrame(scrollToTop);
      }
    }
  }, []);
  (0,react_facet_src.useFacetEffect)(scrollToTop, [scrollToTop], [worldPreviewImage]);
  const semanticColors = hooks_useSemanticColors('neutral80');
  const isStorageLowFacet = (0,react_facet_src.useFacetMap)(facet => {
    return facet.isStorageLow;
  }, [], [deviceInformationSharedFacet]);
  const isStorageLowUnwrapped = (0,react_facet_src.useFacetUnwrap)(isStorageLowFacet);
  const isStorageLow = isStorageLowUnwrapped !== react_facet_src.NO_VALUE ? isStorageLowUnwrapped : false;
  const delegateFocusByAlias = isStorageLow ? SECONDARY_BUTTON : MAIN_BUTTON;
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    loading: showSpinner,
    autofocus: true,
    scrollViewRef: scrollViewRef,
    delegateFocusByAlias: delegateFocusByAlias,
    gamepadAlias: "cnw-side-menu"
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: worldPreviewImage,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"],
    className: classnames_default()(semanticColors.border.base, WorldSettingsSideMenu.border)
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    disabled: isStorageLowFacet,
    gamepadAlias: MAIN_BUTTON,
    narrationSuffix: heroButtonHint,
    variant: "hero",
    onClick: onMainActionClick,
    gamepadIndex: isStorageLow ? -1 : 0,
    inputLegend: mode === 'create' ? createLabel : playLabel
  }, mode === 'create' ? createLabel : playLabel)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRealmsButton
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: SECONDARY_BUTTON,
    narrationSuffix: heroButtonHint,
    linebreak: true,
    variant: grayCNWButton ? 'secondary' : 'primary',
    onClick: onMainRealmsActionClick,
    gamepadIndex: 1,
    inputLegend: mode === 'create' ? createOnRealmLabel : transferToRealmsLabel
  }, mode === 'create' ? createOnRealmLabel : transferToRealmsLabel)))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemList, {
    items: menuItems,
    initialGamepadIndex: 2,
    renderItem: props => /*#__PURE__*/react.createElement(SideMenuItem, {
      item: props.item,
      gamepadIndex: props.gamepadIndex,
      worldPacks: worldPacks
    })
  }));
}

const filterPackTab = (prefix, type, noActivePacks) => `/${prefix}/${type}/${noActivePacks ? 'available' : 'active'}`;

function SideMenuItem({
  item,
  gamepadIndex,
  worldPacks
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const label = (0,react_facet_src.useFacetMap)(item => item.label.includes('.debugTabLabel') ? 'Debug' : t(item.label), [t], [item]);
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const selected = (0,react_facet_src.useFacetMap)(item => params.tab === item.value, [params], [item]);
  const mode = (0,react.useContext)(WorldModeContext);
  const textureActivePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const behaviorActivePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active, [], [worldPacks]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ListItem, {
    narrationText: label,
    onSelect: (0,react_facet_src.useFacetCallback)((item, activeTexturePacks, activeBehaviorPacks) => () => {
      // Avoid redirecting to the already selected tab
      if (item.value === params.tab) return;
      const prefix = mode === 'edit' ? `edit-world/${params.id}` : 'create-new-world'; // If the resource or behavior packs tab is selected, the redirect should go to either active or available tab

      if (item.value === 'resource-packs') historyAPI.replace(filterPackTab(prefix, item.value, activeTexturePacks.length === 0));else if (item.value === 'behavior-packs') historyAPI.replace(filterPackTab(prefix, item.value, activeBehaviorPacks.length === 0));else {
        historyAPI.replace(`/${prefix}/${item.value}`);
      }
    }, [historyAPI, params, mode], [item, textureActivePacks, behaviorActivePacks]),
    value: (0,react_facet_src.useFacetMap)(item => item.value, [], [item]),
    selected: selected,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.inputLegendSelect')
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemCell, null, /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
    iconSrc: (0,react_facet_src.useFacetMap)(item => item.image, [], [item]),
    selected: selected
  })), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemMain, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, label)));
}
;// CONCATENATED MODULE: ./packages/ui/src/PanelButton/PanelButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PanelButton_PanelButton = ({"buttonsContainer":"KIftG"});
;// CONCATENATED MODULE: ./packages/ui/src/PanelButton/PanelButton.tsx





function PanelButton_PanelButton_PanelButton({
  title,
  description,
  buttons,
  gamepadIndex,
  defaultFocusedChildBehavior
}) {
  const gamepadOptions = (0,react_facet_src.useFacetMap)(gamepadIndex => {
    return {
      index: gamepadIndex,
      defaultFocusedChildBehavior
    };
  }, [defaultFocusedChildBehavior], [(0,react_facet_src.useFacetWrap)(gamepadIndex)]);
  const narrationText = (0,react_facet_src.useFacetMap)((title, description) => [title, description].filter(x => x).join(' . '), [], [(0,react_facet_src.useFacetWrap)(title), (0,react_facet_src.useFacetWrap)(description !== null && description !== void 0 ? description : '')]);
  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    narrationText: narrationText
  }, title != null && /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, title), description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description), buttons != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: gamepadOptions
  }, /*#__PURE__*/react.createElement("div", {
    className: PanelButton_PanelButton.buttonsContainer
  }, buttons))));
}

function ButtonSpacing() {
  return /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  });
}

PanelButton_PanelButton_PanelButton.ButtonSpacing = ButtonSpacing;
;// CONCATENATED MODULE: ./packages/ui/src/SectionHeader/SectionHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SectionHeader = ({"description":"Ddo87"});
;// CONCATENATED MODULE: ./packages/ui/src/SectionHeader/SectionHeader.tsx






function SectionHeader_SectionHeader({
  title,
  description,
  role = 'neutral'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticColors.background.base)
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "sectionHeader",
    role: role
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement("fast-text", {
    text: title
  })), description != null && /*#__PURE__*/react.createElement("div", {
    className: SectionHeader.description
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer",
    role: role
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: description
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggle = ({"toggle":"nUoyP","skeleton":"xBetY","labelContainer":"gcCW_","centerLabel":"b73Js","container":"jxTxF","focused":"lHZ6b","pressed":"DLmmU","bottomEdge":"hV7S1","selectedIndicator":"L83HZ","selected":"NGP2h","disabled":"vWkm_","selectedToggle":"bJ4Tv"});
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggle.tsx









function Toggle_Toggle({
  gamepadIndex,
  gamepadAlias,
  children,
  icons,
  disabled,
  selected,
  onClick,
  extraSpeechProps: {
    index,
    groupSize,
    description
  },
  onFocusChanged,
  wrapText,
  soundEffectPressed,
  onRole = 'primary',
  offRole = 'secondary'
}) {
  const {
    t
  } = useLocalization_useLocalization('Toggle');
  const semanticColorsOn = hooks_useSemanticColors(onRole);
  const semanticColorsOff = hooks_useSemanticColors(offRole);
  const role = selected ? onRole : offRole;
  const narrationText = [children, t('.narrationOptionType'), t('.count', [`${index + 1}`, `${groupSize}`]), selected ? t('.narrationSelected') : t('.narrationUnselected'), description !== null && description !== void 0 ? description : ''].join(' . ');
  const containerClassName = classnames_default()(Toggle.container, {
    [Toggle.pressed]: selected,
    [Toggle.disabled]: disabled
  });
  const toggleClassName = classnames_default()(Toggle.toggle, [selected ? [semanticColorsOn.background.base, semanticColorsOn.background.disable] : semanticColorsOff.background.interactive], [selected ? [semanticColorsOn.text.base, semanticColorsOn.text.disable] : semanticColorsOff.text.interactive], {
    [Toggle.disabled]: disabled
  });
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: narrationText,
    className: classnames_default()(containerClassName, semanticColorsOff.border.base, semanticColorsOff.border.disable),
    classNameFocused: classnames_default()(Toggle.focused, focusClass),
    classNamePressed: Toggle.pressed,
    soundEffectPressed: soundEffectPressed,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: t('.select'),
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    disabled: disabled
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role,
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: toggleClassName
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: role,
    interactive: selected === false,
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: Toggle.labelContainer
  }, wrapText ? /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: role,
    align: wrapText ? 'center' : undefined,
    disableable: selected,
    interactive: !selected
  }, icons ? disabled ? icons.disabled : selected ? icons.selected : icons.unselected : null, (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : children) : /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: role,
    align: wrapText ? 'center' : undefined,
    disableable: selected,
    interactive: !selected
  }, icons ? disabled ? icons.disabled : selected ? icons.selected : icons.unselected : null, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, {
    className: Toggle.centerLabel
  }, children))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()([selected ? [semanticColorsOn.icon.base, semanticColorsOn.icon.disable] : undefined], {
      [Toggle.selectedIndicator]: selected,
      [Toggle.disabled]: disabled
    })
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Toggle.bottomEdge, semanticColorsOff.shadow.interactive, {
      [Toggle.disabled]: disabled
    })
  }));
}
function ToggleSkeleton() {
  return /*#__PURE__*/react.createElement("div", {
    className: Toggle.skeleton
  }, /*#__PURE__*/react.createElement("div", {
    className: Toggle.toggle
  }), /*#__PURE__*/react.createElement("div", {
    className: Toggle.bottomEdge
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggles.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Toggles = ({"toggles":"RJ8Px"});
// EXTERNAL MODULE: ./node_modules/ramda/src/propEq.js
var propEq = __webpack_require__(18371);
var propEq_default = /*#__PURE__*/__webpack_require__.n(propEq);
// EXTERNAL MODULE: ./node_modules/ramda/src/find.js
var src_find = __webpack_require__(46376);
var find_default = /*#__PURE__*/__webpack_require__.n(src_find);
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DropdownMenu = ({"wrapper":"BHtky","lastItem":"fD1Jz","inner":"YsLjj"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownMenu.tsx
function DropdownMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function DropdownMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DropdownMenu_ownKeys(Object(source), true).forEach(function (key) { DropdownMenu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DropdownMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DropdownMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function DropdownMenu_DropdownMenu({
  children,
  disabled,
  footer,
  menuRole = 'secondary',
  itemRole = 'neutral60',
  style = {}
}) {
  const semanticColorsMenu = hooks_useSemanticColors(menuRole);
  const semanticColorsItem = hooks_useSemanticColors(itemRole);
  const variants = useSemanticVariants();
  const wrappingRef = (0,react.useRef)(null);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const columnOptions = (0,react_facet_src.useFacetMap)(disabled => {
    return {
      index: 1,
      disabled,
      bounded: true
    };
  }, [], [disabledFacet]);
  return /*#__PURE__*/react.createElement(Landmark, {
    containerRef: wrappingRef,
    disabled: disabledFacet,
    shouldBindFocus: true
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: columnOptions,
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: wrappingRef,
    className: DropdownMenu.wrapper,
    style: DropdownMenu_objectSpread(DropdownMenu_objectSpread({}, style),  true ? {
      marginTop: 'var(--base1Scale)'
    } : 0)
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DropdownMenu.inner, semanticColorsMenu.border.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DropdownMenu.lastItem, semanticColorsItem.border.base, variants.dimmest)
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: itemRole
  }, children)))), footer)));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DropdownItem = ({"dropdownItem":"MneaI","show":"opARO","hide":"jhxB_","image":"GOAWR","imageDisabled":"YJVxh"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/DropdownMenu/DropdownItem.tsx










// If you change this make sure to also update the DropdownItem.css file
const DROPDOWN_ITEM_HEIGHT_REM = 4.8;
function DropdownItem_DropdownItem({
  item,
  onClick,
  isSelectable = true,
  isSelected,
  soundEffectPressed,
  soundEffectHovered,
  role = 'inherit',
  onFocusChanged,
  disabled,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('DropdownItem');
  const itemFacet = (0,react_facet_src.useFacetWrap)(item);
  const isSelectedWrapped = (0,react_facet_src.useFacetWrap)(isSelected);
  const isSelectableWrapped = (0,react_facet_src.useFacetWrap)(isSelectable);
  const disabledWrapped = (0,react_facet_src.useFacetWrap)(disabled);
  const gamepadAliasFacet = (0,react_facet_src.useFacetMap)(item => item.gamepadAlias, [], [itemFacet]);
  const label = (0,react_facet_src.useFacetMap)(item => item.label, [], [itemFacet]);
  const imageSource = (0,react_facet_src.useFacetMap)(item => item.imageSource, [], [itemFacet]);
  const icon = (0,react_facet_src.useFacetMap)(item => item.Icon, [], [itemFacet]);
  const {
    background,
    text,
    border
  } = hooks_useSemanticColors(role);
  const modifiers = useSemanticModifiers();
  const variants = useSemanticVariants();
  const narrationText = (0,react_facet_src.useFacetMap)((item, isSelectable, isSelected, isDisabled) => {
    var _item$description;

    const textItems = [item.label, t('.elementType'), item.enumeration];

    if (isSelectable) {
      textItems.push(isSelected ? t('.selected') : t('.unselected'));
    }

    textItems.push((_item$description = item.description) !== null && _item$description !== void 0 ? _item$description : '', isDisabled ? t('.disabled') : '');
    return textItems.filter(Boolean).join(' . ');
  }, [t], [itemFacet, isSelectableWrapped, isSelectedWrapped, disabledWrapped]);
  const interactivePrimitiveClassnames = (0,react_facet_src.useFacetMap)((isSelected, isDisabled) => {
    return classnames_default()(DropdownItem.dropdownItem, background.interactive, border.interactive, variants.dimmest, {
      [modifiers.selected]: isSelected,
      [modifiers.disabled]: isDisabled
    });
  }, [background.interactive, border.interactive, modifiers.selected, variants.dimmest, modifiers.disabled], [isSelectedWrapped, disabledWrapped]);
  const checkClassname = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? DropdownItem.show : DropdownItem.hide, [], [isSelectedWrapped]);
  const iconClassname = (0,react_facet_src.useFacetMap)(isDisabled => classnames_default()(DropdownItem.image, {
    [DropdownItem.imageDisabled]: isDisabled
  }), [], [disabledWrapped]);
  const handleClick = (0,react_facet_src.useFacetCallback)(isDisabled => isDisabled ? () => null : onClick, [onClick], [disabledWrapped]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: interactivePrimitiveClassnames,
    classNameFocused: classnames_default()(DropdownItem.dropdownFocusedItem, focusClass),
    classNameHovered: DropdownItem.dropdownItemHover,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAliasFacet,
    narrationText: narrationText,
    inputLegend: t('.select'),
    onClick: handleClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    onFocusChanged: onFocusChanged
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role
  }), /*#__PURE__*/react.createElement(MaybeIcon, {
    imageSource: imageSource,
    icon: icon,
    className: iconClassname
  }), /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, {
    className: text.interactive
  }, label), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelectableWrapped
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: checkClassname
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null))));
}
const DropdownItemWrapper = ({
  item,
  onChange,
  currentValue,
  isSelectable = true,
  soundEffectPressed,
  soundEffectHovered,
  onFocusChanged,
  disabled,
  gamepadIndex
}) => {
  const handleClick = (0,react_facet_src.useFacetCallback)(item => () => {
    onChange(item.value);
  }, [onChange], [item]);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const gamepadIndexFacet = (0,react_facet_src.useFacetMap)(isDisabled => isDisabled ? -1 : gamepadIndex + 1, [gamepadIndex], [disabledFacet]);
  const currentValueFacet = (0,react_facet_src.useFacetWrap)(currentValue);
  const isSelectableFacet = (0,react_facet_src.useFacetWrap)(isSelectable);
  return /*#__PURE__*/react.createElement(DropdownItem_DropdownItem, {
    item: item,
    isSelected: (0,react_facet_src.useFacetMap)((item, currentValue) => item.isSelected || item.value === currentValue, [], [item, currentValueFacet]),
    isSelectable: isSelectableFacet,
    gamepadIndex: gamepadIndexFacet,
    onClick: handleClick,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    onFocusChanged: onFocusChanged,
    disabled: disabledFacet
  });
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/images/arrowDown.png
const arrowDown_namespaceObject = __webpack_require__.p + "assets/arrowDown-8543c.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/IconArrowDown.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowDown = ({"iconArrowDown":"fYSEY"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDown/IconArrowDown.tsx
function IconArrowDown_extends() { IconArrowDown_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowDown_extends.apply(this, arguments); }

function IconArrowDown_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowDown_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowDown_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconArrowDown_IconArrowDown = (_ref) => {
  let {
    className
  } = _ref,
      props = IconArrowDown_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconArrowDown.iconArrowDown, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowDown_extends({}, props, {
    className: classNames,
    src: arrowDown_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseDropdown = ({"baseDropdownWrapperMenu":"D93jN","baseDropdown":"UKRdZ","baseDropdownOpen":"fIk9X","baseDropdownBevelOpen":"rQRSc","withMouse":"oNoil","hasScroll":"KVO62","baseToggleInnerWrapper":"NKSLw","noSelection":"hqWc9","baseArrowPosition":"boDJV","hide":"ZSOVX"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseDropdown/BaseDropdown.tsx



function BaseDropdown_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function BaseDropdown_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { BaseDropdown_ownKeys(Object(source), true).forEach(function (key) { BaseDropdown_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { BaseDropdown_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function BaseDropdown_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

















const emptyText = (0,react_facet_src.createFacet)({
  initialValue: ''
});
function BaseDropdown_BaseDropdown({
  options,
  value,
  onChange,
  isOpen: isOpenProp,
  onClick,
  onOpenClose,
  dropdownRef,
  disabled,
  onFocusChanged,
  onHoverChanged,
  placeholder,
  footer,
  gamepadAlias,
  soundEffectPressed,
  soundEffectItemHovered,
  narrationText,
  shouldOnlyHandleBackButtonPressWhenDropdownIsOpen = true,
  isElevated = true,
  hideDownArrow = false,
  menuRole = 'secondary',
  itemRole = 'neutral60',
  dropdownMenuStyle,
  dropdownMenuPortalRef,
  onBackButtonPressProps
}) {
  const semanticColorsMenu = hooks_useSemanticColors(menuRole);
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const isOpenPropFacet = (0,react_facet_src.useFacetWrap)(isOpenProp);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const [isOpen, setIsOpen] = (0,react_facet_src.useFacetState)(false);
  const [isFocused, setIsFocused] = (0,react_facet_src.useFacetState)(false);
  const [isInnerItemFocused, setIsInnerItemFocused] = (0,react_facet_src.useFacetState)(false);
  const placeholderFacet = (0,react_facet_src.useFacetWrap)(placeholder);
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (isOpen != null) {
      setIsOpen(isOpen);
    }
  }, [setIsOpen], [isOpenPropFacet]);
  const localRef = (0,react.useRef)(null);
  const ref = dropdownMenuPortalRef || dropdownRef || localRef;
  (0,react_facet_src.useFacetEffect)(isOpen => onOpenClose && onOpenClose(isOpen), [onOpenClose], [isOpen]);
  const {
    t
  } = useLocalization_useLocalization('BaseDropdown');
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const selectedValueFacet = (0,react_facet_src.useFacetWrap)(value);
  const currentOptionFacet = (0,react_facet_src.useFacetMap)((options, selectedValue) => find_default()(propEq_default()('value', selectedValue))(options), [], [optionsFacet, selectedValueFacet]);
  useOnClickOutside(ref, () => {
    setIsOpen(false);
    setFocus(false);
    setTimeout(() => narrateText(t('.stateCollapsed')), 0);
  }, isOpen);
  const isPointerMouse = useIsPointerInputMouse();
  const itemHeightInPixels = useSizeInPixels(4.8);
  const maxHeightInPixels = useSizeInPixels(30);
  const classNameFacet = (0,react_facet_src.useFacetMap)((options, isOpen, currentOption, isMouse) => {
    const hasScroll = options.length * itemHeightInPixels > maxHeightInPixels;
    return classnames_default()({
      [BaseDropdown.baseDropdownBevelOpen]: isOpen,
      [BaseDropdown.withMouse]: isMouse,
      [BaseDropdown.hasScroll]: hasScroll,
      [BaseDropdown.noSelection]: currentOption == null
    });
  }, [itemHeightInPixels, maxHeightInPixels], [optionsFacet, isOpen, currentOptionFacet, isPointerMouse]);

  const handleFocusChange = focus => {
    setIsFocused(focus);
    onFocusChanged === null || onFocusChanged === void 0 ? void 0 : onFocusChanged(focus);
  };

  const handleHoverChange = hover => {
    onHoverChanged === null || onHoverChanged === void 0 ? void 0 : onHoverChanged(hover);
  };

  const outerClassNameFacet = (0,react_facet_src.useFacetMap)(isOpen => classnames_default()(BaseDropdown.baseDropdown, {
    [BaseDropdown.baseDropdownOpen]: isOpen
  }), [], [isOpen]);
  const uniqueIdentifier = useUniqueIdentifier();
  const pressableGamepadAlias = gamepadAlias != null ? gamepadAlias : `dd-bevel-${uniqueIdentifier}`;
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const setFocus = (0,react.useCallback)(isOpen => {
    if (isOpen) {
      const firstIndexAlias = gamepadAlias != null ? `${gamepadAlias}-0` : `dd-bevel-${uniqueIdentifier}-0`; // We delay this by a frame, as it runs too quickly on the
      // Gameface player and causes buggy scroll behavior (ADO:737546)

      const raf = typeof requestAnimationFrame != 'undefined' ? requestAnimationFrame : mockRequestAnimationFrame;
      raf(() => {
        setFocusedId(firstIndexAlias);
      });
    } else {
      setFocusedId(pressableGamepadAlias);
    }
  }, [gamepadAlias, uniqueIdentifier, setFocusedId, pressableGamepadAlias]);
  const handleBackButtonPress = (0,react_facet_src.useFacetCallback)(isOpen => () => {
    if (isOpen) {
      setIsOpen(false);
      setFocus(false);
      setTimeout(() => narrateText(t('.stateCollapsed')), 0);
    }

    onBackButtonPressProps && onBackButtonPressProps(isOpen);
  }, [onBackButtonPressProps, setIsOpen, setFocus, narrateText, t], [isOpen]);
  const handleClick = (0,react_facet_src.useFacetCallback)(isOpen => () => {
    const isNowOpen = !isOpen;
    setIsOpen(isNowOpen);
    onClick && onClick(isNowOpen);
    setFocus(isNowOpen);
  }, [setIsOpen, onClick, setFocus], [isOpen]);
  const handleChange = (0,react_facet_src.useFacetCallback)(options => value => {
    onChange(value);
    handleClick();

    const currentValue = find_default()(propEq_default()('value', value))(options); // As soon as the narration context supports custom narration id's we can remove this and use that instead.


    setTimeout(() => narrateText([t('.selected'), currentValue === null || currentValue === void 0 ? void 0 : currentValue.narrationSuffix].join(' . ')), 0);
  }, [onChange, handleClick, narrateText, t], [optionsFacet]);
  const shouldHandleBackButtonPress = (0,react_facet_src.useFacetMap)((isOpen, isFocused, isInnerItemFocused) => {
    return (isOpen || !shouldOnlyHandleBackButtonPressWhenDropdownIsOpen) && (isFocused || isInnerItemFocused);
  }, [shouldOnlyHandleBackButtonPressWhenDropdownIsOpen], [isOpen, isFocused, isInnerItemFocused]);
  const optionsWithEnumerationAndGamepadAlias = (0,react_facet_src.useFacetMemo)(options => {
    return options.map((option, index) => {
      return BaseDropdown_objectSpread(BaseDropdown_objectSpread({}, option), {}, {
        enumeration: t('.enumeration', [`${index + 1}`, `${options.length}`]),
        gamepadAlias: gamepadAlias != null ? `${gamepadAlias}-${index}` : `dd-bevel-${uniqueIdentifier}-${index}`
      });
    });
  }, [t, gamepadAlias, uniqueIdentifier], [optionsFacet]);
  const semanticSounds = useSemanticSounds('neutral');
  const baseDropdownWrapperMenuClassnames = (0,react_facet_src.useFacetMap)((isOpen, disabled) => classnames_default()(BaseDropdown.baseDropdownWrapperMenu, {
    [BaseDropdown.hide]: !isOpen || disabled === true
  }), [], [isOpen, disabledFacet]);
  const isClosedOrDisabled = (0,react_facet_src.useFacetMap)((isOpen, disabled) => !isOpen || disabled === true, [], [isOpen, disabledFacet]);
  const dropdownMenuNarrationText = (0,react_facet_src.useFacetMap)(isOpen => isOpen ? t('.stateExpanded') : '', [t], [isOpen]);
  const parentShortcutOptions = (0,react_facet_src.useFacetMap)(shouldHandleBackButtonPress => {
    return {
      button: types_ButtonType.B,
      disabled: !shouldHandleBackButtonPress
    };
  }, [], [shouldHandleBackButtonPress]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText !== null && narrationText !== void 0 ? narrationText : emptyText
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: ref,
    className: outerClassNameFacet
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classNameFacet
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    reflection: "specular",
    variant: menuRole,
    narrationText: "",
    onClick: handleClick,
    gamepadIndex: 0,
    inputLegend: t('.open'),
    onFocusChanged: handleFocusChange,
    onHoverChanged: handleHoverChange,
    shouldNotDepressWhenPressed: true,
    height: 4.2,
    isElevated: isElevated,
    disabled: disabledFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press,
    gamepadAlias: pressableGamepadAlias
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(BaseDropdown.baseToggleInnerWrapper, semanticColorsMenu.text.interactive)
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)((currentOption, placeholder) => currentOption ? currentOption.label : placeholder != null ? `${placeholder}...` : '', [], [currentOptionFacet, placeholderFacet])), !hideDownArrow && /*#__PURE__*/react.createElement("div", {
    className: BaseDropdown.baseArrowPosition
  }, /*#__PURE__*/react.createElement(IconArrowDown_IconArrowDown, null))))), dropdownMenuPortalRef ? /*#__PURE__*/react.createElement(DropdownMenuPortal, {
    when: isOpen,
    content: /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
      text: dropdownMenuNarrationText
    }, /*#__PURE__*/react.createElement("fast-div", {
      className: baseDropdownWrapperMenuClassnames
    }, /*#__PURE__*/react.createElement(DropdownMenu_DropdownMenu, {
      disabled: isClosedOrDisabled,
      footer: footer,
      menuRole: menuRole,
      itemRole: itemRole,
      style: dropdownMenuStyle
    }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
      array: optionsWithEnumerationAndGamepadAlias
    }, (item, index) => /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(DropdownItemWrapper, {
      item: item,
      gamepadIndex: index,
      onChange: handleChange,
      key: index,
      currentValue: selectedValueFacet,
      soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press,
      soundEffectHovered: soundEffectItemHovered !== null && soundEffectItemHovered !== void 0 ? soundEffectItemHovered : semanticSounds.hover,
      onFocusChanged: setIsInnerItemFocused,
      disabled: isClosedOrDisabled
    })))))),
    containerRef: dropdownMenuPortalRef
  }) : /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: dropdownMenuNarrationText
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: baseDropdownWrapperMenuClassnames
  }, /*#__PURE__*/react.createElement(DropdownMenu_DropdownMenu, {
    disabled: isClosedOrDisabled,
    footer: footer,
    menuRole: menuRole,
    itemRole: itemRole,
    style: dropdownMenuStyle
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: optionsWithEnumerationAndGamepadAlias
  }, (item, index) => /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(DropdownItemWrapper, {
    item: item,
    gamepadIndex: index,
    onChange: handleChange,
    key: index,
    currentValue: selectedValueFacet,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.press,
    soundEffectHovered: soundEffectItemHovered !== null && soundEffectItemHovered !== void 0 ? soundEffectItemHovered : semanticSounds.hover,
    onFocusChanged: setIsInnerItemFocused,
    disabled: isClosedOrDisabled
  })))))), /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: parentShortcutOptions,
    onClick: handleBackButtonPress
  })));
}
const DropdownMenuPortal = props => {
  const whenValue = (0,react_facet_src.useFacetUnwrap)(props.when);
  return whenValue === true && props.containerRef.current ? /*#__PURE__*/react.createElement(react.Fragment, null, (0,react_facet_src.createPortal)(props.content, props.containerRef.current)) : null;
}; // Needed for visual regression test workaround (TODO: Find cleaner way)

const mockRequestAnimationFrame = fn => fn();
;// CONCATENATED MODULE: ./packages/ui/src/Dropdown/Dropdown.tsx








// If you change this make sure to also update the DropdownItem.css file
const Dropdown_DROPDOWN_ITEM_HEIGHT_REM = 4.8; // If you change this make sure to also update the DropdownMenu.css file

const DROPDOWN_MENU_MAX_HEIGHT_REM = 30;
function Dropdown({
  description,
  gamepadIndex,
  onChange,
  wrapperRef,
  onFocusChanged,
  placeholder,
  label,
  options,
  value,
  disabled,
  disabledNarrationSuffix,
  soundEffectPressed,
  gamepadAlias
}) {
  // we need a wrapper component here so that the Column context is defined
  // and the inner button to toggle the dropdown menu is inside of it.
  // If we had the column and the focusable inside the same component
  // they would become siblings, and their gamepad indexes would collide
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const indexFacet = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  return /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: (0,react_facet_src.useFacetMap)(index => ({
      index
    }), [], [indexFacet])
  }, /*#__PURE__*/react.createElement(DropdownInnerComponent, {
    options: options,
    value: valueFacet,
    disabled: disabledFacet,
    disabledNarrationSuffix: disabledNarrationSuffix,
    label: label,
    description: description,
    placeholder: placeholder,
    onChange: onChange,
    wrapperRef: wrapperRef,
    onFocusChanged: onFocusChanged,
    soundEffectPressed: soundEffectPressed,
    gamepadAlias: gamepadAlias
  }));
}

function useDropdownHeight(options, dropdownRef, wrapperRef) {
  const dropdownItemHeightInPixels = useSizeInPixels(Dropdown_DROPDOWN_ITEM_HEIGHT_REM);
  const dropdownMenuMaxHeightInPixels = useSizeInPixels(DROPDOWN_MENU_MAX_HEIGHT_REM);
  const numberOfOptions = (0,react_facet_src.useFacetMap)(options => options.length, [], [(0,react_facet_src.useFacetWrap)(options)]);
  const [panelHeight, setPanelHeight] = (0,react_facet_src.useFacetState)('');
  const [dropdownMenuHeight, setDropdownMenuHeight] = (0,react_facet_src.useFacetState)('');
  const panelStyle = {
    height: panelHeight
  };
  const dropdownMenuStyle = {
    height: dropdownMenuHeight
  }; // We'll use this function to determine if we should apply any changes to
  // the panels height when the dropdown changes between opened and closed.

  const calculateNewHeight = isOpen => {
    var _wrapperRef$current;

    // Exit early if we don't have the values we need to perform the calculation
    const wrapper = wrapperRef === null || wrapperRef === void 0 ? void 0 : wrapperRef.current;
    const parent = wrapperRef === null || wrapperRef === void 0 ? void 0 : (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;
    const dropdown = dropdownRef.current;
    const numOfOptions = numberOfOptions.get();

    if (!dropdown || numOfOptions === react_facet_src.NO_VALUE) {
      return;
    }

    if (wrapper && parent) {
      const originalHeight = wrapper.getBoundingClientRect().height;
      const dropdownOffset = dropdown.offsetTop;
      const dropdownHeight = numOfOptions * dropdownItemHeightInPixels;
      const dropdownPaddingBottom = 12;
      const expandedHeight = Math.min(Math.max(originalHeight, dropdownOffset + dropdownHeight + dropdownPaddingBottom), dropdownMenuMaxHeightInPixels + dropdownOffset + dropdownPaddingBottom); // Check if the dropdown fits within the parents scroll height. If not we'll
      // publish a new facet value that is going to grow the height of the panel.

      const shouldPanelExpandIfDropdownOpens = parent.scrollHeight < wrapper.offsetTop + expandedHeight;
      const height = isOpen && shouldPanelExpandIfDropdownOpens ? `${expandedHeight}px` : '';
      setPanelHeight(height);
    } else {
      // If we don't have a wrapper and parent, we want to clamp the height of the menu to the available space in the viewport
      const dropdownRect = dropdown.getBoundingClientRect();

      if (dropdownRect.height === 0) {
        return;
      }

      const height = window.innerHeight - dropdownRect.top;

      if (height < dropdownMenuMaxHeightInPixels) {
        setDropdownMenuHeight(isOpen ? `${height}px` : '');
      } else {
        setDropdownMenuHeight('');
      }
    }
  };

  return [panelStyle, dropdownMenuStyle, calculateNewHeight];
}

function DropdownInnerComponent({
  options,
  label,
  description,
  placeholder,
  value,
  onChange,
  wrapperRef,
  disabled,
  disabledNarrationSuffix,
  onFocusChanged,
  soundEffectPressed,
  gamepadAlias,
  menuRole = 'secondary',
  itemRole = 'neutral60'
}) {
  const {
    t
  } = useLocalization_useLocalization('Dropdown');
  const isNarrationEnabled = useNarrationEnabled();
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options);
  const selectedOption = (0,react_facet_src.useFacetMap)((options, selectedValue) => options.find(option => option.value === selectedValue), [], [optionsFacet, value]);
  const selectedValueLabel = (0,react_facet_src.useFacetMap)(selectedOption => {
    var _selectedOption$label;

    return (_selectedOption$label = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.label) !== null && _selectedOption$label !== void 0 ? _selectedOption$label : '';
  }, [], [selectedOption]);
  const selectedValueDescription = (0,react_facet_src.useFacetMap)(selectedOption => {
    var _selectedOption$descr;

    return (_selectedOption$descr = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.description) !== null && _selectedOption$descr !== void 0 ? _selectedOption$descr : '';
  }, [], [selectedOption]);
  const hasSelectedToggleDescription = (0,react_facet_src.useFacetMap)(selectedValueDescription => Boolean(selectedValueDescription), [], [selectedValueDescription]); // We are able to pass an optional wrapperRef to this component. We'll grow the height of the panel,
  // for a consistent background, if the dropdown items expands outside of the wrappers parent container.

  const dropdownRef = (0,react.useRef)(null);
  const [panelStyle, dropdownMenuStyle, calculateNewHeight] = useDropdownHeight(options, dropdownRef, wrapperRef);
  const baseDropdownNarrationText = (0,react_facet_src.useFacetMap)((selectedValueLabel, selectedValueDescription) => [selectedValueLabel, t('.toggleElementType'), t('.selected'), selectedValueDescription, disabledNarrationSuffix].join(' . '), [t, disabledNarrationSuffix], [selectedValueLabel, selectedValueDescription]);
  const isDisabled = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false);
  const isPanelFocusable = (0,react_facet_src.useFacetMap)(isDisabled => isNarrationEnabled && isDisabled === true, [isNarrationEnabled], [isDisabled]);
  const narrationText = (0,react_facet_src.useFacetMap)((baseDropdownNarrationText, isDisabled) => [label, t('.narrationComponentType'), isDisabled ? t('.narrationDisabled') : '', t('.stateCollapsed'), // If the dropdown is disabled, we need to add extra narration here to match
  // the narration that is calculated in the BaseDropdown. The reason we can't
  // add it in the BaseDropdown is because the Panel below needs to be the focusable element.
  isDisabled ? baseDropdownNarrationText : ''].join(' . '), [t, label], [baseDropdownNarrationText, isDisabled]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    style: panelStyle,
    focusable: isPanelFocusable,
    gamepadIndex: 0,
    narrationText: ''
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, label), description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    narrationText: baseDropdownNarrationText,
    options: options,
    value: value,
    onChange: onChange,
    disabled: disabled,
    placeholder: placeholder,
    onFocusChanged: onFocusChanged,
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null),
    soundEffectPressed: soundEffectPressed,
    onOpenClose: calculateNewHeight,
    dropdownRef: dropdownRef,
    gamepadAlias: gamepadAlias,
    menuRole: menuRole,
    itemRole: itemRole,
    dropdownMenuStyle: dropdownMenuStyle
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasSelectedToggleDescription
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, {
    disabled: disabled
  }, selectedValueDescription)))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Toggles/Toggles.tsx
function Toggles_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Toggles_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Toggles_ownKeys(Object(source), true).forEach(function (key) { Toggles_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Toggles_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Toggles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












let id = 0;

const Toggles_noop = () => {};

function Toggles_Toggles({
  gamepad,
  options,
  title,
  description,
  onChange = Toggles_noop,
  disabled = false,
  value,
  wrapToggleText,
  onMountComplete,
  soundEffectPressed,
  disabledNarrationSuffix
}) {
  const semanticSounds = useSemanticSounds('neutral');
  const wrappingRef = (0,react.useRef)(null);
  const optionsFacet = (0,react_facet_src.useFacetWrap)(options); // the minimum width for one item in REM, when you multiply it by the options cont, it gives you the break-point width in REM

  const minimumItemWidth = 15;
  const smallerThanResult = useIsComponentSmallerThan(wrappingRef, (0,react_facet_src.useFacetMap)(options => options.length * minimumItemWidth, [], [optionsFacet]));
  const smallerThanSize = (0,react_facet_src.useFacetMap)(result => result === 'smaller', [], [smallerThanResult]);
  const unknownSize = (0,react_facet_src.useFacetMap)(result => result === 'unknown', [], [smallerThanResult]);
  const isNarrationEnabled = useNarrationEnabled();
  (0,react_facet_src.useFacetEffect)(unknownSize => {
    if (!unknownSize && onMountComplete != null) {
      onMountComplete();
    }
  }, [onMountComplete], [unknownSize]);
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: Toggles_objectSpread(Toggles_objectSpread({}, gamepad), {}, {
      disabled: (0,react_facet_src.useFacetUnwrap)(disabled) === true && !isNarrationEnabled
    }),
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("div", {
    ref: wrappingRef
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: smallerThanSize
  }, /*#__PURE__*/react.createElement(Dropdown, {
    label: title,
    description: description,
    gamepadIndex: 0,
    options: options,
    value: value,
    onChange: onChange,
    disabled: disabled,
    disabledNarrationSuffix: disabledNarrationSuffix,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle,
    wrapperRef: wrappingRef
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: smallerThanSize,
    condition: false
  }, /*#__PURE__*/react.createElement(InternalToggles, {
    disabledNarrationSuffix: disabledNarrationSuffix,
    options: options,
    title: title,
    description: description,
    onChange: onChange,
    disabled: disabled,
    value: value,
    wrapToggleText: wrapToggleText,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle,
    skeleton: unknownSize
  }))));
}

function InternalToggles({
  options: optionsProp,
  title,
  description,
  onChange = Toggles_noop,
  disabled: disabledProp = false,
  value: valueProp,
  wrapToggleText,
  soundEffectPressed,
  disabledNarrationSuffix,
  skeleton
}) {
  var _options$find;

  const options = (0,react_facet_src.useFacetUnwrap)(optionsProp);
  const value = (0,react_facet_src.useFacetUnwrap)(valueProp);
  const disabled = (0,react_facet_src.useFacetUnwrap)(disabledProp);
  const focusAlias = (0,react.useRef)(`MCT-${id++}`);
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const {
    t
  } = useLocalization_useLocalization('Toggle');
  const isNarrationEnabled = useNarrationEnabled();
  if (options === react_facet_src.NO_VALUE || value === react_facet_src.NO_VALUE || disabled === react_facet_src.NO_VALUE) return null;
  const selectedIndex = options.findIndex(option => {
    return option.value === value;
  });
  const selectedToggleDescription = (_options$find = options.find(option => option.value === value && option.description)) === null || _options$find === void 0 ? void 0 : _options$find.description;

  function handleClickOnToggle(index) {
    if (options === react_facet_src.NO_VALUE) return;
    onChange(options[index].value);
  }

  const disabledNarrationText = disabled && isNarrationEnabled ? [title !== null && title !== void 0 ? title : '', t('.narrationComponentType'), t('.narrationDisabled'), options[selectedIndex].label, t('.narrationOptionType'), t('.narrationSelected'), selectedToggleDescription !== null && selectedToggleDescription !== void 0 ? selectedToggleDescription : '', disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : ''].join(' . ') : '';
  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    focusable: disabled && isNarrationEnabled,
    gamepadIndex: 0,
    narrationText: disabledNarrationText
  }, title != null && /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, title), description != null ? /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description) : null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: Toggles.toggles
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: skeleton,
    condition: false
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: `${title !== null && title !== void 0 ? title : ''} ${t('.narrationComponentType')}`
  }, options.map((option, index) => {
    return /*#__PURE__*/react.createElement(Toggle_Toggle, {
      key: index,
      icons: option.icons,
      onClick: () => {
        const option = options[index];
        narrateText([t('.narrationSelected'), option.narrationSuffix].join(' . '));
        handleClickOnToggle(index);
      },
      selected: selectedIndex === index,
      gamepadIndex: index,
      gamepadAlias: `${focusAlias.current}.${index}`,
      extraSpeechProps: {
        index,
        groupSize: options.length,
        description: option.description
      },
      disabled: disabled,
      wrapText: wrapToggleText,
      soundEffectPressed: selectedIndex === index ? undefined : soundEffectPressed
    }, option.label);
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: skeleton
  }, /*#__PURE__*/react.createElement(ToggleSkeleton, null))), selectedToggleDescription != null && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, selectedToggleDescription)));
}

Toggles_Toggles.displayName = 'Toggles';
Toggles_Toggles.Toggle = Toggle_Toggle;
;// CONCATENATED MODULE: ./packages/react-dnd/src/PointerBlocker.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PointerBlocker = ({"blockPointer":"hVSP2"});
;// CONCATENATED MODULE: ./packages/react-dnd/src/PointerBlocker.tsx
/**
 * This component is used to prevent mouse hovers on focusables when the user
 * is dragging and dropping. Triggering mouse hovers during this action will
 * trigger narration that is probably not relevant to the user.
 */



const SetDisablePointer = (0,react.createContext)(() => {});
const useSetDisablePointerHoverEvents = () => (0,react.useContext)(SetDisablePointer);
function PointerBlocker_PointerBlocker({
  children
}) {
  const [disabled, setDisabled] = (0,react_facet_src.useFacetState)(false);
  return /*#__PURE__*/react.createElement(SetDisablePointer.Provider, {
    value: setDisabled
  }, children, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(disabled => disabled ? PointerBlocker.blockPointer : '', [], [disabled])
  }));
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/Provider.tsx




const DRAG_Z_INDEX = 4;
const DragAndDropProviderApi = (0,react.createContext)(null);
const useDragAndDropProviderApi = () => (0,react.useContext)(DragAndDropProviderApi);
const DragAndDropIsDragging = (0,react.createContext)(null);
const DraggableStatesFacetProvider = (0,react.createContext)(null);
const useDraggableStatesFacet = () => (0,react.useContext)(DraggableStatesFacetProvider);
const DroppableStatesFacetProvider = (0,react.createContext)(null);
const useDroppableStatesFacet = () => (0,react.useContext)(DroppableStatesFacetProvider);
function DragAndDropProvider({
  children
}) {
  const isPointerMouse = useIsPointerInputMouse();
  const draggableStatesFacet = (0,react.useMemo)(() => (0,react_facet_src.createFacet)({
    initialValue: {}
  }), []);
  const droppableStatesFacet = (0,react.useMemo)(() => (0,react_facet_src.createFacet)({
    initialValue: {}
  }), []);
  const isUserDragging = (0,react_facet_src.useFacetMap)(draggableStates => findDragged(draggableStates) != null, [], [draggableStatesFacet]); // When the user drags, we want to disable mouse hover events

  const setDisablePointerHoverEvents = useSetDisablePointerHoverEvents();
  (0,react_facet_src.useFacetEffect)(setDisablePointerHoverEvents, [setDisablePointerHoverEvents], [isUserDragging]);
  const focusDragMove = (0,react_facet_src.useFacetCallback)((draggableStates, droppableStates) => direction => {
    const draggedState = findDragged(draggableStates);
    if (draggedState == null || draggedState.dragging != 'gamepad') return; // Update the dragging element's transform so it snaps to the next droppable position

    draggableStatesFacet.setWithCallback(draggableStates => {
      const dirVal = direction === 'up' ? -1 : direction === 'down' ? 1 : 0;
      const newDragIndex = draggedState.gamepadHoverIndex + dirVal;
      const draggedDroppable = findDroppableByIndex(droppableStates, draggedState.index);

      for (const id in droppableStates) {
        const dropState = droppableStates[id];

        if (dropState.index === newDragIndex) {
          var _dropState$ref$curren;

          const dropBounds = (_dropState$ref$curren = dropState.ref.current) === null || _dropState$ref$curren === void 0 ? void 0 : _dropState$ref$curren.getBoundingClientRect();

          if (draggedState.startX == null || draggedState.startY == null) {
            var _draggedDroppable$ref;

            const dragBounds = draggedDroppable === null || draggedDroppable === void 0 ? void 0 : (_draggedDroppable$ref = draggedDroppable.ref.current) === null || _draggedDroppable$ref === void 0 ? void 0 : _draggedDroppable$ref.getBoundingClientRect();

            if (dragBounds != null) {
              var _dragBounds$left, _dragBounds$top;

              draggedState.startX = (_dragBounds$left = dragBounds.left) !== null && _dragBounds$left !== void 0 ? _dragBounds$left : 0;
              draggedState.startY = (_dragBounds$top = dragBounds.top) !== null && _dragBounds$top !== void 0 ? _dragBounds$top : 0;
            }
          }

          if (dropBounds == null) break;
          const snapBackToOrigin = newDragIndex === draggedState.index;
          draggedState.gamepadHoverIndex = newDragIndex;

          if (snapBackToOrigin) {
            draggedState.transform = `translate(0, 0)`;
          } else {
            draggedState.transform = `translate(${dropBounds.left - draggedState.startX + draggedState.gamepadDragXOffsetPx}px, ${dropBounds.top - draggedState.startY + draggedState.gamepadDragYOffsetPx}px)`;
          }

          break;
        }
      }

      return draggableStates;
    });
    droppableStatesFacet.setWithCallback(droppableStates => {
      if (droppableStates != react_facet_src.NO_VALUE) {
        for (const id in droppableStates) {
          const state = droppableStates[id];
          const moveUp = draggedState.index < state.index && draggedState.gamepadHoverIndex >= state.index;
          const moveDown = draggedState.index > state.index && draggedState.gamepadHoverIndex <= state.index;
          state.displacement = moveUp ? -1 : moveDown ? 1 : 0;
          state.hovering = draggedState.gamepadHoverIndex === state.index;
        }
      }

      return droppableStates;
    });
  }, [draggableStatesFacet, droppableStatesFacet], [draggableStatesFacet, droppableStatesFacet]);
  const pointerMoveHandler = (0,react_facet_src.useFacetCallback)((draggableStates, droppableStates, isPointerMouse) => event => {
    const draggedState = findDragged(draggableStates); // Fix touch bug on browser when triggering right click

    if (!isPointerMouse && event.touches == null) {
      return;
    }

    const {
      clientX,
      clientY
    } = isPointerMouse ? event : event.touches[0];
    const closestDroppableState = findClosestDroppable(clientX, clientY, droppableStates);
    if (draggedState == null) return; // Update the dragging element's transform so it follows the pointer/finger

    draggableStatesFacet.setWithCallback(draggableStates => {
      if (draggedState.startX != null && draggedState.startY != null) {
        var _closestDroppableStat;

        const x = draggedState.pointerAxisLock === 'y' ? 0 : clientX - draggedState.startX;
        const y = draggedState.pointerAxisLock === 'x' ? 0 : clientY - draggedState.startY;
        draggedState.transform = `translate(${x}px, ${y}px)`;
        draggedState.pointerHoverIndex = (_closestDroppableStat = closestDroppableState === null || closestDroppableState === void 0 ? void 0 : closestDroppableState.index) !== null && _closestDroppableStat !== void 0 ? _closestDroppableStat : draggedState.index; // Set a flag when the user has dragged the draggable beyond the
        // initial drag start area for the first time. Can be useful for
        // triggering initial drag

        if (draggedState.pointerHoverIndex !== (draggedState === null || draggedState === void 0 ? void 0 : draggedState.index)) {
          draggedState.hasDraggedPointerBeyondStartArea = true;
        }
      }

      return draggableStates;
    }); // Update the displacement and hovering values of all droppables

    droppableStatesFacet.setWithCallback(droppableStates => {
      if (closestDroppableState != null && droppableStates != react_facet_src.NO_VALUE) {
        for (const id in droppableStates) {
          const state = droppableStates[id];
          const moveUp = draggedState.index < state.index && closestDroppableState.index >= state.index;
          const moveDown = draggedState.index > state.index && closestDroppableState.index <= state.index;
          state.displacement = moveUp ? -1 : moveDown ? 1 : 0;
          state.hovering = false;
        }

        closestDroppableState.hovering = true;
      }

      return droppableStates;
    });
  }, [draggableStatesFacet, droppableStatesFacet], [draggableStatesFacet, droppableStatesFacet, isPointerMouse]);
  /**
   * Register the mouseup and mousemove listener
   */

  (0,react.useEffect)(() => {
    const mouseUpHandler = () => {
      window.removeEventListener('mousemove', pointerMoveHandler);
      window.removeEventListener('touchmove', pointerMoveHandler);
      let dragData;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          for (const id in draggableStates) {
            const state = draggableStates[id];

            if (state.dragging != false) {
              dragData = state.data;
            }

            state.hasDraggedPointerBeyondStartArea = false;
            state.dragging = false;
            state.transform = '';
            state.zIndex = '';
            state.startX = null;
            state.startY = null;
          }
        }

        return draggableStates;
      });
      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          for (const id in droppableStates) {
            const state = droppableStates[id];

            if (state.hovering === true) {
              state.onDrop(dragData, state.data);
            }

            state.displacement = null;
            state.hovering = false;
          }
        }

        return droppableStates;
      });
    };

    window.addEventListener('mouseup', mouseUpHandler);
    window.addEventListener('touchend', mouseUpHandler);
    return () => {
      window.removeEventListener('mouseup', mouseUpHandler);
      window.removeEventListener('touchend', mouseUpHandler);
    };
  }, [pointerMoveHandler, draggableStatesFacet, droppableStatesFacet]);
  const vrPlatform = useVRPlatform();
  const api = (0,react.useMemo)(() => ({
    addDraggable: options => {
      if (options.id == null) return;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          var _options$gamepadDragX, _options$gamepadDragY;

          draggableStates[options.id] = {
            id: options.id,
            gamepadHoverIndex: options.index,
            pointerHoverIndex: options.index,
            hasDraggedPointerBeyondStartArea: false,
            ref: options.ref,
            data: options.data,
            index: options.index,
            dragging: false,
            transform: '',
            zIndex: '',
            startX: null,
            startY: null,
            pointerAxisLock: options.pointerAxisLock,
            gamepadDragXOffsetPx: (_options$gamepadDragX = options.gamepadDragXOffsetPx) !== null && _options$gamepadDragX !== void 0 ? _options$gamepadDragX : 0,
            gamepadDragYOffsetPx: (_options$gamepadDragY = options.gamepadDragYOffsetPx) !== null && _options$gamepadDragY !== void 0 ? _options$gamepadDragY : 0
          };
        }

        return draggableStates;
      });
    },
    removeDraggable: id => {
      if (!id) return;
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          delete draggableStates[id];
        }

        return draggableStates;
      });
    },
    addDroppable: options => {
      if (options.id == null) return; // This function gets recursively called until the element
      // is rendered (and getBoundingClientRect returns a value)

      function registerDroppable(options) {
        var _options$ref$current;

        const bounds = (_options$ref$current = options.ref.current) === null || _options$ref$current === void 0 ? void 0 : _options$ref$current.getBoundingClientRect(); // If we can't get the element bounds this frame, wait and try again

        if (bounds == null || bounds.width === 0 && bounds.height === 0) {
          requestAnimationFrame(() => registerDroppable(options));
          return;
        } // Wait an extra frame - TODO: Is this raf needed?


        requestAnimationFrame(() => {
          // Now that we have the element bounds, register it as a droppable zone
          droppableStatesFacet.setWithCallback(droppableStates => {
            if (bounds == null || droppableStates == react_facet_src.NO_VALUE) {
              return droppableStates;
            }

            droppableStates[options.id] = {
              data: options.data,
              index: options.index,
              hovering: false,
              centerX: bounds.left + bounds.width / 2,
              centerY: bounds.top + bounds.height / 2,
              left: bounds.left,
              top: bounds.top,
              displacement: null,
              ref: options.ref,
              onDrop: options.onDrop
            };
            return droppableStates;
          });
        });
      }

      registerDroppable(options);
    },
    removeDroppable: id => {
      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          delete droppableStates[id];
        }

        return droppableStates;
      });
    },
    pointerDragStart: (id, x, y) => {
      window.addEventListener('mousemove', pointerMoveHandler);
      window.addEventListener('touchmove', pointerMoveHandler); // When pointer dragging starts, we store the
      // boundaries for all the droppable areas.

      droppableStatesFacet.setWithCallback(droppableStates => {
        if (droppableStates != react_facet_src.NO_VALUE) {
          var _droppableStates$id;

          // If the user drops the item instantly we will still narrate the position.
          if (((_droppableStates$id = droppableStates[id]) === null || _droppableStates$id === void 0 ? void 0 : _droppableStates$id.hovering) != null) {
            droppableStates[id].hovering = true;
          }

          for (const id in droppableStates) {
            var _state$ref$current;

            if (droppableStates == null) break;
            const state = droppableStates[id];
            const bounds = (_state$ref$current = state.ref.current) === null || _state$ref$current === void 0 ? void 0 : _state$ref$current.getBoundingClientRect();
            if (bounds == null) continue;
            state.centerX = bounds.left + bounds.width / 2;
            state.centerY = bounds.top + bounds.height / 2;
            state.left = bounds.left;
            state.top = bounds.top;
            state.displacement = 0;
          }
        }

        return droppableStates;
      });
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          draggableStates[id].dragging = 'pointer';
          const ref = draggableStates[id].ref.current; // We calculate an initial offset to handle if the dragged element
          // is moved due to a layout change when dragging starts.

          const bounds = ref === null || ref === void 0 ? void 0 : ref.getBoundingClientRect();
          if (bounds == null) return draggableStates;
          const axisLock = draggableStates[id].pointerAxisLock;
          const xDist = axisLock === 'y' ? 0 : x - bounds.left;
          const yDist = axisLock === 'x' ? 0 : y - bounds.top; // This will be true if a layout change caused the element to from from outside the cursor

          const clickInitializedOutOfBounds = yDist > bounds.height || xDist > bounds.width;

          if (clickInitializedOutOfBounds) {
            draggableStates[id].transform = `translate(${xDist}px, ${yDist}px)`;
          } else {
            draggableStates[id].transform = `translate(0, 0)`;
          }

          draggableStates[id].zIndex = DRAG_Z_INDEX;
          draggableStates[id].startX = clickInitializedOutOfBounds ? x - xDist : x;
          draggableStates[id].startY = clickInitializedOutOfBounds ? y - yDist : y;
        }

        return draggableStates;
      });
    },
    focusDragStop: () => {
      const draggables = draggableStatesFacet.get();

      if (draggables != react_facet_src.NO_VALUE) {
        const dragged = findDragged(draggables);

        if ((dragged === null || dragged === void 0 ? void 0 : dragged.dragging) === 'gamepad') {
          api.focusDragToggle(dragged.id);
        }
      }
    },

    /**
     * Toggles the dragging state of a given focusable.
     * Used for focus interactions (eg. gamepad, keyboard)
     *
     * @param id The id of the target draggable
     */
    focusDragToggle: id => {
      draggableStatesFacet.setWithCallback(draggableStates => {
        if (draggableStates != react_facet_src.NO_VALUE) {
          const state = draggableStates[id]; // Stop dragging if we're already dragging

          if (state.dragging != false) {
            window.removeEventListener('mousemove', api.focusDragStop);
            window.removeEventListener('touchstart', api.focusDragStop);
            state.dragging = false;
            state.zIndex = '';
            state.transform = '';
            state.gamepadHoverIndex = state.index; // Loop through each droppable and reset their states.

            droppableStatesFacet.setWithCallback(droppableStates => {
              if (droppableStates != react_facet_src.NO_VALUE) {
                for (const id in droppableStates) {
                  const dropState = droppableStates[id]; // If this droppable was also currently being hovered by the
                  // dragged item, then call the onDrop handler for that droppable.

                  if (dropState.hovering === true) {
                    dropState.onDrop(state.data, dropState.data);
                  }

                  dropState.displacement = null;
                  dropState.hovering = false;
                }
              }

              return droppableStates;
            });
          } // Start dragging
          else {
              if (vrPlatform.get() === ARVRPlatform.ARVR_None) {
                window.addEventListener('mousemove', api.focusDragStop);
                window.addEventListener('touchstart', api.focusDragStop);
              }

              state.dragging = 'gamepad';
              state.zIndex = DRAG_Z_INDEX; // Set the displacement of all droppables to 0

              droppableStatesFacet.setWithCallback(droppableStates => {
                if (droppableStates != react_facet_src.NO_VALUE) {
                  var _droppableStates$id2;

                  // If the user drops the item instantly we will still narrate the position.
                  if (((_droppableStates$id2 = droppableStates[id]) === null || _droppableStates$id2 === void 0 ? void 0 : _droppableStates$id2.hovering) != null) {
                    droppableStates[id].hovering = true;
                  }

                  for (const id in droppableStates) {
                    const state = droppableStates[id];
                    state.displacement = 0;
                  }
                }

                return droppableStates;
              });
            }
        }

        return draggableStates;
      });
    },
    focusDragMove
  }), [pointerMoveHandler, focusDragMove, draggableStatesFacet, droppableStatesFacet, vrPlatform]);
  return /*#__PURE__*/react.createElement(DragAndDropProviderApi.Provider, {
    value: api
  }, /*#__PURE__*/react.createElement(DroppableStatesFacetProvider.Provider, {
    value: droppableStatesFacet
  }, /*#__PURE__*/react.createElement(DraggableStatesFacetProvider.Provider, {
    value: draggableStatesFacet
  }, /*#__PURE__*/react.createElement(DragAndDropIsDragging.Provider, {
    value: isUserDragging
  }, children))));
}
/**
 * Finds the dragged item in a DraggablesStateMap
 */

function findDragged(draggableStates) {
  for (const id in draggableStates) {
    const state = draggableStates[id];
    if (state.dragging === false) continue;
    return draggableStates[id];
  }
}
/**
 * Finds the closest droppable to an x/y position in a given DroppablesStateMap
 */

function findClosestDroppable(x, y, droppableStates) {
  if (droppableStates == null) return null;
  let closestDroppable = null;
  let closestDistance = null;

  for (const id in droppableStates) {
    const state = droppableStates[id];

    if (state.centerX == null || state.centerY == null) {
      continue;
    }

    const distance = Math.hypot(x - state.centerX, y - state.centerY);

    if (closestDistance == null || distance < closestDistance) {
      closestDistance = distance;
      closestDroppable = state;
    }
  }

  return closestDroppable;
}
function findDroppableByIndex(droppableStates, index) {
  if (droppableStates == null) return null;

  for (const id in droppableStates) {
    const state = droppableStates[id];
    if (state.index === index) return state;
  }
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useIsUserDragging.ts


const useIsUserDragging = () => (0,react.useContext)(DragAndDropIsDragging);
;// CONCATENATED MODULE: ./packages/ui/src/Form/Form.tsx




function Form({
  gamepadIndex,
  children,
  role = 'neutral'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(semanticColors.background.base, semanticColors.text.base)
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: gamepadIndex
    }
  }, children));
}
;// CONCATENATED MODULE: ./packages/react-narrator/src/serializeNarrationDataAttributes.ts
const serializeNarrationDataAttributes = narrationDataAttributesCollection => {
  let result = '';
  const length = narrationDataAttributesCollection.length;

  for (let index = 0; index < length; index++) {
    const currentItem = narrationDataAttributesCollection[index];

    if (currentItem.before != null) {
      result += ' . ' + currentItem.before;
    }

    if (currentItem.text != null) {
      result += ' . ' + currentItem.text;
    }

    if (currentItem.as != null) {
      result += ' . ' + currentItem.as;
    }

    if (currentItem.after != null) {
      result += ' . ' + currentItem.after;
    }
  }

  return result.slice(3);
};
;// CONCATENATED MODULE: ./packages/react-narrator/src/collectNarrationTextFromChildren.ts
const collectNarrationDataAttributes = node => {
  const nodesToNarrate = node.querySelectorAll('[data-narrate]');
  const nodeAmount = nodesToNarrate.length;
  const result = [];

  for (let index = 0; index < nodeAmount; index++) {
    const currentNode = nodesToNarrate[index];
    const dataNarrate = currentNode.getAttribute('data-narrate');
    const dataNarrateAs = currentNode.getAttribute('data-narrate-as');
    const dataNarrateAfter = currentNode.getAttribute('data-narrate-after');
    const dataNarrateBefore = currentNode.getAttribute('data-narrate-before');
    const narrationDataAttributes = {};

    if (dataNarrate != null && dataNarrate !== '') {
      narrationDataAttributes.text = dataNarrate;
    } else {
      const textContent = currentNode.textContent;

      if (textContent != null) {
        narrationDataAttributes.text = textContent;
      } else {
        if (false) {}
      }
    }

    if (dataNarrateAfter != null && dataNarrateAfter !== '') {
      narrationDataAttributes.after = dataNarrateAfter;
    }

    if (dataNarrateAs != null && dataNarrateAs !== '') {
      narrationDataAttributes.as = dataNarrateAs;
    }

    if (dataNarrateBefore != null && dataNarrateBefore !== '') {
      narrationDataAttributes.before = dataNarrateBefore;
    }

    result.push(narrationDataAttributes);
  }

  return result;
};
;// CONCATENATED MODULE: ./packages/ui/src/Banner/Banner.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Banner = ({"banner":"geCU1","defaultCursor":"HWLBO"});
;// CONCATENATED MODULE: ./packages/ui/src/Banner/bannerContext.tsx

const bannerContext = (0,react.createContext)({});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Link = ({"link":"iTfr1","withUnderlinePolyfill":"zaq0M","linkBrowserOnly":"UEzHB","withUnderlinePolyfillBrowserOnly":"_d1Tg","underlinePolyfill":"BeCTv","linkFocused":"vLdsX"});
;// CONCATENATED MODULE: ./packages/ui/src/Link/Link.tsx








function Link_Link({
  children,
  gamepadIndex,
  disabled,
  onClick,
  withUnderlinePolyfill,
  soundEffectPressed,
  inputLegend,
  focusRefOverride,
  __testAlias,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization_useLocalization('Link');
  const semanticColors = hooks_useSemanticColors(role);
  const colorValues = useSemanticColorValues(role);
  const semanticSounds = useSemanticSounds(role);
  const contextualNarrationText = (0,react_facet_src.useFacetMap)(text => `${text} . ${t('.narrationComponentType')}`, [t], [(0,react_facet_src.useFacetWrap)(children)]);
  const textColor = colorValues.text.regular.default;
  const linkStyles = (0,react.useMemo)(() => {
    return {
      textDecorationColor: textColor
    };
  }, [textColor]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    tag: "span",
    className: classnames_default()(Link.link, semanticColors.highlight.hover, semanticColors.text.base, {
      [Link.linkBrowserOnly]: "gameface" === 'browser',
      [Link.withUnderlinePolyfill]: withUnderlinePolyfill,
      [Link.withUnderlinePolyfillBrowserOnly]: withUnderlinePolyfill && "gameface" === 'browser'
    }),
    gamepadAlias: __testAlias,
    classNameFocused: classnames_default()(focusClass, Link.linkFocused),
    gamepadIndex: gamepadIndex,
    focusRefOverride: focusRefOverride,
    inputLegend: inputLegend !== null && inputLegend !== void 0 ? inputLegend : t('.open') // Links are narrated as button to follow the accessibility standard
    ,
    narrationText: contextualNarrationText,
    onClick: onClick,
    disabled: disabled,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.click,
    style: linkStyles
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: role,
    disabled: disabled,
    withoutBorders: true
  }), (0,react_facet_src.isFacet)(children) ? /*#__PURE__*/react.createElement("fast-text", {
    text: children
  }) : children, withUnderlinePolyfill && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Link.underlinePolyfill),
    style: {
      borderBottomColor: textColor
    }
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/Banner/BannerLink.tsx





const BannerLink = ({
  children,
  onClick,
  soundEffectPressed,
  gamepadIndex,
  __testAlias
}) => {
  const bannerRef = (0,react.useContext)(bannerContext);
  const semanticSounds = useSemanticSounds('inherit');
  return /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: "inherit"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.click,
    withUnderlinePolyfill: true,
    onClick: onClick,
    focusRefOverride: bannerRef.ref,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    __testAlias: __testAlias
  }, children));
};
;// CONCATENATED MODULE: ./packages/ui/src/Banner/BannerText.tsx


function BannerText({
  children
}) {
  return /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: "inherit",
    shouldNarrate: true
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/Banner/Banner.tsx











function Banner_Banner({
  children,
  role,
  gamepadIndex,
  narrationId,
  __testAlias
}) {
  const interactivePrimitiveRef = (0,react.useRef)(null);
  const isNarrationEnabled = useNarrationEnabled();
  const semanticColors = hooks_useSemanticColors(role);
  const semanticSounds = useSemanticSounds(role);
  const {
    t
  } = useLocalization_useLocalization('Banner');

  const hasInteractiveLink = children => {
    if (Array.isArray(children)) {
      return children.filter(child => hasInteractiveLink(child)).length > 0;
    }

    if (children != null && typeof children === 'object' && 'type' in children) {
      return children.type === BannerLink;
    }

    return false;
  };

  const getTTSNarration = (0,react.useCallback)(() => {
    if (interactivePrimitiveRef.current == null) return '';
    return serializeNarrationDataAttributes(collectNarrationDataAttributes(interactivePrimitiveRef.current)) + ' . ' + t('.narrationComponentTypeTextBox');
  }, [t]);
  const getContextNarration = (0,react.useCallback)(() => {
    if (interactivePrimitiveRef.current == null) return '';
    return serializeNarrationDataAttributes(collectNarrationDataAttributes(interactivePrimitiveRef.current));
  }, []);
  const bannerContextValue = (0,react.useMemo)(() => {
    return {
      ref: interactivePrimitiveRef
    };
  }, []);
  const builtNarrationId = (0,react.useMemo)(() => `banner.${role}.${narrationId != false ? narrationId : ''}`, [role, narrationId]);
  const isBannerInteractive = isNarrationEnabled && !hasInteractiveLink(children);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isBannerInteractive,
    innerRef: interactivePrimitiveRef,
    gamepadAlias: __testAlias,
    className: classnames_default()(Banner.banner, semanticColors.background.base, semanticColors.text.base, {
      [Banner.defaultCursor]: isNarrationEnabled && !hasInteractiveLink(children)
    }),
    classNameFocused: focusClass,
    inputLegend: false,
    gamepadIndex: gamepadIndex !== null && gamepadIndex !== void 0 ? gamepadIndex : 0,
    getNarrationText: getTTSNarration,
    narrationId: builtNarrationId,
    soundEffectPressed: semanticSounds.click
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    disabled: !isNarrationEnabled,
    withoutBorders: true
  }), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    getText: getContextNarration,
    id: builtNarrationId
  }, /*#__PURE__*/react.createElement(bannerContext.Provider, {
    value: bannerContextValue
  }, isBannerInteractive && /*#__PURE__*/react.createElement(Focus_Focus, {
    inset: true
  }), children))));
}
Banner_Banner.displayName = 'Banner';
Banner_Banner.Text = BannerText;
Banner_Banner.Link = BannerLink;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/MulitplayerWarnings.ts



function isNintendoPlatform(platform) {
  return platform === Platform.NX_HANDHELD || platform === Platform.NX_TV;
}

function isPlaystationPlatform(platform) {
  return platform === Platform.PS4;
}

function getWarningMessage(warningState, platform, t) {
  // Same on all platforms
  if (warningState === GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION) {
    return t('.multiplayerWarnings.checkInternetConnection');
  } // Separate message for Playstation and Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.DISCONNECTED_THIRD_PARTY_WITH_SUBSCRIPTION) {
    if (isPlaystationPlatform(platform)) return t('.multiplayerWarnings.playstationDisconnectedThirdPartyWithSubscription');
    if (isNintendoPlatform(platform)) return t('.multiplayerWarnings.nintendoDisconnectedThirdPartyWithSubscription');
  } // Separate message for Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.LOCAL_MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY) {
    return t('.multiplayerWarnings.nintendoLocalMultiplayerPrivilegesBlockedThirdParty');
  } // Separate message for Playstation and Nintendo, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED_THIRD_PARTY) {
    if (isPlaystationPlatform(platform)) return t('.multiplayerWarnings.playstationMultiplayerPrivilegesBlockedThirdParty');
    if (isNintendoPlatform(platform)) return t('.multiplayerWarnings.nintendoMultiplayerPrivilegesBlockedThirdParty');
  } // Same on all platforms


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED) {
    return t('.multiplayerWarnings.multiplayerPrivilegesBlocked');
  } // Same on all platforms


  if (warningState === GeneralMultiplayerWarningStateEnum.MULTIPLAYER_PRIVILEGES_BLOCKED_ON_CONSOLE) {
    return t('.multiplayerWarnings.multiplayerPrivilegesBlockedOnConsole');
  } // Separate message for Playstation, N/A for other


  if (warningState === GeneralMultiplayerWarningStateEnum.CROSS_PLATFORM_DISABLED) {
    return t('.multiplayerWarnings.playstationCrossPlatformDisabled');
  }

  if (warningState === GeneralMultiplayerWarningStateEnum.NON_MULTIPLAYER_SKIN_EQUIPPED) {
    return t('.multiplayerWarnings.nonMultiplayerSkinEquipped');
  }

  return '';
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/images/achievement-bottle.png
const achievement_bottle_namespaceObject = __webpack_require__.p + "assets/achievement-bottle-1487f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/Notifications.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Notifications = ({"notificationBottle":"TBzZf","notifications":"eegnV","panelContent":"Wb7RU"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/AchievementsDisabledModal/AchievementsDisabledModal.tsx






const CLOSE_BUTTON_GAMEPAD_ALIAS = 'achievements-disabled-back';
const AchievementsDisabledModal = registerModal(({
  achievementsDisabledMessages
}) => {
  const {
    t
  } = useLocalization_useLocalization('AchievementDisabledModal');
  const hideModal = useHideModal(); // If more than one setting has affected achievements, a different message should be shown to reflect this

  const achievementsDisabledMessageTranslation = (0,react_facet_src.useFacetMap)(achievementsDisabledMessage => achievementsDisabledMessage.length === 1 ? t('.oneSettingMessage') : t('.multipleSettingsMessage'), [t], [achievementsDisabledMessages]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: achievementsDisabledMessageTranslation,
    gamepadIndex: 0
  }, achievementsDisabledMessageTranslation), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: achievementsDisabledMessages,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: "achievements-disabled-back",
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButtonText'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/AchievementsDisabledModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/BehaviorPacksConfirmationModal/BehaviorPacksConfirmationModal.tsx





const CONFIRM_BUTTON_GAMEPAD_ALIAS = 'behavior-packs-modal-confirm';
const BehaviorPacksConfirmationModal = registerModal(({
  packId,
  type,
  packType,
  onAccept
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.behaviorPacksRemoveModal');
  const hideModal = useHideModal();
  const isDeactivateAction = type == 'deactivate';

  const confirmAction = () => {
    onAccept(packId, packType);
    hideModal();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CONFIRM_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: isDeactivateAction ? t('.messageDeactivate') : t('.messageActivate'),
    center: true
  }, isDeactivateAction ? t('.messageDeactivate') : t('.messageActivate'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CONFIRM_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: isDeactivateAction ? t('.keepLabel') : t('.dontAddPackLabel'),
    onClick: hideModal,
    variant: "primary"
  }, isDeactivateAction ? t('.keepLabel') : t('.dontAddPackLabel')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: isDeactivateAction ? t('.removeLabel') : t('.addPackLabel'),
    onClick: confirmAction
  }, isDeactivateAction ? t('.removeLabel') : t('.addPackLabel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/BehaviorPacksConfirmationModal/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateOnRealmsErrorModal/CreateOnRealmsErrorModal.tsx






const CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'create-on-realms-error-back';
const CreateOnRealmsErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld');
  const world = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const onClose = (0,react_facet_src.useFacetCallback)(world => () => {
    world.clearErrors();
  }, [], [world]);
  const text = (0,react_facet_src.useFacetMap)(world => {
    switch (world.createOnRealmsError) {
      case CreateOnRealmsError.UNASSIGNED_DEV_VERSION:
        return {
          title: t(`.createOnRealmsError.unassignedDevVersion.title`),
          message: t(`.createOnRealmsError.unassignedDevVersion.message`),
          message2: t(`.createOnRealmsError.unassignedDevVersion.message2`)
        };

      case CreateOnRealmsError.MEMBER_OF_TOO_MANY_REALMS:
        return {
          title: t(`.createOnRealmsError.memberOfTooManyRealms.title`),
          message: t(`.createOnRealmsError.memberOfTooManyRealms.message`),
          message2: ''
        };

      case CreateOnRealmsError.CANNOT_CONNECT_TO_REALM:
        return {
          title: t(`.createOnRealmsError.cannotConnectToRealm.title`),
          message: t(`.createOnRealmsError.cannotConnectToRealm.message`),
          message2: ''
        };

      case CreateOnRealmsError.CROSS_PLATFORM_RESTRICTED:
        return {
          title: t(`.createOnRealmsError.crossPlatformRestricted.title`),
          message: t(`.createOnRealmsError.crossPlatformRestricted.message`),
          message2: t(`.createOnRealmsError.crossPlatformRestricted.message2`)
        };

      case CreateOnRealmsError.UNKNOWN:
      default:
        return {
          title: t(`.createOnRealmsError.unknown.title`),
          message: t(`.createOnRealmsError.unknown.message`),
          message2: ''
        };
    }
  }, [t], [world]);
  const title = (0,react_facet_src.useFacetMap)(text => text.title, [], [text]);
  const message = (0,react_facet_src.useFacetMap)(text => text.message, [], [text]);
  const message2 = (0,react_facet_src.useFacetMap)(text => text.message2, [], [text]);
  const isTwoParagraphs = (0,react_facet_src.useFacetMap)(text => text.message2 != '', [], [text]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isTwoParagraphs,
    condition: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message,
    center: true
  }, message)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isTwoParagraphs,
    condition: true
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${message}. ${message2}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, message), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, message2)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CreateOnRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.createOnRealmsError.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.createOnRealmsError.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateOnRealmsErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateWorldErrorModal/CreateWorldErrorModal.tsx






const CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'create-world-error-back';
const CreateWorldErrorModal = registerModal(function () {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld');
  const onClose = (0,react_facet_src.useFacetCallback)(createNewWorld => () => {
    createNewWorld.clearErrors();
  }, [], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet)]);
  const title = t(`.createWorldError.notEnoughStorage.title`);
  const message = t(`.createWorldError.notEnoughStorage.message`);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message,
    center: true
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CreateWorldErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.createWorldError.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.createWorldError.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/CreateWorldErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LeavingCNWForMarketplaceModal/LeavingCNWForMarketplaceModal.tsx





const CANCEL_BUTTON_ALIAS = 'leaving-cnw-for-marketplace-modal-cancel';
const LeavingCNWForMarketplaceModal = registerModal(({
  onAccept
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.leavingCNWForMarketplaceModal');
  const closeModal = useHideModal();

  const closeModalAndAccept = () => {
    onAccept();
    closeModal();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Overlay, {
    onClick: closeModal
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CANCEL_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: CANCEL_BUTTON_ALIAS,
    inputLegend: t('.cancel'),
    variant: "secondary",
    onClick: closeModal
  }, t('.cancel')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.continue'),
    variant: "primary",
    onClick: closeModalAndAccept
  }, t('.continue')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LeavingCNWForMarketplaceModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/LoseYourChangesModal/LoseYourChangesModal.tsx





const CONTINUE_BUTTON_GAMEPAD_ALIAS = 'lyc-modal-continue';
const LoseYourChangesModal = registerModal(({
  onLeave
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.loseYourChangesModal');
  const closeModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CONTINUE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: CONTINUE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.continueInputLegend'),
    variant: "secondary",
    onClick: closeModal
  }, t('.continueButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.leaveInputLegend'),
    variant: "destructive",
    onClick: () => {
      closeModal();
      onLeave();
    }
  }, t('.leaveButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/MultiplayerPlatformLockedModal/MultiplayerPlatformLockedModal.tsx








const GO_BACK_BUTTON_GAMEPAD_ALIAS = 'mpl-modal-go-back';
const MultiplayerPlatformLockedModal = registerModal(({
  multiplayerData,
  activePacks,
  onDeactivatePack
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.multiplayerPlatformLockedModal');
  const hideModal = useHideModal();
  const platformLockedPacks = (0,react_facet_src.useFacetMap)(activePacks => filter(activePacks, pack => pack.isPlatformLocked), [], [activePacks]);
  const titleText = (0,react_facet_src.useFacetMap)(platformLockedPacks => platformLockedPacks.length > 1 ? t('.titlePlural') : t('.titleSingular'), [t], [platformLockedPacks]);
  const messageText = (0,react_facet_src.useFacetMap)(platformLockedPacks => {
    var _platformLockedPacks$, _platformLockedPacks$2;

    return platformLockedPacks.length > 1 ? t('.messagePlural', [slice(platformLockedPacks, 1).map(x => x.name).join(', '), (_platformLockedPacks$ = platformLockedPacks[0]) === null || _platformLockedPacks$ === void 0 ? void 0 : _platformLockedPacks$.name]) : t('.messageSingular', [(_platformLockedPacks$2 = platformLockedPacks[0]) === null || _platformLockedPacks$2 === void 0 ? void 0 : _platformLockedPacks$2.name]);
  }, [t], [platformLockedPacks]);
  const removePackButtonText = (0,react_facet_src.useFacetMap)(platformLockedPacks => platformLockedPacks.length > 1 ? t('.removeButtonPlural') : t('.removeButtonSingular'), [t], [platformLockedPacks]);
  const removePlatformLockedPacksAndActivateMultiplayer = (0,react_facet_src.useFacetCallback)((multiplayerData, platformLockedPacks) => () => {
    hideModal();

    if (onDeactivatePack) {
      platformLockedPacks.forEach(pack => onDeactivatePack(pack.id, PackType.Resource));
    }

    multiplayerData.multiplayerGame = true;
  }, [hideModal, onDeactivatePack], [multiplayerData, platformLockedPacks]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, titleText), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: messageText,
    gamepadIndex: 0
  }, messageText)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.removeInputLegend'),
    variant: "primary",
    onClick: removePlatformLockedPacksAndActivateMultiplayer
  }, removePackButtonText), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/MultiplayerPlatformLockedModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/OptBackModal/OptBackModal.tsx





const STAY_BUTTON_GAMEPAD_ALIAS = 'stay-button-alias';
const OptBackModal = registerModal(({
  optOutCallback
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.optBackModal');
  const hideModal = useHideModal();

  const optOut = () => {
    hideModal();
    optOutCallback();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: STAY_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: STAY_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.stayInputLegend'),
    variant: "primary",
    onClick: hideModal
  }, t('.stayButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.goBackInputLegend'),
    variant: "secondary",
    onClick: optOut,
    gamepadIndex: 1
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/OptBackModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDependencyWarningModal/ResourcePacksDependencyWarningModal.tsx





const ResourcePacksDependencyWarningModal_GO_BACK_BUTTON_GAMEPAD_ALIAS = 'rpl-modal-go-back';
const ResourcePacksDependencyWarningModal = registerModal(({
  onAccept
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacksDependencyWarningModal');
  const body = t('.body');
  const activatePackButton = t('.activatePackButton');
  const hideModal = useHideModal();

  const onActivatePackContinue = () => {
    hideModal();
    onAccept();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: ResourcePacksDependencyWarningModal_GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0,
    center: true
  }, body)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: ResourcePacksDependencyWarningModal_GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "primary",
    onClick: hideModal
  }, t('.goBackButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: activatePackButton,
    onClick: onActivatePackContinue
  }, activatePackButton)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDependencyWarningModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadModal/ResourcePacksDownloadModal.tsx






const ACCEPT_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-accept';
const ResourcePacksDownloadModal = registerModal(({
  worldId,
  packIds,
  packNames,
  packSizes,
  availableSize,
  onAccept
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.packDownloadModal');
  const packNamesQuoted = packNames.map(option => {
    return `"${option}"`;
  });
  const multiplePacks = packIds.length > 1;
  const body = t(multiplePacks ? '.confirmationBodyMultiple' : '.confirmationBody', [packNamesQuoted.join(', ')]);
  const bodyPackSize = t('.confirmationBodyPackSize', [packSizes]);
  const bodyAvailableSize = (0,react_facet_src.useFacetMap)(availableSize => t('.confirmationBodyAvailableSize', [availableSize]), [t], [availableSize]);
  const hideModal = useHideModal();
  const onAcceptDownload = (0,react.useCallback)(() => {
    onAccept(worldId, packIds);
    hideModal();
  }, [onAccept, hideModal, worldId, packIds]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ACCEPT_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.confirmationTitleAlt')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${bodyPackSize} . ${bodyAvailableSize}`,
    spaceBetweenParagraphs: 1,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bodyPackSize), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bodyAvailableSize))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: ACCEPT_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.confirmationDownloadButton'),
    onClick: onAcceptDownload,
    variant: "primary"
  }, t('.confirmationDownloadButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.confirmationCancelButton'),
    onClick: hideModal,
    gamepadIndex: 1
  }, t('.confirmationCancelButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadAndActivateModal/ResourcePacksDownloadAndActivateModal.tsx






const ResourcePacksDownloadAndActivateModal_ACCEPT_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-accept';
const ResourcePacksDownloadAndActivateModal = registerModal(({
  packId,
  packName,
  packSize,
  availableSize,
  onAccept
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.packDownloadModal');
  const body = (0,react_facet_src.useFacetMap)(packName => t('.confirmationBodyActivate', [packName]), [t], [packName]);
  const bodyPackSize = t('.confirmationBodyPackSize', [packSize]);
  const bodyAvailableSize = (0,react_facet_src.useFacetMap)(availableSize => t('.confirmationBodyAvailableSize', [availableSize]), [t], [availableSize]);
  const hideModal = useHideModal();
  const onAcceptDownload = (0,react_facet_src.useFacetCallback)(packName => () => {
    onAccept(packId, packName);
    hideModal();
  }, [onAccept, hideModal, packId], [packName]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ResourcePacksDownloadAndActivateModal_ACCEPT_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.confirmationTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${bodyPackSize}. ${bodyAvailableSize}`,
    spaceBetweenParagraphs: 1,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bodyPackSize), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bodyAvailableSize))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: ResourcePacksDownloadAndActivateModal_ACCEPT_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.confirmationDownloadAndActivateButton'),
    onClick: onAcceptDownload,
    variant: "primary"
  }, t('.confirmationDownloadAndActivateButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.confirmationCancelButton'),
    onClick: hideModal,
    gamepadIndex: 1
  }, t('.confirmationCancelButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadAndActivateModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadProgressModal/ResourcePacksDownloadProgressModal.tsx







const ResourcePacksDownloadProgressModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-close';
const CONTENT_GAMEPAD_ALIAS = 'rpdl-modal-content';
const ResourcePacksDownloadProgressModal = registerModal(({
  title,
  percentage,
  isImportingPack,
  onCancel = () => {}
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.packDownloadModal');
  const body = (0,react_facet_src.useFacetMap)(isImportingPack => isImportingPack ? t('.importingProgressLabel') : t('.downloadingProgressLabel'), [t], [isImportingPack]);
  const narrationEnabled = useNarrationEnabled();
  const setFocusedId = src_useSetFocusedId_useSetFocusedId(); // Move focus to the modal content when close button is hidden (if it's focusable)

  (0,react_facet_src.useFacetEffect)(isImportingPack => {
    if (isImportingPack && narrationEnabled) {
      setFocusedId(CONTENT_GAMEPAD_ALIAS);
    }
  }, [setFocusedId, narrationEnabled], [isImportingPack]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ResourcePacksDownloadProgressModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onCancel,
    closeButtonGamepadAlias: ResourcePacksDownloadProgressModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    hideCloseButton: isImportingPack
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: CONTENT_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body,
    center: true
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Progress, {
    percentage: percentage
  })));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksDownloadProgressModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksErrorModal/ResourcePacksErrorModal.tsx





const CANCEL_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-cancel'; // This modal handles possible errors while activating/deactivating packs.
// It should not be needed to check if it comes from activate or deactivate because
// they have different and separated error codes.

const ResourcePacksErrorModal = registerModal(({
  errorCode
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacks');
  const hideModal = useHideModal();
  const errorReading = errorCode === PackActionError.NoManifest || errorCode === PackActionError.MissingProperty || errorCode === PackActionError.WrongTypeProperty || errorCode === PackActionError.EmptyProperty || errorCode === PackActionError.InvalidProperty || errorCode === PackActionError.InvalidJSON || errorCode === PackActionError.MalformedPropertyUUID || errorCode === PackActionError.MalformedPropertyVERSION || errorCode === PackActionError.DuplicateUUID || errorCode === PackActionError.MissingModules || errorCode === PackActionError.MultipleModules || errorCode === PackActionError.UnsupportedFormatVersion;
  const errorTitle = errorCode === PackActionError.ContentTierIncompatible ? t('.errorIncompatibleDeviceTitle') : errorCode === PackActionError.ContentTierIncompatibleMemory ? t('.errorIncompatibleMemoryTitle') : errorCode === PackActionError.ContentTierIncompatibleRayTracing ? t('.errorIncompatibleRayTracingTitle') : errorCode === PackActionError.PackSelectErrorNoStore ? t('.errorNoStoreTitle') : errorCode === PackActionError.PackSelectErrorRequiredDependency ? t('.errorRequiredDependencyTitle') : errorCode === PackActionError.NoPackAccess ? t('.errorFileAccessTitle') : errorCode === PackActionError.VersionTooHigh ? t('.errorIncompatibleVersionTitle') : errorCode === PackActionError.VersionTooLow ? t('.errorIncompatibleVersionTitle') : errorCode === PackActionError.IncompletePack ? t('.errorIncompleteTitle') : errorCode === PackActionError.UnsupportedFileFormat ? t('.errorUnsupportedFormatTitle') : errorReading ? t('.errorReadingTitle') : t('.errorUnknownTitle');
  const errorBody = errorCode === PackActionError.ContentTierIncompatible ? t('.errorIncompatibleDeviceBody') : errorCode === PackActionError.ContentTierIncompatibleMemory ? t('.errorIncompatibleMemoryBody') : errorCode === PackActionError.ContentTierIncompatibleRayTracing ? t('.errorIncompatibleRayTracingBody') : errorCode === PackActionError.PackSelectErrorNoStore ? t('.errorNoStoreBody') : errorCode === PackActionError.PackSelectErrorRequiredDependency ? t('.errorRequiredDependencyBody') : errorCode === PackActionError.NoPackAccess ? t('.errorFileAccessBody') : errorCode === PackActionError.VersionTooHigh ? t('.errorIncompatibleVersionHighBody') : errorCode === PackActionError.VersionTooLow ? t('.errorIncompatibleVersionLowBody') : errorCode === PackActionError.IncompletePack ? t('.errorIncompleteBody') : errorCode === PackActionError.UnsupportedFileFormat ? t('.errorUnsupportedFormatBody') : errorReading ? t('.errorReadingBody') : t('.errorUnknownBody');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CANCEL_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, errorTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: errorBody
  }, errorBody)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CANCEL_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.goBackButton'),
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksPlatformLockedModal/ResourcePacksPlatformLockedModal.tsx






const ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS = 'rpl-modal-go-back';
const ResourcePacksPlatformLockedModal = registerModal(({
  multiplayerData,
  packId,
  packName,
  packSize,
  packType,
  onActivatePack
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacksPlatformLockedModal');
  const body = (0,react_facet_src.useFacetMap)(packName => t('.body', [packName]), [t], [packName]);
  const hideModal = useHideModal();

  const turnOffMultiplayerAndActivatePack = () => {
    multiplayerData.multiplayerGame = false;
    onActivatePack(packId, packType, packName, packSize);
    hideModal();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0,
    center: true
  }, body)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.removeInputLegend'),
    variant: "primary",
    onClick: turnOffMultiplayerAndActivatePack
  }, t('.turnOffMultiplayerAndApplyPackButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: ResourcePacksPlatformLockedModal_GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/ResourcePacksPlatformLockedModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/UnlockTemplateSettingsModal/UnlockTemplateSettingsModal.tsx






const UnlockTemplateSettingsModal = registerModal(({
  onUnlockTemplateSettings,
  mainButtonAlias
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld');
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const hideModal = useHideModal();

  const confirmUnlockTemplateSettings = () => {
    onUnlockTemplateSettings();
    hideModal(); // Return focus to given button

    if (mainButtonAlias != null) {
      setFocusedId(mainButtonAlias);
    }
  };

  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-keepSettings';
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.unlockSettingsModal.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.unlockSettingsModal.message'),
    gamepadIndex: 0,
    center: true
  }, t('.unlockSettingsModal.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 1
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.unlockSettingsModal.keepSettings'),
    variant: "primary",
    onClick: hideModal
  }, t('.unlockSettingsModal.keepSettings')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.unlockSettingsModal.unlock'),
    onClick: confirmUnlockTemplateSettings,
    gamepadAlias: "pop-up-modal-unlockSettings"
  }, t('.unlockSettingsModal.unlock'))))), /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: {
      button: types_ButtonType.B,
      inputLegend: t('.unlockSettingsModal.keepSettings')
    },
    onClick: hideModal
  }));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/UnlockTemplateSettingsModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/InProgressModal/InProgressModal.tsx



const InProgressModal = registerModal(({
  title,
  description
}) => {
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: description,
    gamepadIndex: 0,
    center: true
  }, description)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Modals/index.ts
















;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsSideMenu/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/Notifications.tsx















function cnwTabToUpsellTab(cnwTab) {
  var _lookup$cnwTab;

  const lookup = {
    general: TabbedUpsellScreenDefaultTab.MINECRAFT,
    'resource-packs': TabbedUpsellScreenDefaultTab.PACKS,
    cheats: TabbedUpsellScreenDefaultTab.MINECRAFT,
    experimental: TabbedUpsellScreenDefaultTab.MINECRAFT,
    multiplayer: TabbedUpsellScreenDefaultTab.MULTIPLAYER,
    advanced: TabbedUpsellScreenDefaultTab.SEEDS,
    'behavior-packs': TabbedUpsellScreenDefaultTab.PACKS
  };
  return (_lookup$cnwTab = lookup[cnwTab]) !== null && _lookup$cnwTab !== void 0 ? _lookup$cnwTab : TabbedUpsellScreenDefaultTab.MINECRAFT;
}

function Notifications_Notifications({
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  multiplayerWarningState,
  experimentsWarningEnabled,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const {
    t
  } = useLocalization_useLocalization('Notifications');
  const history = RouterEngineProvider_useRouteHistory(); // Achievements disabled or not, Edu and Editor do not currently support achievements

  const achievementsWarning = (0,react_facet_src.useFacetMap)((achievementsDisabled, isEduBuild, isInEditor) => achievementsDisabled && !isEduBuild && !isInEditor, [], [isAchievementsDisabled, (0,react_facet_src.useSharedFacet)(isEduBuildSelector), isEditorWorld]);
  const showAchievementsDisabledModal = AchievementsDisabledModal.useShowModal();

  const onShowAchievementsDisabledModal = () => showAchievementsDisabledModal({
    achievementsDisabledMessages
  }); // In trial mode or or not


  const trialModeWarning = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector); // Warning message when one or more experimental features have been enabled. If
  // the template warning is present the experimental warning should not be shown.

  const showExperimentsWarning = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate && experimentsWarningEnabled, [experimentsWarningEnabled], [isLockedTemplate]);
  const showUnlockTemplateSettingsModal = UnlockTemplateSettingsModal.useShowModal();

  const showUnlockTemplateSettingsModalCallback = () => {
    showUnlockTemplateSettingsModal({
      onUnlockTemplateSettings,
      mainButtonAlias: MAIN_BUTTON
    });
  }; // Warning messages for Multiplayer tab


  const platform = (0,react_facet_src.useFacetMap)(device => device.platform, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const multiplayerWarningMessage = (0,react_facet_src.useFacetMap)(platform => multiplayerWarningState ? getWarningMessage(multiplayerWarningState, platform, t) : '', [t, multiplayerWarningState], [platform]);
  const multiplayerWarning = (0,react_facet_src.useFacetMap)(warningMessage => warningMessage.length > 0, [], [multiplayerWarningMessage]);
  const showChangeSkinLink = (0,react_facet_src.useFacetMap)(() => multiplayerWarningState === GeneralMultiplayerWarningStateEnum.NON_MULTIPLAYER_SKIN_EQUIPPED, [multiplayerWarningState], []);
  const isStorageLowFacet = (0,react_facet_src.useFacetMap)(facet => {
    return facet.isStorageLow;
  }, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]); // If any notification is present, mount div with wrapping padding

  const shouldUsePadding = (0,react_facet_src.useFacetMap)((multiplayerWarning, achievementsWarning, isLockedTemplate, trialModeWarning, isStorageLow) => multiplayerWarning || achievementsWarning || isLockedTemplate || experimentsWarningEnabled || trialModeWarning || isStorageLow, [experimentsWarningEnabled], [multiplayerWarning, achievementsWarning, isLockedTemplate, trialModeWarning, isStorageLowFacet]);
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldUsePadding
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.notifications
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: achievementsWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "neutral100",
    gamepadIndex: 0,
    narrationId: "notifications:achievementsDisabledWarning"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: Notifications.notificationBottle,
    src: achievement_bottle_namespaceObject,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.achievementsDisabled')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: onShowAchievementsDisabledModal,
    gamepadIndex: 0
  }, t('.readMoreLink')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: trialModeWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 1,
    narrationId: "notifications:inTrialModeWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.inTrialMode')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => history.push(`/tabbed-upsell?tab=${cnwTabToUpsellTab(params.tab)}`),
    gamepadIndex: 0
  }, t('.readMoreLink')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: multiplayerWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 2,
    narrationId: "notifications:multiplayerNotificationWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, multiplayerWarningMessage), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showChangeSkinLink
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => history.push('/persona'),
    gamepadIndex: 3
  }, t('.changeSkinLink')))))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showExperimentsWarning
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 4,
    narrationId: "notifications:experimentsWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.experimentsWarning.informationMessage')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    gamepadIndex: 5,
    narrationId: "notifications:lockedTemplateWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.unlockSettingsMessage')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    gamepadIndex: 1,
    onClick: showUnlockTemplateSettingsModalCallback
  }, t('.unlockSettingsLink')))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isStorageLowFacet
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement("div", {
    className: Notifications.panelContent
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "noticeTint",
    gamepadIndex: 6,
    narrationId: "notifications:fullStorageWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.notEnoughStorage')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => history.push('/settings/storage'),
    gamepadIndex: 0
  }, t('.freeSpace'))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Notifications/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/WorldSettingsTabContainer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldSettingsTabContainer = ({"borderedContainer":"KdIrj"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/IsWorldTemplateLoadingProvider.ts


const IsWorldTemplateLoading = (0,react.createContext)((0,react_facet_src.createFacet)({
  initialValue: false
}));
const useIsWorldTemplateLoading = () => (0,react.useContext)(IsWorldTemplateLoading);
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/WorldSettingsTabContainer.tsx















function WorldSettingsTabContainer_WorldSettingsTabContainer({
  children,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  multiplayerWarningState,
  experimentsWarningEnabled,
  nestedRoutes,
  narrationText,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  var _useIsUserDragging;

  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const disableScrolling = (_useIsUserDragging = useIsUserDragging()) !== null && _useIsUserDragging !== void 0 ? _useIsUserDragging : false;
  const isActive = useRouteActive();
  const gamepadAPI = useGamepadAPI();
  const stopCheckingForScroll = (0,react_facet_src.useFacetMap)(isActive => !isActive, [], [isActive]);
  const scrollViewRef = (0,react.useRef)(null);
  const nodeIdRef = (0,react.useRef)();
  (0,react_facet_src.useFacetLayoutEffect)(active => {
    if (!active && nodeIdRef.current != null) {
      gamepadAPI === null || gamepadAPI === void 0 ? void 0 : gamepadAPI.clearRememberCache(nodeIdRef.current);
    }

    if (scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [gamepadAPI], [isActive]);
  const paused = (0,deferred_mount_dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)((parentLoading, deferring) => parentLoading || deferring || paused, [paused], [useIsWorldTemplateLoading(), (0,deferred_mount_dist.useIsDeferring)()]); // For most tabs that don't have any nested routes, we will want to fire paint
  // events as soon as the ScrollView has shown its content. However for tabs with nested routes,
  // we want to give them the control to fire the paint events; and we will instead delay those events
  // if they fire before the ScrollView has finished showing the content.

  const RenderTracker = nestedRoutes ? RenderTrackingDelay : RenderTrackingEvent_RenderTrackingEvent;
  const animationEnabled = (0,react_facet_src.useFacetUnwrap)(useScreenAnimationEnabled());
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld');
  const narrationTextPrefix = t('.tabContainerNarrationSuffix');
  const narrationTextWithPrefix = `${narrationTextPrefix}. ${narrationText}`;
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationTextWithPrefix
  }, /*#__PURE__*/react.createElement(RenderTracker, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: breakpoint !== 'desktop',
    loading: isLoading,
    disableScrolling: disableScrolling,
    innerRef: scrollViewRef,
    defaultFocusedChildBehavior: "remember",
    stopCheckingForScroll: stopCheckingForScroll,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTracker, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    }) // If animations are disabled, we don't want the transparent background as it creates a quick fade effect.
    ,
    spinnerBackgroundColor: animationEnabled === true ? undefined : '#48494A',
    nodeIdRef: nodeIdRef
  }, breakpoint === 'desktop' && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), paused ? null : /*#__PURE__*/react.createElement(Form, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: breakpoint === 'desktop' ? WorldSettingsTabContainer.borderedContainer : ''
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(Notifications_Notifications, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    multiplayerWarningState: multiplayerWarningState,
    experimentsWarningEnabled: experimentsWarningEnabled,
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  })))), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 1
    }
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true
  }, children)))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/components/WorldSettingsTabContainer/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/checkProfanity.ts
const checkProfanity = (filter, text) => {
  return filter.isProfanityInString(text);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ProfanityWarningModal/ProfanityWarningModal.tsx




const ProfanityWarningModal = registerModal(({
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('ProfanityWarningModalRoute');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: "profanity-warning-modal-button"
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.body'),
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.close'),
    variant: "primary",
    delayedClick: true,
    onClick: onClose,
    gamepadAlias: "profanity-warning-modal-button"
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ProfanityWarningModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/useOnBlurDefaultHandler.ts





const useOnBlurDefaultHandler = clearOnProfanity => {
  const profanityWarningModal = ProfanityWarningModal.useModal();
  const showProfanityWarningModal = profanityWarningModal.show;
  const handler = (0,react_facet_src.useFacetCallback)(profanityFilter => (value, setValue) => {
    const hasProfanity = checkProfanity(profanityFilter, value);

    if (hasProfanity) {
      if (clearOnProfanity) {
        setValue('');
      }

      showProfanityWarningModal();
      return TextFieldValidationResult.INVALID;
    }

    return TextFieldValidationResult.VALID;
  }, [clearOnProfanity, showProfanityWarningModal], [(0,react_facet_src.useSharedFacet)(profanityFilterFacet)]);
  return [handler, profanityWarningModal];
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/VanillaTextFieldWithButton.tsx
function VanillaTextFieldWithButton_extends() { VanillaTextFieldWithButton_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return VanillaTextFieldWithButton_extends.apply(this, arguments); }

function VanillaTextFieldWithButton_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = VanillaTextFieldWithButton_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function VanillaTextFieldWithButton_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







const VanillaTextFieldWithButton = (_ref) => {
  let {
    onBlur,
    filterProfanity = false,
    clearOnProfanity = true,
    buttonVariant = 'secondary'
  } = _ref,
      rest = VanillaTextFieldWithButton_objectWithoutProperties(_ref, ["onBlur", "filterProfanity", "clearOnProfanity", "buttonVariant"]);

  const [onBlurDefaultHandler, profanityWarningModal] = useOnBlurDefaultHandler(clearOnProfanity);
  const onBlurDecorated = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      return onBlur(value, setValue, checkProfanity);
    } else if (filterProfanity) {
      return onBlurDefaultHandler(value, setValue);
    }
  }, [onBlur, onBlurDefaultHandler, filterProfanity]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(TextField_TextField.WithButton, VanillaTextFieldWithButton_extends({}, rest, {
    onBlur: onBlurDecorated,
    buttonVariant: buttonVariant
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: profanityWarningModal.isVisible
  }, /*#__PURE__*/react.createElement(ProfanityWarningModal.Component, {
    onClose: profanityWarningModal.hide
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/VanillaTextField.tsx
function VanillaTextField_extends() { VanillaTextField_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return VanillaTextField_extends.apply(this, arguments); }

function VanillaTextField_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = VanillaTextField_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function VanillaTextField_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







 // This component adds a profanity filter to the TextField component, which is a functionality used only by vanilla at the moment.
// If the profanity at a later stage will be used by more games we should move this component to a common package (not @mojang/ui though).

const VanillaTextField_VanillaTextField = (_ref) => {
  let {
    onBlur,
    filterProfanity = false,
    clearOnProfanity = true
  } = _ref,
      rest = VanillaTextField_objectWithoutProperties(_ref, ["onBlur", "filterProfanity", "clearOnProfanity"]);

  const [onBlurDefaultHandler, profanityWarningModal] = useOnBlurDefaultHandler(clearOnProfanity);
  const onBlurDecorated = (0,react.useCallback)((value, setValue) => {
    if (onBlur != null) {
      return onBlur(value, setValue, checkProfanity);
    } else if (filterProfanity) {
      return onBlurDefaultHandler(value, setValue);
    }
  }, [onBlur, onBlurDefaultHandler, filterProfanity]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(TextField_TextField, VanillaTextField_extends({}, rest, {
    onBlur: onBlurDecorated
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: profanityWarningModal.isVisible
  }, /*#__PURE__*/react.createElement(ProfanityWarningModal.Component, {
    onClose: profanityWarningModal.hide
  })));
};
VanillaTextField_VanillaTextField.WithButton = VanillaTextFieldWithButton;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/VanillaTextField/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/hooks/useWorldID.ts

 // grabs and decodes the world ID from the route URL

function useWorldID() {
  const params = hooks_useRouteParams();
  const worldIdDecoded = (0,react_facet_src.useFacetMap)(params => params.id != null ? decodeURIComponent(params.id) : null, [], [params]);
  return worldIdDecoded;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/external-link.png
const external_link_namespaceObject = __webpack_require__.p + "assets/external-link-b22bb.png";
;// CONCATENATED MODULE: ./packages/react-device-information/src/consoles.ts

const consoles_isPlaystationPlatform = platform => platform === Platform.PS4 || platform === Platform.PS5;
const isXboxPlatform = platform => platform === Platform.XBOX;
const consoles_isNintendoPlatform = platform => platform === Platform.NX_HANDHELD || platform === Platform.NX_TV;
const isConsolePlatform = platform => isXboxPlatform(platform) || //
consoles_isNintendoPlatform(platform) || //
consoles_isPlaystationPlatform(platform);
const isWindowsPlatform = platform => platform === Platform.WIN32 || platform === Platform.UWP;
const isTouchscreenPlatform = input => input.indexOf(types_InputMethod.TOUCH) !== -1;
const isBrowserSupportedPlatform = platform => platform === Platform.GOOGLE || platform === Platform.IOS || platform === Platform.MACOS || platform === Platform.UWP || platform === Platform.WIN32 || platform === Platform.XBOX;
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ExportingWorldModal/ExportingWorldModal.tsx




const ExportingWorldModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld.exportingWorldModal');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.content'),
    gamepadIndex: 0
  }, t('.content'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ErrorModal/ErrorModal.tsx




const ERROR_CONTINUE = 'error-modal-continue';
const ErrorModal = registerModal(({
  title,
  description
}) => {
  const {
    t
  } = useLocalization_useLocalization('Vanilla.ErrorModal');
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: ERROR_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: description,
    gamepadIndex: 0,
    center: true
  }, description)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: ERROR_CONTINUE,
    inputLegend: t('.closeButton'),
    variant: "secondary",
    onClick: hideModal
  }, t('.closeButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ClearPlayerDataErrorModal/ClearPlayerDataErrorModal.tsx



const ClearPlayerDataErrorModal = () => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld');
  return /*#__PURE__*/react.createElement(ErrorModal.Component, {
    title: t('.clearPlayerDataErrorModal.title'),
    description: t('.clearPlayerDataErrorModal.description')
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useEditWorldData.tsx


function useEditWorldData() {
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldData = (0,react_facet_src.useFacetMap)(facet => facet.worldData, [], [worldEditorSharedFacet]);
  const advancedData = (0,react_facet_src.useFacetMap)(worldData => worldData.advanced, [], [worldData]);
  const cheatsData = (0,react_facet_src.useFacetMap)(worldData => worldData.cheats, [], [worldData]);
  const generalData = (0,react_facet_src.useFacetMap)(worldData => worldData.general, [], [worldData]);
  const experimentsData = (0,react_facet_src.useFacetMap)(worldData => worldData.betaFeatures, [], [worldData]);
  const multiplayerData = (0,react_facet_src.useFacetMap)(worldData => worldData.multiplayer, [], [worldData]);
  return {
    advancedData,
    cheatsData,
    generalData,
    experimentsData,
    multiplayerData
  };
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useEditWorldSummaryData.tsx



function useEditWorldSummaryData() {
  const worldId = useWorldID();
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldSummary = (0,react_facet_src.useFacetMap)((facet, worldId) => worldId != null ? facet.worldSummary : undefined, [], [worldEditorSharedFacet, worldId]);
  return worldSummary;
}
;// CONCATENATED MODULE: ./packages/react-facet/src/useFacetCoroutine/useFacetCoroutine.ts

/**
 * Represents the state of a facet method execution.
 *
 * A facet that has a method that should be possible to sequence using
 * `useFacetCoroutine` should expose a corresponding progress property of this
 * type that is updated by the facet when the method is running.
 *
 * example:
 * ```
 * type NetworkFacet = {
 *  uploadToServer(): void
 *  uploadToServerProgress: FacetTaskProgress
 * }
 * ```
 */

let FacetTaskProgress;
/**
 * Creates a callback that depends on the value of a facet and that can execute
 * an effect in several steps. An extension of the `useFacetCallback` hook
 *
 * @param callback generator function that should yield the progress properties of methods that should be sequenced
 * @param dependencies variable used by the callback that are available in scope (similar as dependencies of useCallback)
 * @param facets facets that the callback listens to
 *
 * Each step in the callback should be separated with a `yield` that returns the
 * progress-property corresponding to the facet method called in that step.
 *
 * The hook will then resume the callback when that property changes from
 * FacetTaskProgress.RUNNING to FacetTaskProgress.DONE, or abort if it changes
 * to any other state.
 *
 * Before calling the `starter` function returned from the hook, the caller MUST
 * check that all facet methods are NOT running, as starting the coroutine while
 * the facet methods are already running is undefined behavior.
 *
 * Checking that the `starter` is blocked can be done with the helper hook
 * `useFacetCoroutineIsBlocked`.
 *
 * ```
 *  const fooProgress = useFacetMap((facetA) => facetA.fooProgress, [], [facetA])
 *  const barProgress = useFacetMap((facetB) => facetB.barProgress, [], [facetB])
 *  const fooThenBarBlocked = useFacetCoroutineIsBlocked([fooProgress, barProgress])
 *	const fooThenBar = useFacetCoroutine(
 *		(facetA, facetB) =>
 *			function* (x: number, y: number) {
 *				facetA.foo(x)
 *				yield fooProgress
 *
 *				facetB.bar(y)
 *				yield barProgress
 *
 *				console.log('done!')
 *			},
 *		[fooProgress, barProgress],
 *		[facetA, facetB],
 *	)
 *
 *  return (
 *    <Button inputLegend={false} disabled={fooThenBarBlocked} onClick={() => fooThenBar(1,2)}>
 *      Press me!
 *    </Button>
 *  )
 * ```
 */

(function (FacetTaskProgress) {
  FacetTaskProgress[FacetTaskProgress["IDLE"] = 0] = "IDLE";
  FacetTaskProgress[FacetTaskProgress["RUNNING"] = 1] = "RUNNING";
  FacetTaskProgress[FacetTaskProgress["DONE"] = 2] = "DONE";
  FacetTaskProgress[FacetTaskProgress["CANCELLED"] = 3] = "CANCELLED";
  FacetTaskProgress[FacetTaskProgress["FAILED"] = 4] = "FAILED";
})(FacetTaskProgress || (FacetTaskProgress = {}));

function useFacetCoroutine(callback, dependencies, facets) {
  const [alreadyRunning, setAlreadyRunning] = (0,dist.useFacetState)(false);
  const getGenerator = (0,dist.useFacetCallback)(callback, [callback, ...dependencies], [...facets]);
  const starter = (0,dist.useFacetCallback)(alreadyRunning => (...args) => {
    if (alreadyRunning) return; // promise that resolves when `progress` switches from RUNNING to any other state

    const monitorProgress = progress => {
      return asPromise(mapFacetsLightweightTyped([progress], progress => {
        if (progress == FacetTaskProgress.RUNNING) {
          return dist.NO_VALUE;
        }

        return progress;
      }));
    };

    const runner = async (...args) => {
      setAlreadyRunning(true);
      const coroutine = getGenerator(...args);
      if (coroutine === dist.NO_VALUE) return;

      for (const task of coroutine) {
        const result = await monitorProgress(task);

        if (result != FacetTaskProgress.DONE) {
          break;
        }
      }

      setAlreadyRunning(false);
    };

    runner(...args);
  }, [getGenerator, setAlreadyRunning], [alreadyRunning]);
  return starter;
}
/**
 * Helper function for checking that a group of facet methods are not running
 */

function useFacetCoroutineIsBlocked(progresses) {
  return useFacetMap((...progresses) => progresses.some(progress => progress == FacetTaskProgress.RUNNING), [], [...progresses]);
} // This definition borrowed from the "Update to React 18" ore-ui PR
// https://github.com/Mojang/ore-ui/pull/59
//
// TODO: Remove this in favor of the ore-ui package definition once the above PR
// has been merged.

const asPromise = facet => new Promise(resolve => {
  const value = facet.get();

  if (value != dist.NO_VALUE) {
    resolve(value);
    return;
  }

  const cleanup = facet.observe(value => {
    resolve(value);
    cleanup();
  });
}); // Hack around the lack of proper typing in mapFacetsLightweight

function mapFacetsLightweightTyped(facets, fn, equalityCheck) {
  return (0,dist.mapFacetsLightweight)(facets, fn, equalityCheck);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useUploadRealmCompleted.ts



const useUploadRealmCompleted = () => {
  const realmWorldUploaderSharedFacet = (0,react_facet_src.useSharedFacet)(realmWorldUploaderFacet);
  const historyAPI = hooks_useRouterAPI();
  return (0,react_facet_src.useFacetEffect)(realmWorldUploaderFacet => {
    if (realmWorldUploaderFacet.uploadRealmWorldTaskStatus !== FacetTaskProgress.RUNNING && realmWorldUploaderFacet.uploadRealmWorldTaskStatus !== FacetTaskProgress.IDLE) {
      if (realmWorldUploaderFacet.uploadRealmWorldError != null) {
        realmWorldUploaderFacet.clearUploadRealmWorldState();
        historyAPI.goBack();
      }
    }
  }, [historyAPI], [realmWorldUploaderSharedFacet]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useNotifyAfterExported.ts



const useNotifyAfterExported = () => {
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const {
    t
  } = useLocalization_useLocalization('EditWorld');
  /**
   * This will be executed when the world was exported successfully
   *
   * Dependencies:
   * @t: translations method
   * @clearExport: callback to clear export state
   * Facets:
   * @worldOperationSharedFacet: world operations facet
   * @notificationsSharedFacet: facet used to show the toast
   *
   */

  (0,react_facet_src.useFacetEffect)((facet, notificationsSharedFacet) => {
    const exportResult = facet.exportWorldResult;

    if (exportResult === ExportWorldResult.Ok) {
      notificationsSharedFacet.queueSnackbar(t('.notificationToasts.exported'));
      facet.clearExportWorldState();
    }
  }, [t], [worldOperationSharedFacet, notificationsSharedFacet]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useNotifyAfterPlayerDataCleared.ts



const useNotifyAfterPlayerDataCleared = () => {
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const {
    t
  } = useLocalization_useLocalization('EditWorld');
  (0,react_facet_src.useFacetEffect)((worldOperationsFacet, notifyFacet) => {
    if (worldOperationsFacet.clearPlayerDataStatus === FacetTaskProgress.DONE) {
      notifyFacet.queueSnackbar(t('.clearPlayerDataToast'));
      worldOperationsFacet.resetClearPlayerData();
    }
  }, [t], [worldOperationSharedFacet, notificationsSharedFacet]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/useToggleBackButton.ts



const useToggleBackButton = () => {
  const [backButtonDisabled, setBackButtonDisabled] = (0,react.useState)(false);
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  (0,react_facet_src.useFacetEffect)((worldEditorFacet, worldOperationFacet) => {
    if (worldOperationFacet.duplicateWorldError != null || worldEditorFacet.saveLocalWorldError != null) {
      setBackButtonDisabled(false);
    }
  }, [setBackButtonDisabled], [worldEditorSharedFacet, worldOperationSharedFacet]);
  return [backButtonDisabled, setBackButtonDisabled];
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/hooks/index.ts






;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/DuplicatingWorldModal/DuplicatingWorldModal.tsx








function DuplicatingWorldModal_noop() {}

const DuplicatingWorldModal = registerModal(() => {
  const {
    generalData
  } = useEditWorldData();
  const worldName = (0,react_facet_src.useFacetMap)(facet => facet.worldName, [], [generalData]);
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.duplicateWorld');
  const header = (0,react_facet_src.useFacetMap)(worldName => t('.header', [worldName]), [t], [worldName]);
  const FOCUS_ALIAS_CONTENT = 'duplicate-world-spinner-modal-content-focus';
  const FOCUS_ALIAS_CLOSE = 'duplicate-world-spinner-modal-close-focus'; // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the progress content and narrate that.

  const onClose = useNarrationEnabled() ? undefined : DuplicatingWorldModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, header), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/DeletePlayerDataModal/DeletePlayerDataModal.tsx





const DeletePlayerDataModal = registerModal(({
  clearAll,
  clearAllButLocalUser
}) => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld.clearPlayerDataModal');
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.descriptionOne'),
    center: true
  }, t('.descriptionOne')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 1,
    narrationText: t('.descriptionTwo'),
    center: true
  }, t('.descriptionTwo'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.allButton'),
    onClick: clearAll
  }, t('.allButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.keepButton'),
    onClick: clearAllButLocalUser
  }, t('.keepButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ClearingPlayerDataModal/ClearingPlayerDataModal.tsx



const ClearingPlayerDataModal = () => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld');
  return /*#__PURE__*/react.createElement(InProgressModal.Component, {
    title: t('.clearingPlayerDataModal.title'),
    description: t('.clearingPlayerDataModal.description')
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/DeleteWorldModal/DeleteWorldModal.tsx





const DELETE_WORLD_CONTINUE = 'lyc-modal-continue';
const DeleteWorldModal = registerModal(({
  deleteWorld,
  closeModal
}) => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.deleteWorldModal');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: closeModal,
    defaultFocusAlias: DELETE_WORLD_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: DELETE_WORLD_CONTINUE,
    inputLegend: t('.continueInputLegend'),
    variant: "secondary",
    onClick: closeModal
  }, t('.continueButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.deleteInputLegend'),
    variant: "destructive",
    onClick: deleteWorld
  }, t('.deleteButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/EditWorldErrorModal/EditWorldErrorModal.tsx








const EDIT_WORLD_ERROR_CONTINUE = 'lyc-modal-continue';
const EditWorldErrorModal = registerModal(() => {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.editWorldErrorModal');
  const worldEditor = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldOperations = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const worldId = useWorldID();
  const readError = (0,react_facet_src.useFacetMap)((facet, worldId) => {
    if (worldId != null) {
      return facet.loadWorld(worldId);
    }
  }, [], [worldEditor, worldId]);
  const writeError = (0,react_facet_src.useFacetMap)((facet, worldOperations) => {
    return worldOperations.duplicateWorldError || facet.saveLocalWorldError;
  }, [], [worldEditor, worldOperations]);
  const showModal = (0,react_facet_src.useFacetMap)((readError, writeError) => readError != null || writeError != null, [], [readError, writeError]);
  const errorType = (0,react_facet_src.useFacetMap)((readError, writeError, showModal) => {
    if (!showModal) {
      return null;
    }

    switch (readError) {
      case ReadWorldError.IncorrectWorldId:
      case ReadWorldError.UnexpectedError:
        return 'unexpected';
    }

    switch (writeError) {
      case WriteWorldError.IncorrectWorldId:
      case WriteWorldError.UnableToCreateWorldDirectoryPath:
        return 'unexpected';

      case WriteWorldError.InsufficientDiskSpace:
        return 'storage';
    }
  }, [], [readError, writeError, showModal]);
  const errorMessageTitle = (0,react_facet_src.useFacetMap)(facet => {
    return facet === 'storage' ? t('.storageError.title') : t('.unexpectedError.title');
  }, [t], [errorType]);
  const errorMessageDescription = (0,react_facet_src.useFacetMap)(facet => {
    return facet === 'storage' ? t('.storageError.description') : t('.unexpectedError.description');
  }, [t], [errorType]);
  const editWorldErrorModalClose = (0,react_facet_src.useFacetCallback)((facet, worldOperations, readError) => () => {
    if (readError != null) {
      historyAPI.goBack();
    } else if (worldOperations.duplicateWorldError != null) {
      worldOperations.clearDuplicateWorld();
    } else if (facet.saveLocalWorldError != null) {
      facet.clearSaveLocalWorld();
    }
  }, [historyAPI], [worldEditor, worldOperations, readError]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: editWorldErrorModalClose,
    defaultFocusAlias: EDIT_WORLD_ERROR_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: editWorldErrorModalClose
  }, errorMessageTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: errorMessageDescription,
    gamepadIndex: 0,
    center: true
  }, errorMessageDescription)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: EDIT_WORLD_ERROR_CONTINUE,
    inputLegend: t('.closeButton'),
    variant: "secondary",
    onClick: editWorldErrorModalClose
  }, t('.closeButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ExportErrorModal/ExportErrorModal.tsx






const EXPORT_ERROR_CONTINUE = 'export-error-modal-continue';
const ExportErrorModal = registerModal(() => {
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.editWorldErrorModal');
  const {
    t: t2
  } = useLocalization_useLocalization('CreateNewWorld');
  const {
    t: t3
  } = useLocalization_useLocalization('EditWorld');
  const errorMessageTitle = (0,react_facet_src.useFacetMap)(facet => {
    switch (facet.exportWorldResult) {
      case ExportWorldResult.NeedToRemoveVRHeadset:
        return t3('.exportWorldErrorModal.vrErrorTitle');

      case ExportWorldResult.NoFile:
        return t2('.editWorldErrorModal.noFileError.title');

      default:
        return t2('.editWorldErrorModal.unexpectedError.title');
    }
  }, [t2, t3], [worldOperationSharedFacet]);
  const errorMessageDescription = (0,react_facet_src.useFacetMap)(facet => {
    switch (facet.exportWorldResult) {
      case ExportWorldResult.NeedToRemoveVRHeadset:
        return t3('.exportWorldErrorModal.vrErrorMessage');

      case ExportWorldResult.NoFile:
        return t2('.editWorldErrorModal.noFileError.description');

      default:
        return t2('.editWorldErrorModal.unexpectedError.description');
    }
  }, [t2, t3], [worldOperationSharedFacet]);
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: EXPORT_ERROR_CONTINUE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, errorMessageTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: errorMessageDescription,
    gamepadIndex: 0,
    center: true
  }, errorMessageDescription)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: EXPORT_ERROR_CONTINUE,
    inputLegend: t('.closeButton'),
    variant: "secondary",
    onClick: hideModal
  }, t('.closeButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/SavingWorldModal/SavingWorldModal.tsx




const SavingWorldModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.savingWorldModal');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ResourcePacksDownloadErrorModal/ResourcePacksDownloadErrorModal.tsx






const ResourcePacksDownloadErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS = 'rpdl-modal-cancel';
const ResourcePacksDownloadErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacks');
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const errorCode = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadError, [], [worldPackagesSharedFacet]);
  const onClose = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.cancelPackDownload();
  }, [], [worldPackagesSharedFacet]);
  const errorTitle = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateNoInternetTitle') : errorCode === PackDownloadError.NoInternet ? t('.downloadNoInternetTitle') : errorCode === PackDownloadError.HasPerformanceIssues ? t('.incompatibleTitle') : t('.unspecifiedErrorTitle'), [t], [errorCode]);
  const errorBody = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateNoInternetMsg') : errorCode === PackDownloadError.NoInternet ? t('.connectionFailedBody') : errorCode === PackDownloadError.HasPerformanceIssues ? t('.incompatibleBody') : t('.unspecifiedErrorBody'), [t], [errorCode]);
  const errorBodyExtra = (0,react_facet_src.useFacetMap)(errorCode => errorCode === PackDownloadError.MissingDlcWorldTemplate ? t('.downloadWorldTemplateMsgRemovePacks') : '', [t], [errorCode]);
  const isMissingDLC = (0,react_facet_src.useFacetUnwrap)(errorCode) !== PackDownloadError.MissingDlcWorldTemplate;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ResourcePacksDownloadErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, errorTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: errorBody,
    center: isMissingDLC
  }, errorBody), isMissingDLC && /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 1,
    narrationText: errorBodyExtra,
    center: true
  }, errorBodyExtra)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: ResourcePacksDownloadErrorModal_CANCEL_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.goBackButton'),
    onClick: onClose
  }, t('.goBackButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/ResourcePacksDownloadErrorModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/index.ts










;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/GeneralTab.tsx
function GeneralTab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function GeneralTab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { GeneralTab_ownKeys(Object(source), true).forEach(function (key) { GeneralTab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { GeneralTab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function GeneralTab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















function GeneralTab({
  isLockedTemplate,
  generalData,
  isUsingTemplate,
  worldSummary,
  isEditorWorld,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  onDuplicateWorld,
  onDeleteWorld,
  onExportWorld,
  onOptOut
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.general');
  const {
    t: tSideMenu
  } = useLocalization_useLocalization('CreateNewWorldSideMenu');
  const editorLocalizationTag = (0,react_facet_src.useFacetUnwrap)(isEditorWorld) == true ? '.editor' : '';
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const webBrowserSharedFacet = (0,react_facet_src.useSharedFacet)(webBrowserFacet);
  const screenTechStackSharedFacet = (0,react_facet_src.useSharedFacet)(screenTechStackFacet);
  const showOptBackModal = OptBackModal.useShowModal();
  const worldId = useWorldID();
  const optOut = (0,react_facet_src.useFacetCallback)((screenTechStack, worldId) => () => {
    if (worldId != null) {
      if (onOptOut != null) {
        onOptOut();
      }

      screenTechStack.selectTechStackForScreen(ScreenName.EditWorldScreen, UITechStack.JsonUI);
    }
  }, [onOptOut], [screenTechStackSharedFacet, worldId]);
  const openFeedbackPage = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    webBrowser.openLink(WebBrowserLink.EditWorldScreenFeedbackPage);
  }, [], [webBrowserSharedFacet]);
  const worldNameValue = (0,react_facet_src.useFacetMap)(facet => facet.worldName, [], [generalData]);
  const worldNameCallback = (0,react_facet_src.useFacetCallback)(facet => newValue => facet.worldName = newValue, [], [generalData]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    narrationText: tSideMenu('.generalTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, editingWorld && /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "first",
    title: t('.designPreviewTitle'),
    description: t('.designPreviewDescription'),
    buttons: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.designPreviewInputLegend'),
      horizontal: true,
      onClick: openFeedbackPage,
      imgSrc: external_link_namespaceObject,
      gamepadIndex: 0
    }, t('.feedbackButton')), /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.designPreviewInputLegend'),
      horizontal: true,
      onClick: () => showOptBackModal({
        optOutCallback: optOut
      }),
      gamepadIndex: 1
    }, t('.optOutButton')))
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.projectHeader')
  }))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField, {
    label: t(`${editorLocalizationTag}.worldNameTitle`),
    gamepadIndex: 1,
    placeholder: t(`${editorLocalizationTag}.worldNamePlaceholder`) // Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.
    ,
    maxLength: 30,
    value: worldNameValue,
    onChange: worldNameCallback,
    filterProfanity: true,
    disabled: isLockedTemplate
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.exportSettingsHeader'),
    description: t('.exportSettingsDescription')
  }))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(GameModeToggles, {
    isLockedTemplate: isLockedTemplate,
    generalData: generalData,
    isUsingTemplate: isUsingTemplate,
    achievementsDisabledMessages: achievementsDisabledMessages
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DifficultyToggles, {
    isLockedTemplate: isLockedTemplate,
    generalData: generalData
  })), editingWorld && worldSummary != null && /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(FileManagementButtons, {
    worldSummary: worldSummary,
    onDuplicateWorld: onDuplicateWorld,
    onDeleteWorld: onDeleteWorld,
    onExportWorld: onExportWorld
  }))));
}

function DifficultyToggles({
  generalData,
  isLockedTemplate
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.general');
  const notifyDeferredRendererMountComplete = (0,deferred_mount_dist.useNotifyMountComplete)();
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: notifyDeferredRendererMountComplete,
    title: t('.difficultyTitle'),
    disabled: isLockedTemplate,
    gamepad: {
      index: 3
    },
    options: [{
      label: t('.difficultyPeacefulLabel'),
      description: t('.difficultyPeacefulDescription'),
      value: DifficultyEnum.PEACEFUL
    }, {
      label: t('.difficultyEasyLabel'),
      description: t('.difficultyEasyDescription'),
      value: DifficultyEnum.EASY
    }, {
      label: t('.difficultyNormalLabel'),
      description: t('.difficultyNormalDescription'),
      value: DifficultyEnum.NORMAL
    }, {
      label: t('.difficultyHardLabel'),
      description: t('.difficultyHardDescription'),
      value: DifficultyEnum.HARD
    }],
    value: (0,react_facet_src.useFacetMap)(facet => facet.difficulty, [], [generalData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.difficulty = newValue;
    }, [], [generalData])
  });
}

function GameModeToggles({
  generalData,
  isLockedTemplate,
  isUsingTemplate,
  achievementsDisabledMessages
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.general');
  const {
    t: a
  } = useLocalization_useLocalization('CreateNewWorld.all');
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const togglesDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const gameModes = (0,react_facet_src.useFacetMap)((achievementsDisabledMessages, isUsingTemplate) => {
    const modes = [GeneralTab_objectSpread({
      label: t('.gameModeSurvivalLabel'),
      description: t('.gameModeSurvivalDescription'),
      value: GameMode.SURVIVAL
    }, achievementsDisabledMessages.length === 1 // This makes the narrationSuffix optional (and not string | undefined).
    ? {
      narrationSuffix: a('.narrationSuffixEnablesAchievements')
    } : {}), {
      label: t('.gameModeCreativeLabel'),
      description: t('.gameModeCreativeDescription'),
      value: GameMode.CREATIVE,
      narrationSuffix: a('.narrationSuffixDisablesAchievements')
    }];

    if (editingWorld || isUsingTemplate) {
      modes.push(GeneralTab_objectSpread({
        label: t('.gameModeAdventureLabel'),
        description: isUsingTemplate ? t('.gameModeAdventureTemplateDescription') : t('.gameModeAdventureDescription'),
        value: GameMode.ADVENTURE
      }, achievementsDisabledMessages.length === 1 // This makes the narrationSuffix optional (and not string | undefined).
      ? {
        narrationSuffix: a('.narrationSuffixEnablesAchievements')
      } : {}));
    }

    return modes;
  }, [t, a, editingWorld], [achievementsDisabledMessages, isUsingTemplate]);
  const notifyDeferredRendererMountComplete = (0,deferred_mount_dist.useNotifyMountComplete)();
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    title: t('.gameModeTitle'),
    gamepad: {
      index: 2
    },
    disabled: togglesDisabled,
    options: gameModes,
    onMountComplete: notifyDeferredRendererMountComplete,
    value: (0,react_facet_src.useFacetMap)(facet => facet.gameMode, [], [generalData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.gameMode = newValue;
    }, [], [generalData])
  });
}

function FileManagementButtons({
  worldSummary,
  onDuplicateWorld,
  onDeleteWorld,
  onExportWorld
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.general');
  const fileInfo = (0,react_facet_src.useFacetMap)(worldSummary => {
    var _worldSummary$fileSiz, _worldSummary$lastPla;

    const fileSize = (_worldSummary$fileSiz = worldSummary === null || worldSummary === void 0 ? void 0 : worldSummary.fileSize) !== null && _worldSummary$fileSiz !== void 0 ? _worldSummary$fileSiz : '-';
    const date = (_worldSummary$lastPla = worldSummary === null || worldSummary === void 0 ? void 0 : worldSummary.lastPlayed) !== null && _worldSummary$lastPla !== void 0 ? _worldSummary$lastPla : '-';
    return t('.fileDetails', [fileSize, date]);
  }, [t], [worldSummary]);
  const fileManagementNarrationText = (0,react_facet_src.useFacetMap)(fileInfo => [t('.fileManagementTitle'), t('.fileManagement.narrationComponentTypeSectionHeader'), fileInfo].join(' . '), [t], [fileInfo]);
  const openDeleteWorldModal = DeleteWorldModal.useShowModal();
  const closeModal = useHideModal();
  const deleteWorld = (0,react.useCallback)(() => {
    if (onDeleteWorld != null) {
      onDeleteWorld();
      closeModal();
    }
  }, [onDeleteWorld, closeModal]);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const isWindowsPlatformFacet = (0,react_facet_src.useFacetMap)(facet => isWindowsPlatform(facet.platform), [], [deviceInformation]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: fileManagementNarrationText
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 5
    }
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.fileManagementTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      flexDirection: 'row'
    }
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    gamepadIndex: 0,
    onClick: onDuplicateWorld,
    inputLegend: t('.fileManagementDuplicateWorldLabel'),
    autofocus: true,
    horizontal: true
  }, t('.fileManagementDuplicateWorldLabel')), /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "destructive",
    gamepadIndex: 1,
    onClick: () => openDeleteWorldModal({
      deleteWorld: deleteWorld,
      closeModal: closeModal
    }),
    inputLegend: t('.fileManagementDeleteWorldLabel'),
    autofocus: true,
    horizontal: true
  }, t('.fileManagementDeleteWorldLabel'))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isWindowsPlatformFacet
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    style: {
      flexDirection: 'row'
    }
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    gamepadIndex: 2,
    onClick: onExportWorld,
    inputLegend: t('.fileManagementExportWorldLabel'),
    autofocus: true,
    horizontal: true
  }, t('.fileManagementExportWorldLabel'))))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, fileInfo), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Switch_Switch = ({"Switch":"BMKqH","context":"_8UmaI"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSwitch/BaseSwitch.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BaseSwitch = ({"BaseSwitch":"A9D4z","toggle":"e7MoW","imageOn":"bgIQq","disabled":"p_TUt","imageOff":"R_YeG","toggleContainerBorder":"qxKas","toggleBase":"XjUWP","toggleBaseItem":"gMVJP","toggleTop":"RS5ul","toggleTopInner":"fr1iK","toggleTopTop":"aVlBS","toggleTopBottomBevel":"xqZlc","toggleTopOn":"KjBRi","toggleTopOff":"IxVml","toggleTopOnAnimated":"moANc","toggleTopOffAnimated":"FVcXO","switch-toggle-top-animation-on":"shenE","switch-toggle-top-animation-off":"kEW1j","offText":"pqxNj","onText":"ldgdO","toggleLabel":"SWTSF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/images/onImage.png
const onImage_namespaceObject = __webpack_require__.p + "assets/onImage-b40d0.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/IconOn.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconOn = ({"iconOn":"R3e0Q"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOn/IconOn.tsx
function IconOn_extends() { IconOn_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconOn_extends.apply(this, arguments); }

function IconOn_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconOn_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconOn_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconOn_IconOn = (_ref) => {
  let {
    className
  } = _ref,
      props = IconOn_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconOn.iconOn, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconOn_extends({}, props, {
    className: classNames,
    src: onImage_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/images/offImage.png
const offImage_namespaceObject = __webpack_require__.p + "assets/offImage-cc909.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/IconOff.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconOff = ({"iconOff":"i0_sF"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconOff/IconOff.tsx
function IconOff_extends() { IconOff_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconOff_extends.apply(this, arguments); }

function IconOff_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconOff_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconOff_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconOff_IconOff = (_ref) => {
  let {
    className
  } = _ref,
      props = IconOff_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconOff.iconOff, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconOff_extends({}, props, {
    className: classNames,
    src: offImage_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-internal/src/BaseSwitch/BaseSwitch.tsx












const getToggleTopClasses = (value, shouldAnimate) => classnames_default()(BaseSwitch.toggleTop, {
  [shouldAnimate ? BaseSwitch.toggleTopOnAnimated : BaseSwitch.toggleTopOn]: value,
  [shouldAnimate ? BaseSwitch.toggleTopOffAnimated : BaseSwitch.toggleTopOff]: !value
});

function BaseSwitch_BaseSwitch({
  onChange,
  gamepad,
  value,
  disabled = false,
  onFocusChanged,
  showOnOffText = false,
  shouldAnimateRef,
  soundEffectHovered,
  soundEffectFocused,
  soundEffectPressed,
  offNarrationText: offNarration,
  onNarrationText: onNarration,
  disabledNarrationSuffix,
  onRole = 'primary',
  offRole = 'neutral50',
  thumbRole = 'secondary'
}) {
  var _gamepad$index;

  const {
    t
  } = useLocalization_useLocalization('BaseSwitch');
  const semanticColorsInherited = hooks_useSemanticColors('inherit');
  const semanticColorsThumb = hooks_useSemanticColors(thumbRole);
  const semanticColorsOn = hooks_useSemanticColors(onRole);
  const semanticColorsOff = hooks_useSemanticColors(offRole);
  const semanticSounds = useSemanticSounds('inherit');
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const internalShouldAnimateRef = (0,react.useRef)(false);
  const finalShouldAnimateRef = shouldAnimateRef !== null && shouldAnimateRef !== void 0 ? shouldAnimateRef : internalShouldAnimateRef;
  const toggleTopRef = (0,react.useRef)(null);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value); // We use this to delay the rendering until we have a value. Otherwise, we can't know if
  // the switch should be on or off. That can potentially cause a flicker.

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [valueFacet]); // We run this effect to apply the correct classes

  (0,react_facet_src.useFacetEffect)(value => {
    if (toggleTopRef.current) {
      var _finalShouldAnimateRe;

      toggleTopRef.current.className = getToggleTopClasses(value, (_finalShouldAnimateRe = finalShouldAnimateRef.current) !== null && _finalShouldAnimateRe !== void 0 ? _finalShouldAnimateRe : false);
    }
  }, [finalShouldAnimateRef], [valueFacet]); // The `onClick` handler, that is defined a couple of lines below, is going to add the
  // class that makes the transition between *on* and *off* states animate. We want to
  // remove these classes after - so that they only occur on user interaction. Otherwise,
  // they could get triggered by a parent component that switches from display:none

  const onAnimationEnd = (0,react_facet_src.useFacetCallback)((value, offNarration, onNarration) => () => {
    if (toggleTopRef.current) {
      toggleTopRef.current.className = getToggleTopClasses(value, false); // We are doing the narration here because we could have validation that is happening in the onChange handler.

      narrateText(value ? [t('.on'), onNarration !== null && onNarration !== void 0 ? onNarration : ''].join(' . ') : [t('.off'), offNarration !== null && offNarration !== void 0 ? offNarration : ''].join(' . '));
    }

    finalShouldAnimateRef.current = false;
  }, [narrateText, t, finalShouldAnimateRef], [valueFacet, (0,react_facet_src.useFacetWrap)(offNarration), (0,react_facet_src.useFacetWrap)(onNarration)]);
  const onClick = (0,react_facet_src.useFacetCallback)(value => () => {
    finalShouldAnimateRef.current = true;
    onChange === null || onChange === void 0 ? void 0 : onChange(!value);
  }, [onChange, finalShouldAnimateRef], [valueFacet]);
  const setToggleTopRef = (0,react.useCallback)(node => {
    if (!toggleTopRef.current && node) {
      const val = (0,react_facet_src.isFacet)(value) ? value.get() : value;
      node.className = getToggleTopClasses(val, finalShouldAnimateRef.current);
    } // Cleanup event listeners for the previous ref.


    if (toggleTopRef.current) {
      toggleTopRef.current.removeEventListener('animationend', onAnimationEnd);
    } // This function gets called with null when the component dismounts.


    if (node) {
      node.addEventListener('animationend', onAnimationEnd);
    }

    toggleTopRef.current = node;
  }, [onAnimationEnd, value, finalShouldAnimateRef]);
  const narrationText = (0,react_facet_src.useFacetMap)((value, disabled) => [t('.elementType'), disabled === true ? t('.narrationDisabled') : '', value ? t('.on') : t('.off'), disabled ? disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '' : ''].join(' . '), [t, disabledNarrationSuffix], [valueFacet, (0,react_facet_src.useFacetWrap)(disabled)]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: onChange != null,
    className: BaseSwitch.BaseSwitch,
    narrationText: narrationText,
    inputLegend: t('.toggle'),
    gamepadIndex: (_gamepad$index = gamepad === null || gamepad === void 0 ? void 0 : gamepad.index) !== null && _gamepad$index !== void 0 ? _gamepad$index : 0,
    soundEffectHovered: soundEffectHovered !== null && soundEffectHovered !== void 0 ? soundEffectHovered : semanticSounds.hover,
    soundEffectFocused: soundEffectFocused !== null && soundEffectFocused !== void 0 ? soundEffectFocused : semanticSounds.focus,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle,
    classNameHovered: BaseSwitch.hovered,
    classNameFocused: classnames_default()(BaseSwitch.focused, focusClass),
    classNamePressed: BaseSwitch.pressed,
    classNameDisabled: BaseSwitch.disabled,
    disabled: disabled,
    onFocusChanged: onFocusChanged,
    onClick: onClick
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.offText,
    style: {
      opacity: (0,react_facet_src.useFacetMap)(value => value ? 0.6 : 1, [], [valueFacet]),
      display: showOnOffText ? 'flex' : 'none'
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(BaseSwitch.toggleLabel, semanticColorsInherited.text.base, semanticColorsInherited.text.disable)
  }, t('.off'))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggle, semanticColorsOff.border.base, semanticColorsOff.border.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.toggleContainerBorder
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.toggleBase
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleBaseItem, BaseSwitch.toggleBaseItemOn, semanticColorsOn.background.base, semanticColorsOn.background.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.imageOn
  }, /*#__PURE__*/react.createElement(IconOn_IconOn, null)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    right: false,
    role: "primary",
    disabled: disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleBaseItem, BaseSwitch.toggleBaseItemOff, semanticColorsOff.background.base, semanticColorsOff.background.disable)
  }, /*#__PURE__*/react.createElement("div", {
    className: BaseSwitch.imageOff
  }, /*#__PURE__*/react.createElement(IconOff_IconOff, null)), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    interactive: false,
    left: false,
    role: "neutral50",
    disabled: disabled
  }))), /*#__PURE__*/react.createElement("div", {
    ref: setToggleTopRef,
    className: BaseSwitch.toggleTop
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(BaseSwitch.toggleTopInner, semanticColorsThumb.border.base, semanticColorsThumb.border.disable, semanticColorsThumb.background.interactive)
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    role: "secondary",
    disabled: disabled
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleTopTop)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    role: "secondary",
    disabled: disabled
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BaseSwitch.toggleTopBottomBevel, semanticColorsThumb.shadow.base, semanticColorsThumb.shadow.disable)
  })))), /*#__PURE__*/react.createElement("fast-div", {
    className: BaseSwitch.onText,
    style: {
      opacity: (0,react_facet_src.useFacetMap)(value => value ? 1 : 0.6, [], [valueFacet]),
      display: showOnOffText ? 'flex' : 'none'
    }
  }, /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(BaseSwitch.toggleLabel, semanticColorsInherited.text.base, semanticColorsInherited.text.disable)
  }, t('.on')))));
}
;// CONCATENATED MODULE: ./packages/ui/src/Switch/Switch.tsx









const Switch_noop = () => {};

function Switch_Switch_Switch({
  onChange = Switch_noop,
  gamepad,
  value,
  title,
  description,
  disabled = false,
  showOnOffText = false,
  soundEffectHovered,
  soundEffectFocused,
  soundEffectPressed,
  offNarrationText,
  onNarrationText,
  disabledNarrationSuffix,
  wrapperRole = 'neutral',
  onRole,
  offRole,
  thumbRole
}) {
  var _gamepad$index;

  const {
    t
  } = useLocalization_useLocalization('Switch');
  const semanticSounds = useSemanticSounds(wrapperRole);
  const shouldAnimateRef = (0,react.useRef)(false);
  const valueFacet = (0,react_facet_src.useFacetWrap)(value);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const titleFacet = (0,react_facet_src.useFacetWrap)(title); // We use this to delay the rendering until we have a value. Otherwise, we can't know if
  // the switch should be on or off. That can potentially cause a flicker.

  const shouldRender = (0,react_facet_src.useFacetMap)(() => true, [], [valueFacet]);
  const onClick = (0,react_facet_src.useFacetCallback)((value, disabled) => () => {
    if (!disabled) {
      shouldAnimateRef.current = true;
      onChange(!value);
    }
  }, [onChange], [valueFacet, disabledFacet]);
  const valueFacetRef = (0,react_facet_src.useFacetRef)(valueFacet);
  const disabledFacetRef = (0,react_facet_src.useFacetRef)(disabledFacet);
  const titleFacetRef = (0,react_facet_src.useFacetRef)(titleFacet);
  const getNarrationText = (0,react.useCallback)(() => {
    if (valueFacetRef.current === react_facet_src.NO_VALUE || disabledFacetRef.current === react_facet_src.NO_VALUE) return '';
    const value = valueFacetRef.current;
    const disabled = disabledFacetRef.current;
    return [title, t('.elementType'), disabled === true ? t('.narrationDisabled') : '', value ? t('.on') : t('.off'), description !== null && description !== void 0 ? description : '', disabled ? disabledNarrationSuffix !== null && disabledNarrationSuffix !== void 0 ? disabledNarrationSuffix : '' : ''].filter(x => x).join(' . ');
  }, [valueFacetRef, disabledFacetRef, description, disabledNarrationSuffix, t, title]);
  const contextClass = (0,react_facet_src.useFacetMap)(title => {
    const hasContext = title !== '' || description != null && description !== '';
    return hasContext ? Switch_Switch.context : '';
  }, [description], [titleFacet]);
  const isNarrationEnabled = useNarrationEnabled();
  const hasTitle = (0,react_facet_src.useFacetMap)(title => title != null && title.length > 0, [], [titleFacet]);
  const isPanelFocusableFacet = (0,react_facet_src.useFacetMap)(disabled => disabled === true && isNarrationEnabled, [isNarrationEnabled], [disabledFacet]);
  const propInputLegendFacet = (0,react_facet_src.useFacetMap)(disabled => !disabled ? t('.toggle') : false, [t], [disabledFacet]);
  const panelSoundEffectHoveredFacet = (0,react_facet_src.useFacetMap)((isDisabled, soundEffectHovered) => !isDisabled ? soundEffectHovered !== null && soundEffectHovered !== void 0 ? soundEffectHovered : semanticSounds.hover : undefined, [semanticSounds.hover], [disabledFacet, (0,react_facet_src.useFacetWrap)(soundEffectHovered)]);
  const panelSoundEffectFocusedFacet = (0,react_facet_src.useFacetMap)(soundEffectFocused => soundEffectFocused !== null && soundEffectFocused !== void 0 ? soundEffectFocused : semanticSounds.focus, [semanticSounds.focus], [(0,react_facet_src.useFacetWrap)(soundEffectFocused)]);
  const panelSoundEffectPressedFacet = (0,react_facet_src.useFacetMap)((isDisabled, soundEffectPressed) => !isDisabled ? soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle : undefined, [semanticSounds.toggle], [disabledFacet, (0,react_facet_src.useFacetWrap)(soundEffectPressed)]);
  const narrationId = titleFacetRef.current !== react_facet_src.NO_VALUE ? titleFacetRef.current : '';
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    getText: getNarrationText,
    id: `narration-${narrationId}`
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    role: wrapperRole,
    disabled: disabledFacet,
    onClick: onClick,
    focusable: isPanelFocusableFacet,
    gamepadIndex: (_gamepad$index = gamepad === null || gamepad === void 0 ? void 0 : gamepad.index) !== null && _gamepad$index !== void 0 ? _gamepad$index : 0,
    shouldDisplayFocus: isPanelFocusableFacet,
    inputLegend: propInputLegendFacet,
    soundEffectHovered: panelSoundEffectHoveredFacet,
    soundEffectFocused: panelSoundEffectFocusedFacet,
    soundEffectPressed: panelSoundEffectPressedFacet,
    narrationText: ""
  }, /*#__PURE__*/react.createElement("div", {
    className: Switch_Switch.Switch
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: contextClass
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasTitle
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, {
    disabled: disabled
  }, titleFacet)), description != '' && description != null && /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description)), /*#__PURE__*/react.createElement(BaseSwitch_BaseSwitch, {
    value: valueFacet,
    disabled: disabledFacet,
    showOnOffText: showOnOffText,
    shouldAnimateRef: shouldAnimateRef,
    disabledNarrationSuffix: disabledNarrationSuffix,
    onNarrationText: onNarrationText,
    offNarrationText: offNarrationText,
    onRole: onRole,
    offRole: offRole,
    thumbRole: thumbRole
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/CheatsTab.tsx











const MAX_TICK_SPEED = 4096;
const DEFAULT_TICK_SPEED = 1;
function RandomTickSpeedSetting({
  cheatsData,
  disabled,
  gamepadIndex
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.cheats');
  const {
    t: n
  } = localization_useLocalization('CreateNewWorld.cheats.narration');
  const tickSpeed = (0,react_facet_src.useFacetMap)(cheats => cheats.tickSpeed.toString(), [], [cheatsData]);
  const {
    narrateText
  } = useNarrateText_useNarrateText({
    interruptible: false
  });
  const setTickSpeed = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.tickSpeed = newValue;
  }, [], [cheatsData]);
  const tickSpeedBlurHandler = (0,react.useCallback)(
  /**
   * Handler for sanitizing the input if it is less
   * than MAX_TICK_SPEED and only contains digits.
   */
  (speed, setSpeed) => {
    const numbersReg = /^[0-9]*$/g;
    const isOnlyDigits = speed.match(numbersReg);
    const isWithinRange = parseInt(speed) <= MAX_TICK_SPEED;
    const isEmpty = speed.length === 0;

    if (isEmpty || !isOnlyDigits) {
      narrateText(n('.tickSpeedInvalidValue'));
      setSpeed(DEFAULT_TICK_SPEED.toString());
      return TextField_TextField.ValidationResult.INVALID;
    } else if (!isWithinRange) {
      narrateText(n('.tickSpeedNotWithinRange'));
      setSpeed(MAX_TICK_SPEED.toString());
      return TextField_TextField.ValidationResult.INVALID;
    }

    return TextField_TextField.ValidationResult.VALID;
  }, [narrateText, n]);
  return /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField.WithButton, {
    disabledNarrationSuffix: t('.settingDisabledHint'),
    buttonInputLegend: t('.tickSpeedReset'),
    buttonText: t('.tickSpeedReset'),
    disabled: disabled,
    buttonOnClick: () => setTickSpeed(DEFAULT_TICK_SPEED.toString()),
    gamepadIndex: gamepadIndex,
    label: t('.tickSpeedLabel'),
    description: t('.tickSpeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 4,
    value: tickSpeed,
    onChange: setTickSpeed,
    onBlur: tickSpeedBlurHandler,
    buttonNarrationHint: t('.narrationTickSpeedButtonNarrationHint'),
    isNumber: true
  });
}
function DaylightCycleToggles({
  cheatsData,
  disabled,
  gamepadIndex
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.cheats');
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const daylightCycleCallback = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.daylightCycle = newValue;
  }, [], [cheatsData]);
  const daylightCycleValue = (0,react_facet_src.useFacetMap)(cheatsData => cheatsData.daylightCycle, [], [cheatsData]);
  const daylightCycleOptions = [{
    label: t('.daylightCycleNormalLabel'),
    description: t('.daylightCycleNormalDescription'),
    value: DaylightCycleEnum.NORMAL
  }, {
    label: t('.daylightCycleAlwaysDayLabel'),
    description: t('.daylightCycleAlwaysDayDescription'),
    value: DaylightCycleEnum.ALWAYS_DAY
  }];

  if (editingWorld) {
    daylightCycleOptions.push({
      label: t('.daylightCycleLockTimeLabel'),
      description: t('.daylightCycleLockTimeDescription'),
      value: DaylightCycleEnum.LOCK_TIME
    });
  }

  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.settingDisabledHint'),
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: t('.daylightCycleTitle'),
    disabled: disabled,
    gamepad: {
      index: gamepadIndex
    },
    options: daylightCycleOptions,
    value: daylightCycleValue,
    onChange: daylightCycleCallback
  });
}

function CheatsEnabledSwitch({
  cheatsData,
  isLockedTemplate,
  achievementsDisabledMessages
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.cheats');
  const {
    t: a
  } = localization_useLocalization('CreateNewWorld.all');
  const cheatTabDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [isLockedTemplate, (0,react_facet_src.useSharedFacet)(isTrialAccountSelector)]);
  const cheatsEnabledCallback = (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
    cheatsData.cheatsEnabled = newValue;
  }, [], [cheatsData]);
  const cheatsEnabledValue = (0,react_facet_src.useFacetMap)(cheatsData => cheatsData.cheatsEnabled, [], [cheatsData]);
  return /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.title'),
    description: t('.description'),
    disabled: cheatTabDisabled,
    gamepad: {
      index: 0
    },
    value: cheatsEnabledValue,
    onChange: cheatsEnabledCallback,
    onNarrationText: a('.narrationSuffixDisablesAchievements') + ' . ' + a('.narrationSuffixSettingsAvailable'),
    offNarrationText: (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? a('.narrationSuffixEnablesAchievements') : undefined, [a], [achievementsDisabledMessages])
  });
}

function CheatsTab({
  cheatsData,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.cheats');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const isEduFacetUnwrapped = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useSharedFacet)(isEduBuildSelector)) === true;
  const cheatSwitches = [{
    title: t('.inventoryTitle'),
    description: t('.inventoryDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.keepInventory, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.keepInventory = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.mobSpawningTitle'),
    description: t('.mobSpawningDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobSpawning, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobSpawning = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.mobGriefingTitle'),
    description: t('.mobGriefingDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobGriefing, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobGriefing = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.entitiesDropLootTitle'),
    description: t('.entitiesDropLootDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.entitiesDropLoot, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.entitiesDropLoot = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.weatherTitle'),
    description: t('.weatherDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.weather, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.weather = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.commandBlocksTitle'),
    description: t('.commandBlocksDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandBlocks, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.commandBlocks = newValue;
    }, [], [cheatsData])
  }, {
    title: t('.educationTitle'),
    description: t('.educationDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.educationEdition, [], [cheatsData]),
    // When you are already in Minecraft Education, hide the "education edition" toggle
    hidden: isEduFacetUnwrapped,
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.educationEdition = newValue;
    }, [], [cheatsData])
  }];
  const cheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatsData, isLockedTemplate) => !cheatsData.cheatsEnabled || isLockedTemplate, [], [cheatsData, isLockedTemplate]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    narrationText: tSideMenu('.cheatsTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, isEduFacetUnwrapped ? null : /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(CheatsEnabledSwitch, {
    cheatsData: cheatsData,
    isLockedTemplate: isLockedTemplate,
    achievementsDisabledMessages: achievementsDisabledMessages
  })), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: isEduFacetUnwrapped ? [t('.settingsTitle.edu'), t('.settingsDescription.1'), t('.settingsDescription.2')].join(' . ') : [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, isEduFacetUnwrapped ? /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    compact: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "sectionHeader"
  }, t('.settingsTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, t('.settingsDescription.1')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, t('.settingsDescription.2')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }))) : /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.settingsTitle')
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DaylightCycleToggles, {
    cheatsData: cheatsData,
    disabled: cheatSettingsDisabled,
    gamepadIndex: 1
  })), cheatSwitches.map((option, index) => {
    return option.hidden ? null : /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      disabledNarrationSuffix: t('.settingDisabledHint'),
      title: option.title,
      description: option.description,
      gamepad: {
        index: index + 2
      },
      disabled: cheatSettingsDisabled,
      value: option.value,
      onChange: option.onChange
    }));
  }), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(RandomTickSpeedSetting, {
    disabled: cheatSettingsDisabled,
    gamepadIndex: cheatSwitches.length + 2,
    cheatsData: cheatsData
  })))));
}
;// CONCATENATED MODULE: ./packages/react-localization/src/useLocalizationGlobal.tsx


function useLocalizationGlobal() {
  const {
    translate,
    formatDate
  } = (0,react.useContext)(LocalizationContext);
  const localization = (0,react.useMemo)(() => {
    return {
      f: {
        formatDate
      },
      gt: (key, params) => {
        var _translate;

        return (_translate = translate(key, params)) !== null && _translate !== void 0 ? _translate : key;
      }
    };
  }, [translate, formatDate]);
  return localization;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/under-construction-art-cropped.png
const under_construction_art_cropped_namespaceObject = __webpack_require__.p + "assets/under-construction-art-cropped-2afbb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UnderConstructionMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const UnderConstructionMessage = ({"emptyStateArt":"DvNo3","emptyStateArtBig":"DlMUa","emptyStateRealmsArt":"Qhp5U","emptyStateRealmsArtBig":"xjJ6b"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ExperimentalFeaturesTab.tsx
function ExperimentalFeaturesTab_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ExperimentalFeaturesTab_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ExperimentalFeaturesTab_ownKeys(Object(source), true).forEach(function (key) { ExperimentalFeaturesTab_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ExperimentalFeaturesTab_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ExperimentalFeaturesTab_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ExperimentalFeaturesTab_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ExperimentalFeaturesTab_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function ExperimentalFeaturesTab_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }















 //	Remove this constant when the functionality is complete for Edit World screen

const UNDER_CONSTRUCTION_IN_EDIT_WORLD = false;

function DynamicSwitch({
  experimentalFeature,
  gamepadIndex,
  disabled,
  achievementsDisabledMessages
}) {
  const {
    gt
  } = useLocalizationGlobal();
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.all');
  const idFacet = (0,react_facet_src.useFacetMap)(facet => facet.id, [], [experimentalFeature]);
  const idValue = (0,react_facet_src.useFacetUnwrap)(idFacet);
  const titleFacet = (0,react_facet_src.useFacetMap)(facet => facet.title, [], [experimentalFeature]);
  const titleValue = (0,react_facet_src.useFacetUnwrap)(titleFacet);
  const descriptionFacet = (0,react_facet_src.useFacetMap)(facet => facet.description, [], [experimentalFeature]);
  const descriptionValue = (0,react_facet_src.useFacetUnwrap)(descriptionFacet);
  const valueFacet = (0,react_facet_src.useFacetMap)(facet => facet.isEnabled, [], [experimentalFeature]);
  const onChange = (0,react_facet_src.useFacetCallback)((betaFeaturesToggled, experimentalFeature) => newValue => {
    if (newValue && !betaFeaturesToggled.userHasAcceptedBetaFeatures) {
      betaFeatureToggledFacet.set({
        userTriedToActivateToggle: true,
        doSetToggleValue: () => experimentalFeature.isEnabled = newValue,
        userHasAcceptedBetaFeatures: false
      });
    } else {
      experimentalFeature.isEnabled = newValue;
    }
  }, [], [betaFeatureToggledFacet, experimentalFeature]);
  const onNarrationText = t('.narrationSuffixDisablesAchievements');
  const offNarrationText = (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? t('.narrationSuffixEnablesAchievements') : undefined, [t], [achievementsDisabledMessages]);
  return idValue != null ? /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: titleValue !== react_facet_src.NO_VALUE ? gt(titleValue) : '',
    description: descriptionValue !== react_facet_src.NO_VALUE ? gt(descriptionValue) : '',
    gamepad: {
      index: gamepadIndex
    },
    value: valueFacet,
    disabled: disabled,
    onChange: onChange,
    onNarrationText: onNarrationText,
    offNarrationText: offNarrationText
  }) : null;
}

function DynamicSwitchList({
  item,
  index,
  achievementsDisabledMessages
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.experimentalFeatures');
  const sectionNarration = (0,react_facet_src.useFacetMap)(({
    description,
    numOfSections,
    title
  }) => {
    const enumeration = numOfSections > 1 ? t('.sectionEnumeration', [`${index + 1}`, `${numOfSections}`]) : null;
    return [title, t('.narrationComponentTypeSectionHeader'), enumeration, description].filter(x => x).join(' . ');
  }, [t, index], [item]);
  const title = (0,react_facet_src.useFacetMap)(({
    title
  }) => title, [], [item]);
  const description = (0,react_facet_src.useFacetMap)(({
    description
  }) => description, [], [item]);
  const disabled = (0,react_facet_src.useFacetMap)(({
    disabled
  }) => disabled, [], [item]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: sectionNarration
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index
    }
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: title,
    description: description
  })), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: (0,react_facet_src.useFacetMap)(({
      features
    }) => features, [], [item])
  }, (dynamicSwitch, index) => /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(DynamicSwitch, {
    experimentalFeature: dynamicSwitch,
    gamepadIndex: index,
    disabled: disabled,
    achievementsDisabledMessages: achievementsDisabledMessages
  })))));
}

const sections = [{
  title: '.gameplayTitle',
  description: '.gameplayDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.GAMEPLAY
}, {
  title: '.addOnCreatorsTitle',
  description: '.addOnCreatorsDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  title: '.internalTestsTitle',
  description: '.internalTestsDescription',
  featuresFilter: feature => feature.category === ExperimentalFeatureCategory.INTERNAL_TESTS
}];

const ExperimentsUnderConstruction = () => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.experimentalFeatures'); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 260
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.underConstruction.title'),
    imgSrc: under_construction_art_cropped_namespaceObject,
    imgClass: narrowImage ? UnderConstructionMessage.emptyStateArt : UnderConstructionMessage.emptyStateArtBig
  })));
};

function ExperimentalFeaturesTab({
  experimentsData,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.experimentalFeatures');
  const {
    t: tSideMenu
  } = useLocalization_useLocalization('CreateNewWorldSideMenu');
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const experimentsDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => isLockedTemplate || isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const dynamicSwitchListsFacet = (0,react_facet_src.useFacetMemo)((experimentsDisabled, experimentsData) => sections // Map the features to each section
  .map((_ref) => {
    let {
      featuresFilter
    } = _ref,
        section = ExperimentalFeaturesTab_objectWithoutProperties(_ref, ["featuresFilter"]);

    return ExperimentalFeaturesTab_objectSpread(ExperimentalFeaturesTab_objectSpread({}, section), {}, {
      features: filter(experimentsData, featuresFilter)
    });
  }) // Filter out empty sections
  .filter(({
    features
  }) => features.length > 0) // Add the number of populated sections, disabled state and localizations
  .map((_ref2, index, {
    length
  }) => {
    let {
      title,
      description
    } = _ref2,
        filteredSection = ExperimentalFeaturesTab_objectWithoutProperties(_ref2, ["title", "description"]);

    return ExperimentalFeaturesTab_objectSpread(ExperimentalFeaturesTab_objectSpread({}, filteredSection), {}, {
      description: t(description),
      disabled: experimentsDisabled,
      numOfSections: length,
      title: t(title)
    });
  }), [t], [experimentsDisabled, experimentsData]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, UNDER_CONSTRUCTION_IN_EDIT_WORLD && editingWorld ? /*#__PURE__*/react.createElement(ExperimentsUnderConstruction, null) : /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    experimentsWarningEnabled: true,
    narrationText: tSideMenu('.experimentalFeaturesTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dynamicSwitchListsFacet
  }, (item, index) => /*#__PURE__*/react.createElement(DynamicSwitchList, {
    item: item,
    index: index,
    achievementsDisabledMessages: achievementsDisabledMessages
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ExperimentalFeaturesActivationWarningModal.tsx






const {
  FontWeight: ExperimentalFeaturesActivationWarningModal_FontWeight
} = Typography_Typography_Typography;
const ExperimentalFeaturesActivationWarningModal_CANCEL_BUTTON_ALIAS = 'cnw-bfw-cancel';
function ExperimentalFeaturesActivationWarningModal() {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.experimentalFeatures');
  const experimentalFeatureToggled = (0,react_facet_src.useFacetUnwrap)(betaFeatureToggledFacet);
  const userTriedToActivateToggle = experimentalFeatureToggled !== react_facet_src.NO_VALUE && experimentalFeatureToggled.userTriedToActivateToggle;
  const userHasAcceptedExperimentalFeaturesWarning = experimentalFeatureToggled !== react_facet_src.NO_VALUE && experimentalFeatureToggled.userHasAcceptedBetaFeatures;
  const showModal = userTriedToActivateToggle && !userHasAcceptedExperimentalFeaturesWarning;

  const resetBetaFeatureToggle = () => {
    betaFeatureToggledFacet.set({
      userTriedToActivateToggle: false,
      doSetToggleValue: () => {},
      userHasAcceptedBetaFeatures: false
    });
  };

  const doSetToggleValue = experimentalFeatureToggled !== react_facet_src.NO_VALUE ? experimentalFeatureToggled.doSetToggleValue : () => {};
  const descI = t('.activateExperimentsConfirmationDescriptionPart1');
  const descII = t('.activateExperimentsConfirmationDescriptionPart2');
  return /*#__PURE__*/react.createElement(react.Fragment, null, showModal && /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ExperimentalFeaturesActivationWarningModal_CANCEL_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: resetBetaFeatureToggle
  }, t('.activateExperimentsConfirmationTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${descI}. ${descII}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, descI), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    fontWeight: ExperimentalFeaturesActivationWarningModal_FontWeight.Bold
  }, descII))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: 'primary',
    gamepadIndex: 0,
    gamepadAlias: ExperimentalFeaturesActivationWarningModal_CANCEL_BUTTON_ALIAS,
    inputLegend: t('.activateExperimentsConfirmationCancelInputLegend'),
    onClick: resetBetaFeatureToggle
  }, t('.activateExperimentsConfirmationCancel')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.activateExperimentsConfirmationConfirmInputLegend'),
    onClick: () => {
      doSetToggleValue();
      betaFeatureToggledFacet.set({
        userTriedToActivateToggle: false,
        doSetToggleValue: () => {},
        userHasAcceptedBetaFeatures: true
      });
    }
  }, t('.activateExperimentsConfirm')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/AdvancedTab.tsx













const CHUNK_BLOCK_SIZE = 16;
function AdvancedTab({
  advancedData,
  cheatsData,
  isUsingTemplate,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  isEditorWorld,
  onSeedValueChange,
  isSeedChangeLocked
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.advanced');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const {
    t: tCheats
  } = localization_useLocalization('CreateNewWorld.cheats');
  const {
    t: tAll
  } = localization_useLocalization('CreateNewWorld.all');
  const mode = (0,react.useContext)(WorldModeContext);
  const isEditWorld = mode === 'edit';
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const clipboard = (0,react_facet_src.useSharedFacet)(clipboardFacet_clipboardFacet);
  const isTrialAccount = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  const isUnlockRecipesFeatureFlagEnabled = useFeatureFlag(UNLOCKS_RECIPES_FEATURE_FLAG);
  const isUsingTemplateOrTrialAccount = (0,react_facet_src.useFacetMap)((isUsingTemplate, isTrialAccount) => isUsingTemplate || isTrialAccount, [], [isUsingTemplate, isTrialAccount]);
  const isUsingTemplateOrEditWorld = (0,react_facet_src.useFacetMap)(isUsingTemplate => isUsingTemplate || isEditWorld, [isEditWorld], [isUsingTemplate]);
  const isUsingTemplateOrTrialAccountOrEditWorld = (0,react_facet_src.useFacetMap)((isUsingTemplate, isTrialAccount) => isUsingTemplate || isTrialAccount || isEditWorld, [isEditWorld], [isUsingTemplate, isTrialAccount]);
  const showSeedTemplates = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(isEduBuild => !isEduBuild, [], [(0,react_facet_src.useSharedFacet)(isEduBuildSelector)])) === true;
  const simulationDistanceDisabled = (0,react_facet_src.useFacetMap)(({
    simulationDistanceOptions
  }) => simulationDistanceOptions.length <= 1, [], [(0,react_facet_src.useSharedFacet)(simulationDistanceFacet)]);
  const eduCheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatsData, isLockedTemplate) => !cheatsData.cheatsEnabled || isLockedTemplate, [], [cheatsData, isLockedTemplate]);
  const advancedSwitches = [{
    title: t('.useFlatWorldTitle'),
    description: t('.useFlatWorldDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.useFlatWorld, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.useFlatWorld = newValue;
    }, [], [advancedData]),
    onNarrationText: tAll('.narrationSuffixDisablesAchievements'),
    offNarrationText: (0,react_facet_src.useFacetMap)(achievementsDisabledMessages => achievementsDisabledMessages.length === 0 ? tAll('.narrationSuffixEnablesAchievements') : undefined, [tAll], [achievementsDisabledMessages]),
    disabled: isUsingTemplateOrTrialAccountOrEditWorld
  }, {
    title: t('.startWithMapTitle'),
    description: t('.startWithMapDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.startWithMap, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.startWithMap = newValue;
    }, [], [advancedData]),
    disabled: isUsingTemplateOrEditWorld
  }, {
    title: t('.bonusChestTitle'),
    description: t('.bonusChestDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.bonusChest, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.bonusChest = newValue;
    }, [], [advancedData]),
    disabled: isUsingTemplateOrTrialAccountOrEditWorld
  }];
  const unlockRecipesSwitch = {
    title: t('.recipesUnlockTitle'),
    description: t('.recipesUnlockDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.recipesUnlock, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.recipesUnlock = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.recipesUnlockDescription')
  };
  const advancedExportSettingsSwitches = [{
    title: t('.showCoordinatesTitle'),
    description: t('.showCoordinatesDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.showCoordinates, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.showCoordinates = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.showCoordinatesDescription')
  }, ...(isUnlockRecipesFeatureFlagEnabled ? [unlockRecipesSwitch] : []), {
    title: t('.firesSpreadsTitle'),
    description: t('.firesSpreadsDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.firesSpreads, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.firesSpreads = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.firesSpreadsDescription')
  }, {
    title: t('.tntExplodesTitle'),
    description: t('.tntExplodesDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.tntExplodes, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.tntExplodes = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.tntExplodesDescription')
  }, {
    title: t('.respawnBlocksExplodeTitle'),
    description: t('.respawnBlocksExplodeDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.respawnBlocksExplode, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.respawnBlocksExplode = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.respawnBlocksExplodeDescription')
  }, {
    title: t('.mobLootTitle'),
    description: t('.mobLootDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.mobLoot, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.mobLoot = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.mobLootDescription')
  }, {
    title: t('.naturalRegenerationTitle'),
    description: t('.naturalRegenerationDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.naturalRegeneration, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.naturalRegeneration = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.naturalRegenerationDescription')
  }, {
    title: t('.tileDropsTitle'),
    description: t('.tileDropsDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.tileDrops, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.tileDrops = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.tileDropsDescription')
  }, {
    title: t('.immediateRespawnTitle'),
    description: t('.immediateRespawnDescription'),
    value: (0,react_facet_src.useFacetMap)(value => value.immediateRespawn, [], [advancedData]),
    onChange: (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
      advancedData.immediateRespawn = newValue;
    }, [], [advancedData]),
    disabled: isTrialAccount,
    onNarrationText: t('.immediateRespawnDescription')
  }];
  const eduAdvancedSwitches = [{
    title: tCheats('.inventoryTitle'),
    description: tCheats('.inventoryDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.keepInventory, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.keepInventory = newValue;
    }, [], [cheatsData])
  }, {
    title: tCheats('.mobSpawningTitle'),
    description: tCheats('.mobSpawningDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobSpawning, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobSpawning = newValue;
    }, [], [cheatsData])
  }, {
    title: tCheats('.mobGriefingTitle'),
    description: tCheats('.mobGriefingDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.mobGriefing, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.mobGriefing = newValue;
    }, [], [cheatsData])
  }, {
    title: tCheats('.entitiesDropLootTitle'),
    description: tCheats('.entitiesDropLootDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.entitiesDropLoot, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.entitiesDropLoot = newValue;
    }, [], [cheatsData])
  }, {
    title: tCheats('.weatherTitle'),
    description: tCheats('.weatherDescription'),
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.weather, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(cheatsData => newValue => {
      cheatsData.weather = newValue;
    }, [], [cheatsData])
  }];
  const simulationDistanceTogglesDisabled = (0,react_facet_src.useFacetMap)((simulationDistanceDisabled, isLockedTemplate) => simulationDistanceDisabled || isLockedTemplate, [], [simulationDistanceDisabled, isLockedTemplate]);
  const seedTemplateValue = (0,react_facet_src.useFacetMap)(value => value.worldSeed, [], [advancedData]);
  const copySeedTemplateValue = (0,react_facet_src.useFacetCallback)((seedTemplateValue, clipboard, notificationsSharedFacet) => () => {
    clipboard.copyToClipboard(seedTemplateValue);
    notificationsSharedFacet.queueSnackbar(t('.copyToClipboard'));
  }, [t], [seedTemplateValue, clipboard, notificationsSharedFacet]);

  const navigateToSeedTemplates = () => historyAPI.push(`/create-new-world/seed-templates`);

  const seedButtonText = isEditWorld ? t('.worldSeedCopyButton') : t('.worldSeedButton');
  const onSeedButtonClick = isEditWorld ? copySeedTemplateValue : navigateToSeedTemplates;
  const seedPlaceholder = isEditWorld ? '' : t('.worldSeedPlaceholder'); // Using this initialIndex we set different start when the advancedSwitches are moved to the bottom of the page.

  const initialIndex = isEditWorld ? 0 : advancedSwitches.length;
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    narrationText: tSideMenu('.advancedTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.projectHeader'),
    description: t('.projectDescription')
  }))), showSeedTemplates ? /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField.WithButton, {
    buttonInputLegend: seedButtonText,
    buttonText: seedButtonText,
    buttonOnClick: onSeedButtonClick,
    gamepadIndex: 0,
    textDisabled: isEditWorld,
    disabled: isSeedChangeLocked,
    label: t('.worldSeedLabel'),
    description: t('.worldSeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 32,
    value: seedTemplateValue,
    onChange: onSeedValueChange,
    placeholder: seedPlaceholder,
    buttonNarrationHint: t('.narrationTemplatesButtonNarrationHint'),
    disabledNarrationSuffix: tAll('.narrationSuffixTemplateLocked')
  })) : /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField, {
    gamepadIndex: 0,
    disabled: isLockedTemplate,
    label: t('.worldSeedLabel'),
    description: t('.worldSeedDescription')
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 32,
    value: seedTemplateValue,
    onChange: onSeedValueChange,
    placeholder: t('.worldSeedPlaceholder'),
    disabledNarrationSuffix: tAll('.narrationSuffixTemplateLocked')
  })), !isEditWorld ? advancedSwitches.map((option, index) => {
    var _option$disabled;

    return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled = option.disabled) !== null && _option$disabled !== void 0 ? _option$disabled : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      onNarrationText: option.onNarrationText,
      offNarrationText: option.offNarrationText,
      gamepad: {
        index: index + 1
      }
    }));
  }) : /*#__PURE__*/react.createElement(react.Fragment, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.exportSettingsHeader'),
    description: t('.exportSettingsDescription')
  }))), advancedExportSettingsSwitches.map((option, index) => {
    var _option$disabled2;

    return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled2 = option.disabled) !== null && _option$disabled2 !== void 0 ? _option$disabled2 : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      gamepad: {
        index: initialIndex + 1 + index
      }
    }));
  }), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(RespawnRadius, {
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + 1,
    label: t('.respawnRadiusLabel'),
    disabled: isUsingTemplateOrTrialAccount,
    description: t('.respawnRadiusDescription'),
    placeholder: t('.respawnRadiusPlaceholder'),
    advancedData: advancedData
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(SimulationDistanceToggles, {
    title: t('.simulationDistanceTitle'),
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + 2,
    disabled: simulationDistanceTogglesDisabled,
    advancedData: advancedData
  })), isEditWorld ? advancedSwitches.map((option, index) => {
    var _option$disabled3;

    return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: (_option$disabled3 = option.disabled) !== null && _option$disabled3 !== void 0 ? _option$disabled3 : isLockedTemplate,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      onNarrationText: option.onNarrationText,
      offNarrationText: option.offNarrationText,
      gamepad: {
        index: advancedExportSettingsSwitches.length + index + 3
      }
    }));
  }) : /*#__PURE__*/react.createElement(react.Fragment, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useSharedFacet)(isEduBuildSelector)
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(DaylightCycleToggles, {
    cheatsData: cheatsData,
    disabled: eduCheatSettingsDisabled,
    gamepadIndex: initialIndex + advancedExportSettingsSwitches.length + advancedSwitches.length + 4
  })), eduAdvancedSwitches.map((option, index) => {
    return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, {
      key: option.title
    }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
      title: option.title,
      disabled: eduCheatSettingsDisabled,
      description: option.description,
      onChange: option.onChange,
      value: option.value,
      gamepad: {
        index: initialIndex + advancedExportSettingsSwitches.length + advancedSwitches.length + index + 5
      }
    }));
  }), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(RandomTickSpeedSetting, {
    cheatsData: cheatsData,
    disabled: eduCheatSettingsDisabled,
    gamepadIndex: initialIndex + eduAdvancedSwitches.length + advancedExportSettingsSwitches.length + advancedSwitches.length + 6
  }))))));
}

function SimulationDistanceToggles({
  title,
  gamepadIndex,
  disabled,
  advancedData
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.advanced');
  const mapDistanceOption = (0,react.useCallback)((distance, translation) => {
    return {
      label: t('.simulationDistanceOption', [`${distance}`]),
      value: distance,
      description: t(translation, [`${distance * CHUNK_BLOCK_SIZE}`, `${distance}`])
    };
  }, [t]);
  const mappedSimulationDistanceOptions = (0,react_facet_src.useFacetMap)(({
    simulationDistanceOptions
  }) => {
    const userHasChoices = simulationDistanceOptions.length > 1;
    const values = userHasChoices ? simulationDistanceOptions : [4, 6, 8];
    const translation = userHasChoices ? '.simulationDistanceDescription' : '.simulationDistanceDescriptionOnlyOne';
    return values.map(distance => mapDistanceOption(distance, translation));
  }, [mapDistanceOption], [(0,react_facet_src.useSharedFacet)(simulationDistanceFacet)]);
  const simulationDistanceSetter = (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
    advancedData.simulationDistance = newValue;
  }, [], [advancedData]);
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: title,
    gamepad: {
      index: gamepadIndex
    },
    options: mappedSimulationDistanceOptions,
    value: (0,react_facet_src.useFacetMap)(value => value.simulationDistance, [], [advancedData]),
    onChange: simulationDistanceSetter,
    disabled: disabled,
    wrapToggleText: true
  });
}

const DEFAULT_RESPAWN_RADIUS = 5;
const MAX_RESPAWN_RADIUS = 128;

function RespawnRadius({
  gamepadIndex,
  label,
  description,
  placeholder,
  disabled,
  advancedData
}) {
  const respawnRadius = (0,react_facet_src.useFacetMap)(value => value.respawnRadius.toString(), [], [advancedData]);
  const {
    t: a
  } = localization_useLocalization('CreateNewWorld.all');
  const {
    t: n
  } = localization_useLocalization('CreateNewWorld.advanced.narration');
  const {
    narrateText
  } = useNarrateText_useNarrateText({
    interruptible: false
  });
  const setRespawnRadius = (0,react_facet_src.useFacetCallback)(advancedData => newValue => {
    advancedData.respawnRadius = newValue;
  }, [], [advancedData]);
  const respawnRadiusBlurHandler = (0,react.useCallback)(
  /**
   * Handler for sanitizing the input if it is less
   * than MAX_RESPAWN_RADIUS and only contains digits.
   */
  (radius, setRadius) => {
    const numbersReg = /^[0-9]*$/g;
    const isOnlyDigits = radius.match(numbersReg);
    const isWithinRange = parseInt(radius) <= MAX_RESPAWN_RADIUS;
    const isEmpty = radius.length === 0;

    if (isEmpty || !isOnlyDigits) {
      narrateText(n('.respawnRadiusInvalidValue'));
      const newValue = DEFAULT_RESPAWN_RADIUS.toString();
      setRadius(newValue);
      return TextField_TextField.ValidationResult.INVALID;
    } else if (!isWithinRange) {
      narrateText(n('.respawnRadiusNotWithinRange'));
      const newValue = MAX_RESPAWN_RADIUS.toString();
      setRadius(newValue);
      return TextField_TextField.ValidationResult.INVALID;
    }

    return TextField_TextField.ValidationResult.VALID;
  }, [narrateText, n]);
  return /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField, {
    gamepadIndex: gamepadIndex,
    label: label,
    description: description
    /* Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.*/
    ,
    maxLength: 8,
    value: respawnRadius,
    disabled: disabled,
    onChange: setRespawnRadius,
    onBlur: respawnRadiusBlurHandler,
    placeholder: placeholder,
    disabledNarrationSuffix: a('.narrationSuffixTemplateLocked'),
    isNumber: true
  });
}
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/some.ts
function some(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return true;
    }
  }

  return false;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/PlayerPermissionIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerPermissionIcon = ({"icon":"kFoCR","iconWrapper":"d8tfi"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray10.png
const visitorGray10_namespaceObject = __webpack_require__.p + "assets/visitorGray10-9a6b6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray70.png
const visitorGray70_namespaceObject = __webpack_require__.p + "assets/visitorGray70-d4a9e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/visitorGray90.png
const visitorGray90_namespaceObject = __webpack_require__.p + "assets/visitorGray90-9d4d1.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray10.png
const memberGray10_namespaceObject = __webpack_require__.p + "assets/memberGray10-7cc66.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray70.png
const memberGray70_namespaceObject = __webpack_require__.p + "assets/memberGray70-7b6db.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/memberGray90.png
const memberGray90_namespaceObject = __webpack_require__.p + "assets/memberGray90-a38ee.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray10.png
const operatorGray10_namespaceObject = __webpack_require__.p + "assets/operatorGray10-1b749.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray70.png
const operatorGray70_namespaceObject = __webpack_require__.p + "assets/operatorGray70-266ca.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/operatorGray90.png
const operatorGray90_namespaceObject = __webpack_require__.p + "assets/operatorGray90-0f8a3.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/PlayerPermissionIcon.tsx














const icons = {
  [PlayerPermissions.VISITOR]: {
    selected: visitorGray10_namespaceObject,
    unselected: visitorGray90_namespaceObject,
    disabled: visitorGray70_namespaceObject
  },
  [PlayerPermissions.MEMBER]: {
    selected: memberGray10_namespaceObject,
    unselected: memberGray90_namespaceObject,
    disabled: memberGray70_namespaceObject
  },
  [PlayerPermissions.OPERATOR]: {
    selected: operatorGray10_namespaceObject,
    unselected: operatorGray90_namespaceObject,
    disabled: operatorGray70_namespaceObject
  }
};
function PlayerPermissionIcon_PlayerPermissionIcon({
  type,
  status
}) {
  return /*#__PURE__*/react.createElement("div", {
    className: PlayerPermissionIcon.iconWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: icons[type][status],
    className: PlayerPermissionIcon.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/PlayerPermissionIcon/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/MultiplayerTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MultiplayerTab = ({"subscriptionImage":"BHnbR"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/steve-island.png
const steve_island_namespaceObject = __webpack_require__.p + "assets/steve-island-6fbc9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/MultiplayerTab.tsx
















function MultiplayerTab_MultiplayerTab({
  multiplayerData,
  worldPacks,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onDeactivatePack,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const {
    t: tAll
  } = localization_useLocalization('CreateNewWorld.all');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const multiplayerToggleDisabled = (0,react_facet_src.useFacetMap)((multiplayer, user) => !multiplayer.multiplayerSupported || user.isTrialAccount, [], [multiplayerData, userAccount]);
  const multiplayerDisabled = (0,react_facet_src.useFacetMap)(multiplayer => !multiplayer.multiplayerGame, [], [multiplayerData]);
  const platform = (0,react_facet_src.useFacetMap)(device => device.platform, [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const isEduBuild = (0,react_facet_src.useSharedFacet)(isEduBuildSelector);
  const showNintendoPromotion = (0,react_facet_src.useFacetMap)((userAccount, platform) => consoles_isNintendoPlatform(platform) && !userAccount.hasPremiumNetworkAccess, [], [userAccount, platform]);
  const showPlaystationPromotion = (0,react_facet_src.useFacetMap)((userAccount, platform) => consoles_isPlaystationPlatform(platform) && !userAccount.hasPremiumNetworkAccess, [], [userAccount, platform]); // If on a third party platform but missing premium internet access

  const premiumAccountInternetServicePromotion = (0,react_facet_src.useFacetMap)((showNintendoPromotion, showPlaystationPromotion) => showNintendoPromotion || showPlaystationPromotion, [], [showNintendoPromotion, showPlaystationPromotion]);
  const thirdPartyPlatform = (0,react_facet_src.useFacetMap)(platform => consoles_isPlaystationPlatform(platform) || consoles_isNintendoPlatform(platform), [], [platform]);
  const showLANInfo = (0,react_facet_src.useFacetMap)((thirdPartyPlatform, isEduBuild) => !thirdPartyPlatform && !isEduBuild, [], [thirdPartyPlatform, isEduBuild]);
  const showMSALogin = (0,react_facet_src.useFacetMap)((userAccount, thirdPartyPlatform) => thirdPartyPlatform && !userAccount.isLoggedInWithMicrosoftAccount, [], [userAccount, thirdPartyPlatform]);
  const disableMSALogin = (0,react_facet_src.useFacetMap)((multiplayer, multiplayerDisabled) => {
    return multiplayer.generalWarningState === GeneralMultiplayerWarningStateEnum.CHECK_INTERNET_CONNECTION || multiplayerDisabled;
  }, [], [multiplayerData, multiplayerDisabled]);
  const showPlayerAccessToggles = (0,react_facet_src.useFacetMap)((showMSALogin, isEduBuild) => !showMSALogin && !isEduBuild, [], [showMSALogin, isEduBuild]);
  const showPlatformPlayerAccessToggles = (0,react_facet_src.useFacetMap)(multiplayer => multiplayer.platformPlayerAccessSupported, [], [multiplayerData]);
  const activePacksFacet = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const showMultiplayerPlatformLockedModal = MultiplayerPlatformLockedModal.useShowModal();
  const toggleMultiplayer = (0,react_facet_src.useFacetCallback)((multiplayer, activePacks) => newValue => {
    // We should always be able to disable multiplayer without any validation.
    if (!newValue) {
      return multiplayer.multiplayerGame = newValue;
    } // If they instead want to activate multiplayer we need to ensure none
    // of the active resource packs are locked to a specific platform.


    const hasPlatformLockedResourcePack = some(activePacks, pack => pack.isPlatformLocked);

    if (hasPlatformLockedResourcePack) {
      showMultiplayerPlatformLockedModal({
        multiplayerData: multiplayerData,
        activePacks: activePacksFacet,
        onDeactivatePack: onDeactivatePack
      });
    } else {
      multiplayer.multiplayerGame = newValue;
    }
  }, [showMultiplayerPlatformLockedModal, onDeactivatePack, multiplayerData, activePacksFacet], [multiplayerData, activePacksFacet]);
  const multiplayerOffNarrationText = (0,react_facet_src.useFacetMap)((multiplayer, achievementsDisabledMessages) => multiplayer.playerPermissions === PlayerPermissions.OPERATOR && achievementsDisabledMessages.length === 1 ? [t('.narrationMultiplayerAdditionalSettingsDisabled'), tAll('.narrationSuffixEnablesAchievements')].join(' . ') : t('.narrationMultiplayerAdditionalSettingsDisabled'), [t, tAll], [multiplayerData, achievementsDisabledMessages]);
  const multiplayerWarningStateFacet = (0,react_facet_src.useFacetMap)(multiplayerData => multiplayerData.generalWarningState, [], [multiplayerData]);
  const multiplayerWarningStateUnwrap = (0,react_facet_src.useFacetUnwrap)(multiplayerWarningStateFacet);
  const multiplayerWarningState = multiplayerWarningStateUnwrap === react_facet_src.NO_VALUE ? undefined : multiplayerWarningStateUnwrap;
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isAchievementsDisabled: isAchievementsDisabled,
    isLockedTemplate: isLockedTemplate,
    achievementsDisabledMessages: achievementsDisabledMessages,
    multiplayerWarningState: multiplayerWarningState,
    narrationText: tSideMenu('.multiplayerTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNintendoPromotion
  }, /*#__PURE__*/react.createElement(NintendoSubscriptionPromotionPanel, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlaystationPromotion
  }, /*#__PURE__*/react.createElement(PlaystationPlusSubscriptionPromotionPanel, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: premiumAccountInternetServicePromotion,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.multiplayerGameTitle'),
    title: t('.multiplayerGameTitle'),
    description: t('.multiplayerGameDescription'),
    onNarrationText: t('.narrationMultiplayerAdditionalSettingsEnabled'),
    offNarrationText: multiplayerOffNarrationText,
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(value => value.multiplayerGame, [], [multiplayerData]),
    disabled: multiplayerToggleDisabled,
    onChange: toggleMultiplayer
  })), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.settingsTitle')
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlatformPlayerAccessToggles
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlatformPlayerAccessToggles, {
    gamepadIndex: 1,
    platform: platform,
    multiplayer: multiplayerData
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showMSALogin
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(MSALogin, {
    gamepadIndex: 2,
    disabled: disableMSALogin
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayerAccessToggles
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlayerAccessToggles, {
    gamepadIndex: 2,
    disabled: multiplayerDisabled,
    multiplayer: multiplayerData
  }))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountWithCallback, null, /*#__PURE__*/react.createElement(PlayerPermissionsToggles, {
    multiplayer: multiplayerData,
    gamepadIndex: 3,
    disabled: multiplayerDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showLANInfo
  }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.visibleToLanPlayersTitle'),
    title: t('.visibleToLanPlayersTitle'),
    description: t('.visibleToLanPlayersDescription'),
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    gamepad: {
      index: 4
    },
    disabled: multiplayerDisabled,
    value: (0,react_facet_src.useFacetMap)(value => value.visibleToLanPlayers, [], [multiplayerData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.visibleToLanPlayers = newValue;
    }, [], [multiplayerData])
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.friendlyFireTitle'),
    title: t('.friendlyFireTitle'),
    description: t('.friendlyFireDescription'),
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    gamepad: {
      index: 5
    },
    disabled: multiplayerDisabled,
    value: (0,react_facet_src.useFacetMap)(value => value.friendlyFire, [], [multiplayerData]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.friendlyFire = newValue;
    }, [], [multiplayerData])
  })))))));
}

function PlatformPlayerAccessToggles({
  platform,
  gamepadIndex,
  multiplayer
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  const platformPlayerAccessDisabled = (0,react_facet_src.useFacetMap)(multiplayer => !multiplayer.platformPlayerAccessEnabled || !multiplayer.multiplayerGame, [], [multiplayer]);
  const platformPlayerToggleOptions = (0,react_facet_src.useFacetMemo)((multiplayer, platform) => getPlatformPlayerAccessToggleOptions(multiplayer, platform, t), [t], [multiplayer, platform]); // TODO: Stop unwrapping when underlying components have been updated to accept facet strings

  const platformPlayerAccessTitle = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMemo)(platform => consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessTitle') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessTitle') : t('.playerAccessTitle'), [t], [platform]));
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: platformPlayerAccessTitle === react_facet_src.NO_VALUE ? t('.playerAccessTitle') : platformPlayerAccessTitle,
    gamepad: {
      index: gamepadIndex
    },
    disabled: platformPlayerAccessDisabled,
    wrapToggleText: true,
    options: platformPlayerToggleOptions,
    value: (0,react_facet_src.useFacetMap)(value => value.platformPlayerAccess, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.platformPlayerAccess = newValue;
    }, [], [multiplayer])
  });
}

function PlayerAccessToggles({
  disabled,
  gamepadIndex,
  multiplayer
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  const platformPlayerAccessSupported = (0,react_facet_src.useFacetMap)(multiplayer => multiplayer.platformPlayerAccessSupported, [], [multiplayer]);
  const title = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMemo)(platformPlayerAccessSupported => // If you're on a third party, prefix with "Microsoft" to make it clearer for the user
  platformPlayerAccessSupported ? t('.microsoftPlayerAccessTitle') : t('.playerAccessTitle'), [t], [platformPlayerAccessSupported]));
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: title !== react_facet_src.NO_VALUE ? title : t('.playerAccessTitle'),
    gamepad: {
      index: gamepadIndex
    },
    disabled: disabled,
    wrapToggleText: true,
    options: [{
      label: t('.playerAccessInvitedLabel'),
      value: PlayerAccess.INVITED,
      description: t('.playerAccessInvitedDescription')
    }, {
      label: t('.playerAccessFriendsLabel'),
      value: PlayerAccess.FRIENDS,
      description: t('.playerAccessFriendsDescription')
    }, {
      label: t('.playerAccessFriendsOfFriendsLabel'),
      value: PlayerAccess.FRIENDS_OF_FRIENDS,
      description: t('.playerAccessFriendsOfFriendsDescription')
    }],
    value: (0,react_facet_src.useFacetMap)(value => value.playerAccess, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.playerAccess = newValue;
    }, [], [multiplayer])
  });
}

function PlayerPermissionsToggles({
  multiplayer,
  gamepadIndex,
  disabled,
  achievementsDisabledMessages
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  const {
    t: a
  } = localization_useLocalization('CreateNewWorld.all');
  const options = (0,react_facet_src.useFacetMap)((multiplayer, achievementsDisabledMessages) => [{
    label: t('.playerPermissionsVisitorLabel'),
    value: PlayerPermissions.VISITOR,
    description: t('.playerPermissionsVisitorDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.VISITOR,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.VISITOR,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.VISITOR,
        status: 'unselected'
      })
    },
    narrationSuffix: multiplayer.playerPermissions === PlayerPermissions.OPERATOR && achievementsDisabledMessages.length === 1 ? a('.narrationSuffixEnablesAchievements') : undefined
  }, {
    label: t('.playerPermissionsMemberLabel'),
    value: PlayerPermissions.MEMBER,
    description: t('.playerPermissionsMemberDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.MEMBER,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.MEMBER,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.MEMBER,
        status: 'unselected'
      })
    },
    narrationSuffix: multiplayer.playerPermissions === PlayerPermissions.OPERATOR && achievementsDisabledMessages.length === 1 ? a('.narrationSuffixEnablesAchievements') : undefined
  }, {
    label: t('.playerPermissionsOperatorLabel'),
    value: PlayerPermissions.OPERATOR,
    description: t('.playerPermissionsOperatorDescription'),
    icons: {
      disabled: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.OPERATOR,
        status: 'disabled'
      }),
      selected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.OPERATOR,
        status: 'selected'
      }),
      unselected: /*#__PURE__*/react.createElement(PlayerPermissionIcon_PlayerPermissionIcon, {
        type: PlayerPermissions.OPERATOR,
        status: 'unselected'
      })
    },
    narrationSuffix: a('.narrationSuffixDisablesAchievements')
  }], [t, a], [multiplayer, achievementsDisabledMessages]);
  return /*#__PURE__*/react.createElement(Toggles_Toggles, {
    disabledNarrationSuffix: t('.multiplayerSettingsDisabledNarrationHint'),
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: t('.playerPermissionsTitle'),
    gamepad: {
      index: gamepadIndex
    },
    disabled: disabled,
    options: options,
    value: (0,react_facet_src.useFacetMap)(value => value.playerPermissions, [], [multiplayer]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.playerPermissions = newValue;
    }, [], [multiplayer])
  });
}
/**
 * Returns the Toggles options for alternative multiplayer platforms (PS & Nintendo).
 */


function getPlatformPlayerAccessToggleOptions(multiplayer, platform, t) {
  const toggles = [];

  if (multiplayer.platformPlayerInviteAccessSupported && !consoles_isNintendoPlatform(platform) && !consoles_isPlaystationPlatform(platform)) {
    toggles.push({
      label: t('.playerAccessInvitedLabel'),
      value: PlayerAccess.INVITED,
      description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessInvitedDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessInvitedDescription') : t('.playerAccessInvitedDescription')
    });
  }

  toggles.push({
    label: t('.playerAccessFriendsLabel'),
    value: PlayerAccess.FRIENDS,
    description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessFriendsDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessFriendsDescription') : t('.playerAccessFriendsDescription')
  });
  toggles.push({
    label: t('.playerAccessFriendsOfFriendsLabel'),
    value: PlayerAccess.FRIENDS_OF_FRIENDS,
    description: consoles_isNintendoPlatform(platform) ? t('.nintendoPlayerAccessFriendsOfFriendsDescription') : consoles_isPlaystationPlatform(platform) ? t('.playstationPlayerAccessFriendsOfFriendsDescription') : t('.playerAccessFriendsOfFriendsDescription')
  });
  return toggles;
}

function NintendoSubscriptionPromotionPanel() {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: true,
    gamepadIndex: 0,
    title: t('.nintendoSubscriptionPromotionTitle'),
    text: t('.nintendoSubscriptionPromotionBody'),
    imgSrc: steve_island_namespaceObject,
    imgClass: MultiplayerTab.subscriptionImage,
    buttons: [{
      text: t('.nintendoSubscriptionPromotionButtonLabel'),
      onClick: (0,react_facet_src.useFacetCallback)(facet => () => facet.showPremiumNetworkUpsellModal(), [], [(0,react_facet_src.useSharedFacet)(userAccountFacet)]),
      inputLegend: t('.nintendoSubscriptionPromotionButtonLabel')
    }]
  });
}

function PlaystationPlusSubscriptionPromotionPanel() {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: true,
    gamepadIndex: 0,
    title: t('.playStationPlusSubscriptionPromotionTitle'),
    text: t('.playStationPlusSubscriptionPromotionBody'),
    imgSrc: steve_island_namespaceObject,
    imgClass: MultiplayerTab.subscriptionImage
  });
}

function MSALogin({
  gamepadIndex,
  disabled
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.multiplayer');
  const showMSASignInScreen = (0,react_facet_src.useFacetCallback)(userAccount => () => userAccount.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING), [], [(0,react_facet_src.useSharedFacet)(userAccountFacet)]);
  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.microsoftSignInButtonTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.microsoftSignInButtonLabel'),
    onClick: showMSASignInScreen,
    gamepadIndex: gamepadIndex,
    disabled: disabled
  }, t('.microsoftSignInButtonLabel')));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabs/PackTabs.tsx






const PackTabs = props => {
  const {
    gamepadAliasNamespace,
    path,
    narrationTitle
  } = props;
  const {
    t
  } = useLocalization_useLocalization('PackTabs');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const mode = (0,react.useContext)(WorldModeContext);
  const isEditWorld = mode === 'edit';
  const params = RouterEngineProvider_useRouteParamsUnwrapped(); // worldTemplateId used as placeholder for active|available filter param

  const tabs = [{
    label: t('.activeTabButtonLabel'),
    value: 'active'
  }, {
    label: t('.availableTabButtonLabel'),
    value: 'available'
  }];
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const prefix = isEditWorld ? `edit-world/${params.id}` : `create-new-world`;
  return /*#__PURE__*/react.createElement(TabBar_TabBar_TabBar, {
    gamepadAliasNamespace: gamepadAliasNamespace,
    gamepadIndex: 1,
    value: params.worldTemplateId // active|available
    ,
    onChange: newValue => {
      setFocusedId(TabBar_TabBar_TabBar.getFocusAlias(gamepadAliasNamespace, newValue));
      historyAPI.replace(`/${prefix}/${path}/${newValue}`);
    },
    tabs: tabs,
    enableGamepadShortcuts: params.tab === path,
    narrationTitle: narrationTitle
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabs/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabWrapper/PackTabWrapper.tsx








/**
 * Wrapper component that uses the route status to decide if the Tab component
 * should be rendered or not.
 */
function PackTabWrapper({
  component,
  filter,
  gamepadIndex
}) {
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const visible = params.worldTemplateId === filter;
  const parentRouteActive = useRouteActive();
  const active = (0,react_facet_src.useFacetMap)(parentRouteActive => visible && parentRouteActive, [visible], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: active
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex,
      disabled: !visible
    }
  }, /*#__PURE__*/react.createElement(RouteInstantTransition_RouteInstantTransition, {
    visible: visible,
    contentComponent: component,
    unmountOnExit: false
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackTabWrapper/index.ts

;// CONCATENATED MODULE: ./packages/gameface-hacks/src/map.ts
// Temporary hack until Gameface supports `map` on ChakraCore on iOS.
//
// Differs from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
// in that it does not accept a `thisArg` parameters, and the input and output arrays are of type T[] and
// T2[] respectively.
function map(array, f) {
  const result = [];

  for (let i = 0; i < array.length; i++) {
    result[i] = f(array[i], i, array);
  }

  return result;
}
;// CONCATENATED MODULE: ./packages/gameface-hacks/src/every.ts
function every(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    if (!predicate(array[i], i)) {
      return false;
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./packages/ui/src/Tag/Tag.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Tag_Tag = ({"tag":"c3aSY","tagWrapper":"j_y1K"});
;// CONCATENATED MODULE: ./packages/ui/src/Tag/Tag.tsx







function Tag_Tag_Tag({
  children,
  role
}) {
  const semanticColors = hooks_useSemanticColors();
  const tagClasses = (0,react_facet_src.useFacetMap)(role => classnames_default()(Tag_Tag.tag, semanticColors[role].background.base, semanticColors[role].text.base), [semanticColors], [(0,react_facet_src.useFacetWrap)(role)]);
  return /*#__PURE__*/react.createElement("div", {
    className: Tag_Tag.tagWrapper
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: tagClasses
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: role
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, children))), /*#__PURE__*/react.createElement("fast-div", {
    className: Tag_Tag.shadowBottom
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: Tag_Tag.shadowRight
  }));
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useDrag.ts



function useDrag({
  id,
  data,
  index,
  ref,
  pointerAxisLock,
  onDragStart,
  disabled,
  gamepadDragXOffsetPx,
  gamepadDragYOffsetPx
}) {
  const api = useDragAndDropProviderApi();
  const draggableStatesFacet = useDraggableStatesFacet();
  const dragStateFacet = (0,react_facet_src.useFacetMap)(draggableStates => draggableStates[id], [id], [(0,react_facet_src.useFacetWrap)(draggableStatesFacet !== null && draggableStatesFacet !== void 0 ? draggableStatesFacet : {})]);
  (0,react.useEffect)(() => {
    if (api == null) return;
    if (disabled == true) return; // Register draggable and get reference to state facet.

    api.addDraggable({
      id,
      index,
      data,
      ref,
      pointerAxisLock,
      onDragStart,
      gamepadDragXOffsetPx,
      gamepadDragYOffsetPx
    });
    return () => {
      api.removeDraggable(id);
    };
  }, [id, data, api, ref, index, pointerAxisLock, onDragStart, gamepadDragXOffsetPx, gamepadDragYOffsetPx, disabled]);
  const onGamepadDirectionPress = (0,react_facet_src.useFacetCallback)(state => direction => {
    if (state.dragging == 'gamepad' && api != null) {
      if (direction === 'up' || direction == 'down') {
        api.focusDragMove(direction);
      }
    }

    return state.dragging != false ? true : false;
  }, [api], [dragStateFacet]);
  const onMouseDown = (0,react.useCallback)(event => {
    if (api == null || event == null) return; // @TODO research if it can be TouchEvent

    const {
      clientX,
      clientY
    } = event.clientX != null ? event : event.touches[0];

    if (onDragStart) {
      onDragStart(() => {
        api.pointerDragStart(id, clientX, clientY);
      });
    } else {
      api.pointerDragStart(id, clientX, clientY);
    }
  }, [api, id, onDragStart]);
  const onGamepadClick = (0,react.useCallback)(() => {
    if (api == null) return;

    if (onDragStart) {
      onDragStart(() => {
        api.focusDragToggle(id);
      });
    } else {
      api.focusDragToggle(id);
    }
  }, [api, onDragStart, id]);
  const handlers = (0,react.useMemo)(() => ({
    onMouseDown,
    onGamepadClick,
    onUp: () => onGamepadDirectionPress('up') === true,
    onDown: () => onGamepadDirectionPress('down') === true,
    onLeft: () => onGamepadDirectionPress('left') === true,
    onRight: () => onGamepadDirectionPress('right') === true
  }), [onMouseDown, onGamepadClick, onGamepadDirectionPress]);
  return {
    dragStateFacet,
    handlers
  };
}
;// CONCATENATED MODULE: ./packages/react-dnd/src/useDrop.ts



function useDrop({
  id,
  index,
  ref,
  data,
  disabled,
  onDrop
}) {
  const api = useDragAndDropProviderApi();
  const droppableStatesFacet = useDroppableStatesFacet();
  const stateFacet = (0,react_facet_src.useFacetMap)(droppableStates => droppableStates[id] != null ? droppableStates[id] : {}, [id], [(0,react_facet_src.useFacetWrap)(droppableStatesFacet !== null && droppableStatesFacet !== void 0 ? droppableStatesFacet : {})]);
  (0,react.useEffect)(() => {
    if (api == null) return;
    if (disabled == true) return;
    api.addDroppable({
      id,
      index,
      ref,
      data,
      onDrop
    });
    return () => {
      api.removeDroppable(id);
    };
  }, [id, index, ref, data, onDrop, api, disabled]);
  return stateFacet;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/draggable-icon.png
const draggable_icon_namespaceObject = __webpack_require__.p + "assets/draggable-icon-bcf37.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/arrow-down.png
const arrow_down_namespaceObject = __webpack_require__.p + "assets/arrow-down-cf46b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/remove-icon.png
const remove_icon_namespaceObject = __webpack_require__.p + "assets/remove-icon-5a112.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/settings-icon.png
const settings_icon_namespaceObject = __webpack_require__.p + "assets/settings-icon-af819.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/add-icon.png
const add_icon_namespaceObject = __webpack_require__.p + "assets/add-icon-675d0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/warning-icon.png
const warning_icon_namespaceObject = __webpack_require__.p + "assets/warning-icon-e02fb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/mario_pack_icon_HACK.png
const mario_pack_icon_HACK_namespaceObject = __webpack_require__.p + "assets/mario_pack_icon_HACK-36558.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/images/missing-pack-icon.png
const missing_pack_icon_namespaceObject = __webpack_require__.p + "assets/missing-pack-icon-0a761.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/PackListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PackListItem = ({"packListItemDragAnimationContainer":"K_ftf","packImage":"jkWPs","border":"IyJVt","draggableIcon":"yh9nh","expandArrowIcon":"ZVibx","flipped":"s7QSb","settingsIcon":"RvsYq","removeIcon":"jrqnD","addIcon":"v5aeN","expandableWrapper":"KpUwY","expanded":"ZFmh4","expandableContent":"S0c54","expandableContentWrapper":"cDMTw","expandableContentDescription":"emj3l","expandableContentLinksWrapper":"H2ovu","disabledPackImage":"qCfGN"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/hooks/useExpandable.ts

 // Can't set to exact zero due to Gameface bug with scrollHeight. Ticket here: https://coherentlabs.zendesk.com/hc/en-us/requests/19103

const GAMEFACE_ZERO = '0.0001px';
function useExpandable(expanded) {
  const contentRef = (0,react.useRef)(null);
  const expandedFacet = (0,react_facet_src.useFacetWrap)(expanded);
  const [height, setHeight] = (0,react_facet_src.useFacetState)(GAMEFACE_ZERO);
  const [overflow, setOverflow] = (0,react_facet_src.useFacetState)('hidden');
  (0,react_facet_src.useFacetEffect)(isExpanded => {
    if (!contentRef.current) return; // When we are running screenshot tests we don't want to wait for the timeout.

    if (false) {}

    setHeight(`${contentRef.current.scrollHeight}px`);

    if (isExpanded) {
      const timeOut = setTimeout(() => {
        setHeight('auto');
        setOverflow('visible');
      }, 225);
      return () => {
        clearTimeout(timeOut);
      };
    }

    if (!isExpanded) {
      requestAnimationFrame(() => {
        setHeight(GAMEFACE_ZERO);
        setOverflow('hidden');
      });
    }
  }, [setOverflow, setHeight], [expandedFacet]);
  return [{
    height,
    overflow
  }, contentRef];
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useActivateDeactivatePacks.tsx
function useActivateDeactivatePacks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function useActivateDeactivatePacks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useActivateDeactivatePacks_ownKeys(Object(source), true).forEach(function (key) { useActivateDeactivatePacks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useActivateDeactivatePacks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useActivateDeactivatePacks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








const BEHAVIOR_PACKS_TAB = 'behaviorPacks';

function packCollectionKeysWithResourcePacksAndGamepadAliasesEqualityCheck() {
  const previous = {
    active: 0,
    available: 0,
    realms: 0
  };
  return current => {
    return Object.keys(previous).reduce((acc, cur) => {
      var _current$resourcePack, _current, _current$resourcePack2;

      // Behavior packs doesn't have realms
      const currentLength = (_current$resourcePack = (_current = current[cur]) === null || _current === void 0 ? void 0 : (_current$resourcePack2 = _current.resourcePacks) === null || _current$resourcePack2 === void 0 ? void 0 : _current$resourcePack2.length) !== null && _current$resourcePack !== void 0 ? _current$resourcePack : 0;
      const isEqual = previous[cur] === currentLength;
      previous[cur] = currentLength;

      if (!acc) {
        return acc;
      }

      return isEqual;
    }, true);
  };
}

function usePackOperationNarration() {
  const firstTimeAPackIsActivated = (0,react.useRef)(true);
  const {
    narrateText
  } = useNarrateText_useNarrateText({
    interruptible: false
  });
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacks');
  return (0,react.useCallback)(operation => {
    // Check if this is the first available pack to be activated
    if (firstTimeAPackIsActivated.current && operation === 'activate') {
      narrateText(t('.activateNarrationFirstPack'));
      firstTimeAPackIsActivated.current = false;
    } else {
      narrateText(t(`.${operation}Narration`));
    }
  }, [narrateText, t]);
}

function useActivateDeactivatePacks(packTypeKey, packsGamepadAliases, worldPacks, multiplayerData, onActivatePack, onDeactivatePack) {
  const {
    narrateText
  } = useNarrateText_useNarrateText({
    interruptible: false
  });
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.resourcePacks');
  const packType = packTypeKey === BEHAVIOR_PACKS_TAB ? PackType.Behavior : PackType.Resource;
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const isNarrationEnabled = useNarrationEnabled();
  const resourcePackId = (0,react.useRef)(null);
  const resourcePackIndex = (0,react.useRef)(null);
  const previousPackCollectionKey = (0,react.useRef)(null);
  const previousOperation = (0,react.useRef)(null);
  const showResourcePacksPlatformLockedModal = ResourcePacksPlatformLockedModal.useShowModal();
  const narrateBehaviorPacksAction = usePackOperationNarration();
  const narrateTexturePacksAction = usePackOperationNarration();
  const deactivatePack = (0,react_facet_src.useFacetCallback)(() => (id, index, currentKey) => {
    resourcePackId.current = id;
    resourcePackIndex.current = index;
    previousPackCollectionKey.current = currentKey;
    previousOperation.current = 'remove';
    onDeactivatePack(id, packType);
  }, [packType, onDeactivatePack], []);
  const activatePack = (0,react_facet_src.useFacetCallback)(multiplayerData => (packId, packName, packSize, packIsPlatformLocked, index, currentKey) => {
    resourcePackId.current = packId;
    resourcePackIndex.current = index;
    previousPackCollectionKey.current = currentKey;
    previousOperation.current = 'activate';

    if (packIsPlatformLocked && multiplayerData.multiplayerGame) {
      showResourcePacksPlatformLockedModal({
        multiplayerData: multiplayerData,
        packId: packId,
        packType: packType,
        packName: packName,
        packSize: packSize,
        onActivatePack: onActivatePack
      });
    } else {
      onActivatePack(packId, packType, packName, packSize);
    }
  }, [packType, onActivatePack, showResourcePacksPlatformLockedModal], [multiplayerData]);
  const packCollectionKeysWithResourcePacksAndGamepadAliases = (0,react_facet_src.useFacetMemo)(worldPacks => Object.keys(packsGamepadAliases).reduce((acc, cur) => {
    const gamepadAliases = packsGamepadAliases[cur];
    const resourcePacks = worldPacks[packTypeKey][cur];
    return useActivateDeactivatePacks_objectSpread(useActivateDeactivatePacks_objectSpread({}, acc), {}, {
      [cur]: {
        gamepadAliases,
        resourcePacks
      }
    });
  }, {}), [packsGamepadAliases, packTypeKey], [worldPacks], packCollectionKeysWithResourcePacksAndGamepadAliasesEqualityCheck);
  (0,react_facet_src.useFacetEffect)(packCollectionKeysWithResourcePacksAndGamepadAliases => {
    // The first time this effect runs it won't be because of a users action.
    // Ensure that the refs have values. If not we should exit early.
    if (resourcePackId.current == null || resourcePackIndex.current == null || previousPackCollectionKey.current == null || previousOperation.current == null) {
      return;
    }

    if (packTypeKey === 'texturePacks') {
      narrateTexturePacksAction(previousOperation.current);
    }

    if (packTypeKey === 'behaviorPacks') {
      narrateBehaviorPacksAction(previousOperation.current);
    }

    const previousResourcePacksWithGamepadAliases = packCollectionKeysWithResourcePacksAndGamepadAliases[previousPackCollectionKey.current]; // We removed the last item of a list. Set the focus id to either the tab
    // or the empty state message (depends if narration is enabled or not)

    const wasLastItemInList = previousResourcePacksWithGamepadAliases.resourcePacks.length === 0;

    if (wasLastItemInList) {
      const nextFocusId = isNarrationEnabled ? previousResourcePacksWithGamepadAliases.gamepadAliases.emptyStateMessageAlias : previousResourcePacksWithGamepadAliases.gamepadAliases.tabsAlias;
      setFocusedId(nextFocusId);
      return;
    } // Not the last item. Therefore, the other items will move up one index,
    // and we want to select the one that took the previous items place (if possible).


    const itemToFocusIndex = previousResourcePacksWithGamepadAliases.resourcePacks[resourcePackIndex.current] != null ? resourcePackIndex.current : resourcePackIndex.current - 1;
    const itemToFocusId = previousResourcePacksWithGamepadAliases.resourcePacks[itemToFocusIndex].id;
    const nextFocusId = createPackActionGamepadAlias(previousOperation.current, itemToFocusId);
    setFocusedId(nextFocusId);
  }, [narrateText, t, setFocusedId, isNarrationEnabled, packTypeKey, narrateTexturePacksAction, narrateBehaviorPacksAction], [packCollectionKeysWithResourcePacksAndGamepadAliases]);
  return {
    deactivatePack,
    activatePack
  };
} // This function is to ensure that the pack list items focus alias stay in sync with what we move the focus to.

function createPackActionGamepadAlias(operation, id) {
  return `${operation}-${id}`;
} // This context is used to keep track of which list a item belonged to before it was
// activated or removed. We use that information when we choose what item we should
// focus next. This could, technically, be deduced from keeping track of all resource
// pack arrays and their length. However, this context reduces the complexity.

const PackCollectionKeyContext = (0,react.createContext)(null);
const usePackCollectionKey = () => (0,react.useContext)(PackCollectionKeyContext);
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/helpers.ts

function useResourcePacksFallback(packFacet) {
  return (0,react_facet_src.useFacetMap)(pack => {
    if (pack != null) return pack;
    return {
      id: '-1',
      contentId: '-1',
      name: '-1',
      creator: '-1',
      description: '-1',
      size: '-1',
      image: undefined,
      isMarketplaceItem: false,
      isPlatformLocked: false,
      hasSettings: false
    };
  }, [], [packFacet]);
} // Used by .filter() to check existence of an element

function exists(x) {
  return x;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/PackListItem.tsx
function PackListItem_extends() { PackListItem_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return PackListItem_extends.apply(this, arguments); }



























 // The Minecraft Texture Pack does not exist on the backend and is currently being
// hardcoded in the UI. We are currently having discussions about it and we are not sure
// if we'll keep it in the new Create New World screen. Therefore, we went with the
// solution of hardcoding the id like this rather than breaking the current interfaces and
// modifying existing functionality.

const MINECRAFT_TEXTURE_PACK_ID = '_GLOBAL_MINECRAFT_TEXTURE_PACK_'; // How much the draggable element is lifted off the page

const DRAG_X_LIFT_REM = -0.4;
const DRAG_Y_LIFT_REM = -0.8;
const MARIO_PACK_ID = '7f4ba1a2-43dd-45b1-aa3f-0b3ca2ebd5c8';

function ActivePack({
  pack: packFacet,
  gamepadIndex,
  index,
  draggable,
  removable,
  activatable,
  canShowSettingsButton = false,
  expandedPackId,
  containerListLength,
  outerRole = 'neutral',
  innerRole = 'neutral80',
  onDragStart = PackListItem_noop,
  onDrop = PackListItem_noop,
  onExpand = PackListItem_noop,
  onRemove = PackListItem_noop,
  onActivate = PackListItem_noop,
  onClickPackSettings = PackListItem_noop,
  onClickMoreDetails = PackListItem_noop,
  showTechnicalDetailsLink = false
}) {
  const {
    t
  } = useLocalization_useLocalization('PackListItem');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const isLastInputPointerFacet = context_useIsLastInputPointer();
  const telemetry = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const draggableFacet = (0,react_facet_src.useFacetWrap)(draggable || false);
  const removableFacet = (0,react_facet_src.useFacetWrap)(removable !== null && removable !== void 0 ? removable : false);
  const activatableFacet = (0,react_facet_src.useFacetWrap)(activatable !== null && activatable !== void 0 ? activatable : false); // Dummy resourcePack when the pack is undefined to avoid asserts triggering

  const newPackFacet = useResourcePacksFallback(packFacet);
  const packId = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(pack => pack.id, [], [newPackFacet]));
  const packName = (0,react_facet_src.useFacetMap)(pack => pack.name, [], [newPackFacet]);
  const packSize = (0,react_facet_src.useFacetMap)(pack => pack.size, [], [newPackFacet]);
  const packDescription = (0,react_facet_src.useFacetMap)(pack => pack.description, [], [newPackFacet]);
  const packIsPlatformLocked = (0,react_facet_src.useFacetMap)(pack => pack.isPlatformLocked, [], [newPackFacet]);
  const packIsPlatformLockedRef = (0,react_facet_src.useFacetRef)(packIsPlatformLocked, false);
  const packErrorMessage = (0,react_facet_src.useFacetMap)(pack => {
    switch (pack.error) {
      case PackActionError.PackDependencyWarning:
        return t('.errorPackMissingDependencies');

      case PackActionError.ContentTierIncompatible:
        return t('.errorPackNotCompatible');

      case PackActionError.ContentTierIncompatibleMemory:
        return t('.errorPackNotCompatibleMemory');

      case PackActionError.ContentTierIncompatibleRayTracing:
        return t('.errorPackNotCompatibleRayTracing');

      case PackActionError.NoPackAccess:
        return t('.errorPackAccess');

      case PackActionError.UnsupportedFileFormat:
        return t('.errorPackUnsupportedFormat');

      case PackActionError.NoManifest:
      case PackActionError.MissingProperty:
      case PackActionError.WrongTypeProperty:
      case PackActionError.EmptyProperty:
      case PackActionError.InvalidProperty:
      case PackActionError.MalformedPropertyUUID:
      case PackActionError.MalformedPropertyVERSION:
      case PackActionError.DuplicateUUID:
      case PackActionError.InvalidJSON:
      case PackActionError.MissingModules:
      case PackActionError.MultipleModules:
      case PackActionError.UnsupportedFormatVersion:
        return t('.errorPackReading');

      case PackActionError.VersionTooHigh:
      case PackActionError.VersionTooLow:
        return t('.errorPackIncompatibleVersion');

      case PackActionError.IncompletePack:
        return t('.errorPackIncomplete');

      default:
        return '';
      // Empty string (no error message).
    }
  }, [t], [newPackFacet]);
  const packErrorMessageRole = (0,react_facet_src.useFacetMap)(pack => {
    if (pack.error === PackActionError.PackDependencyWarning || pack.error === PackActionError.IncompletePack || pack.error === PackActionError.VersionTooHigh || pack.error === PackActionError.VersionTooLow) {
      return 'noticeTint'; // Warning.
    } else {
        return 'destructiveTint'; // Error.
      }
  }, [], [newPackFacet]);
  const packHasError = (0,react_facet_src.useFacetMap)(message => message.length != 0, [], [packErrorMessage]);
  const packHasErrorAndDownloaded = (0,react_facet_src.useFacetMap)((packHasError, pack) => {
    if (packHasError && pack.error !== PackActionError.NeedToDownloadPack) {
      // Error messages should only appear on active packs except for the 3 warnings below.
      return canShowSettingsButton || // i.e. active pack.
      pack.error === PackActionError.VersionTooHigh || pack.error === PackActionError.VersionTooLow || pack.error === PackActionError.IncompletePack;
    }

    return false;
  }, [canShowSettingsButton], [packHasError, newPackFacet]);
  const isNotMarketplaceItem = (0,react_facet_src.useFacetMap)(pack => !pack.isMarketplaceItem, [], [newPackFacet]);
  const packImage = (0,react_facet_src.useFacetMap)(pack => {
    const packImage = pack.image != null && pack.image.length > 0 ? pack.image : missing_pack_icon_namespaceObject; // while waiting for bug 772743 to be resolved by Core UI, the C++ side
    // currently doesn't have the ability to expose images from an embedded
    // resource pack to JavaScript, so until the bug is resolved we have to hack
    // the image this way.
    // https://dev-mc.visualstudio.com/Minecraft/_workitems/edit/772743

    const packImageOrMarioIcon = pack.id.startsWith(MARIO_PACK_ID) ? mario_pack_icon_HACK_namespaceObject : packImage;
    return packImageOrMarioIcon;
  }, [], [newPackFacet]);
  const droppableRef = (0,react.useRef)(null);
  const expandButtonGamepadIndex = (0,react_facet_src.useFacetMap)(draggable => draggable ? 1 : 0, [], [draggableFacet]);
  const expanded = (0,react_facet_src.useFacetMap)(expandedId => expandedId === packId, [packId], [expandedPackId]);
  const notExpanded = (0,react_facet_src.useFacetUnwrap)(expanded) === false;
  const disabled = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(draggable => !draggable, [], [draggableFacet])) === true;
  const {
    handlers,
    dragStateFacet
  } = useDrag({
    data: index,
    id: packId,
    index,
    onDragStart,
    pointerAxisLock: 'y',
    ref: droppableRef,
    disabled,
    gamepadDragXOffsetPx: useSizeInPixels(DRAG_X_LIFT_REM),
    gamepadDragYOffsetPx: useSizeInPixels(DRAG_Y_LIFT_REM)
  });
  const dropStateFacet = useDrop({
    id: packId,
    index,
    data: index,
    onDrop: (previousIndex, newIndex) => {
      // Narration: After the user re-orders
      // Keep in setTimeout to override other focus narration
      setTimeout(() => {
        narrateText(t('.narrationReorderComplete', [`${newIndex + 1}`]));
      }, 16); // Call prop onDrop handler.

      onDrop(packId, previousIndex, newIndex);
    },
    ref: droppableRef,
    disabled
  });
  const draggingFacet = (0,react_facet_src.useFacetMap)(state => state != null && state.dragging != false, [], [dragStateFacet]);
  const dragTypeFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.dragging : false, [], [dragStateFacet]);
  const displacementFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.displacement : 0, [], [dropStateFacet]);
  const dragZIndexFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.zIndex : '', [], [dragStateFacet]);
  const dragTransformFacet = (0,react_facet_src.useFacetMap)(state => state != null ? state.transform : '', [], [dragStateFacet]);
  const displacementTransformStyle = (0,react_facet_src.useFacetMap)(displacement => displacement == null ? '' : `translate(0, ${`${displacement * 100}%`})`, [], [displacementFacet]);
  const dragDropTransformLeft = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_X_LIFT_REM}rem` : '0', [], [draggingFacet]);
  const dragDropTransformTop = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_Y_LIFT_REM}rem` : '0', [], [draggingFacet]);
  const dragDropBoxShadowStyle = (0,react_facet_src.useFacetMap)(dragging => dragging ? `${DRAG_X_LIFT_REM * -1.8}rem ${DRAG_Y_LIFT_REM * -1.8}rem 0 rgba(0, 0, 0, 0.3)` : ``, [], [draggingFacet]);
  const dragButtonText = (0,react_facet_src.useFacetMap)(dragging => dragging ? t('.dropInputLegendText') : t('.dragInputLegendText'), [t], [draggingFacet]);
  const droppableTransitionStyle = (0,react_facet_src.useFacetMap)((dragging, displacement) => // We remove the transform transition when nothing is being dragged
  // to prevent it sliding into it's new position after an onDrop re-arrangement.
  // We also remove the transition for the dragged element, because it
  // isn't running smoothly in gameface (unsure why).
  displacement != null && !dragging ? 'transform 100ms linear' : '', [], [draggingFacet, displacementFacet]);
  const draggableTransitionStyle = (0,react_facet_src.useFacetMap)(dragType => dragType === 'gamepad' ? 'transform 100ms linear' : '', [], [dragTypeFacet]);
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const onExpandCallback = (0,react_facet_src.useFacetCallback)((pack, expanded) => () => {
    // This callback is called before the expanded boolean has flipped.
    expanded = !expanded;
    narrateText([t(expanded ? '.narrationExpanded' : '.narrationCollapsed'), expanded ? t('.narrationExpandedHint') : null].filter(exists).join(' . '));
    onExpand(pack.id);
  }, [onExpand, narrateText, t], [packFacet, expanded]);

  const onClickMoreDetailsWithPackId = () => onClickMoreDetails(typeof packId === 'string' ? packId : '');

  const onClickTechnicalDetails = (0,react_facet_src.useFacetCallback)((pack, telemetry) => () => {
    telemetry.fireEventButtonPressed('Resource_Pack_Pack_Manifest_Button_OreUI', {});
    historyAPI.push(`/manifest-validation/${pack.id}`);
  }, [historyAPI], [packFacet, telemetry]);
  const expandInputLegend = (0,react_facet_src.useFacetMap)(isExpanded => t(isExpanded ? '.collapseDescriptionInputLegend' : '.expandDescriptionInputLegend'), [t], [expanded]);
  const expandArrowClassName = (0,react_facet_src.useFacetMap)(isExpanded => classnames_default()(PackListItem.expandArrowIcon, {
    [PackListItem.flipped]: isExpanded
  }), [], [expanded]);
  const shouldMountSettingsButton = (0,react_facet_src.useFacetMap)(pack => pack.hasSettings && canShowSettingsButton, [canShowSettingsButton], [packFacet]); // Narration: Contextual pack information, wrapping the list item and expandable content.

  const contextNarration = (0,react_facet_src.useFacetMap)((packName, containerListLength) => [packName, t('.narrationComponentType'), containerListLength > 0 ? t('.narrationListLengthContext', [`${index + 1}`, `${containerListLength}`]) : undefined].filter(exists).join(' . '), [t, index], [packName, (0,react_facet_src.useFacetWrap)(containerListLength !== null && containerListLength !== void 0 ? containerListLength : 0)]); // Narration: Expandable cell containing pack description

  const descriptionButtonNarration = (0,react_facet_src.useFacetMap)((expanded, removable, hasSettings) => [t('.narrationPackDescription'), t('.narrationAccordion'), t(expanded ? '.narrationExpanded' : '.narrationCollapsed'), !expanded ? removable || hasSettings ? t('.narrationExpandHint') : t('.narrationExpandHintNoButtons') : null].filter(exists).join(' . '), [t], [expanded, removableFacet, shouldMountSettingsButton]); // Narration: Focus narration for the re-order button

  const reorderButtonNarration = (0,react_facet_src.useFacetMap)(isPointer => [t('.narrationReorderPack'), t('.narrationPackRank', [`${index + 1}`]), t('.narrationButton'), t(isPointer ? '.narrationReorderPointerHint' : '.narrationReorderGamepadHint'), t('.narrationMultiplePacksHint')].filter(exists).join(' . '), [t, index], [isLastInputPointerFacet]);
  const gamepadHoverIndex = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.gamepadHoverIndex, [], [dragStateFacet]);
  const pointerHoverIndex = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.pointerHoverIndex, [], [dragStateFacet]);
  const hasDraggedBeyondStartArea = (0,react_facet_src.useFacetMap)(dragState => dragState === null || dragState === void 0 ? void 0 : dragState.hasDraggedPointerBeyondStartArea, [], [dragStateFacet]); // Narration: User drags pack into new rank

  (0,react_facet_src.useFacetEffect)((dragging, gamepadHoverIndex, pointerHoverIndex, isPointer, hasDraggedBeyondStartArea) => {
    if (!dragging || gamepadHoverIndex == null && pointerHoverIndex == null) {
      return;
    } // If using a pointer


    if (isPointer && pointerHoverIndex != null && hasDraggedBeyondStartArea) {
      narrateText(t('.narrationReorderPointerChangeConfirmation', [`${pointerHoverIndex + 1}`]));
    } else if (gamepadHoverIndex != null) {
      narrateText(t('.narrationReorderGamepadChangeConfirmation', [`${gamepadHoverIndex + 1}`]));
    }
  }, [narrateText, t], [draggingFacet, gamepadHoverIndex, pointerHoverIndex, isLastInputPointerFacet, hasDraggedBeyondStartArea]); // Narration: User begins re-ordering.
  // This should occur after the previous dragging narration to override it on the initial drag start.

  (0,react_facet_src.useFacetEffect)((dragging, isPointer) => {
    if (!dragging) {
      return;
    }

    if (isPointer) {
      narrateText(t('.narrationReorderPointerDraggingHint'));
    } else {
      narrateText(t('.narrationReorderGamepadDraggingHint'));
    }
  }, [narrateText, t], [draggingFacet, isLastInputPointerFacet]);
  const packCollectionKey = usePackCollectionKey();
  const semanticSounds = useSemanticSounds(outerRole);
  const semanticColors = hooks_useSemanticColors(outerRole);
  const mainActionSound = (0,react_facet_src.useFacetMap)(expanded => expanded ? semanticSounds.contract : semanticSounds.expand, [semanticSounds], [expanded]); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to packId --> only render when packId is available

  if (packId == react_facet_src.NO_VALUE) return null;
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: contextNarration,
    key: packId
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: outerRole
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    style: {
      top: dragDropTransformTop,
      left: dragDropTransformLeft,
      zIndex: dragZIndexFacet
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: droppableRef,
    style: {
      transform: dragTransformFacet,
      transition: draggableTransitionStyle
    },
    className: PackListItem.packListItemContent
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: PackListItem.packListItemDragAnimationContainer,
    style: {
      transform: displacementTransformStyle,
      boxShadow: dragDropBoxShadowStyle,
      transition: droppableTransitionStyle
    }
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: draggableFacet
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, PackListItem_extends({
    fitContent: true,
    onClick: PackListItem_noop,
    inputLegend: dragButtonText,
    narrationText: reorderButtonNarration,
    gamepadIndex: 0,
    touchDetectionDelay: 0,
    soundEffectPressed: semanticSounds.lift
  }, handlers), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: draggable_icon_namespaceObject,
    className: PackListItem.draggableIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort"
  }, index + 1), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: expandInputLegend,
    gamepadIndex: expandButtonGamepadIndex,
    narrationText: descriptionButtonNarration,
    onClick: onExpandCallback,
    soundEffectPressed: mainActionSound
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: packImage,
    className: classnames_default()(PackListItem.packImage, semanticColors.border.base, PackListItem.border)
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, packName)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: packHasErrorAndDownloaded
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: packErrorMessageRole
  }, packErrorMessage))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: arrow_down_namespaceObject,
    className: expandArrowClassName,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }))),
  /*#__PURE__*/
  // Settings button
  react.createElement(react_facet_src.Mount, {
    when: shouldMountSettingsButton
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.settingsButtonText'),
    onClick: () => onClickPackSettings(packId),
    narrationText: t('.narrationSettingsButton'),
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: settings_icon_namespaceObject,
    className: PackListItem.settingsIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.settingsButtonText'))))),
  /*#__PURE__*/
  // Remove button
  react.createElement(react_facet_src.Mount, {
    when: removableFacet
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.removeButtonText'),
    onClick: () => onRemove(packId, index, packCollectionKey),
    narrationText: t('.narrationRemoveButton'),
    gamepadIndex: 3,
    gamepadAlias: createPackActionGamepadAlias('remove', packId)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: remove_icon_namespaceObject,
    className: PackListItem.removeIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.removeButtonText'))))),
  /*#__PURE__*/
  // Details button.
  react.createElement(react_facet_src.Mount, {
    when: packHasErrorAndDownloaded
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.detailsButtonText'),
    onClick: onClickTechnicalDetails,
    narrationText: t('.narrationDetailsButton'),
    gamepadIndex: 4
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: warning_icon_namespaceObject,
    className: PackListItem.addIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.detailsButtonText'))))),
  /*#__PURE__*/
  // Activate Button
  react.createElement(react_facet_src.Mount, {
    when: activatableFacet
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.activateButtonText'),
    onClick: () => onActivate(packId, packName, packSize, packIsPlatformLockedRef.current, index, packCollectionKey),
    narrationText: t('.narrationActivateButton'),
    gamepadIndex: 2,
    gamepadAlias: createPackActionGamepadAlias('activate', packId)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: add_icon_namespaceObject,
    className: PackListItem.addIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.activateButtonText'))))))))), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    disabled: notExpanded,
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(ExpandableContent, {
    size: packSize,
    description: packDescription,
    onClickMoreDetails: onClickMoreDetailsWithPackId,
    onClickTechnicalDetails: onClickTechnicalDetails,
    expanded: expanded,
    hideMarketplaceLink: isNotMarketplaceItem,
    hideSize: isNotMarketplaceItem,
    outerRole: outerRole,
    innerRole: innerRole // We don't show the technical details link for the 'fake' global
    // texture pack (but we do show it for other global packs)
    ,
    showTechnicalDetailsLink: showTechnicalDetailsLink && packId != MINECRAFT_TEXTURE_PACK_ID
  }))))));
}

function ExpandableContent({
  expanded,
  description,
  size,
  onClickMoreDetails,
  onClickTechnicalDetails,
  hideMarketplaceLink,
  hideSize,
  outerRole,
  innerRole,
  showTechnicalDetailsLink = false
}) {
  const ref = (0,react.useRef)(null);
  const {
    t
  } = useLocalization_useLocalization('PackListItem');
  const [expandableStyles, contentRef] = useExpandable(expanded);
  const linkDisabled = (0,react_facet_src.useFacetMap)(isExpanded => !isExpanded, [], [expanded]);
  const semanticColors = hooks_useSemanticColors(outerRole);
  const semanticColorsInner = hooks_useSemanticColors(innerRole);
  const narrationContext = (0,react_facet_src.useFacetMap)((size, description, hideSize) => [hideSize ? null : size, description].filter(exists).join(' . '), [], [size, description, hideSize]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationContext
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    delegateFocusFromMemory: true
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(isExpanded => classnames_default()(PackListItem.expandableWrapper, semanticColors.background.base, {
      [PackListItem.expanded]: isExpanded
    }), [semanticColors], [expanded]),
    ref: ref,
    style: expandableStyles
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: innerRole
  }, /*#__PURE__*/react.createElement("div", {
    ref: contentRef
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    narrationText: false,
    gamepadIndex: 0,
    isInteractive: hideMarketplaceLink,
    className: classnames_default()(PackListItem.expandableContent, semanticColorsInner.background.base, semanticColorsInner.border.base),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: PackListItem.expandableContentWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: PackListItem.expandableContentDescription
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, description), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideMarketplaceLink,
    condition: false
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    disabled: linkDisabled,
    gamepadIndex: 0,
    onClick: onClickMoreDetails,
    withUnderlinePolyfill: true
  }, t(`.descriptionMarketplaceLink`))))), /*#__PURE__*/react.createElement("div", {
    className: PackListItem.expandableContentLinksWrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideSize,
    condition: false
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, size)), showTechnicalDetailsLink && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", null), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    gamepadIndex: 1,
    onClick: onClickTechnicalDetails,
    withUnderlinePolyfill: true
  }, t(`.descriptionTechnicalDetailsLink`)))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideSize,
    condition: false
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }))))));
}

function DeactivatedPack({
  pack: packFacet,
  index,
  gamepadIndex,
  containerListLength,
  role = 'neutral'
}) {
  // Dummy resourcePack when the pack is undefined to avoid asserts triggering
  const newPackFacet = useResourcePacksFallback(packFacet);
  const packId = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(pack => pack.id, [], [newPackFacet]));
  const packName = (0,react_facet_src.useFacetMap)(pack => pack.name, [], [newPackFacet]);
  const packImage = (0,react_facet_src.useFacetMap)(pack => pack.image != null && pack.image.length > 0 ? pack.image : missing_pack_icon_namespaceObject, [], [newPackFacet]);
  const {
    t
  } = useLocalization_useLocalization('PackListItem'); // Narration: Contextual pack information

  const disabledContextNarration = (0,react_facet_src.useFacetMap)((packName, containerListLength) => [packName, t('.narrationComponentType'), containerListLength > 0 ? t('.narrationListLengthContext', [`${index + 1}`, `${containerListLength}`]) : undefined, t('.narrationDeactivatedState')].filter(exists).join(' . '), [t, index], [packName, (0,react_facet_src.useFacetWrap)(containerListLength !== null && containerListLength !== void 0 ? containerListLength : 0)]);
  const semanticColors = hooks_useSemanticColors(role); // If narration is enabled the pack should be possible to focus

  const isNarrationEnabled = useNarrationEnabled(); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to packId --> only render when packId is available

  if (packId == react_facet_src.NO_VALUE) return null;
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: disabledContextNarration,
    key: packId
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    isFocusable: isNarrationEnabled,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: packImage,
    className: classnames_default()(PackListItem.disabledPackImage, semanticColors.border.base, PackListItem.border)
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, packName)))))));
} // Deactivated pack lists are shown as inert


function isDeactivated(props) {
  var _props$deactivated;

  return (_props$deactivated = props.deactivated) !== null && _props$deactivated !== void 0 ? _props$deactivated : false;
}

function PackListItem_PackListItem(props) {
  if (isDeactivated(props)) {
    return /*#__PURE__*/react.createElement(DeactivatedPack, props);
  } else {
    return /*#__PURE__*/react.createElement(ActivePack, props);
  }
}

function PackListItem_noop() {}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItem/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItemWrapper/PackListItemWrapper.tsx





const PackListItemWrapper = props => {
  const pack = (0,react_facet_src.useFacetMemo)(facet => {
    const result = find_find(facet, pack => pack.id === props.packId);
    return result !== null && result !== void 0 ? result : facet[props.index];
  }, [props.packId, props.index], [props.packs]);
  const listLength = (0,react_facet_src.useFacetMap)(packs => packs.length, [], [props.packs]);
  return /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    showTechnicalDetailsLink: props.showTechnicalDetailsLink,
    gamepadIndex: props.index,
    pack: pack,
    index: props.index,
    draggable: props.draggable,
    expandedPackId: props.expandedId,
    removable: props.isNotLockedTemplate,
    containerListLength: listLength,
    onDragStart: props.onDragStart,
    onDrop: props.onDrop,
    onExpand: props.onExpand,
    onRemove: props.onRemove,
    canShowSettingsButton: props.canShowSettingsButton,
    onClickPackSettings: props.onClickPackSettings,
    onClickMoreDetails: props.onClickMoreDetails
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListItemWrapper/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackMap/PackMap.tsx





function resourcePackEqualityCheck() {
  let previousResourcePackIds = [];
  return function (current) {
    if (previousResourcePackIds.length !== current.length) {
      previousResourcePackIds = map(current, pack => pack.id);
      return false;
    }

    const isEqual = every(current, (pack, i) => previousResourcePackIds[i] === pack.id);

    if (!isEqual) {
      previousResourcePackIds = map(current, pack => pack.id);
    }

    return isEqual;
  };
}

function PackMap(props) {
  const packs = (0,react_facet_src.useFacetMemo)(facet => facet, [], [props.packsFacet], resourcePackEqualityCheck);
  const packIds = (0,react_facet_src.useFacetMap)(packs => packs.map(p => p.id), [], [packs]);
  const ids = (0,react_facet_src.useFacetUnwrap)(packIds);
  return ids !== react_facet_src.NO_VALUE ? /*#__PURE__*/react.createElement(react.Fragment, null, ids === null || ids === void 0 ? void 0 : ids.map((packId, index) => /*#__PURE__*/react.createElement(PackListItemWrapper, {
    showTechnicalDetailsLink: props.showTechnicalDetailsLink,
    packs: packs,
    key: ids[index],
    packId: packId,
    index: index,
    draggable: props.draggable,
    expandedId: props.expandedId,
    onDragStart: props.onDragStart,
    onDrop: props.onDrop,
    onExpand: props.onExpand,
    onRemove: props.onRemove,
    canShowSettingsButton: props.canShowSettingsButton,
    onClickPackSettings: props.onClickPackSettings,
    onClickMoreDetails: props.onClickMoreDetails,
    isNotLockedTemplate: props.isNotLockedTemplate
  }))) : null;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackMap/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListInfoMessage/PackListInfoMessage.tsx



function PackListInfoMessage({
  text
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, text));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PackListInfoMessage/index.ts

;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/images/arrowUpWhite.png
const arrowUpWhite_namespaceObject = __webpack_require__.p + "assets/arrowUpWhite-2c2b7.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/IconArrowUpWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowUpWhite = ({"iconArrowUpWhite":"wXcBf"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowUpWhite/IconArrowUpWhite.tsx
function IconArrowUpWhite_extends() { IconArrowUpWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowUpWhite_extends.apply(this, arguments); }

function IconArrowUpWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowUpWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowUpWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconArrowUpWhite_IconArrowUpWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconArrowUpWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconArrowUpWhite.iconArrowUpWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowUpWhite_extends({}, props, {
    className: classNames,
    src: arrowUpWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/images/arrowDownWhite.png
const arrowDownWhite_namespaceObject = __webpack_require__.p + "assets/arrowDownWhite-55034.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/IconArrowDownWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowDownWhite = ({"iconArrowDownWhite":"ayLXu"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowDownWhite/IconArrowDownWhite.tsx
function IconArrowDownWhite_extends() { IconArrowDownWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowDownWhite_extends.apply(this, arguments); }

function IconArrowDownWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowDownWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowDownWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconArrowDownWhite_IconArrowDownWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconArrowDownWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconArrowDownWhite.iconArrowDownWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowDownWhite_extends({}, props, {
    className: classNames,
    src: arrowDownWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Accordion/Accordion.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Accordion_Accordion = ({"bevelWrapper":"xy0uV","content":"koWU0","left":"aMZtH","count":"NejtX","expandableWrapper":"cydJJ","expanded":"izYgc"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Accordion/Accordion.tsx










function Accordion_Accordion_Accordion(props) {
  const {
    label,
    count,
    children,
    gamepadIndex,
    narrationHint,
    alwaysShowHint = false,
    onExpandNarrationHint,
    expandedDefaultState = false,
    gamepadAlias
  } = props;
  const {
    t
  } = useLocalization_useLocalization('Accordion');
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const [expandedFacet, setExpanded] = (0,react_facet_src.useFacetState)(expandedDefaultState);
  const [expandableStyles, contentRef] = useExpandable(expandedFacet);
  const countLabel = (0,react_facet_src.useFacetMap)(count => `(${count})`, [], [count !== null && count !== void 0 ? count : Accordion_zeroFacet]);
  const inputLegend = (0,react_facet_src.useFacetMap)(expanded => expanded ? t('.closeInputLegend') : t('.openInputLegend'), [t], [expandedFacet]);
  const narrationHintFacet = (0,react_facet_src.useFacetWrap)(narrationHint);
  const narrationLabelFacet = (0,react_facet_src.useFacetWrap)(label);
  const narrationText = (0,react_facet_src.useFacetMap)((expanded, count, narrationHintFacet, narrationLabelFacet) => {
    const text = count != null ? t('.narrationCountLabel', [narrationLabelFacet, `${count > 100 ? '100+' : count}`]) : narrationLabelFacet;
    const componentType = t('.narrationComponentType');
    const state = expanded ? t('.stateExpanded') : t('.stateCollapsed');
    const hint = expanded && !alwaysShowHint ? null : narrationHintFacet;
    return [text, componentType, state, hint].join(' . ');
  }, [t, alwaysShowHint], [expandedFacet, count !== null && count !== void 0 ? count : nullFacet, narrationHintFacet, narrationLabelFacet]);
  const onClick = (0,react_facet_src.useFacetCallback)(expanded => () => {
    const text = expanded ? t('.stateCollapsed') : [t('.stateExpanded'), onExpandNarrationHint].join(' . ');
    narrateText(text);
    setExpanded(!expanded);
  }, [narrateText, t, onExpandNarrationHint, setExpanded], [expandedFacet]);
  const rowOptions = (0,react_facet_src.useFacetMap)(expanded => ({
    index: 1,
    disabled: !expanded
  }), [], [expandedFacet]);
  const expandableWrapperStyles = (0,react_facet_src.useFacetMap)(expanded => `${Accordion_Accordion.expandableWrapper} ${expanded ? Accordion_Accordion.expanded : ''}`, [], [expandedFacet]);
  const isDisabled = (0,react_facet_src.useFacetMap)(expanded => !expanded, [], [expandedFacet]);
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion_Accordion.bevelWrapper
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: narrationText,
    onClick: onClick,
    height: 4.4,
    variant: "neutral80",
    reflection: "bevel",
    gamepadAlias: gamepadAlias
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion_Accordion.content
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion_Accordion.left
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: label
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), count != null && /*#__PURE__*/react.createElement("div", {
    className: Accordion_Accordion.count
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: countLabel
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: expandedFacet,
    condition: true
  }, /*#__PURE__*/react.createElement(IconArrowUpWhite_IconArrowUpWhite, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: expandedFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(IconArrowDownWhite_IconArrowDownWhite, null)))))), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: rowOptions
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(FocusGroup, {
    disabled: isDisabled
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: expandableWrapperStyles,
    style: expandableStyles
  }, /*#__PURE__*/react.createElement("div", {
    ref: contentRef
  }, /*#__PURE__*/react.createElement("div", {
    className: Accordion_Accordion.expandableContent
  }, children))))))));
}
const Accordion_zeroFacet = (0,react_facet_src.createFacet)({
  initialValue: 0
});
const nullFacet = (0,react_facet_src.createFacet)({
  initialValue: null
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useExpandableIndex.ts


function useExpandableIndex() {
  return (0,react.useMemo)(() => {
    const expandedId = (0,react_facet_src.createFacet)({
      initialValue: false
    });
    return {
      closeExpanded: () => expandedId.set(false),
      toggleExpanded: id => expandedId.setWithCallback(prev => prev != id ? id : false),
      expandedId
    };
  }, []);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useReorderPacks.ts

const useReorderPacks = (activePacks, packType, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority) => {
  const moreThanOneActivePack = (0,react_facet_src.useFacetMap)(facet => facet.length > 1, [], [activePacks]);
  const isDraggable = (0,react_facet_src.useFacetMap)((multiplePacks, isLockedTemplate) => multiplePacks && !isLockedTemplate, [], [moreThanOneActivePack, isLockedTemplate]);
  const changePackPriority = (0,react_facet_src.useFacetCallback)(() => (packId, dragIndex, dropIndex) => {
    if (onChangePackPriority) {
      onChangePackPriority(packId, packType, dragIndex, dropIndex);
    }
  }, [packType, onChangePackPriority], []); // If the packs are expanded, we wait for the collapse
  // to finish before we start the dragging animation.

  const dragStartHandler = (0,react_facet_src.useFacetCallback)(expandedId => {
    const dragStart = callback => {
      if (expandedId === false) {
        callback();
      } else {
        closeExpanded();
        setTimeout(() => {
          callback();
        }, 200);
      }
    };

    return dragStart;
  }, [closeExpanded], [expandedId]);
  return {
    isDraggable,
    changePackPriority,
    dragStartHandler
  };
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/realms-plus-promotion.png
const realms_plus_promotion_namespaceObject = __webpack_require__.p + "assets/realms-plus-promotion-f1ffa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/marketplace-icon.png
const marketplace_icon_namespaceObject = __webpack_require__.p + "assets/marketplace-icon-bca68.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/minecraft-texture-pack.png
const minecraft_texture_pack_namespaceObject = __webpack_require__.p + "assets/minecraft-texture-pack-070c0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ResourcePacksTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ResourcePacksTab = ({"container":"g9sbm","draggableDashedBackground":"ufNa6","draggableDashedBackgroundGreyCover":"mojsE","marketplaceButtonContent":"Jk4Oc","marketplaceButtonTextWrap":"Iabmi","marketplaceIcon":"xkjpr","realmsPlusPromotionImage":"uBhPx"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/useOnClickPackMoreDetails.ts




 // the packId usually contains extra version information appended
// to the id e.g `ee4fdd53-d555-4618-b450-2a064d75b156_1.0.38`.
// We cut off the extra version info from the end of the string

const UUID_LENGTH = 36;

function marketPlacePackRouteFromPackId(contentId) {
  return `/marketplace?packId=${contentId.substring(0, UUID_LENGTH)}`;
}

function useOnClickPackMoreDetails(telemetryEvent) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const showLeavingCNWForMarketplaceModal = LeavingCNWForMarketplaceModal.useShowModal();
  const isNarrationEnabled = useNarrationEnabled();
  const onClickPackMoreDetails = (0,react_facet_src.useFacetCallback)(telemetry => packId => {
    // Function to navigate to a marketplace pack and fire telemetry event
    function navigateToMarketplacePack() {
      historyAPI.push(marketPlacePackRouteFromPackId(packId));
      telemetry.fireEventButtonPressed(telemetryEvent, {});
    } // Show a warning modal only for narration users
    // that they are now leaving the CNW screen.


    if (isNarrationEnabled) {
      showLeavingCNWForMarketplaceModal({
        onAccept: navigateToMarketplacePack
      });
    } else {
      navigateToMarketplacePack();
    }
  }, [historyAPI, showLeavingCNWForMarketplaceModal, isNarrationEnabled, telemetryEvent], [(0,react_facet_src.useSharedFacet)(telemetryFacet)]);
  return onClickPackMoreDetails;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ResourcePacksTab.tsx































const ACTIVE_RP_TAB_ALIAS = 'tab-bar-cnw-rp-active';
const AVAILABLE_RP_TAB_ALIAS = 'tab-bar-cnw-rp-available';
const EMPTY_LOCAL_ACTIVE_PACKS_ALIAS = 'empty-local-active-rp';
const EMPTY_AVAILABLE_PACKS_ALIAS = 'empty-available-rp';
const EMPTY_REALMS_PLUS_PACKS_ALIAS = 'empty-realms-plus-rp';

function ActiveTab({
  worldPacks,
  isEditorWorld,
  isLockedTemplate,
  onClickPackMoreDetails,
  onClickPackSettings,
  onChangePackPriority
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there is currently a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(ActiveLocalPacks, {
    worldPacks: worldPacks,
    isEditorWorld: isEditorWorld,
    isLockedTemplate: isLockedTemplate,
    onClickPackMoreDetails: onClickPackMoreDetails,
    onClickPackSettings: onClickPackSettings,
    onChangePackPriority: onChangePackPriority
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(GlobalPacks, {
    worldPacks: worldPacks,
    onClickPackMoreDetails: onClickPackMoreDetails
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })), [worldPacks, isEditorWorld, isLockedTemplate, onClickPackMoreDetails, onClickPackSettings, onChangePackPriority]));
}

const createGlobalMinecraftTexturePack = t => ({
  id: MINECRAFT_TEXTURE_PACK_ID,
  contentId: MINECRAFT_TEXTURE_PACK_ID,
  name: t('.globalMinecraftPackTitle'),
  creator: 'Minecraft',
  description: t('.globalMinecraftPackDescription'),
  size: 'n/a',
  image: minecraft_texture_pack_namespaceObject,
  isMarketplaceItem: false,
  isPlatformLocked: false,
  hasSettings: false
});

function GlobalPacks({
  worldPacks,
  onClickPackMoreDetails
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const globalPacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.global, [], [worldPacks]);
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const localPacksLength = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(facet => facet.length, [], [activePacks])); // Start the index offset as 1 to account for a focusable empty state message on the local packs

  const localPacksGamepadIndexOffset = localPacksLength == react_facet_src.NO_VALUE || localPacksLength === 0 ? 1 : localPacksLength;
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex(); // If shared packs are enabled, the global packs should be visible but deactivated

  const sharedPacks = (0,react_facet_src.useFacetMap)(facet => facet.sharedPacks, [], [worldPacks]);
  const deactivatedPacks = (0,react_facet_src.useFacetUnwrap)(sharedPacks) === true;
  const lengthGlobalPacks = (0,react_facet_src.useFacetMap)(globalPacks => globalPacks.length === 0 ? 1 : globalPacks.length + 1, [], [globalPacks]); // The Minecraft texture will be shown beneath both local and global packs
  // It will always be present even if there are no other global packs

  const minecraftTextureIndexUnwrapped = (0,react_facet_src.useFacetUnwrap)(lengthGlobalPacks);
  const minecraftTextureGamepadIndexUnwrapped = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(lengthGlobalPacks => localPacksGamepadIndexOffset + lengthGlobalPacks - 1, [localPacksGamepadIndexOffset], [lengthGlobalPacks])); // The Minecraft texture index should be global packs - 1, since it's always the last element

  const minecraftTextureIndex = minecraftTextureIndexUnwrapped === react_facet_src.NO_VALUE ? 0 : minecraftTextureIndexUnwrapped - 1;
  const minecraftTextureGamepadIndex = minecraftTextureGamepadIndexUnwrapped === react_facet_src.NO_VALUE ? 0 : minecraftTextureGamepadIndexUnwrapped;
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.narrationGlobalPacksHeader')
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
    role: "neutral",
    label: t('.globalPacksListHeader')
  }), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: globalPacks
  }, (packFacet, index) => deactivatedPacks ? /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    containerListLength: lengthGlobalPacks,
    deactivated: true,
    pack: packFacet,
    index: index,
    gamepadIndex: index + localPacksGamepadIndexOffset
  }) : /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    pack: packFacet,
    containerListLength: lengthGlobalPacks,
    showTechnicalDetailsLink: true,
    index: index,
    gamepadIndex: index + localPacksGamepadIndexOffset,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    canShowSettingsButton: false,
    onClickMoreDetails: onClickPackMoreDetails
  })), /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    showTechnicalDetailsLink: true,
    containerListLength: lengthGlobalPacks,
    pack: (0,react_facet_src.useFacetWrap)(createGlobalMinecraftTexturePack(t)),
    index: minecraftTextureIndex,
    gamepadIndex: minecraftTextureGamepadIndex,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    onClickMoreDetails: onClickPackMoreDetails
  }), /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.globalPacksInfoMessage')
  }));
}

function ActiveLocalPacks({
  worldPacks,
  isLockedTemplate,
  onClickPackMoreDetails,
  onClickPackSettings,
  onChangePackPriority,
  role = 'neutral'
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const semanticColors = hooks_useSemanticColors(role);
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const activePacksEmpty = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length < 1, [], [activePacks]);
  const activePacksMoreThanOne = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 1, [], [activePacks]);
  const {
    expandedId,
    toggleExpanded,
    closeExpanded
  } = useExpandableIndex();
  const {
    isDraggable,
    changePackPriority,
    dragStartHandler
  } = useReorderPacks(activePacks, PackType.Resource, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority);
  const {
    deactivatePack
  } = usePackActions();
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.narrationActiveLocalPacksHeader')
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
    role: "neutral",
    label: t('.localPacksListHeader')
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_LOCAL_ACTIVE_PACKS_ALIAS,
    title: t('.emptyLocalActivePacksMessageTitle'),
    text: t('.emptyLocalActivePacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.draggableDashedBackground
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ResourcePacksTab.draggableDashedBackgroundGreyCover, semanticColors.background.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty,
    condition: false
  }, /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "active"
  }, /*#__PURE__*/react.createElement(PackMap, {
    showTechnicalDetailsLink: true,
    packsFacet: activePacks,
    draggable: isDraggable,
    expandedId: expandedId,
    onDragStart: dragStartHandler,
    onDrop: changePackPriority,
    onExpand: toggleExpanded,
    onRemove: deactivatePack,
    onClickMoreDetails: onClickPackMoreDetails,
    onClickPackSettings: onClickPackSettings,
    canShowSettingsButton: true,
    isNotLockedTemplate: isNotLockedTemplate
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate,
    condition: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksMoreThanOne
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.packPriorityInfoMessage')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.changesDisabledMessage')
  })));
}

function AvailableTab({
  worldPacks,
  isEditorWorld,
  isLockedTemplate,
  onClickPackMoreDetails
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there seems to be a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex();
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.active, [], [worldPacks]);
  const availablePacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.available, [], [worldPacks]);
  const availablePacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length < 1, [], [availablePacks]);
  const availablePacksLength = (0,react_facet_src.useFacetMap)(facet => facet.length, [], [availablePacks]);
  const isMarketplaceSupported = (0,react_facet_src.useFacetMap)((isEduBuild, isEditorWorld) => !isEduBuild && !isEditorWorld, [], [(0,react_facet_src.useSharedFacet)(isEduBuildSelector), isEditorWorld]); // If the player has active packs but no available, all packs have been activated and the empty state message should say so
  // If the player doesn't have any active packs or available packs, they don't own any and the empty state message should inform them where they can buy packs

  const userOwnsAtLeastOnePack = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 0, [], [activePacks]);
  const emptyStateTitle = (0,react_facet_src.useFacetMap)(userOwnsAtLeastOnePack => userOwnsAtLeastOnePack ? t('.activatedAllPacksMessageTitle') : t('.userOwnsNoPacksMessageTitle'), [t], [userOwnsAtLeastOnePack]);
  const emptyStateText = (0,react_facet_src.useFacetMap)(userOwnsAtLeastOnePack => userOwnsAtLeastOnePack ? t('.activatedAllPacksMessageDescription') : t('.userOwnsNoMessageDescription'), [t], [userOwnsAtLeastOnePack]);
  const packsActivateable = (0,react_facet_src.useFacetMap)((isLockedTemplate, isTrialAccount) => !isLockedTemplate && !isTrialAccount, [], [isLockedTemplate, isTrialAccountFacet]);
  const {
    activatePack
  } = usePackActions();
  return /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Accordion_Accordion_Accordion, {
    gamepadIndex: 0,
    label: t('.inactivePacksAccordionHeader'),
    count: availablePacksLength,
    narrationHint: t('.inactivePacksAccordionHint'),
    onExpandNarrationHint: t('.inactivePacksOnExpandAccordionHint'),
    expandedDefaultState: "production" === 'test'
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: availablePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_AVAILABLE_PACKS_ALIAS,
    title: emptyStateTitle,
    text: emptyStateText,
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "available"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: availablePacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    containerListLength: availablePacksLength,
    activatable: packsActivateable,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    onClickMoreDetails: onClickPackMoreDetails
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  })), /*#__PURE__*/react.createElement(RealmsPlusPackList, {
    worldPacks: worldPacks,
    isEditorWorld: isEditorWorld,
    isLockedTemplate: isLockedTemplate,
    expandedId: expandedId,
    toggleExpanded: toggleExpanded,
    onClickPackMoreDetails: onClickPackMoreDetails
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isMarketplaceSupported
  }, /*#__PURE__*/react.createElement(GetMorePacksButton, {
    gamepadIndex: 2
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })), [t, availablePacks, availablePacksEmpty, availablePacksLength, isMarketplaceSupported, emptyStateText, emptyStateTitle, packsActivateable, activatePack, worldPacks, isEditorWorld, isLockedTemplate, expandedId, toggleExpanded, onClickPackMoreDetails]));
}

function RealmsPlusPackList({
  worldPacks,
  isEditorWorld,
  isLockedTemplate,
  expandedId,
  toggleExpanded,
  onClickPackMoreDetails
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const isRealmsPlusSupported = (0,react_facet_src.useFacetMap)((facet, isEduBuild, isEditorWorld) => facet.realmsPlusSupported && !isEduBuild && !isEditorWorld, [], [worldPacks, (0,react_facet_src.useSharedFacet)(isEduBuildSelector), isEditorWorld]);
  const realmsSubscriber = (0,react_facet_src.useFacetMap)(facet => facet.realmsSubscriber, [], [worldPacks]);
  const notRealmsSubscriber = (0,react_facet_src.useFacetMap)(facet => !facet.realmsSubscriber, [], [worldPacks]);
  const realmsPacks = (0,react_facet_src.useFacetMap)(facet => facet.texturePacks.realms, [], [worldPacks]);
  const realmsPacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length <= 0, [], [realmsPacks]);
  const realmsPacksLength = (0,react_facet_src.useFacetMap)((facet, subscriber) => subscriber ? facet.length : '100+', [], [realmsPacks, realmsSubscriber]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  const {
    activatePack
  } = usePackActions();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isRealmsPlusSupported
  }, /*#__PURE__*/react.createElement(Accordion_Accordion_Accordion, {
    gamepadIndex: 1,
    label: t('.realmsPlusPacksAccordionHeader'),
    count: realmsPacksLength,
    narrationHint: t('.realmsPlusPacksAccordionHint'),
    onExpandNarrationHint: t('.realmsPlusPacksOnExpandAccordionHint'),
    expandedDefaultState: "production" === 'test'
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsSubscriber
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsPacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_REALMS_PLUS_PACKS_ALIAS,
    gamepadIndex: 0,
    title: t('.realmsPlusPacksEmptyTitle'),
    text: t('.realmsPlusPacksEmptyBody')
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "realms"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: realmsPacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    activatable: isNotLockedTemplate,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    onClickMoreDetails: onClickPackMoreDetails
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: notRealmsSubscriber
  }, /*#__PURE__*/react.createElement(RealmsPlusPromotionPanel, null)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }))));
}

function RealmsPlusPromotionPanel() {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    title: t('.realmsPlusPromotionTitle'),
    text: t('.realmsPlusPromotionBody'),
    imgSrc: realms_plus_promotion_namespaceObject,
    imgClass: ResourcePacksTab.realmsPlusPromotionImage,
    buttons: [{
      text: t('.realmsPlusPromotionButtonLabel'),
      inputLegend: t('.realmsPlusPromotionButtonInputLegend'),
      onClick: () => historyAPI.push('/realms-plus-pdp?tab=default')
    }],
    gamepadIndex: 0
  });
}

function GetMorePacksButton({
  gamepadIndex,
  role = 'neutral'
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const semanticColors = hooks_useSemanticColors(role);
  const isNarrationEnabled = useNarrationEnabled();
  const showLeavingCNWForMarketplaceModal = LeavingCNWForMarketplaceModal.useShowModal();
  const onClick = (0,react_facet_src.useFacetCallback)((marketplaceFacet, telemetryFacet) => () => {
    // Function to navigate to a marketplace pack and fire telemetry event
    function navigateToMarketplace() {
      telemetryFacet.fireEventButtonPressed('Get_More_Packs_Button_OreUI', {});
      const queryParams = marketplaceFacet.getMorePacks ? `?title=${marketplaceFacet.getMorePacks.title}&pageId=${marketplaceFacet.getMorePacks.pageId}` : '';
      historyAPI.push(`/marketplace/get-more-packs${queryParams}`);
    } // Show a warning modal only for narration users
    // that they are now leaving the CNW screen.


    if (isNarrationEnabled) {
      showLeavingCNWForMarketplaceModal({
        onAccept: navigateToMarketplace
      });
    } else {
      navigateToMarketplace();
    }
  }, [historyAPI, isNarrationEnabled, showLeavingCNWForMarketplaceModal], [(0,react_facet_src.useSharedFacet)(marketplaceSuggestionsFacet), (0,react_facet_src.useSharedFacet)(telemetryFacet)]);
  const narrationText = `${t('.getMorePacksButtonTitle')} . ${t('.narrationComponentTypeMarketplaceButton')} , ${t('.getMorePacksButtonBody')}`;
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    delayedClick: true,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.getMorePacksButtonInputLegend'),
    narrationText: narrationText,
    onClick: onClick,
    variant: "neutral",
    reflection: "bevel"
  }, /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.marketplaceButtonContent
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: marketplace_icon_namespaceObject,
    className: ResourcePacksTab.marketplaceIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ResourcePacksTab.marketplaceButtonTextWrap, semanticColors.text.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    role: role,
    type: "body"
  }, t('.getMorePacksButtonTitle')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    role: role,
    variant: "dimmer",
    type: "captionShort"
  }, t('.getMorePacksButtonBody')))));
}

const ResourcePackActionsContext = (0,react.createContext)({});

const usePackActions = () => (0,react.useContext)(ResourcePackActionsContext);

function ResourcePacksTab_ResourcePacksTab({
  worldPacks,
  multiplayerData,
  isEditorWorld,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onActivatePack,
  onDeactivatePack,
  onChangePackPriority,
  onClickPackSettings,
  onUnlockTemplateSettings
}) {
  const {
    activatePack,
    deactivatePack
  } = useActivateDeactivatePacks('texturePacks', {
    active: {
      tabsAlias: ACTIVE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_LOCAL_ACTIVE_PACKS_ALIAS
    },
    available: {
      tabsAlias: AVAILABLE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_AVAILABLE_PACKS_ALIAS
    },
    realms: {
      tabsAlias: AVAILABLE_RP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_REALMS_PLUS_PACKS_ALIAS
    }
  }, worldPacks, multiplayerData, onActivatePack, onDeactivatePack);
  const resourcePacksDisabled = (0,react_facet_src.useFacetMap)((isLockedTemplate, user) => isLockedTemplate || user.isTrialAccount, [], [isLockedTemplate, (0,react_facet_src.useSharedFacet)(userAccountFacet)]);
  const {
    t
  } = localization_useLocalization('CreateNewWorld.resourcePacks');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const value = (0,react.useMemo)(() => ({
    activatePack,
    deactivatePack
  }), [activatePack, deactivatePack]);
  const onClickPackMoreDetails = useOnClickPackMoreDetails('Resource_Pack_More_Details_Button_OreUI'); // When shared packs go from disabled to enabled, a snack bar should be shown,
  // informing the player that global packs are now deactivated

  const sharedPacks = (0,react_facet_src.useFacetMap)(facet => facet.sharedPacks, [], [worldPacks]); // It should not fire if the player enters the tab for the first time _with shared packs enabled_

  const firstTimeEnteringTab = (0,react.useRef)(true);
  (0,react_facet_src.useFacetEffect)((sharedPacks, notificationsFacet) => {
    if (sharedPacks && !firstTimeEnteringTab.current) {
      // Fire snack bar event for global packs being deactivated
      notificationsFacet.queueSnackbar(t('.globalPacksDeactivatedSnackbarMessage'));
    }

    firstTimeEnteringTab.current = false;
  }, [t], [sharedPacks, (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet)]);
  return /*#__PURE__*/react.createElement(ResourcePackActionsContext.Provider, {
    value: value
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(DragAndDropProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isEditorWorld: isEditorWorld,
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    nestedRoutes: true,
    narrationText: tSideMenu('.resourcePacksTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    disabled: resourcePacksDisabled,
    gamepad: {
      index: 0
    },
    title: t('.sharedPacksTitle'),
    description: t('.sharedPacksDescription'),
    onNarrationText: t('.sharedPacksDeactivatingGlobalPacks'),
    offNarrationText: t('.sharedPacksActivatingGlobalPacks'),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => facet.sharedPacks = newValue, [], [worldPacks]),
    value: sharedPacks
  })), /*#__PURE__*/react.createElement("div", {
    className: ResourcePacksTab.container
  }, /*#__PURE__*/react.createElement(PackTabs, {
    gamepadAliasNamespace: "cnw-rp",
    path: "resource-packs",
    narrationTitle: tSideMenu('.resourcePacksTabLabel')
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ActiveTab, {
      worldPacks: worldPacks,
      isEditorWorld: isEditorWorld,
      isLockedTemplate: isLockedTemplate,
      onClickPackSettings: onClickPackSettings,
      onClickPackMoreDetails: onClickPackMoreDetails,
      onChangePackPriority: onChangePackPriority
    }), [worldPacks, isEditorWorld, isLockedTemplate, onClickPackSettings, onClickPackMoreDetails, onChangePackPriority]),
    gamepadIndex: 3,
    filter: "active"
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(AvailableTab, {
      worldPacks: worldPacks,
      isEditorWorld: isEditorWorld,
      isLockedTemplate: isLockedTemplate,
      onClickPackMoreDetails: onClickPackMoreDetails
    }), [worldPacks, isEditorWorld, isLockedTemplate, onClickPackMoreDetails]),
    gamepadIndex: 3,
    filter: "available"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/images/empty-state-art.png
const empty_state_art_namespaceObject = __webpack_require__.p + "assets/empty-state-art-2afbb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/BehaviorPacksTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BehaviorPacksTab = ({"emptyStateArt":"XnOc_","emptyStateArtBig":"Md7uv","container":"TPaUw","draggableDashedBackground":"PWSBv","draggableDashedBackgroundGreyCover":"pTqB3"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/BehaviorPacksTab.tsx
























const ACTIVE_BP_TAB_ALIAS = 'tab-bar-cnw-bp-active';
const EMPTY_ACTIVE_PACKS_ALIAS = 'empty-active-bp';
const AVAILABLE_BP_TAB_ALIAS = 'tab-bar-cnw-bp-available';
const BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS = 'empty-available-bp';

function BehaviorPacksTab_ActiveTab({
  worldPacks,
  isLockedTemplate,
  onChangePackPriority,
  onClickPackSettings,
  onClickPackMoreDetails
}) {
  // This is used to disable the column on this route. We shouldn't need to,
  // but there is currently a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled
  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(ActivePacks, {
    isLockedTemplate: isLockedTemplate,
    worldPacks: worldPacks,
    onChangePackPriority: onChangePackPriority,
    onClickPackSettings: onClickPackSettings,
    onClickPackMoreDetails: onClickPackMoreDetails
  }), [isLockedTemplate, onChangePackPriority, worldPacks, onClickPackSettings, onClickPackMoreDetails])), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}

function ActivePacks({
  role = 'neutral',
  worldPacks,
  isLockedTemplate,
  onChangePackPriority,
  onClickPackMoreDetails,
  onClickPackSettings
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.behaviorPacks');
  const {
    toggleExpanded,
    expandedId,
    closeExpanded
  } = useExpandableIndex();
  const semanticColors = hooks_useSemanticColors(role);
  const {
    deactivatePack
  } = BehaviorPacksTab_usePackActions();
  const activePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active, [], [worldPacks]);
  const activePacksEmpty = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length < 1, [], [activePacks]);
  const activePacksMoreThanOne = (0,react_facet_src.useFacetMap)(activePacks => activePacks.length > 1, [], [activePacks]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  const {
    isDraggable,
    changePackPriority,
    dragStartHandler
  } = useReorderPacks(activePacks, PackType.Behavior, expandedId, closeExpanded, isLockedTemplate, onChangePackPriority);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_ACTIVE_PACKS_ALIAS,
    title: t('.emptyLocalActivePacksMessageTitle'),
    text: t('.emptyLocalActivePacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement("div", {
    className: BehaviorPacksTab.draggableDashedBackground
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(BehaviorPacksTab.draggableDashedBackgroundGreyCover, semanticColors.background.base)
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksEmpty,
    condition: false
  }, /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "active"
  }, /*#__PURE__*/react.createElement(PackMap, {
    showTechnicalDetailsLink: true,
    packsFacet: activePacks,
    draggable: isDraggable,
    expandedId: expandedId,
    onDragStart: dragStartHandler,
    onDrop: changePackPriority,
    onExpand: toggleExpanded,
    onRemove: deactivatePack,
    onClickMoreDetails: onClickPackMoreDetails,
    onClickPackSettings: onClickPackSettings,
    canShowSettingsButton: true,
    isNotLockedTemplate: isNotLockedTemplate
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate,
    condition: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: activePacksMoreThanOne
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.packPriorityInfoMessage')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLockedTemplate
  }, /*#__PURE__*/react.createElement(PackListInfoMessage, {
    text: t('.changesDisabledMessage')
  })));
}

function BehaviorPacksTab_AvailableTab({
  worldPacks,
  isLockedTemplate,
  onClickPackMoreDetails
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.behaviorPacks');
  const {
    toggleExpanded,
    expandedId
  } = useExpandableIndex();
  const {
    activatePack
  } = BehaviorPacksTab_usePackActions(); // This is used to disable the column on this route. We shouldn't need to,
  // but there seems to be a bug with focus navigation which is causing the below
  // tree to be focusable despite the parent Tab focusable being disabled

  const parentRouteActive = useRouteActive();
  const options = (0,react_facet_src.useFacetMap)(parentRouteActive => ({
    index: 0,
    disabled: !parentRouteActive
  }), [], [parentRouteActive]);
  const availablePacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.available, [], [worldPacks]);
  const availablePacksEmpty = (0,react_facet_src.useFacetMap)(facet => facet.length < 1, [], [availablePacks]);
  const isNotLockedTemplate = (0,react_facet_src.useFacetMap)(isLockedTemplate => !isLockedTemplate, [], [isLockedTemplate]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: options
  }, (0,react.useMemo)(() => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: availablePacksEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS,
    title: t('.activatedAllPacksMessageTitle'),
    text: t('.activatedAllPacksMessageDescription'),
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(PackCollectionKeyContext.Provider, {
    value: "available"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: availablePacks
  }, (packFacet, index) => /*#__PURE__*/react.createElement(PackListItem_PackListItem, {
    activatable: isNotLockedTemplate,
    onActivate: activatePack,
    pack: packFacet,
    index: index,
    gamepadIndex: index,
    expandedPackId: expandedId,
    onExpand: toggleExpanded,
    onClickMoreDetails: onClickPackMoreDetails
  })))), [t, availablePacks, availablePacksEmpty, isNotLockedTemplate, activatePack, expandedId, toggleExpanded, onClickPackMoreDetails])), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}

const BehaviorPacksTab_ResourcePackActionsContext = (0,react.createContext)({});

const BehaviorPacksTab_usePackActions = () => (0,react.useContext)(BehaviorPacksTab_ResourcePackActionsContext);

function BehaviorPacksTab_BehaviorPacksTab({
  worldPacks,
  multiplayerData,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onActivatePack,
  onDeactivatePack,
  onChangePackPriority,
  onClickPackSettings,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.behaviorPacks');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const hasBehaviorPacks = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active.length > 0 || facet.behaviorPacks.available.length > 0, [], [worldPacks]);
  const togglePack = useActivateDeactivatePacks('behaviorPacks', {
    active: {
      tabsAlias: ACTIVE_BP_TAB_ALIAS,
      emptyStateMessageAlias: EMPTY_ACTIVE_PACKS_ALIAS
    },
    available: {
      tabsAlias: AVAILABLE_BP_TAB_ALIAS,
      emptyStateMessageAlias: BehaviorPacksTab_EMPTY_AVAILABLE_PACKS_ALIAS
    }
  }, worldPacks, multiplayerData, onActivatePack, onDeactivatePack); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 5,
    width: 260
  });
  const imageClass = narrowImage ? BehaviorPacksTab.emptyStateArt : BehaviorPacksTab.emptyStateArtBig; // In the future we might want to change this telemetry to specify it's on the Behavior Packs tab

  const onClickPackMoreDetails = useOnClickPackMoreDetails('Resource_Pack_More_Details_Button_OreUI');
  return /*#__PURE__*/react.createElement(BehaviorPacksTab_ResourcePackActionsContext.Provider, {
    value: togglePack
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(DragAndDropProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    nestedRoutes: true,
    narrationText: tSideMenu('.behaviorPacksTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasBehaviorPacks,
    condition: true
  }, /*#__PURE__*/react.createElement("div", {
    className: BehaviorPacksTab.container
  }, /*#__PURE__*/react.createElement(PackTabs, {
    gamepadAliasNamespace: "cnw-bp",
    path: "behavior-packs",
    narrationTitle: tSideMenu('.behaviorPacksTabLabel')
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: () => /*#__PURE__*/react.createElement(BehaviorPacksTab_ActiveTab, {
      worldPacks: worldPacks,
      isLockedTemplate: isLockedTemplate,
      onChangePackPriority: onChangePackPriority,
      onClickPackSettings: onClickPackSettings,
      onClickPackMoreDetails: onClickPackMoreDetails
    }),
    gamepadIndex: 3,
    filter: "active"
  }), /*#__PURE__*/react.createElement(PackTabWrapper, {
    component: () => /*#__PURE__*/react.createElement(BehaviorPacksTab_AvailableTab, {
      worldPacks: worldPacks,
      isLockedTemplate: isLockedTemplate,
      onChangePackPriority: onChangePackPriority,
      onClickPackMoreDetails: onClickPackMoreDetails
    }),
    gamepadIndex: 3,
    filter: "available"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasBehaviorPacks,
    condition: false
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadAlias: EMPTY_ACTIVE_PACKS_ALIAS,
    title: t('.noPacksAvailableTitle'),
    text: t('.noPacksAvailableBody'),
    gamepadIndex: 0,
    imgSrc: empty_state_art_namespaceObject,
    borderless: true,
    imgClass: imageClass
  })))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/DebugTab.tsx















function DebugTab({
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  onExportTemplate,
  isEditorWorld
}) {
  const debugSettings = (0,react_facet_src.useSharedFacet)(debugSettingsFacet);
  const allBiomesRaw = (0,react_facet_src.useFacetMap)(({
    allBiomes
  }) => allBiomes, [], [debugSettings]);
  const spawnDimension = (0,react_facet_src.useFacetMap)(({
    spawnDimensionId
  }) => spawnDimensionId, [], [debugSettings]);
  const allBiomes = (0,react_facet_src.useFacetMap)(allBiomesRaw => map(allBiomesRaw, biome => ({
    label: biome.label,
    dimension: biome.dimension,
    value: biome.id
  })), [], [allBiomesRaw]);
  const biomeOptions = (0,react_facet_src.useFacetMap)((allBiomes, selectedBiomeType) => filter(allBiomes, biome => biome.dimension === selectedBiomeType), [], [allBiomes, spawnDimension]);
  const spawnBiomeId = (0,react_facet_src.useFacetMap)(facet => facet.spawnBiomeId, [], [debugSettings]);
  const disableSpawnBiomeOptions = (0,react_facet_src.useFacetMap)(facet => facet.defaultSpawnBiome || facet.isBiomeOverrideActive, [], [debugSettings]);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const isWindowsPlatformFacet = (0,react_facet_src.useFacetMap)(facet => isWindowsPlatform(facet.platform), [], [deviceInformation]);
  const editingWorld = (0,react.useContext)(WorldModeContext) === 'edit';
  const showFileManagement = (0,react_facet_src.useFacetMap)(facet => facet && editingWorld, [editingWorld], [isWindowsPlatformFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    narrationText: "Debug",
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Flat nether',
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(value => value.flatNether, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.flatNether = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Enable game version override',
    gamepad: {
      index: 1
    },
    value: (0,react_facet_src.useFacetMap)(value => value.enableGameVersionOverride, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.enableGameVersionOverride = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField, {
    label: 'Game version override',
    gamepadIndex: 2,
    placeholder: '0.0.0' // Do not change the maxLength to a value > 1024 until bug #507491 is fixed. This to avoid issues with text input on GameCore.
    ,
    maxLength: 30,
    disabled: (0,react_facet_src.useFacetMap)(value => !value.enableGameVersionOverride, [], [debugSettings]),
    value: (0,react_facet_src.useFacetMap)(value => value.gameVersionOverride, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(facet => newValue => {
      facet.gameVersionOverride = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: 'World biome settings'
  })), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Default spawn biome',
    description: 'Using the default spawn biome will mean a random overworld spawn is selected',
    gamepad: {
      index: 3
    },
    disabled: (0,react_facet_src.useFacetMap)(facet => facet.isBiomeOverrideActive, [], [debugSettings]),
    value: (0,react_facet_src.useFacetMap)(facet => facet.defaultSpawnBiome, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.defaultSpawnBiome = newValue;
    }, [], [debugSettings])
  }), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Toggles_Toggles, {
    onMountComplete: (0,deferred_mount_dist.useNotifyMountComplete)(),
    title: 'Spawn dimension filter',
    gamepad: {
      index: 4
    },
    disabled: disableSpawnBiomeOptions,
    wrapToggleText: true,
    options: [{
      label: 'Overworld',
      value: 0
    }, {
      label: 'Nether',
      value: 1
    }],
    value: spawnDimension,
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.spawnDimensionId = newValue;
    }, [], [debugSettings])
  })), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Dropdown, {
    label: "Spawn biome",
    options: biomeOptions,
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => debugSettings.spawnBiomeId = newValue, [], [debugSettings]),
    disabled: disableSpawnBiomeOptions,
    gamepadIndex: 5,
    value: (0,react_facet_src.useFacetMap)((spawnBiomeId, biomeOptions) => // If the spawnBiomeSelector is returned as 0 but the select biome subset doesn't contain that
    // value, it should fall back to the first biome option for the subset
    biomeOptions.filter(biome => biome.value === spawnBiomeId).length > 0 ? spawnBiomeId : biomeOptions[0].value, [], [spawnBiomeId, biomeOptions])
  })), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: 'Biome override',
    description: "Set the world to a selected biome. This will override the Spawn biome!",
    gamepad: {
      index: 6
    },
    value: (0,react_facet_src.useFacetMap)(value => value.isBiomeOverrideActive, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.isBiomeOverrideActive = newValue;
    }, [], [debugSettings])
  }), /*#__PURE__*/react.createElement(Dropdown, {
    label: "Biome override",
    description: "Select biome to be used in the entire world",
    options: allBiomes,
    disabled: (0,react_facet_src.useFacetMap)(value => !value.isBiomeOverrideActive, [], [debugSettings]),
    onChange: (0,react_facet_src.useFacetCallback)(debugSettings => newValue => {
      debugSettings.biomeOverrideId = newValue;
    }, [], [debugSettings]),
    gamepadIndex: 7,
    value: (0,react_facet_src.useFacetMap)(value => value.biomeOverrideId, [], [debugSettings])
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFileManagement
  }, /*#__PURE__*/react.createElement(FileManagementSection, {
    onExportTemplate: onExportTemplate,
    firstGamepadIndex: 8
  }))));
}

const FileManagementSection = ({
  onExportTemplate,
  firstGamepadIndex
}) => {
  const worldId = useWorldID();
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const clearPlayerData = (0,react_facet_src.useFacetCallback)((facet, worldId) => type => {
    if (worldId != null) {
      facet.clearPlayerData(type, worldId);
    }
  }, [], [worldOperationSharedFacet, worldId]);
  const showClearPlayerDataModal = DeletePlayerDataModal.useShowModal();
  const closeModal = useHideModal();

  const onClearAll = () => {
    clearPlayerData(ClearPlayerDataType.IncludeLocalUser);
    closeModal();
  };

  const onClearAllButLocalUser = () => {
    clearPlayerData(ClearPlayerDataType.SkipLocalUser);
    closeModal();
  };

  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "sectionHeader"
  }, "File management"), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    gamepadIndex: firstGamepadIndex,
    onClick: () => showClearPlayerDataModal({
      clearAll: onClearAll,
      clearAllButLocalUser: onClearAllButLocalUser
    }),
    inputLegend: "Clear player data",
    autofocus: true
  }, 'Clear player data'), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    gamepadIndex: firstGamepadIndex + 1,
    onClick: onExportTemplate,
    inputLegend: "Export template",
    autofocus: true
  }, 'Export template'));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/ScriptingCodingTab.tsx








function ScriptingCodingTab({
  cheatsData,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onUnlockTemplateSettings,
  isEditorWorld
}) {
  const {
    t
  } = localization_useLocalization('CreateNewWorld.scriptingCoding');
  const {
    t: tSideMenu
  } = localization_useLocalization('CreateNewWorldSideMenu');
  const {
    t: tCheats
  } = localization_useLocalization('CreateNewWorld.cheats');
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const cheatSettingsDisabled = (0,react_facet_src.useFacetMap)((cheatsData, isLockedTemplate) => !cheatsData.cheatsEnabled || isLockedTemplate, [], [cheatsData, isLockedTemplate]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldSettingsTabContainer_WorldSettingsTabContainer, {
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    narrationText: tSideMenu('.scriptingCodingTabLabel'),
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    isEditorWorld: isEditorWorld
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: [t('.settingsTitle'), t('.narrationComponentTypeSectionHeader')].join(' . ')
  }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: t('.codeBuilderTitle'),
    title: t('.codeBuilderTitle'),
    description: t('.codeBuilderDescription'),
    gamepad: {
      index: 0
    },
    value: (0,react_facet_src.useFacetMap)(scriptingCoding => scriptingCoding.codeBuilderEnabled, [], [(0,react_facet_src.useSharedFacet)(scriptingCodingSettingsSelector)]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.scriptingCoding.codeBuilderEnabled = newValue;
    }, [], [createNewWorld])
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    key: tCheats('.commandBlocksTitle'),
    title: tCheats('.commandBlocksTitle'),
    description: tCheats('.commandBlocksDescription'),
    disabledNarrationSuffix: tCheats('.settingDisabledHint'),
    gamepad: {
      index: 2
    },
    disabled: cheatSettingsDisabled,
    value: (0,react_facet_src.useFacetMap)(cheats => cheats.commandBlocks, [], [cheatsData]),
    onChange: (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
      createNewWorld.worldCreationData.cheats.commandBlocks = newValue;
    }, [], [createNewWorld])
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/index.tsx










;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/Prompt.tsx







function Prompt_noop() {}

function Prompt() {
  const resourcePacks = (0,react_facet_src.useSharedFacet)(resourcePacksFacet);
  const show = (0,react_facet_src.useFacetMap)(facet => facet.prompt.active, [], [resourcePacks]); // TODO: Check/optimise the equality fn

  const title = (0,react_facet_src.useFacetMap)(facet => facet.prompt.title, [], [resourcePacks]);
  const body = (0,react_facet_src.useFacetMap)(facet => facet.prompt.body, [], [resourcePacks]);
  const buttons = (0,react_facet_src.useFacetMap)(facet => facet.prompt.actions, [], [resourcePacks]);
  const handleOption = (0,react_facet_src.useFacetCallback)(facet => id => {
    facet.prompt.handleAction(id);
  }, [], [resourcePacks]); // Hide the close button if there is only one button

  const hideCloseButton = (0,react_facet_src.useFacetMap)(buttons => buttons.length <= 1, [], [buttons]); // If there is more than one button, we use the first 'secondary' button variant as the close handler

  const closeHandler = (0,react_facet_src.useFacetCallback)(buttons => buttons.length > 1 ? () => {
    var _buttons$find;

    const buttonId = (_buttons$find = buttons.find(({
      variant
    }) => variant === types_PromptActionVariant.Secondary)) === null || _buttons$find === void 0 ? void 0 : _buttons$find.id;

    if (buttonId != null) {
      handleOption(buttonId);
    }
  } : Prompt_noop, [handleOption], [buttons]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: show
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: MODAL_DEFAULT_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeHandler,
    hideCloseButton: hideCloseButton
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: body,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: body
  }))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: false
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (button, index) => /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(ModalButton, {
    button: button,
    index: index,
    onClick: handleOption
  }))))));
}
const MODAL_DEFAULT_BUTTON_ALIAS = 'prompt-default-btn';

function ModalButton({
  button,
  onClick,
  index
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.dlcCheckErrorModal');
  const onClickWithId = (0,react_facet_src.useFacetCallback)(button => () => onClick(button.id), [onClick], [button]);
  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(button => button.variant === types_PromptActionVariant.Primary ? 'primary' : 'secondary', [], [button]));
  return /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: onClickWithId,
    gamepadIndex: index,
    inputLegend: t('.buttonSelectInputLegend'),
    gamepadAlias: index === 0 ? MODAL_DEFAULT_BUTTON_ALIAS : undefined,
    variant: variant === react_facet_src.NO_VALUE ? 'secondary' : variant
  }, (0,react_facet_src.useFacetMap)(button => button.label, [], [button]));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/hooks/useButtonTelemetry.tsx


/**
 * Given a button and a screen name, this function fires a button telemetry event
 * <ScreenName>Screen_<ButtonName>Button_OreUI
 * @param button string with camel cased button name, eg AllWorldsTab
 * @param screen string with camel cased screen name, eg CreateNewWorld
 * @param details Record<string, string> for {string:string} key value pairs
 * @returns void
 */

function useButtonTelemetry() {
  return (0,react_facet_src.useFacetCallback)(telemetry => ({
    button,
    screen,
    details = {}
  }) => telemetry.fireEventButtonPressed(telemetryIdStringFormatting({
    button,
    screen
  }), details), [], [(0,react_facet_src.useSharedFacet)(telemetryFacet)]);
}
/**
 * Given a button and a screen name, this function returns a concatenated string
 * to use for telemetry button events
 * @param button string with camel cased button name, eg AllWorldsTab
 * @param screen string with camel cased screen name, eg CreateNewWorld
 * @returns telemetry id string, eg  <ScreenName>Screen_<ButtonName>Button_OreUI
 */

function telemetryIdStringFormatting({
  button,
  screen
}) {
  return `${screen}Screen_${button}Button_OreUI`;
}
;// CONCATENATED MODULE: ./packages/react-facet/src/Unwrap/Unwrap.ts


/**
 * Renders a child with an unwrapped given facet value
 *
 * @param data facet value
 * @param children render prop which receives the unwrapped facet
 */
const Unwrap = ({
  data,
  children
}) => {
  const unwrapped = (0,dist.useFacetUnwrap)(data);
  return unwrapped === dist.NO_VALUE ? null : children(unwrapped);
};
;// CONCATENATED MODULE: ./packages/ui/src/Drawer/Drawer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Drawer = ({"container":"_2ofy","overlay":"oNyMv","overlayOpen":"s4MUE","content":"sV4l2","anchorTop":"QB5Kg","anchorLeft":"oz9Hz","anchorRight":"JXIjK","anchorBottom":"KMoQ1","contentOpen":"FSf9q","contentDisplayNone":"ywOIV"});
;// CONCATENATED MODULE: ./packages/react-sound-effect/src/SoundEffect.tsx





const SoundEffect_noop = () => {};

function SoundEffect({
  autoplay,
  eventName,
  delay = 0,
  disabled = false,
  cancellable = false
}) {
  const autoplayFacet = (0,react_facet_src.useFacetWrap)(autoplay);
  const cancellableFacet = (0,react_facet_src.useFacetWrap)(cancellable);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled);
  const delayFacet = (0,react_facet_src.useFacetWrap)(delay);
  const eventNameFacet = (0,react_facet_src.useFacetWrap)(eventName);
  const play = usePlay();
  const cancelEffectRef = (0,react.useRef)(SoundEffect_noop);
  const hasMountedRef = (0,react.useRef)(false);
  (0,react_facet_src.useFacetLayoutEffect)((autoplay, delay, disabled, cancellable, eventName) => {
    const shouldPlay = disabled === false && autoplay && eventName !== NO_SOUND;

    if (!hasMountedRef.current) {
      // don't play any sounds on mount
      hasMountedRef.current = true;
      return;
    }

    if (shouldPlay) {
      cancelEffectRef.current = play(eventName, delay !== null && delay !== void 0 ? delay : 0);
    }

    return () => {
      if (!cancellable) return;
      cancelEffectRef.current();
      cancelEffectRef.current = SoundEffect_noop;
    };
  }, [play], [autoplayFacet, delayFacet, disabledFacet, cancellableFacet, eventNameFacet]);
  return null;
}
;// CONCATENATED MODULE: ./packages/ui/src/Drawer/Drawer.tsx






 // Should match the duration in ms for the drawer transition in the stylesheet

const DRAWER_TRANSITION_DURATION = 275;
var Anchor;

(function (Anchor) {
  Anchor[Anchor["Left"] = 0] = "Left";
  Anchor[Anchor["Right"] = 1] = "Right";
  Anchor[Anchor["Top"] = 2] = "Top";
  Anchor[Anchor["Bottom"] = 3] = "Bottom";
})(Anchor || (Anchor = {}));

const anchorClasses = {
  [Anchor.Top]: Drawer.anchorTop,
  [Anchor.Left]: Drawer.anchorLeft,
  [Anchor.Right]: Drawer.anchorRight,
  [Anchor.Bottom]: Drawer.anchorBottom
};
function Drawer_Drawer({
  anchor = Anchor.Right,
  children,
  drawerContent,
  isOpen,
  role = 'inherit',
  onOverlayClick
}) {
  var _isOpen;

  isOpen = (0,react_facet_src.useFacetWrap)((_isOpen = isOpen) !== null && _isOpen !== void 0 ? _isOpen : false);
  const semanticColors = hooks_useSemanticColors(role);
  const [isDrawerExited, setIsDrawerExited] = (0,react_facet_src.useFacetState)(isOpen.get());
  const safeZone = useSafeZone();
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (!isOpen) {
      /**
       * We set an opacity:0 class on the drawer when it is closed
       * to work around a gameface bug where the drawer renders beyond
       * the overflow:hidden boundaries. We don't use display:none because
       * that breaks the entry transition unfortunately (but it would
       * be more correct).
       */
      const timeout = setTimeout(() => {
        setIsDrawerExited(true);
      }, DRAWER_TRANSITION_DURATION);
      return () => {
        clearTimeout(timeout);
      };
    } else {
      setIsDrawerExited(false);
    }
  }, [setIsDrawerExited], [isOpen]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, children, /*#__PURE__*/react.createElement("fast-div", {
    className: Drawer.container
  }, /*#__PURE__*/react.createElement("fast-div", {
    onClick: onOverlayClick,
    className: (0,react_facet_src.useFacetMap)(isOpen => classnames_default()(Drawer.overlay, semanticColors.overlay.base, {
      [Drawer.overlayOpen]: isOpen
    }), [semanticColors], [isOpen])
  }), /*#__PURE__*/react.createElement("fast-div", {
    style: {
      top: anchor === Anchor.Bottom ? '' : safeZone.top + 'px',
      bottom: anchor === Anchor.Top ? '' : safeZone.bottom + 'px',
      right: anchor === Anchor.Left ? '' : safeZone.right + 'px',
      left: anchor === Anchor.Right ? '' : safeZone.left + 'px'
    },
    className: (0,react_facet_src.useFacetMap)((isOpen, isDrawerExited) => classnames_default()(Drawer.content, anchorClasses[anchor], {
      [Drawer.contentOpen]: isOpen,
      [Drawer.contentDisplayNone]: isDrawerExited
    }), [anchor], [isOpen, isDrawerExited])
  }, drawerContent)), /*#__PURE__*/react.createElement(SoundEffect, {
    eventName: "ui.drawer_open",
    autoplay: isOpen
  }), /*#__PURE__*/react.createElement(SoundEffect, {
    eventName: "ui.drawer_close",
    autoplay: (0,react_facet_src.useFacetMap)(isOpen => !isOpen, [], [isOpen])
  }));
}
Drawer_Drawer.Anchor = Anchor;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/images/under-construction-art-cropped.png
const FriendsDrawer_images_under_construction_art_cropped_namespaceObject = __webpack_require__.p + "assets/under-construction-art-cropped-2afbb.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/FriendsDrawer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const FriendsDrawer = ({"container":"Smx2z","scrollContainer":"CeXrm","scrollContainerBanned":"EXjPA","emptyStateArt":"w1M8x","friendContent":"Dbc94"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/AddFriendsButton/AddFriendsButton.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddFriendsButton = ({"addButton":"mSqKT"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/AddFriendsButton/AddFriendsButton.tsx






function AddFriendsButton_AddFriendsButton() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('AddFriendsButton');
  return /*#__PURE__*/react.createElement("div", {
    className: AddFriendsButton.addButton
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "primary",
    onClick: () => historyAPI.push('/xbl_friend_finder'),
    gamepadIndex: 0,
    inputLegend: t('.searchForFriends')
  }, t('.searchForFriends')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }));
}
;// CONCATENATED MODULE: ./packages/ui-internal/src/Border/Border.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Border = ({"Border":"m23U_"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/Border/Border.tsx




const Border_Border = ({
  role
}) => {
  const semanticColors = hooks_useSemanticColors();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Border.Border, semanticColors[role].border.base)
  });
};
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/Images/online-badge.png
const online_badge_namespaceObject = __webpack_require__.p + "assets/online-badge-73dd0.png";
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/PlayerStatusBadge.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerStatusBadge = ({"onlineBadge":"KDWBk"});
;// CONCATENATED MODULE: ./packages/ui/src/PlayerStatusBadge/PlayerStatusBadge.tsx




function PlayerStatusBadge_PlayerStatusBadge() {
  return /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: online_badge_namespaceObject,
    className: PlayerStatusBadge.onlineBadge,
    imageRendering: "pixelated"
  });
}
;// CONCATENATED MODULE: ./packages/ui/src/PlayerAvatar/PlayerAvatar.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerAvatar_PlayerAvatar = ({"PlayerAvatar":"FZHBQ","large":"yRhRU","badge":"hYQ3Q","online":"acBo_","offline":"W7VPS","image":"qA9dD"});
;// CONCATENATED MODULE: ./packages/ui/src/PlayerAvatar/PlayerAvatar.tsx







function PlayerAvatar_PlayerAvatar_PlayerAvatar({
  status = 'online',
  src,
  variant = 'small'
}) {
  const statusFacet = (0,react_facet_src.useFacetWrap)(status);
  const variantFacet = (0,react_facet_src.useFacetWrap)(variant);
  const srcFacet = (0,react_facet_src.useFacetWrap)(src);
  const badgeStyles = (0,react_facet_src.useFacetMap)(status => classnames_default()(PlayerAvatar_PlayerAvatar.badge, status === 'online' ? PlayerAvatar_PlayerAvatar.online : PlayerAvatar_PlayerAvatar.offline), [], [statusFacet]);
  const wrapperStyles = (0,react_facet_src.useFacetMap)(variant => classnames_default()(PlayerAvatar_PlayerAvatar.PlayerAvatar, {
    [PlayerAvatar_PlayerAvatar.large]: variant === 'large'
  }), [], [variantFacet]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: wrapperStyles
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: srcFacet,
    className: PlayerAvatar_PlayerAvatar.image
  }), /*#__PURE__*/react.createElement(Border_Border, {
    role: "neutral"
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: badgeStyles
  }, /*#__PURE__*/react.createElement(PlayerStatusBadge_PlayerStatusBadge, null)));
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayWhite/images/play.png
const play_namespaceObject = __webpack_require__.p + "assets/play-7c0c9.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayWhite/IconPlayWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPlayWhite = ({"iconPlayWhite":"Jc2Hh"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayWhite/IconPlayWhite.tsx




const IconPlayWhite_IconPlayWhite = ({
  className
}) => {
  const classList = className != null ? `${IconPlayWhite.iconPlayWhite} ${className}` : IconPlayWhite.iconPlayWhite;
  return /*#__PURE__*/react.createElement(Image_Image_Image, {
    className: classList,
    src: play_namespaceObject,
    imageRendering: "pixelated"
  });
};
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconDelete/images/delete.png
const delete_namespaceObject = __webpack_require__.p + "assets/delete-dc012.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconDelete/IconDelete.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconDelete_IconDelete = ({"iconDelete":"igbFB"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconDelete/IconDelete.tsx
function IconDelete_extends() { IconDelete_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconDelete_extends.apply(this, arguments); }

function IconDelete_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconDelete_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconDelete_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconDelete_IconDelete_IconDelete = (_ref) => {
  let {
    className
  } = _ref,
      props = IconDelete_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconDelete_IconDelete.iconDelete, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconDelete_extends({}, props, {
    className: classNames,
    src: delete_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/FriendListItem/FriendListItem.tsx










function FriendListItem_withVariant(player, variant) {
  // don't use spread operator here due to win arm64 gameface bug
  return {
    xuid: player.xuid,
    gamerTag: player.gamerTag,
    gamerIcon: player.gamerIcon,
    isOnline: player.isOnline,
    playingOnServerId: player.playingOnServerId,
    isCurrentlyPlaying: player.isCurrentlyPlaying,
    variant,
    titleHistory: player.titleHistory
  };
}

function FriendListItem_noop() {}

const FriendListItem_FriendListItemRouteOnClick = props => {
  const routerAPI = hooks_useRouterAPI();
  const onClick = (0,react_facet_src.useFacetCallback)(item => () => routerAPI.push(`/profile/${item.xuid}`), [routerAPI], [props.itemFacet]);
  return /*#__PURE__*/react.createElement(FriendListItem_FriendListItem, {
    onClick: onClick,
    gamepadIndex: props.index,
    listLength: props.listLengthFacet,
    item: props.itemFacet
  });
};
function FriendListItem_FriendListItem({
  item,
  gamepadIndex,
  listLength,
  onClick
}) {
  const variant = (0,react_facet_src.useFacetMap)(item => item.variant, [], [item]);
  const isFriend = (0,react_facet_src.useFacetMap)(variant => variant === 'friend', [], [variant]);
  const isOnline = (0,react_facet_src.useFacetMap)((item, isFriend) => item.isOnline && isFriend, [], [item, isFriend]);
  const isOffline = (0,react_facet_src.useFacetMap)((isOnline, isFriend) => !isOnline && isFriend, [], [isOnline, isFriend]);
  const sentRequest = (0,react_facet_src.useFacetMap)(variant => variant === 'sent-request', [], [variant]);
  const receivedRequest = (0,react_facet_src.useFacetMap)(variant => variant === 'received-request', [], [variant]);
  const friendId = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(friendInfo => friendInfo.xuid, [], [item]));
  const gamerIcon = (0,react_facet_src.useFacetMap)(friendInfo => friendInfo.gamerIcon, [], [item]);
  const gamerTag = (0,react_facet_src.useFacetMap)(friendInfo => friendInfo.gamerTag, [], [item]);
  const playingOnServerId = (0,react_facet_src.useFacetMap)(friendInfo => friendInfo.playingOnServerId, [], [item]);
  const {
    t
  } = useLocalization_useLocalization('FriendListItem'); // All four different friend item variants share the initial contextual narration, and only differ when it comes to hints

  const contextualNarration = (0,react_facet_src.useFacetMap)((gamerTag, listLength) => [gamerTag, t('.listItem.narrationComponentType'), t('.narrationItemOrderContext', [`${gamepadIndex + 1}`, `${listLength}`]),,].join(' . '), [t, gamepadIndex], [gamerTag, listLength]); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to key --> only render when key is available

  if (friendId === react_facet_src.NO_VALUE) return /*#__PURE__*/react.createElement(react.Fragment, null);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOnline
  }, /*#__PURE__*/react.createElement(OnlineFriend, {
    onClick: onClick,
    gamerTag: gamerTag,
    gamerIcon: gamerIcon,
    friendId: friendId,
    gamepadIndex: gamepadIndex,
    contextualNarration: contextualNarration,
    playingOnServerId: playingOnServerId
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOffline
  }, /*#__PURE__*/react.createElement(OfflineFriend, {
    onClick: onClick,
    gamerTag: gamerTag,
    gamerIcon: gamerIcon,
    friendId: friendId,
    gamepadIndex: gamepadIndex,
    contextualNarration: contextualNarration
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: sentRequest
  }, /*#__PURE__*/react.createElement(SentRequest, {
    onClick: FriendListItem_noop,
    gamerTag: gamerTag,
    gamerIcon: gamerIcon,
    friendId: friendId,
    gamepadIndex: gamepadIndex,
    contextualNarration: contextualNarration
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: receivedRequest
  }, /*#__PURE__*/react.createElement(ReceivedRequest, {
    onClick: FriendListItem_noop,
    gamerTag: gamerTag,
    gamerIcon: gamerIcon,
    friendId: friendId,
    gamepadIndex: gamepadIndex,
    contextualNarration: contextualNarration
  })));
}

function OfflineFriend({
  gamerTag,
  gamerIcon,
  friendId,
  gamepadIndex,
  contextualNarration,
  onClick
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendListItem');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: contextualNarration,
    key: friendId
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    gamepadIndex: 0,
    narrationText: t('.offlineHint'),
    inputLegend: t('.select'),
    onClick: onClick
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    variant: 'large',
    src: gamerIcon,
    status: 'offline'
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, gamerTag)), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, t('.offline')))))));
}

function OnlineFriend({
  gamerTag,
  gamerIcon,
  friendId,
  gamepadIndex,
  contextualNarration,
  onClick,
  playingOnServerId: maybePlayingOnServerId
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendListItem');
  const playingOnServerId = (0,react_facet_src.useFacetWrap)(maybePlayingOnServerId);
  const showJoinButton = (0,react_facet_src.useFacetMap)(playingOnServerId => playingOnServerId != null, [], [playingOnServerId]);
  const serverId = (0,react_facet_src.useFacetMap)(playingOnServerId => playingOnServerId !== null && playingOnServerId !== void 0 ? playingOnServerId : '', [], [playingOnServerId]);
  const networkJoinerFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const friendServerJoinerProgress = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinFriendServerProgress, [], [networkJoinerFacet]);
  const joinFriendServerCoroutine = useFacetCoroutine(networkJoinerFacet => function* (serverId) {
    networkJoinerFacet.joinFriendServer(serverId);
    yield friendServerJoinerProgress;
    networkJoinerFacet.clearJoinFriendServerState();
  }, [friendServerJoinerProgress], [networkJoinerFacet]);
  const joinFriendServer = (0,react_facet_src.useFacetCallback)(serverId => () => {
    joinFriendServerCoroutine(serverId);
  }, [joinFriendServerCoroutine], [serverId]);
  return (
    /*#__PURE__*/
    // TODO: When it's possible to join a friend who's online, the narration should reflect this
    react.createElement(NarrationContext_NarrationContext, {
      text: contextualNarration,
      key: friendId
    }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
      gamepadIndex: gamepadIndex
    }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
      gamepadIndex: 0,
      narrationText: [t('.onlineHint'), t('.buttonSiblings', ['1', '2'])].join(' . '),
      inputLegend: t('.select'),
      onClick: onClick
    }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
      direction: "row"
    }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
      variant: 'large',
      src: gamerIcon,
      status: 'online'
    })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "body"
    }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, gamerTag)), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionShort",
      variant: "dimmer"
    }, t('.online')))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: showJoinButton
    }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
      gamepadIndex: 0,
      narrationText: [t('.joinFriend'), t('.buttonSiblings', ['2', '2'])].join(' . '),
      inputLegend: t('.select'),
      onClick: joinFriendServer
    }, /*#__PURE__*/react.createElement(IconPlayWhite_IconPlayWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionShort"
    }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, t('.join')))))))
  );
}

function SentRequest({
  gamerTag,
  gamerIcon,
  friendId,
  gamepadIndex,
  contextualNarration
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendListItem');
  const narrationWithHint = (0,react_facet_src.useFacetMap)(contextualNarration => [contextualNarration, t('.sentRequestNarration'), t('.sentRequestAdditionalActions')].join(' . '), [t], [contextualNarration]);
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(PaddedPlayerAvatar, {
    src: gamerIcon
  }), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, gamerTag)), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, t('.pending'))), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationWithHint,
    key: friendId
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.select'),
    onClick: () => {},
    narrationText: [t('.delete'), t('.button.narrationComponentType')].join(' . '),
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(IconDelete_IconDelete_IconDelete, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.delete'))))));
}

function ReceivedRequest({
  gamerTag,
  gamerIcon,
  friendId,
  gamepadIndex,
  contextualNarration
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendListItem');
  const handleFriends = (0,react_facet_src.useSharedFacet)(friendsManagerFacet);
  const acceptFriendRequest = (0,react_facet_src.useFacetCallback)(handleFriends => () => handleFriends.acceptRequest(friendId), [friendId], [handleFriends]);
  const rejectFriendRequest = (0,react_facet_src.useFacetCallback)(handleFriends => () => handleFriends.rejectRequest(friendId), [friendId], [handleFriends]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: contextualNarration,
    key: friendId
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement(PaddedPlayerAvatar, {
    src: gamerIcon
  }), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, gamerTag)), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, t('.receivedRequest'))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.select'),
    onClick: acceptFriendRequest,
    narrationText: [t('.accept'), t('.button.narrationComponentType'), t('.narrationItemOrderContext', ['1', '2'])].join(' . '),
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.accept')))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    inputLegend: t('.select'),
    onClick: rejectFriendRequest,
    narrationText: [t('.reject'), t('.button.narrationComponentType'), t('.narrationItemOrderContext', ['2', '2'])].join(' . '),
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.reject'))))));
} // Without ListItem.Action the content in the ListItem lacks proper padding
// To avoid giving the additional actions padding (not letting reject/accept/delete stretch the entire height),
// the padding needs to be set on the avatar itself and not the entire wrapping ListItem


function PaddedPlayerAvatar({
  src
}) {
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    variant: 'large',
    src: src,
    status: 'offline'
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/FriendList/FriendList.tsx








function FriendList({
  loading,
  friendsOnline,
  friendsOffline,
  incomingRequests,
  outgoingRequests,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendList');
  const friendItems = (0,react_facet_src.useFacetMap)((online, offline, incoming, outgoing) => groupFriends({
    friendsOnline: online,
    friendsOffline: offline,
    incomingRequests: incoming,
    outgoingRequests: outgoing
  }), [], [friendsOnline, friendsOffline, incomingRequests, outgoingRequests]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SectionList_SectionList, {
    gamepadIndex: gamepadIndex,
    header: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }), /*#__PURE__*/react.createElement(AddFriendsButton_AddFriendsButton, null)),
    loading: loading,
    data: (0,react_facet_src.useFacetMap)(friendItems => [{
      role: 'successTint',
      title: t('.online', [`${friendItems.online.length}`]),
      narrationTitle: t('.onlineFriends'),
      narrationSuffix: t('.onlineFriendsNumber', [`${friendItems.online.length}`]),
      data: friendItems.online
    }, {
      role: 'neutral',
      title: t('.pending', [`${friendItems.requests.length}`]),
      narrationTitle: t('.pendingFriends'),
      narrationSuffix: t('.pendingFriendsNumber', [`${friendItems.online.length}`]),
      data: friendItems.requests
    }, {
      role: 'secondary',
      title: t('.offline', [`${friendItems.offline.length}`]),
      narrationTitle: t('.offlineFriends'),
      data: friendItems.offline
    }], [t], [friendItems]),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    })),
    sectionSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 3
    }),
    renderSectionHeader: (title, role) => /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
      role: role,
      label: title
    }),
    renderItem: FriendListItem_FriendListItemRouteOnClick
  }));
}
function groupFriends({
  friendsOnline,
  friendsOffline,
  incomingRequests,
  outgoingRequests
}) {
  return {
    online: sortOnlineFriends(friendsOnline).map(friend => FriendListItem_withVariant(friend, 'friend')),
    offline: friendsOffline.map(friend => FriendListItem_withVariant(friend, 'friend')),
    requests: [...incomingRequests.map(friend => FriendListItem_withVariant(friend, 'received-request')), ...outgoingRequests.map(friend => FriendListItem_withVariant(friend, 'sent-request'))]
  };
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/EmptyFriendList/images/no_friends.png
const no_friends_namespaceObject = __webpack_require__.p + "assets/no_friends-1107f.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/EmptyFriendList/EmptyFriendList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const EmptyFriendList = ({"noFriendsContainer":"y1MBg","illustration":"HSft6"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/EmptyFriendList/EmptyFriendList.tsx









function EmptyFriendList_EmptyFriendList() {
  const {
    t
  } = useLocalization_useLocalization('EmptyFriendList');
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.noFriendsCaption')
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: EmptyFriendList.noFriendsContainer
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "center"
  }, t('.noFriendsCaption')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    imageRendering: "pixelated",
    src: no_friends_namespaceObject,
    className: EmptyFriendList.illustration
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(AddFriendsButton_AddFriendsButton, null)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/TemplateScreenNoInternetModal.tsx




const TemplateScreenNoInternetModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.templateScreenNoInternetModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-templateScreenNoInternetModal';
  const onClose = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/hooks/navigate.tsx






function useNavigateToCreateNewWorld() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const buttonTelemetry = useButtonTelemetry();
  return (0,react.useCallback)(() => {
    buttonTelemetry({
      button: 'CreateNewWorld',
      screen: 'Play'
    });
    historyAPI.push('/create-new-world');
  }, [historyAPI, buttonTelemetry]);
}
function useNavigateToCreateFromTemplate() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const worldTemplateList = (0,react_facet_src.useSharedFacet)(worldTemplateListFacet);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const buttonTelemetry = useButtonTelemetry();
  const showNoInternetModal = TemplateScreenNoInternetModal.useShowModal();
  return (0,react_facet_src.useFacetCallback)((worldTemplateList, deviceInformation) => () => {
    buttonTelemetry({
      button: 'CreateFromTemplate',
      screen: 'Play'
    });
    const noLocalTemplates = worldTemplateList.premiumTemplates.length + worldTemplateList.customTemplates.length == 0;
    const noInternetConnection = !deviceInformation.isOnline;

    if (noLocalTemplates && noInternetConnection) {
      showNoInternetModal();
    } else {
      historyAPI.push('/create-new-world-from-template');
    }
  }, [showNoInternetModal, historyAPI, buttonTelemetry], [worldTemplateList, deviceInformation]);
}
function useOpenFeedbackPage() {
  const webBrowserSharedFacet = (0,react_facet_src.useSharedFacet)(webBrowserFacet);
  const buttonTelemetry = useButtonTelemetry();
  const openFeedbackPage = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    buttonTelemetry({
      button: 'Feedback',
      screen: 'Play'
    });
    webBrowser.openLink(WebBrowserLink.PlayScreenFeedbackPage);
  }, [buttonTelemetry], [webBrowserSharedFacet]);
  return openFeedbackPage;
}
function useOptOut(tab) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const screenTechStackSharedFacet = (0,react_facet_src.useSharedFacet)(screenTechStackFacet);
  const buttonTelemetry = useButtonTelemetry();
  const optOut = (0,react_facet_src.useFacetCallback)(screenTechStack => () => {
    buttonTelemetry({
      button: 'OptOut',
      screen: 'Play'
    });
    screenTechStack.selectTechStackForScreen(ScreenName.PlayScreen, UITechStack.JsonUI);
    historyAPI.replace('/play/' + tab);
  }, [historyAPI, tab, buttonTelemetry], [screenTechStackSharedFacet]);
  return optOut;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ParentalPermissionMessage/ParentalPermissionMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ParentalPermissionMessage = ({"emptyStateArt":"OvFxx","emptyStateArtBig":"vNRQM"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ParentalPermissionMessage/images/parental-permission-art.png
const parental_permission_art_namespaceObject = __webpack_require__.p + "assets/parental-permission-art-80d7f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ParentalPermissionMessage/images/external-link.png
const ParentalPermissionMessage_images_external_link_namespaceObject = __webpack_require__.p + "assets/external-link-b22bb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ParentalPermissionMessage/ParentalPermissionMessage.tsx









function ParentalPermissionMessage_ParentalPermissionMessage({
  borderless = false,
  gamepadIndex = 0
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.parentalPermissionMessage'); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 256
  });
  const openParentValidationHelpPage = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    webBrowser.openLink(WebBrowserLink.ParentPermissionHelpPage);
  }, [], [(0,react_facet_src.useSharedFacet)(webBrowserFacet)]);
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: borderless,
    gamepadIndex: gamepadIndex,
    title: t('.title'),
    text: t('.message'),
    imgSrc: parental_permission_art_namespaceObject,
    imgClass: narrowImage || borderless ? ParentalPermissionMessage.emptyStateArt : ParentalPermissionMessage.emptyStateArtBig,
    buttons: [{
      text: t('.helpButton'),
      imgSrc: ParentalPermissionMessage_images_external_link_namespaceObject,
      inputLegend: t('.helpButton'),
      onClick: openParentValidationHelpPage
    }]
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/ParentalPermissionMessage/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/BannedMessage/BannedMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const BannedMessage = ({"header":"AzDBT","title":"fiVzs","EmptyStateMessage":"B7SS5","borderless":"qt3Wn","buttonContainer":"YrEch"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/BannedMessage/BannedMessage.tsx













function BannedMessage_BannedMessage({
  borderless = false,
  spaceless = false
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.BannedMessage');
  const {
    t: bannedReasons
  } = useLocalization_useLocalization('PlayerBannedModalRoute.');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const reasons = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(userAccount => userAccount.banReason, [], [userAccount]));
  const reasonLocalization = bannedReasons(String(reasons));
  const semanticColors = hooks_useSemanticColors('neutral80');
  const className = classnames_default()(BannedMessage.EmptyStateMessage, semanticColors.background.base, semanticColors.border.base, {
    [BannedMessage.borderless]: borderless
  });
  const narrationText = [t('.title'), t('.reasonsTitle'), reasonLocalization, t('.disclaimer')].join(' . ');
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, spaceless ? null : /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: 'noticeTint',
    narrationId: "banned-banner"
  }, /*#__PURE__*/react.createElement("div", {
    className: BannedMessage.header
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.title')))), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: className
  }, /*#__PURE__*/react.createElement("div", {
    className: BannedMessage.title
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmest",
    align: "left"
  }, t('.reasonsTitle'), " ", /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, reasonLocalization)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmest",
    align: "left"
  }, t('.disclaimer')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: BannedMessage.buttonContainer
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    autofocus: true,
    inputLegend: t('.helpButton'),
    variant: "secondary",
    imgSrc: external_link_namespaceObject,
    onClick: (0,react_facet_src.useFacetCallback)(webBrowser => () => {
      webBrowser.openLink(WebBrowserLink.BannedHelpPage);
    }, [], [(0,react_facet_src.useSharedFacet)(webBrowserFacet)])
  }, t('.helpButton'))))), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/NoInternetMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NoInternetMessage = ({"emptyStateArt":"_3knR","emptyStateArtBig":"LFQ28"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/no-internet-art.png
const no_internet_art_namespaceObject = __webpack_require__.p + "assets/no-internet-art-6e094.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/NoInternetMessage.tsx







function NoInternetMessage_NoInternetMessage({
  tab,
  borderless
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const text = `${t('.noInternetMessage')} ${t('.noInternetMessage.' + tab)}`; // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 256
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    borderless: borderless,
    gamepadIndex: 0,
    text: text,
    imgSrc: no_internet_art_namespaceObject,
    imgClass: narrowImage || borderless ? NoInternetMessage.emptyStateArt : NoInternetMessage.emptyStateArtBig
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/NoSubscriptionMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const NoSubscriptionMessage = ({"noSubscriptionArt":"nbcjU","noSubscriptionArtBig":"rBBkq"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/no-subscription-art.png
const no_subscription_art_namespaceObject = __webpack_require__.p + "assets/no-subscription-art-9fdea.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/NoSubscriptionMessage.tsx











function NoSubscriptionMessage_NoSubscriptionMessage({
  narrow = false,
  borderless = false,
  button = false
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.noSubscriptionMessage');
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const title = (0,react_facet_src.useFacetMap)(device => {
    if (consoles_isPlaystationPlatform(device.platform)) {
      return t('.titlePlaystation');
    }

    if (consoles_isNintendoPlatform(device.platform)) {
      return t('.titleNintendo');
    }

    return '';
  }, [t], [deviceInformationSharedFacet]);
  const text = t('.subtitle'); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 256
  });
  const noNintendoSubscriptionInformation = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    webBrowser.openLink(WebBrowserLink.NintendoSwitchTechnicalSupportPage);
  }, [], [(0,react_facet_src.useSharedFacet)(webBrowserFacet)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    borderless: borderless,
    title: title,
    text: text,
    imgSrc: no_subscription_art_namespaceObject,
    imgClass: narrowImage || narrow ? NoSubscriptionMessage.noSubscriptionArt : NoSubscriptionMessage.noSubscriptionArtBig,
    buttons: button ? [{
      text: t('.moreInformation'),
      variant: 'secondary',
      onClick: noNintendoSubscriptionInformation
    }] : undefined
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/FriendsDrawer/FriendsDrawer.tsx
























function useDefaultFocusOnOpen(gamepadAlias, isOpen) {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (isOpen) {
      const cleanup = setFocusedId(gamepadAlias);
      return cleanup === react_facet_src.NO_VALUE ? undefined : cleanup;
    }
  }, [gamepadAlias, setFocusedId], [isOpen]);
}

function UnderConstruction() {
  const {
    t
  } = useLocalization_useLocalization('FriendsDrawer');
  const optOut = useOptOut('friends');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    borderless: true,
    imgSrc: FriendsDrawer_images_under_construction_art_cropped_namespaceObject,
    imgClass: FriendsDrawer.emptyStateArt,
    title: t('.emptyStateTitle'),
    text: t('.emptyStateBody'),
    buttons: [{
      text: t('.emptyStateButtonLabel'),
      inputLegend: t('.emptyStateButtonInputLegend'),
      onClick: optOut
    }]
  }));
}

function useShouldShowUnderConstruction() {
  const isFeatureFlagEnabled = useFeatureFlag(FeatureFlag.FriendsDrawer);
  return (0,react_facet_src.useFacetMap)((user, device) => // Show it if the feature flag isn't set
  !isFeatureFlagEnabled || // Or if the user is on a different platform without being signed in to their MS account
  !consoles_isPlaystationPlatform(device.platform) && !consoles_isNintendoPlatform(device.platform) && !user.isLoggedInWithMicrosoftAccount, [isFeatureFlagEnabled], [(0,react_facet_src.useSharedFacet)(userAccountFacet), (0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
}
function DrawerContent({
  closeButtonAlias,
  closeFriendsDrawer,
  isDrawerOpen,
  role = 'neutral80'
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendsDrawer');
  const semanticColors = hooks_useSemanticColors(role);
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const friendsList = (0,react_facet_src.useSharedFacet)(friendsListFacet_friendsListFacet);
  const isFriendsDrawerClosed = (0,react_facet_src.useFacetMap)(isDrawerOpen => !isDrawerOpen, [], [isDrawerOpen]);
  const friendsLoading = (0,react_facet_src.useFacetMap)(friendsList => !friendsList.isLoaded, [], [friendsList]);
  const incomingRequests = (0,react_facet_src.useFacetWrap)([]); // TODO

  const outgoingRequests = (0,react_facet_src.useFacetWrap)([]); // TODO

  const friendsOnline = (0,react_facet_src.useFacetMap)(friendsList => friendsList.friends != null ? friendsList.friends.filter(friend => friend.isOnline && friend.titleHistory == PlayerTitleHistory.HasPlayed) : [], [], [friendsList]);
  const friendsOffline = (0,react_facet_src.useFacetMap)(friendsList => friendsList.friends != null ? friendsList.friends.filter(friend => !friend.isOnline && friend.titleHistory == PlayerTitleHistory.HasPlayed) : [], [], [friendsList]); // If the player has no friends or incoming/outgoing requests, an empty state should be shown

  const emptyFriendsList = (0,react_facet_src.useFacetMap)((incomingRequests, outgoingRequests, friendsOnline, friendsOffline) => incomingRequests.length === 0 && outgoingRequests.length === 0 && friendsOnline.length === 0 && friendsOffline.length === 0, [], [incomingRequests, outgoingRequests, friendsOnline, friendsOffline]);
  const drawerContentState = (0,react_facet_src.useFacetMap)((shouldShowUnderConstruction, userAccount, deviceInformation, emptyFriendsList) => {
    if (shouldShowUnderConstruction) return 'under-construction';
    if (!deviceInformation.isOnline) return 'offline'; // "Parental permissions is needed" is shown when permission for either multiplayer _or_ adding friends is missing
    // This will be become more granular in the future

    if (userAccount.isParentalPermissionRequiredForMultiplayer || !userAccount.isAllowedToAddFriends) return 'parental-permission';
    if (!userAccount.hasPremiumNetworkAccess && consoles_isNintendoPlatform(deviceInformation.platform)) return 'no-subscription-nintendo';
    if (userAccount.isBanned) return 'banned';
    if (emptyFriendsList) return 'empty-friends-list';
    return 'friends-list';
  }, [], [useShouldShowUnderConstruction(), userAccount, deviceInformation, emptyFriendsList]);
  const narrationWithHint = (0,react_facet_src.useFacetMap)(device => {
    if (isWindowsPlatform(device.platform)) return [t('.exitShortcut', ['F']), t('.closeButtonNarrationHint')].join(' . ');
    if (isTouchscreenPlatform(device.inputMethods)) return t('.closeButtonNarrationHint');
    return '';
  }, [t], [deviceInformation]);
  const narrationContextHint = (0,react_facet_src.useFacetMap)(friendsOnline => [t('.friendsDrawerName'), t('.numberOfFriends', [`${friendsOnline.length}`])].join(' . '), [t], [friendsOnline]);
  const title = (0,react_facet_src.useFacetMap)((drawerContentState, friendsOnline) => // Only show the friends amount when rendering the friends list
  drawerContentState != 'friends-list' ? t('.title') : t('.titleWithAmount', [`${friendsOnline.length}`]), [t], [drawerContentState, friendsOnline]);
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    disabled: isFriendsDrawerClosed,
    shouldBindFocus: true
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: classnames_default()(FriendsDrawer.container, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    onClick: closeFriendsDrawer,
    options: {
      button: types_ButtonType.B,
      inputLegend: TitleBar_TitleBar.Buttons.Close.useLocalization().t('.inputLegend')
    }
  }), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationContextHint
  }, /*#__PURE__*/react.createElement(TitleBar_TitleBar, {
    gamepadIndex: 0,
    right: /*#__PURE__*/react.createElement(TitleBar_TitleBar.Buttons.Close.Component, {
      gamepadAlias: closeButtonAlias,
      narrationSuffix: narrationWithHint,
      gamepadIndex: 0,
      onClick: closeFriendsDrawer
    })
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, title))), /*#__PURE__*/react.createElement(Unwrap, {
    data: drawerContentState
  }, drawerContentState => {
    switch (drawerContentState) {
      case 'empty-friends-list':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainer
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(EmptyFriendList_EmptyFriendList, null)));

      case 'friends-list':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.friendContent
        }, /*#__PURE__*/react.createElement(FriendList, {
          loading: friendsLoading,
          gamepadIndex: 0,
          friendsOnline: friendsOnline,
          friendsOffline: friendsOffline,
          incomingRequests: incomingRequests,
          outgoingRequests: outgoingRequests
        }));

      case 'parental-permission':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainer
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(ParentalPermissionMessage_ParentalPermissionMessage, {
          borderless: true
        })));

      case 'no-subscription-nintendo':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainer
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(NoSubscriptionMessage_NoSubscriptionMessage, {
          narrow: true,
          borderless: true,
          button: true
        })));

      case 'banned':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainerBanned
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(BannedMessage_BannedMessage, {
          borderless: true,
          spaceless: true
        })));

      case 'offline':
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainer
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(NoInternetMessage_NoInternetMessage, {
          tab: "friends",
          borderless: true
        })));

      case 'under-construction':
      default:
        return /*#__PURE__*/react.createElement("div", {
          className: FriendsDrawer.scrollContainer
        }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
          gamepadIndex: 1,
          flexShrinkWrapper: true
        }, /*#__PURE__*/react.createElement(UnderConstruction, null)));
    }
  }))));
}
function FriendsDrawer_FriendsDrawer({
  children,
  role = 'neutral80'
}) {
  const DEFAULT_FOCUS_ALIAS = 'friends-close-btn';
  const [isFriendsDrawerOpen, setIsFriendsDrawerOpen] = (0,react_facet_src.useFacetState)(false);

  function toggleFriendsDrawer() {
    setIsFriendsDrawerOpen(prev => prev === react_facet_src.NO_VALUE ? prev : !prev);
  }

  function closeFriendsDrawer() {
    setIsFriendsDrawerOpen(false);
  }

  function openFriendsDrawer() {
    setIsFriendsDrawerOpen(true);
  }

  useDefaultFocusOnOpen(DEFAULT_FOCUS_ALIAS, isFriendsDrawerOpen);
  return /*#__PURE__*/react.createElement(Drawer_Drawer, {
    anchor: Drawer_Drawer.Anchor.Right,
    drawerContent: /*#__PURE__*/react.createElement(DrawerContent, {
      closeFriendsDrawer: closeFriendsDrawer,
      isDrawerOpen: isFriendsDrawerOpen,
      closeButtonAlias: DEFAULT_FOCUS_ALIAS,
      role: role
    }),
    isOpen: isFriendsDrawerOpen,
    onOverlayClick: closeFriendsDrawer
  }, children({
    toggleFriendsDrawer,
    openFriendsDrawer,
    closeFriendsDrawer,
    isFriendsDrawerOpen
  }), /*#__PURE__*/react.createElement(ToggleDrawerShortcut, {
    onClick: toggleFriendsDrawer,
    isFriendsDrawerOpen: isFriendsDrawerOpen
  }));
}
/**
 * This shortcut is not used until a pattern for narration is confirmed with GlobalShortcuts
 */

function ToggleDrawerShortcut({
  onClick,
  isFriendsDrawerOpen
}) {
  const {
    t
  } = useLocalization_useLocalization('FriendsDrawer');
  return /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    onClick: onClick,
    options: (0,react_facet_src.useFacetMap)((isOpen, isFocusInputGamepad) => ({
      disabled: !isFocusInputGamepad,
      button: types_ButtonType.Y,
      inputLegend: t(isOpen ? '.closeDrawerShortcutInputLegend' : '.openDrawerShortcutInputLegend')
    }), [t], [isFriendsDrawerOpen, useIsFocusInputGamepad()])
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/DebugDrawer/DebugDrawer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DebugDrawer = ({"container":"cmQ5x","scrollContainer":"ZErRB"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/Tabs/CreateTestWorldTab.tsx






/**
 * This tab is used by a developer tool which creates a test world with some pre-defined settings.
 * Visually, it only displays a loading spinner. Users will not be on this tab for long, as it will
 * instantly trigger world creation.
 */

const useSetTestSettingsAndCreateWorld = ({
  generalData,
  advancedData,
  cheatsData
}) => {
  const routerAPI = hooks_useRouterAPI();
  const notifications = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  return (0,react_facet_src.useFacetCallback)((generalData, advancedData, cheatsData, notifications) => redirect => {
    generalData.gameMode = GameMode.CREATIVE;
    advancedData.useFlatWorld = true;
    cheatsData.cheatsEnabled = true;
    cheatsData.daylightCycle = DaylightCycleEnum.ALWAYS_DAY;
    cheatsData.mobSpawning = false;
    cheatsData.weather = false;
    cheatsData.keepInventory = true;
    notifications.queueSnackbar('Test world settings applied');

    if (redirect) {
      routerAPI.replace('/create-new-world/general');
    }
  }, [routerAPI], [generalData, advancedData, cheatsData, notifications]);
};

const CreateTestWorldTab = ({
  generalData,
  advancedData,
  cheatsData
}) => {
  const isRouteActive = useRouteIsActive();
  const setTestSettingsAndCreateWorld = useSetTestSettingsAndCreateWorld({
    generalData,
    advancedData,
    cheatsData
  });
  useFacetEffect(isRouteActive => {
    // Ensure we call this on every visit, not just the first time
    // this tab is mounted.
    if (isRouteActive) {
      // This timeout solves an edge case issue where the redirect
      // within setTestSettingsAndCreateWorld() doesn't succeed if
      // this tab is navigated to from elsewhere (eg. Play Screen)
      // It's not a priority for us to dig into this race condition
      // at the time of writing.
      setTimeout(() => {
        setTestSettingsAndCreateWorld(true);
      }, 500);
    }
  }, [setTestSettingsAndCreateWorld], [isRouteActive]);
  return /*#__PURE__*/React.createElement(ScrollView, {
    loading: true,
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement("div", null));
};
/**
 * We need to export this tab via a wrapper, because it is conditionally rendered but needs to use hooks.
 * We conditionally render it because we only want it available on dev builds.
 */


const CreateTestWorldTabWrapper = ({
  generalData,
  advancedData,
  cheatsData
}) => {
  return /*#__PURE__*/React.createElement(TabWrapper, {
    component: useCallback(() => /*#__PURE__*/React.createElement(CreateTestWorldTab, {
      generalData: generalData,
      advancedData: advancedData,
      cheatsData: cheatsData
    }), [generalData, advancedData, cheatsData]),
    tab: "create-test-world"
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/DebugDrawer/tools/CreateTestWorld/CreateTestWorld.tsx








const CreateTestWorldInfoModal = registerModal(({
  onClose
}) => {
  const backBtnAlias = 'CreateTestWorldInfoModal-close-btn';
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: backBtnAlias,
    onOverlayClick: onClose
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, "Create Test World"), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: false
  }, "This button applies the following settings on the Create New World screen:"), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    gamepadIndex: 1,
    items: (0,react_facet_src.useFacetWrap)(['Game Mode: Creative', 'Flat World: true', 'Cheats Enabled: true', 'Daylight cycle: Always Day', 'Mob spawning: false', 'Weather: false', 'Keep Inventory: true'])
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: false
  }, "Any other settings which don't conflict with the above will remain unchanged.")), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: onClose,
    inputLegend: 'Back',
    gamepadAlias: backBtnAlias
  }, "Back")));
});
function CreateTestWorld({
  onComplete
}) {
  const routerAPI = hooks_useRouterAPI();
  const routePathname = useRoutePathname();
  const showInfoModal = CreateTestWorldInfoModal.useModal();
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const worldData = (0,react_facet_src.useFacetMap)(facet => facet.worldCreationData, [], [createNewWorld]);
  const advancedData = (0,react_facet_src.useFacetMap)(facet => facet.advanced, [], [worldData]);
  const cheatsData = (0,react_facet_src.useFacetMap)(facet => facet.cheats, [], [worldData]);
  const generalData = (0,react_facet_src.useFacetMap)(facet => facet.general, [], [worldData]);
  const setTestSettingsAndCreateWorld = useSetTestSettingsAndCreateWorld({
    advancedData,
    cheatsData,
    generalData
  });
  const createTestWorld = (0,react_facet_src.useFacetCallback)(routePathname => () => {
    // If we aren't on CNW already, send the user there
    if (!routePathname.startsWith('/create-new-world')) {
      routerAPI.push('/create-new-world/create-test-world');
    } else {
      setTestSettingsAndCreateWorld();
    }

    onComplete();
  }, [onComplete, setTestSettingsAndCreateWorld, routerAPI], [routePathname]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: createTestWorld,
    inputLegend: "Create Test World"
  }, "Create Test World"), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    align: "center",
    verticalAlign: "center"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    onClick: showInfoModal.show,
    gamepadIndex: 1,
    withUnderlinePolyfill: true
  }, "What does this do?")), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showInfoModal.isVisible
  }, /*#__PURE__*/react.createElement(CreateTestWorldInfoModal.Component, {
    onClose: showInfoModal.hide
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/DebugDrawer/DebugDrawer.tsx












function DebugDrawer_useDefaultFocusOnOpen(gamepadAlias, isOpen) {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  (0,react_facet_src.useFacetEffect)(isOpen => {
    if (isOpen) {
      const cleanup = setFocusedId(gamepadAlias);
      return cleanup === react_facet_src.NO_VALUE ? undefined : cleanup;
    }
  }, [gamepadAlias, setFocusedId], [isOpen]);
}

function MountTool({
  options,
  when,
  children
}) {
  return options != null && options.indexOf(when) > -1 ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(Divider_Divider_Divider, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), children) : null;
}

function DebugDrawer_DrawerContent({
  closeButtonAlias,
  closeDebugDrawer,
  isDrawerOpen,
  role = 'neutral80',
  options
}) {
  const {
    t
  } = useLocalization_useLocalization('DebugDrawer');
  const semanticColors = hooks_useSemanticColors(role);
  const isDebugDrawerClosed = (0,react_facet_src.useFacetUnwrap)(isDrawerOpen) != true;
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    bounded: true,
    gamepadIndex: 0,
    scrollRef: ref,
    disabled: isDebugDrawerClosed
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    style: {
      flex: 1
    }
  }, /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    onClick: closeDebugDrawer,
    options: {
      button: types_ButtonType.B,
      inputLegend: TitleBar_TitleBar.Buttons.Close.useLocalization().t('.inputLegend')
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(DebugDrawer.container, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(TitleBar_TitleBar, {
    gamepadIndex: 0,
    right: /*#__PURE__*/react.createElement(TitleBar_TitleBar.Buttons.Close.Component, {
      gamepadAlias: closeButtonAlias,
      narrationSuffix: t('.closeButtonNarrationHint'),
      gamepadIndex: 0,
      onClick: closeDebugDrawer
    })
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, "Developer Tools"))), /*#__PURE__*/react.createElement("div", {
    className: DebugDrawer.scrollContainer
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 1,
    flexShrinkWrapper: true
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    align: "center"
  }, "These tools are only available in developer builds and they are contextual to each screen."), /*#__PURE__*/react.createElement(MountTool, {
    options: options,
    when: 'create-test-world'
  }, /*#__PURE__*/react.createElement(CreateTestWorld, {
    onComplete: closeDebugDrawer
  }))))))));
}
function DebugDrawer_DebugDrawer({
  children,
  role = 'neutral80',
  options
}) {
  const DEFAULT_FOCUS_ALIAS = 'debug-close-btn';
  const [isDebugDrawerOpen, setIsDebugDrawerOpen] = (0,react_facet_src.useFacetState)(false);

  function toggleDebugDrawer() {
    setIsDebugDrawerOpen(prev => prev === react_facet_src.NO_VALUE ? prev : !prev);
  }

  function closeDebugDrawer() {
    setIsDebugDrawerOpen(false);
  }

  function openDebugDrawer() {
    setIsDebugDrawerOpen(true);
  }

  DebugDrawer_useDefaultFocusOnOpen(DEFAULT_FOCUS_ALIAS, isDebugDrawerOpen);
  return /*#__PURE__*/react.createElement(Drawer_Drawer, {
    anchor: Drawer_Drawer.Anchor.Right,
    drawerContent: /*#__PURE__*/react.createElement(DebugDrawer_DrawerContent, {
      options: options,
      closeDebugDrawer: closeDebugDrawer,
      isDrawerOpen: isDebugDrawerOpen,
      closeButtonAlias: DEFAULT_FOCUS_ALIAS,
      role: role
    }),
    isOpen: isDebugDrawerOpen,
    onOverlayClick: closeDebugDrawer
  }, children({
    toggleDebugDrawer,
    openDebugDrawer,
    closeDebugDrawer,
    isDebugDrawerOpen
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/VanillaScreenLayout/VanillaScreenLayout.tsx












const VanillaScreenLayout_falseFacet = (0,react_facet_src.createStaticFacet)(false);

const VanillaScreenLayout_noop = () => {};

const mockDebugDrawerProps = {
  isDebugDrawerOpen: VanillaScreenLayout_falseFacet,
  closeDebugDrawer: VanillaScreenLayout_noop,
  openDebugDrawer: VanillaScreenLayout_noop,
  toggleDebugDrawer: VanillaScreenLayout_noop
};

const MockDebugDrawer = props => /*#__PURE__*/react.createElement(react.Fragment, null, props.children(mockDebugDrawerProps));

const MaybeDebugDrawer = ({
  condition,
  children,
  options
}) => {
  const isFeatureFlagEnabled = useFeatureFlag(FeatureFlag.DebugDrawer);
  const shouldShowDrawer = isFeatureFlagEnabled && condition && "publish" === 'release';
  return shouldShowDrawer ? /*#__PURE__*/react.createElement(DebugDrawer_DebugDrawer, {
    children: children,
    options: options
  }) : /*#__PURE__*/react.createElement(MockDebugDrawer, {
    children: children
  });
};

function VanillaScreenLayoutChildren(props) {
  const isAnyDrawerOpen = (0,react_facet_src.useFacetMap)((x, y) => x || y, [], [props.isDebugDrawerOpen, props.isFriendsDrawerOpen]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, props.children({
    isAnyDrawerOpen
  }));
}

const mockFriendsDrawerProps = {
  isFriendsDrawerOpen: VanillaScreenLayout_falseFacet,
  closeFriendsDrawer: VanillaScreenLayout_noop,
  openFriendsDrawer: VanillaScreenLayout_noop,
  toggleFriendsDrawer: VanillaScreenLayout_noop
};

const MockFriendsDrawer = props => /*#__PURE__*/react.createElement(react.Fragment, null, props.children(mockFriendsDrawerProps));

const MaybeFriendsDrawer = ({
  condition,
  children
}) => {
  const shouldShowDrawer = (0,react_facet_src.useFacetUnwrap)(condition) === true;
  return shouldShowDrawer ? /*#__PURE__*/react.createElement(FriendsDrawer_FriendsDrawer, {
    children: children
  }) : /*#__PURE__*/react.createElement(MockFriendsDrawer, {
    children: children
  });
};

function VanillaScreenLayout_VanillaScreenLayout({
  children,
  debugDrawer,
  delegateByAlias,
  friendsDrawer,
  gamepadAlias,
  onBack,
  title,
  screenAnalyticsId
}) {
  const {
    t
  } = useLocalization_useLocalization('VanillaScreenLayout');
  const routerAPI = hooks_useRouterAPI();
  const trackButtonClick = useButtonTelemetry();
  const isDebugDrawerFeatureFlagEnabled = useFeatureFlag(FeatureFlag.DebugDrawer);
  const isDebugDrawerEnabled = debugDrawer != null && debugDrawer.length > 0 && isDebugDrawerFeatureFlagEnabled;
  const isFriendsDrawerEnabled = (0,react_facet_src.useFacetWrap)(friendsDrawer !== null && friendsDrawer !== void 0 ? friendsDrawer : false);
  const screenNarration = (0,react_facet_src.useFacetMap)(title => t('.narration.title', [title]), [t], [(0,react_facet_src.useFacetWrap)(title)]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(MaybeDebugDrawer, {
    condition: isDebugDrawerEnabled,
    options: debugDrawer
  }, ({
    toggleDebugDrawer,
    isDebugDrawerOpen
  }) => /*#__PURE__*/react.createElement(MaybeFriendsDrawer, {
    condition: isFriendsDrawerEnabled
  }, ({
    toggleFriendsDrawer,
    isFriendsDrawerOpen
  }) => /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: screenNarration
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: onBack !== null && onBack !== void 0 ? onBack : routerAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, title),
    right: /*#__PURE__*/react.createElement(react.Fragment, null,  false ? /*#__PURE__*/0 : null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: isFriendsDrawerEnabled
    }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.Divider, null), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.FriendsButton, {
      onClick: () => {
        trackButtonClick({
          button: 'Friends',
          screen: screenAnalyticsId
        });
        toggleFriendsDrawer();
      },
      gamepadIndex: 2
    })))),
    defaultFocusedChildBehavior: "remember",
    gamepadAlias: gamepadAlias,
    delegateByAlias: delegateByAlias
  }, /*#__PURE__*/react.createElement(VanillaScreenLayoutChildren, {
    isDebugDrawerOpen: isDebugDrawerOpen,
    isFriendsDrawerOpen: isFriendsDrawerOpen
  }, children)))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/WorldSettings.tsx
















function WorldSettings({
  advancedData,
  cheatsData,
  experimentsData,
  generalData,
  multiplayerData,
  worldPacks,
  worldPreviewImage,
  isUsingTemplate,
  isLockedTemplate,
  isAchievementsDisabled,
  achievementsDisabledMessages,
  onActivatePack,
  onDeactivatePack,
  onChangePackPriority,
  onClickPackSettings,
  onUnlockTemplateSettings,
  mainActionCallback,
  realmsActionCallback,
  worldSummary,
  isEditorWorld,
  onDuplicateWorld,
  onDeleteWorld,
  onExportWorld,
  onExportTemplate,
  onOptOut,
  onSeedValueChange = () => {},
  isSeedChangeLocked,
  isPageLoading
}) {
  const mode = (0,react.useContext)(WorldModeContext);
  const isTrialAccountFacet = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const isEduBuildFacet = (0,react_facet_src.useSharedFacet)(isEduBuildSelector);
  useAutofocus();
  const showRealmsButton = (0,react_facet_src.useFacetMap)((isEditor, isEduBuild, isTrialAccount) => !(isEditor || isEduBuild || isTrialAccount), [], [isEditorWorld, isEduBuildFacet, isTrialAccountFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(WorldSettingsSideMenu_WorldSettingsSideMenu, {
    showRealmsButton: showRealmsButton,
    showSpinner: (0,react_facet_src.useFacetWrap)(isPageLoading !== null && isPageLoading !== void 0 ? isPageLoading : false),
    worldPreviewImage: worldPreviewImage,
    onMainActionClick: mainActionCallback,
    onMainRealmsActionClick: realmsActionCallback,
    worldPacks: worldPacks,
    generalData: generalData
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 8,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(GeneralTab, {
      isLockedTemplate: isLockedTemplate,
      generalData: generalData,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      worldSummary: worldSummary,
      isUsingTemplate: isUsingTemplate,
      isEditorWorld: isEditorWorld,
      onDuplicateWorld: onDuplicateWorld,
      onDeleteWorld: onDeleteWorld,
      onExportWorld: onExportWorld,
      onOptOut: onOptOut
    }), [isLockedTemplate, generalData, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, worldSummary, isUsingTemplate, isEditorWorld, onDuplicateWorld, onDeleteWorld, onExportWorld, onOptOut]),
    tab: "general"
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ExperimentalFeaturesTab, {
      experimentsData: experimentsData,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      isEditorWorld: isEditorWorld
    }), [experimentsData, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, isEditorWorld]),
    tab: "experimental"
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(CheatsTab, {
      cheatsData: cheatsData,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      isEditorWorld: isEditorWorld
    }), [cheatsData, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, isEditorWorld]),
    tab: "cheats"
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "advanced",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(AdvancedTab, {
      advancedData: advancedData,
      cheatsData: cheatsData,
      isUsingTemplate: isUsingTemplate,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      isEditorWorld: isEditorWorld,
      onSeedValueChange: onSeedValueChange,
      isSeedChangeLocked: isSeedChangeLocked
    }), [advancedData, cheatsData, isUsingTemplate, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, isEditorWorld, onSeedValueChange, isSeedChangeLocked])
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "multiplayer",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(MultiplayerTab_MultiplayerTab, {
      multiplayerData: multiplayerData,
      worldPacks: worldPacks,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onDeactivatePack: onDeactivatePack,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      isEditorWorld: isEditorWorld
    }), [multiplayerData, worldPacks, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onDeactivatePack, onUnlockTemplateSettings, isEditorWorld])
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(isEduBuild => isEduBuild && mode !== 'edit', [mode], [isEduBuildFacet])
  }, /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ScriptingCodingTab, {
      cheatsData: cheatsData,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      isEditorWorld: isEditorWorld
    }), [cheatsData, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, isEditorWorld]),
    tab: "scripting-coding"
  })), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(ResourcePacksTab_ResourcePacksTab, {
      worldPacks: worldPacks,
      multiplayerData: multiplayerData,
      isEditorWorld: isEditorWorld,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onActivatePack: onActivatePack,
      onDeactivatePack: onDeactivatePack,
      onChangePackPriority: onChangePackPriority,
      onClickPackSettings: onClickPackSettings,
      onUnlockTemplateSettings: onUnlockTemplateSettings
    }), [worldPacks, multiplayerData, isEditorWorld, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onActivatePack, onDeactivatePack, onChangePackPriority, onClickPackSettings, onUnlockTemplateSettings]),
    tab: "resource-packs"
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(BehaviorPacksTab_BehaviorPacksTab, {
      worldPacks: worldPacks,
      multiplayerData: multiplayerData,
      isEditorWorld: isEditorWorld,
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onActivatePack: onActivatePack,
      onDeactivatePack: onDeactivatePack,
      onChangePackPriority: onChangePackPriority,
      onClickPackSettings: onClickPackSettings,
      onUnlockTemplateSettings: onUnlockTemplateSettings
    }), [worldPacks, multiplayerData, isEditorWorld, isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onActivatePack, onDeactivatePack, onChangePackPriority, onClickPackSettings, onUnlockTemplateSettings]),
    tab: "behavior-packs"
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(DebugTab, {
      isLockedTemplate: isLockedTemplate,
      isAchievementsDisabled: isAchievementsDisabled,
      achievementsDisabledMessages: achievementsDisabledMessages,
      onUnlockTemplateSettings: onUnlockTemplateSettings,
      onExportTemplate: onExportTemplate,
      isEditorWorld: isEditorWorld
    }), [isLockedTemplate, isAchievementsDisabled, achievementsDisabledMessages, onUnlockTemplateSettings, onExportTemplate, isEditorWorld]),
    tab: "debug"
  }),  false ?
  /*#__PURE__*/
  // In release builds, we provide a developer tool which will send the user
  // to the Create New World screen a automatically create a world under certain presets.
  0 : null))), /*#__PURE__*/react.createElement(ExperimentalFeaturesActivationWarningModal, null));
}

const WorldSettingsWrapper = props => {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld');
  const mode = (0,react.useContext)(WorldModeContext);
  const title = (0,react_facet_src.useFacetMap)(isEditor => mode === 'edit' ? t('.editTitle') : t(`${isEditor ? '.editor' : ''}.title`), [t, mode], [props.isEditorWorld]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: props.renderPage
  }, /*#__PURE__*/react.createElement(PointerBlocker_PointerBlocker, null, /*#__PURE__*/react.createElement(VanillaScreenLayout_VanillaScreenLayout, {
    screenAnalyticsId: mode === 'edit' ? 'Edit' : 'CreateNewWorld',
    onBack: props.backButtonCallback,
    disableBackButton: props.backButtonDisabled,
    title: title,
    gamepadAlias: "cnw-layout-content",
    delegateByAlias: "cnw-side-menu",
    debugDrawer: mode === 'edit' ? [] : ['create-test-world']
  }, () => /*#__PURE__*/react.createElement(WorldSettings, props)), /*#__PURE__*/react.createElement(Prompt, null)));
};
/**
 * Makes sure that the focus is on the main action once this route becomes active
 * TODO: this hook will become obsolete with the new gamepad visual navigation
 */

const useAutofocus = () => {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const isRouteActive = hooks_useRouteIsActive();
  (0,react_facet_src.useFacetEffect)(isActive => {
    if (isActive) {
      setFocusedId(MAIN_BUTTON);
    }
  }, [setFocusedId], [isRouteActive]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/images/world-preview-default.jpg
const world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-03016.jpg";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewCreateModal/RealmsPreviewCreateModal.tsx







const RealmsPreviewCreateModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-preview-create-preview-realm-close';
const RealmsPreviewCreateModal = registerModal(({
  onConfirm,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsPreviews.create');
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const titleAndButtonLabel = (0,react_facet_src.useFacetMap)(buildSettings => buildSettings.isBetaBuild ? t('.titleAndButtonLabel.beta') : t('.titleAndButtonLabel.preview'), [t], [buildSettings]);
  const message = (0,react_facet_src.useFacetMap)(buildSettings => buildSettings.isBetaBuild ? t('.message.beta') : t('.message.preview'), [t], [buildSettings]);
  const cancel = (0,react_facet_src.useFacetMap)(buildSettings => buildSettings.isBetaBuild ? t('.cancel.beta') : t('.cancel.preview'), [t], [buildSettings]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: RealmsPreviewCreateModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, titleAndButtonLabel), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.select'),
    variant: "primary",
    onClick: onConfirm
  }, titleAndButtonLabel), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: RealmsPreviewCreateModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: onClose
  }, cancel)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewCreateModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsLoadingModals/RealmsLoadingModals.tsx




const RealmsFetchingSubscriptionInformationModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('Realms.LoadingModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.fetchingSubscriptionInformation')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
const RealmsFetchingRealmInformationModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('Realms.LoadingModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.fetchingRealmInformation')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
const RealmsCreatingRealmModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('Realms.LoadingModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.creatingRealm')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
const RealmsStoryLoadingModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('Realms.LoadingModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.loadingRealmsStories')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
const RealmsStoryContactingRealmsLoadingModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('Realms.LoadingModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.contactingRealms')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsLoadingModals/index.ts




;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsErrorModals/RealmsErrorModals.tsx




const RealmsCannotContactRealmsErrorModal = registerModal(({
  onClickClose
}) => {
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-error-cannot-contact-realms-close';
  const {
    t
  } = useLocalization_useLocalization('Realms.ErrorModals');
  const closeModal = useHideModal();
  const handleClose = (0,react.useCallback)(() => {
    closeModal();

    if (onClickClose) {
      onClickClose();
    }
  }, [closeModal, onClickClose]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: handleClose
  }, t('.CannotContactRealms.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.CannotContactRealms.message'),
    center: true
  }, t('.CannotContactRealms.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: handleClose
  }, t('.close'))));
});
const RealmsSomethingWentWrongErrorModal = registerModal(({
  onClickClose
}) => {
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-error-something-went-wrong-close';
  const {
    t
  } = useLocalization_useLocalization('Realms.ErrorModals');
  const closeModal = useHideModal();
  const handleClose = (0,react.useCallback)(() => {
    closeModal();

    if (onClickClose) {
      onClickClose();
    }
  }, [closeModal, onClickClose]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: handleClose
  }, t('.somethingWentWrong.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.somethingWentWrong.message'),
    center: true
  }, t('.somethingWentWrong.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: handleClose
  }, t('.close'))));
});
const RealmsPostingCommentFailedErrorModal = registerModal(({
  onClickClose
}) => {
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-error-posting-comment-failed';
  const {
    t
  } = useLocalization_useLocalization('Realms.ErrorModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClickClose
  }, t('.postingCommentFailed.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.postingCommentFailed.message'),
    center: true
  }, t('.postingCommentFailed.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: onClickClose
  }, t('.close'))));
});
const RealmsRateLimitErrorModal = registerModal(({
  onClickClose
}) => {
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-rate-limit-error';
  const {
    t
  } = useLocalization_useLocalization('Realms.ErrorModals');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClickClose
  }, t('.rateLimitError.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.rateLimitError.message'),
    center: true
  }, t('.rateLimitError.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: onClickClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsErrorModals/index.ts




;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewSubscriptionNeededModal/RealmsPreviewSubscriptionNeededModal.tsx






const RealmsPreviewSubscriptionNeededModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-preview-subscription-needed-close';
const RealmsPreviewSubscriptionNeededModal = registerModal(({
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsPreviews.SubscriptionNeeded');
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const titleAndButtonLabel = t('.title');
  const message = (0,react_facet_src.useFacetMap)(buildSettings => buildSettings.isBetaBuild ? t('.message.beta') : t('.message.preview'), [t], [buildSettings]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: RealmsPreviewSubscriptionNeededModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, titleAndButtonLabel), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: RealmsPreviewSubscriptionNeededModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewSubscriptionNeededModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useAchievementsDisabledMessages.tsx




function checkIfMessagesChanged() {
  let previousValue = null;
  return function (nextValue) {
    if (!previousValue) {
      previousValue = nextValue;
      return false;
    }

    if (nextValue.length !== previousValue.length) {
      previousValue = nextValue;
      return false;
    }

    for (const message of nextValue) {
      if (!previousValue.includes(message)) {
        previousValue = nextValue;
        return false;
      }
    }

    return true;
  };
}

function useAchievementsDisabledMessages({
  generalData,
  advancedData,
  cheatsData,
  multiplayerData,
  betaFeaturesEnabled,
  behaviorPacksEnabled
}) {
  const {
    t
  } = useLocalization_useLocalization('CreateNewWorld.achievementsDisabledMessages');
  const achievementsDisabledMessages = (0,react_facet_src.useFacetMemo)((general, advanced, cheats, multiplayer, experiments, behaviorPacks) => {
    const settingMessage = [];

    if (general.gameMode === GameMode.CREATIVE) {
      settingMessage.push(t('.creativeMode'));
    }

    if (advanced.useFlatWorld) {
      settingMessage.push(t('.flatWorld'));
    }

    if (cheats.cheatsEnabled) {
      settingMessage.push(t('.cheatsEnabled'));
    }

    if (multiplayer.playerPermissions === PlayerPermissions.OPERATOR) {
      settingMessage.push(t('.operator'));
    }

    if (experiments) {
      settingMessage.push(t('.experiments'));
    }

    if (behaviorPacks) {
      settingMessage.push(t('.behaviorPacks'));
    }

    return settingMessage;
  }, [t], [generalData, advancedData, cheatsData, multiplayerData, betaFeaturesEnabled, behaviorPacksEnabled], checkIfMessagesChanged);
  return achievementsDisabledMessages;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/hooks/useCreateNewWorldOnPreviewRealm.ts



let CreateNewWorldOnPreviewRealmState;
/**
 * useCreateNewWorldOnPreviewRealm Hook
 *
 * Purpose:
 * - Manages the workflow for creating a new world on a preview realm.
 *
 * Behavior:
 * - The hook initiates a stateful flow process for creating a new world on a preview realm.
 * - This flow begins by checking whether the realms list is still loading.
 * - Once the realms list is available, it will check the number of existing preview realms and unpaired parent realms to determine the next step.
 * - If both are empty, the user needs a subscription.
 * - If only the existing preview realms is empty, the user need to create a preview realm from an unpaired parent realm first
 * - If there only 1 unpaired parent realms while the existing preview realms is empty, it will automatically create a preview realm using the first subscription
 * - If the existing preview realms is not empty, the user has the ability to create the new world on an existing preview realm
 * - The hook also validates the user's account. Only users logged in with a Microsoft account and not banned are allowed to proceed.
 * - Depending on the state, the hook might redirect the user to different routes.
 *
 * Returns:
 * - An object containing:
 *   - `state`: The current state of the flow (e.g., 'idle', 'verifying-account').
 *   - `create`: A function to start the process of preview realm creation.
 * 	 - `confirm`: When we get to the 'awaiting-confirmation' state, this function must be called to proceed
 *   - `reset`: A function to reset the workflow to its initial state.
 */

(function (CreateNewWorldOnPreviewRealmState) {
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["IDLE"] = 0] = "IDLE";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["LOADING_REALMS_LIST"] = 1] = "LOADING_REALMS_LIST";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["VERIFYING_ACCOUNT"] = 2] = "VERIFYING_ACCOUNT";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["SUBSCRIPTION_NEEDED"] = 3] = "SUBSCRIPTION_NEEDED";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["AWAITING_CONFIRMATION"] = 4] = "AWAITING_CONFIRMATION";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["CONFIRMED"] = 5] = "CONFIRMED";
  CreateNewWorldOnPreviewRealmState[CreateNewWorldOnPreviewRealmState["AWAITING_WORLD_CREATION"] = 6] = "AWAITING_WORLD_CREATION";
})(CreateNewWorldOnPreviewRealmState || (CreateNewWorldOnPreviewRealmState = {}));

function useCreateNewWorldOnPreviewRealm() {
  const [state, setState] = (0,react_facet_src.useFacetState)(CreateNewWorldOnPreviewRealmState.IDLE);
  const isRouteActive = hooks_useRouteIsActive();
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const realmList = (0,react_facet_src.useSharedFacet)(realmListFacet);
  const createPreviewRealm = (0,react_facet_src.useSharedFacet)(createPreviewRealmFacet);
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const telemetry = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const activeRealms = (0,react_facet_src.useSharedFacet)(activeRealmsSelector);
  const activeUnpairedParentRealms = (0,react_facet_src.useSharedFacet)(activeUnpairedParentRealmsSelector);
  const createPreviewRealmCallback = (0,react_facet_src.useFacetCallback)((telemetry, createNewWorld, activeRealmList, activeUnpairedParentRealmList) => () => {
    if (activeRealmList.length === 0 && activeUnpairedParentRealmList.length === 0) {
      setState(CreateNewWorldOnPreviewRealmState.SUBSCRIPTION_NEEDED);
    } else {
      setState(CreateNewWorldOnPreviewRealmState.VERIFYING_ACCOUNT);
      createNewWorld.inWorldCreation = true;
      telemetry.fireEventButtonPressed('Create_On_Realms_OreUI', {});
      createNewWorld.createOnRealms_v2();
    }
  }, [setState], [telemetry, createNewWorld, activeRealms, activeUnpairedParentRealms]);
  /**
   * First effect in the flow. It waits for the realms
   * list to load before calling createPreviewRealmCallback()
   */

  (0,react_facet_src.useFacetEffect)((isRouteActive, state, realmList) => {
    if (!isRouteActive || state !== CreateNewWorldOnPreviewRealmState.LOADING_REALMS_LIST) return;

    if (!realmList.isLoading) {
      createPreviewRealmCallback();
    }
  }, [createPreviewRealmCallback], [isRouteActive, state, realmList]);
  const continueCreatingPreviewRealmCallback = (0,react_facet_src.useFacetCallback)((createPreviewRealm, activeRealmList, activeUnpairedParentRealmList) => () => {
    if (activeRealmList.length === 0) {
      if (activeUnpairedParentRealmList.length === 1) {
        setState(CreateNewWorldOnPreviewRealmState.AWAITING_CONFIRMATION);
        createPreviewRealm.createPreviewRealmFromSubscriptionId(activeUnpairedParentRealmList[0].id);
      } else {
        setState(CreateNewWorldOnPreviewRealmState.IDLE);
        historyAPI.push('/realms-choose-realm/realm-subscriptions');
      }
    } else {
      setState(CreateNewWorldOnPreviewRealmState.IDLE);
      historyAPI.push('/realms-choose-realm/preview-realms');
    }
  }, [historyAPI, setState], [createPreviewRealm, activeRealms, activeUnpairedParentRealms]);
  /**
   * Second effect in the flow. This verifies that the user's account
   * is valid to create a realm. Much of this part of the flow is handled
   * on the C++ side, but we pick up the flow again if the account is valid.
   */

  (0,react_facet_src.useFacetEffect)((isRouteActive, state, userAccount) => {
    if (!isRouteActive || state !== CreateNewWorldOnPreviewRealmState.VERIFYING_ACCOUNT) return;

    if (userAccount.isLoggedInWithMicrosoftAccount && !userAccount.isBanned) {
      continueCreatingPreviewRealmCallback();
    }
  }, [continueCreatingPreviewRealmCallback, setState], [isRouteActive, state, userAccount]);
  const createWorldOnPreviewRealmCallback = (0,react_facet_src.useFacetCallback)((createNewWorld, createPreviewRealm) => () => {
    if (createNewWorld.inWorldCreation) {
      createNewWorld.createWorldOnPreviewRealm(createPreviewRealm.getCreatedPreviewRealmId());
    }
  }, [], [createNewWorld, createPreviewRealm]);
  /**
   * Third effect in the flow. Waits for the realm to be created successfully before
   * resetting the state and then creating the world on the preview realm.
   */

  (0,react_facet_src.useFacetEffect)((isRouteActive, state, createPreviewRealm) => {
    if (!isRouteActive || state !== CreateNewWorldOnPreviewRealmState.CONFIRMED) return;

    if (createPreviewRealm.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.DONE) {
      setState(CreateNewWorldOnPreviewRealmState.AWAITING_WORLD_CREATION);
      createPreviewRealm.reset();
      createWorldOnPreviewRealmCallback();
    }
  }, [setState, createWorldOnPreviewRealmCallback], [isRouteActive, state, createPreviewRealm]);
  const resetCallback = (0,react_facet_src.useFacetCallback)(facet => () => {
    setState(CreateNewWorldOnPreviewRealmState.IDLE);
    facet.reset();
  }, [setState], [createPreviewRealm]);
  /**
   * Final effect in the flow. Once we're no longer in this route, reset to idle.
   */

  (0,react_facet_src.useFacetEffect)((isRouteActive, state) => {
    if (!isRouteActive && state === CreateNewWorldOnPreviewRealmState.AWAITING_WORLD_CREATION) {
      resetCallback();
    }
  }, [resetCallback], [isRouteActive, state]);
  return {
    state,
    create: () => setState(CreateNewWorldOnPreviewRealmState.LOADING_REALMS_LIST),
    confirm: () => setState(CreateNewWorldOnPreviewRealmState.CONFIRMED),
    reset: () => resetCallback()
  };
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/hooks/useApplyWorldTemplate.ts




const isValidWorldTemplateId = worldTemplateId => worldTemplateId != null && !['available', 'active'].includes(worldTemplateId);
/**
 * Custom hook to apply a world template when creating a new world.
 *
 * This hook checks if the user intends to create a world using a template.
 * If a valid template ID is provided in the route parameters, it attempts to apply the template.
 * After applying, the user is redirected to the "general" tab.
 *
 * @returns {Facet<boolean>} A Facet indicating if the template application is in progress. This can be used to show a loading state to the user.
 */


const useApplyWorldTemplate = () => {
  const routerAPI = hooks_useRouterAPI();
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const routeParams = hooks_useRouteParams(); // Extract world template ID from route parameters

  const worldTemplateId = (0,react_facet_src.useFacetMap)(params => params.worldTemplateId, [], [routeParams]); // Determine if we're currently using a template and its application progress

  const isUsingTemplate = (0,react_facet_src.useFacetMap)(facet => facet.isUsingTemplate, [], [createNewWorld]);
  const progress = (0,react_facet_src.useFacetMap)(facet => facet.applyTemplateProgress, [], [createNewWorld]);
  const isInProgress = (0,react_facet_src.useFacetMap)(progress => progress === FacetTaskProgress.RUNNING, [], [progress]);
  const applyWorldTemplate = useFacetCoroutine(createNewWorld => function* (worldTemplateId) {
    // Initiate template application and await its completion
    createNewWorld.applyTemplate(worldTemplateId);
    yield progress; // After completion, redirect user to the "general" tab

    routerAPI.replace('/create-new-world/general');
  }, [progress, routerAPI], [createNewWorld, isUsingTemplate, worldTemplateId]); // Try to apply the template when the component mounts or when relevant facets change

  (0,react_facet_src.useFacetEffect)((isUsingTemplate, worldTemplateId) => {
    // Exit early if there's no need to apply a template
    if (isUsingTemplate || !isValidWorldTemplateId(worldTemplateId)) return;
    applyWorldTemplate(worldTemplateId);
  }, [applyWorldTemplate], [isUsingTemplate, worldTemplateId]);
  return isInProgress;
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/CreateNewWorldRoute.tsx




















const CreateNewWorldRoute = () => {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const createNewWorld = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const resourcePacks = (0,react_facet_src.useSharedFacet)(resourcePacksFacet);
  const optionsFacetLocal = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const inputFacetLocal = (0,react_facet_src.useSharedFacet)(inputFacet_inputFacet);
  const telemetry = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const worldData = (0,react_facet_src.useFacetMap)(facet => facet.worldCreationData, [], [createNewWorld]);
  const advancedData = (0,react_facet_src.useFacetMap)(facet => facet.advanced, [], [worldData]);
  const cheatsData = (0,react_facet_src.useFacetMap)(facet => facet.cheats, [], [worldData]);
  const experimentsData = (0,react_facet_src.useFacetMap)(facet => facet.betaFeatures, [], [worldData]);
  const generalData = (0,react_facet_src.useFacetMap)(facet => facet.general, [], [worldData]);
  const multiplayerData = (0,react_facet_src.useFacetMap)(facet => facet.multiplayer, [], [worldData]);
  const isUsingTemplate = (0,react_facet_src.useFacetMap)(facet => facet.isUsingTemplate, [], [createNewWorld]);
  const isLockedTemplate = (0,react_facet_src.useFacetMap)(facet => facet.isLockedTemplate, [], [createNewWorld]);
  const isAchievementsDisabled = (0,react_facet_src.useFacetMap)(facet => facet.isAchievementsDisabled, [], [createNewWorld]);
  const isEditorWorld = (0,react_facet_src.useFacetMap)(facet => facet.isEditorWorld, [], [createNewWorld]); // Achievements disabled messages.

  const betaFeaturesEnabled = (0,react_facet_src.useFacetMap)(facet => facet.worldCreationData.betaFeatures.some(feature => feature.isEnabled), [], [createNewWorld]);
  const behaviorPacksEnabled = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active.length > 0, [], [resourcePacks]);
  const achievementsDisabledMessages = useAchievementsDisabledMessages({
    generalData,
    advancedData,
    cheatsData,
    multiplayerData,
    betaFeaturesEnabled,
    behaviorPacksEnabled
  }); // Download pack modal.

  const showDownloadPackProgressModal = (0,react_facet_src.useFacetMap)(facet => facet.resourcePackToDownload != null && (facet.status === resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks || facet.status === resourcePacksFacet_ResourcePacksFacetStatus.StartDownload), [], [resourcePacks]);
  const packDownloadName = (0,react_facet_src.useFacetMap)(facet => facet.resourcePackToDownload.title, [], [resourcePacks]);
  const packDownloadPercentage = (0,react_facet_src.useFacetMap)(facet => (facet.downloadProgress + facet.importProgress) * 0.5, [], [resourcePacks]);
  const isImportingPack = (0,react_facet_src.useFacetMap)(facet => facet.downloadProgress >= 1 && facet.importProgress < 1, [], [resourcePacks]); // Pack actions.

  const onActivatePack = (0,react_facet_src.useFacetCallback)((resourcePacks, createNewWorld) => packId => {
    resourcePacks.activate(packId, createNewWorld.showedAchievementWarning, true, true);
  }, [], [resourcePacks, createNewWorld]);
  const onDeactivatePack = (0,react_facet_src.useFacetCallback)(facet => packId => {
    facet.deactivate(packId);
  }, [], [resourcePacks]);
  const onChangePackPriority = (0,react_facet_src.useFacetCallback)(facet => (packId, packType, dragIndex, dropIndex) => {
    facet.changePackPriority(packId, dragIndex, dropIndex);
  }, [], [resourcePacks]);
  const onClickPackSettings = (0,react_facet_src.useFacetCallback)(f => packId => f.showSettings(packId), [], [resourcePacks]);
  const onDownloadPackCancel = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.cancelDownload();
  }, [], [resourcePacks]);
  const onUnlockTemplateSettings = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.unlockTemplateSettings();
  }, [], [createNewWorld]);
  const createWorldError = (0,react_facet_src.useFacetMap)(createNewWorld => createNewWorld.createWorldError != null, [], [createNewWorld]);
  const worldPreviewImagePath = (0,react_facet_src.useFacetMap)(facet => facet.worldPreviewImagePath != null && facet.worldPreviewImagePath.length > 0 ? facet.worldPreviewImagePath : world_preview_default_namespaceObject, [], [createNewWorld]);
  const showLoseYourChangesModal = LoseYourChangesModal.useShowModal();
  const backButtonCallback = (0,react_facet_src.useFacetCallback)(facet => () => {
    const userHasChangedSettings = facet.checkIfUserHasChangedSettings();

    if (userHasChangedSettings) {
      showLoseYourChangesModal({
        onLeave: () => {
          historyAPI.goBack();
        }
      });
    } else {
      historyAPI.goBack();
    }
  }, [historyAPI, showLoseYourChangesModal], [createNewWorld]);
  const createWorldCallback = (0,react_facet_src.useFacetCallback)((options, input, world, telemetry) => () => {
    if (options.showTouchControlSelectionScreen && input.currentInputType == types_InputMethod.TOUCH) {
      world.inWorldCreation = true;
      historyAPI.push('/touch-control-selection');
    } else {
      telemetry.fireEventButtonPressed('Create_World_Button_OreUI', {});
      world.createWorld_v2();
    }
  }, [historyAPI], [optionsFacetLocal, inputFacetLocal, createNewWorld, telemetry]);
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const createPreviewRealmFacetLocal = (0,react_facet_src.useSharedFacet)(createPreviewRealmFacet);
  const isRouteActive = hooks_useRouteIsActive();
  const createNewWorldOnPreviewRealm = useCreateNewWorldOnPreviewRealm();
  const createPreviewRealmBusyOrCreatingWorld = (0,react_facet_src.useFacetMap)(state => state === CreateNewWorldOnPreviewRealmState.CONFIRMED || state === CreateNewWorldOnPreviewRealmState.AWAITING_WORLD_CREATION, [], [createNewWorldOnPreviewRealm.state]);
  const createOnRealmsCallback = (0,react_facet_src.useFacetCallback)((world, telemetry, buildSettingsFacet) => () => {
    if (buildSettingsFacet.isPreviewBuild) {
      createNewWorldOnPreviewRealm.create();
      return;
    }

    world.inWorldCreation = true;
    telemetry.fireEventButtonPressed('Create_On_Realms_OreUI', {});
    world.createOnRealms_v2();
  }, [createNewWorldOnPreviewRealm], [createNewWorld, telemetry, buildSettings]);
  const isShowingErrorModal = (0,react_facet_src.useFacetMap)((facet, routeIsActive) => facet.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.FAILED && routeIsActive, [], [createPreviewRealmFacetLocal, isRouteActive]); // This is a temporary hack for a scenario where the user can load a new CNW screen while
  // the CNW screen is already on the scene stack (by going through marketplace from Resource Packs).
  // In this scenario, the backend will flip this consumeResetFlag to true for a frame so we reset
  // the React states.

  const renderPage = (0,react_facet_src.useFacetMap)(facet => !facet.consumeResetFlag, [], [createNewWorld]);
  const showCreateOnRealmsErrorModal = (0,react_facet_src.useFacetMap)(world => world.createOnRealmsError != null, [], [createNewWorld]);
  const onSeedValueChange = (0,react_facet_src.useFacetCallback)(createNewWorld => newValue => {
    // If a url is set to the world preview image, either a template or a seed template has been selected
    // If the seed template value changes the preview image should revert back to default
    if (createNewWorld.worldPreviewImagePath != null && createNewWorld.worldCreationData.advanced.worldSeed != newValue) {
      createNewWorld.worldPreviewImagePath = '';
    }

    createNewWorld.worldCreationData.advanced.worldSeed = newValue;
  }, [], [createNewWorld]);
  const isRandomSeedAllowed = (0,react_facet_src.useFacetMap)(facet => facet.isRandomSeedAllowed, [], [createNewWorld]);
  const isTrialAccount = (0,react_facet_src.useSharedFacet)(isTrialAccountSelector);
  const isSeedChangeLocked = (0,react_facet_src.useFacetMap)((isTrialAccount, isUsingTemplate, isRandomSeedAllowed) => isTrialAccount || isUsingTemplate && !isRandomSeedAllowed, [], [isTrialAccount, isUsingTemplate, isRandomSeedAllowed]);
  const applyingWorldTemplate = useApplyWorldTemplate();
  const packParams = useRouteQuery();
  const addonUUID = (0,react_facet_src.useFacetMap)(params => params.get('packid'), [], [packParams]);
  (0,react_facet_src.useFacetEffect)(addonUUID => {
    // Exit early if there's no addon query parameter
    if (addonUUID == null) return;
    onActivatePack(addonUUID);
  }, [onActivatePack], [addonUUID]);
  return /*#__PURE__*/react.createElement(WorldModeContext.Provider, {
    value: "create"
  }, /*#__PURE__*/react.createElement(IsWorldTemplateLoading.Provider, {
    value: applyingWorldTemplate
  }, /*#__PURE__*/react.createElement(WorldSettingsWrapper, {
    isPageLoading: applyingWorldTemplate,
    advancedData: advancedData,
    cheatsData: cheatsData,
    experimentsData: experimentsData,
    generalData: generalData,
    multiplayerData: multiplayerData,
    worldPacks: resourcePacks,
    worldPreviewImage: worldPreviewImagePath,
    isUsingTemplate: isUsingTemplate,
    isLockedTemplate: isLockedTemplate,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    renderPage: renderPage,
    onActivatePack: onActivatePack,
    onDeactivatePack: onDeactivatePack,
    onChangePackPriority: onChangePackPriority,
    onClickPackSettings: onClickPackSettings,
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    backButtonCallback: backButtonCallback,
    mainActionCallback: createWorldCallback,
    realmsActionCallback: createOnRealmsCallback,
    backButtonDisabled: false,
    isEditorWorld: isEditorWorld,
    onSeedValueChange: onSeedValueChange,
    isSeedChangeLocked: isSeedChangeLocked
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackProgressModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadProgressModal.Component, {
    title: packDownloadName,
    percentage: packDownloadPercentage,
    isImportingPack: isImportingPack,
    onCancel: onDownloadPackCancel
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: createWorldError
  }, /*#__PURE__*/react.createElement(CreateWorldErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showCreateOnRealmsErrorModal
  }, /*#__PURE__*/react.createElement(CreateOnRealmsErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(state => state === CreateNewWorldOnPreviewRealmState.SUBSCRIPTION_NEEDED, [], [createNewWorldOnPreviewRealm.state])
  }, /*#__PURE__*/react.createElement(RealmsPreviewSubscriptionNeededModal.Component, {
    onClose: createNewWorldOnPreviewRealm.reset
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(state => state === CreateNewWorldOnPreviewRealmState.AWAITING_CONFIRMATION, [], [createNewWorldOnPreviewRealm.state])
  }, /*#__PURE__*/react.createElement(RealmsPreviewCreateModal.Component, {
    onConfirm: (0,react_facet_src.useFacetCallback)((createPreviewRealm, createNewWorld) => () => {
      createPreviewRealm.activateNewPreviewRealm(createNewWorld.inWorldCreation);
      createNewWorldOnPreviewRealm.confirm();
    }, [createNewWorldOnPreviewRealm], [createPreviewRealmFacetLocal, createNewWorld]),
    onClose: createNewWorldOnPreviewRealm.reset
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: createPreviewRealmBusyOrCreatingWorld
  }, /*#__PURE__*/react.createElement(RealmsCreatingRealmModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(state => state === CreateNewWorldOnPreviewRealmState.LOADING_REALMS_LIST, [], [createNewWorldOnPreviewRealm.state])
  }, /*#__PURE__*/react.createElement(RealmsFetchingRealmInformationModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingErrorModal
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: createNewWorldOnPreviewRealm.reset
  }))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreateNewWorldRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/MobileDataBlockedModalRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MobileDataBlockedModalRoute = ({"centeredLink":"Hrjsd"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/MobileDataBlockedModalRoute.tsx









const MobileDataBlockedModalRoute_MobileDataBlockedModalRoute = () => {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const optionsWrapped = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const telemetryWrapped = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const fireTelemetry = (0,react_facet_src.useFacetCallback)(telemetry => buttonName => {
    telemetry.fireEventButtonPressed('MobileDataBlockedModal_'.concat(buttonName), {});
  }, [], [telemetryWrapped]);
  const setUseDataOnce = (0,react_facet_src.useFacetCallback)(options => () => {
    options.useMobileDataOnce = true;
  }, [], [optionsWrapped]);
  const DEFAULT_FOCUS_ALIAS = 'backButton';
  const {
    t
  } = useLocalization_useLocalization('MobileDataBlockedModalRoute');
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: `${t('.title')}. ${t('.onlyWifi')}. ${t('.costWarning')}`
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: () => {
      fireTelemetry('Close_Button_Or_Unfocus');
      historyAPI.goBack();
    }
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.onlyWifi')}. ${t('.costWarning')}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.onlyWifi')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    fontWeight: Typography_Typography_Typography.FontWeight.Bold
  }, t('.costWarning'))), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: `${t('.changeSettings')}`
  }, /*#__PURE__*/react.createElement("div", {
    className: MobileDataBlockedModalRoute.centeredLink
  }, /*#__PURE__*/react.createElement(Link_Link, {
    gamepadIndex: 1,
    onClick: () => {
      fireTelemetry('Settings_Page_Link');
      historyAPI.replace(`/mobile-data-blocked-modal/links/settings-page`);
    },
    withUnderlinePolyfill: true
  }, t('.changeSettings'))))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: () => {
      fireTelemetry('Go_Back_Button');
      historyAPI.goBack();
    },
    autofocus: true,
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.goBack'),
    variant: "primary"
  }, t('.goBack')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    delayedClick: true,
    onClick: () => {
      fireTelemetry('Use_Data_Once_Button');
      setUseDataOnce();
      historyAPI.goBack();
    },
    inputLegend: t('.playOnceWithData'),
    variant: "secondary"
  }, t('.playOnceWithData')))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/MobileDataBlockedModalRoute/index.ts

// EXTERNAL MODULE: ./node_modules/ramda/src/times.js
var times = __webpack_require__(32250);
var times_default = /*#__PURE__*/__webpack_require__.n(times);
// EXTERNAL MODULE: ./node_modules/ramda/src/splitEvery.js
var splitEvery = __webpack_require__(59241);
var splitEvery_default = /*#__PURE__*/__webpack_require__.n(splitEvery);
;// CONCATENATED MODULE: ./packages/ui/src/GridList/GridList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const GridList = ({"row":"jc_nV","cell":"aTnV0"});
;// CONCATENATED MODULE: ./packages/ui/src/GridList/GridList.tsx








const FILLER = Symbol('filler');

const GridListItem = ({
  horizontalIndex,
  verticalIndex,
  index,
  itemSeparatorHorizontal,
  renderItem,
  item,
  listLengthFacet
}) => {
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, horizontalIndex > 0 && itemSeparatorHorizontal, /*#__PURE__*/react.createElement("div", {
    className: GridList.cell
  }, /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: (0,react_facet_src.useFacetMemo)(item => item !== FILLER ? item : undefined, [], [item])
  }, item => renderItem({
    itemFacet: item,
    index,
    rowIndex: verticalIndex,
    columnIndex: horizontalIndex,
    listLengthFacet
  })))));
};

function GridList_GridList({
  loading,
  emptyMessage,
  renderItem,
  data,
  gamepadIndex,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  itemSeparatorHorizontal,
  itemSeparatorVertical,
  firstRowSeparatorVertical,
  footer,
  renderTracker,
  columns,
  autofocus,
  gamepadAlias
}) {
  const isRenderingPaused = (0,deferred_mount_dist.useIsPaused)();
  const dataFacet = (0,react_facet_src.useFacetWrap)(data);
  const countFacet = (0,react_facet_src.useFacetMap)(data => data.length, [], [dataFacet]);
  const countValue = (0,react_facet_src.useFacetUnwrap)(countFacet);
  const dataMatrix = (0,react_facet_src.useFacetMemo)(data => {
    // If there is no data the matrix should contain an empty array
    if (data.length > 0) {
      const rows = splitEvery_default()(columns, data);

      const lastRow = rows[rows.length - 1];

      times_default()(() => lastRow.push(FILLER), columns - lastRow.length);

      return rows;
    } else {
      return [];
    }
  }, [columns], [dataFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(GridList_ScrollViewContainer, {
    autofocus: autofocus,
    loading: (0,react_facet_src.useFacetWrap)(loading !== null && loading !== void 0 ? loading : false),
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    gamepadAlias: gamepadAlias
  }, !isRenderingPaused && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataMatrix
  }, (row, verticalIndex) => /*#__PURE__*/react.createElement(react.Fragment, null, verticalIndex === 0 && firstRowSeparatorVertical, verticalIndex > 0 && itemSeparatorVertical, /*#__PURE__*/react.createElement("div", {
    className: GridList.row
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: verticalIndex,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: row
  }, (item, horizontalIndex) => /*#__PURE__*/react.createElement(GridListItem, {
    horizontalIndex: horizontalIndex,
    verticalIndex: verticalIndex,
    index: verticalIndex * columns + horizontalIndex,
    itemSeparatorHorizontal: itemSeparatorHorizontal,
    renderItem: renderItem,
    item: item,
    listLengthFacet: countFacet
  })))))),
  /**
   * We need to deffer the empty message, since the DeferredMountProvider will be waiting
   * for something to be mounted using DeferredMount so that it will run its process and complete
   * any deferred rendering
   *
   * Removing this would cause an spinner to be shown for all eternity.
   */
  countValue != null && countValue === 0 && /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, emptyMessage)), footer));
}
function GridList_ScrollViewContainer({
  loading,
  gamepadIndex,
  children,
  scrollIntoViewAlign,
  scrollIntoViewSpeedFactor,
  renderTracker,
  horizontal,
  autofocus,
  gamepadAlias
}) {
  const isPaused = (0,deferred_mount_dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)((isDeferring, loading) => isDeferring || isPaused || loading, [isPaused], [(0,deferred_mount_dist.useIsDeferring)(), loading]);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    autofocus: autofocus,
    loading: isLoading,
    gamepadIndex: gamepadIndex,
    scrollIntoViewAlign: scrollIntoViewAlign,
    scrollIntoViewSpeedFactor: scrollIntoViewSpeedFactor,
    renderTracker: renderTracker,
    horizontal: horizontal,
    gamepadAlias: gamepadAlias,
    defaultFocusedChildBehavior: "remember"
  }, children);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useImagePreloading.tsx
function useImagePreloading_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function useImagePreloading_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { useImagePreloading_ownKeys(Object(source), true).forEach(function (key) { useImagePreloading_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { useImagePreloading_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useImagePreloading_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function useImagePreloading(imageUrls, timeoutMS) {
  const urls = (0,react_facet_src.useFacetWrap)(imageUrls);
  const callbackState = (0,react.useRef)({});
  const [isPreloading, setIsPreloading] = (0,react_facet_src.useFacetState)(true); // Store a reference to the container that contains all of the image nodes

  const containerRef = (0,react.useRef)(null); // This effect will start running the check as soon as we've got some urls.

  (0,react_facet_src.useFacetLayoutEffect)(urls => {
    // If the urls changes we'll remove the previous container and reset the refs.
    containerRef.current && document.body.removeChild(containerRef.current);
    containerRef.current = null;
    callbackState.current = urls.reduce((acc, cur) => useImagePreloading_objectSpread(useImagePreloading_objectSpread({}, acc), {}, {
      [cur]: false
    }), {});

    const imageHasLoaded = url => () => {
      // Update the hashmap so we know that this url has been loaded
      callbackState.current[url] = true; // Check if this was the last image to load

      const callbackValues = Object.values(callbackState.current);

      if (callbackValues.length === urls.length && callbackValues.every(x => x)) {
        setIsPreloading(false);
      }
    };

    if (urls.filter(url => url.length > 0).length) {
      const container = document.createElement('div');
      container.style.visibility = 'hidden';
      container.style.position = 'absolute';
      containerRef.current = container;
      urls.forEach(url => {
        const image = new Image();
        image.src = url;
        image.addEventListener('load', imageHasLoaded(url));
        container.appendChild(image);
      });
      document.body.appendChild(container);
    }

    return () => {
      containerRef.current && document.body.removeChild(containerRef.current);
      containerRef.current = null;
    };
  }, [setIsPreloading], [urls]); // Make it possible to short-ciruit the preloading

  (0,react.useEffect)(() => {
    let timeout;

    if (timeoutMS != null) {
      timeout = setTimeout(() => setIsPreloading(false), timeoutMS);
    }

    return () => {
      if (timeout != null) {
        clearTimeout(timeout);
      }
    };
  }, [timeoutMS, setIsPreloading]);
  return isPreloading;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/images/placeholder.png
const SeedTemplateCard_images_placeholder_namespaceObject = __webpack_require__.p + "assets/placeholder-9e208.png";
;// CONCATENATED MODULE: ./packages/react-narrator/src/hooks/useSetParentNarrationText.tsx

 // To enable compositional components that cna have both text, buttons and images as children
// to internally handle the narration, The text content is provided using context

const ChildTextNarrationApi = (0,react.createContext)({
  getId: () => 0,
  set: () => {}
});

const useChildTextNarrationApi = () => (0,react.useContext)(ChildTextNarrationApi);
/**
 * This hook should be used in compositional components to help configure the narration tex, since there might be multiple of them.
 * It receives a unique id from the parent component and uses this as an key to set the narration text at a higher level.
 */


const useSetParentNarrationText = text => {
  const childNarrationApi = useChildTextNarrationApi();
  const [id, setId] = (0,react_facet_src.useFacetState)(react_facet_src.NO_VALUE); // Get a unique id for this child

  (0,react.useEffect)(() => {
    // Exit early if we don't have an id (shouldn't happen)
    if (id.get() != react_facet_src.NO_VALUE) return;
    setId(childNarrationApi.getId());
  }, [id, setId, childNarrationApi]); // Set the narration text against our unique id

  (0,react_facet_src.useFacetEffect)((id, text) => {
    childNarrationApi.set(id, text);
  }, [childNarrationApi], [id, (0,react_facet_src.useFacetWrap)(text)]);
};
function ChildTextNarrationApiProvider({
  children,
  setNarrationTextState
}) {
  const childId = (0,react.useRef)(0);
  return /*#__PURE__*/react.createElement(ChildTextNarrationApi.Provider, {
    value: (0,react.useMemo)(() => ({
      getId: () => childId.current++,
      set: (childId, text) => setNarrationTextState(prev => {
        if (prev === react_facet_src.NO_VALUE) return []; // Shouldn't ever happen as we default to an array

        prev[childId] = text === false ? '' : text;
        return prev;
      })
    }), [setNarrationTextState])
  }, children);
}
;// CONCATENATED MODULE: ./packages/ui/src/Card/Card.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Card = ({"cardWrapper":"MLe4y","card":"Dsmzk","cardDropShadow":"xeqcX","hovered":"IseJx","pressed":"JAVQA","information":"XiGeZ","bottomEdge":"Ikw_7"});
;// CONCATENATED MODULE: ./packages/ui/src/Card/Card.tsx








function Card_Card({
  autofocus,
  gamepadIndex,
  children,
  onClick,
  inputLegend,
  gamepadAlias,
  onFocusChanged,
  onHoverChanged,
  narrationSuffix,
  narrationTextOverride,
  role = 'neutral',
  narrateCardRole = true
}) {
  const semanticSounds = useSemanticSounds('neutral');
  const [titleNarrationTextState, setTitleNarrationTextState] = (0,react_facet_src.useFacetState)([]);
  const semanticColors = hooks_useSemanticColors(role);
  const narrationTextOverrideWrapped = (0,react_facet_src.useFacetWrap)(narrationTextOverride !== null && narrationTextOverride !== void 0 ? narrationTextOverride : '');
  const {
    t
  } = useLocalization_useLocalization('Card');
  const contextNarration = (0,react_facet_src.useFacetMap)((titleNarrationTextState, narrationTextOverrideWrapped, narrationSuffix) => {
    // If the narration is overridden, it should only use the provided string
    if (narrationTextOverrideWrapped) return narrationTextOverrideWrapped;
    return [...titleNarrationTextState, narrateCardRole ? t('.narrationComponentTypeButton') : null, narrationSuffix].filter(Boolean).join(' . ');
  }, [t, narrateCardRole], [titleNarrationTextState, narrationTextOverrideWrapped, (0,react_facet_src.useFacetWrap)(narrationSuffix !== null && narrationSuffix !== void 0 ? narrationSuffix : '')]);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: Card.cardWrapper
  }, /*#__PURE__*/react.createElement(Pressable_BoxBorder, {
    autofocus: autofocus,
    gamepadAlias: gamepadAlias,
    className: classnames_default()(Card.card, semanticColors.border.interactive, semanticColors.text.base),
    classNameHovered: Card.hovered,
    classNamePressed: Card.pressed,
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationText: contextNarration,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: semanticSounds.press
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(ChildTextNarrationApiProvider, {
    setNarrationTextState: setTitleNarrationTextState
  }, children), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.bottomEdge, semanticColors.shadow.base)
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.cardDropShadow, semanticColors.dropShadow.base)
  })));
}

function Information({
  children,
  innerRef,
  narrationText
}) {
  const semanticColors = hooks_useSemanticColors('inherit'); // Set child string value as narration string

  useSetParentNarrationText(narrationText);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Card.information, semanticColors.border.base, semanticColors.background.base, semanticColors.background.hover),
    ref: innerRef
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }));
}

Card_Card.Information = Information;
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/SeedTemplateCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SeedTemplateCard = ({"illustrationPlaceholder":"CPwL0"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/SeedTemplateCard.tsx








const hasImage = template => template.image != null && template.image != '';

function SeedTemplateCard_SeedTemplateCard({
  template,
  onSelect,
  gamepadIndex,
  inputLegend,
  autofocus
}) {
  const handleClickOnCard = (0,react_facet_src.useFacetCallback)(facetTemplate => () => {
    onSelect(facetTemplate.seedValue, facetTemplate.image);
  }, [onSelect], [template]);
  const title = (0,react_facet_src.useFacetMap)(facet => facet.title, [], [template]);
  const useTemplateImage = (0,react_facet_src.useFacetMap)(template => hasImage(template), [], [template]);
  const src = (0,react_facet_src.useFacetMap)(template => hasImage(template) ? template.image : SeedTemplateCard_images_placeholder_namespaceObject, [], [template]);
  const {
    t
  } = useLocalization_useLocalization('SeedTemplateCard');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: gamepadIndex,
    inputLegend: inputLegend,
    narrationSuffix: t('.narrationSuffix'),
    onClick: handleClickOnCard,
    autofocus: autofocus
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: useTemplateImage
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: src,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: useTemplateImage,
    condition: false
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: src,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"],
    className: SeedTemplateCard.illustrationPlaceholder,
    imageRendering: 'pixelated'
  })), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: title
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    verticalAlign: "center"
  }, title))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SeedTemplateCard/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/images/creeper-cropped.png
const creeper_cropped_namespaceObject = __webpack_require__.p + "assets/creeper-cropped-1ee9c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/SeedTemplatesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SeedTemplatesRoute = ({"errorImage":"UzH8W","errorImageBig":"wdc99"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/SeedTemplatesRoute.tsx



















const WAIT_FOR_SEED_TEMPLATE_IMAGES_MS = 1250;
const IMAGE_PRELOADING_TIMEOUT_MS = 8000;
const SeedTemplatesRoute_LOADING_TIMEOUT = 10000;
const SeedTemplatesRoute_LOADING_WARNING = 1500;
const emptySeedsFacet = (0,react_facet_src.createFacet)({
  initialValue: {
    templates: []
  }
});

const templateHasImage = template => template.image != null && template.image.length > 0;

function SeedTemplateRoute() {
  const {
    t
  } = useLocalization_useLocalization('SeedTemplatesRoute');
  const isPaused = (0,deferred_mount_dist.useIsPaused)();
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint(); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 260
  });
  const sharedFacet = (0,react_facet_src.useSharedFacet)(seedTemplatesFacet);
  const seedsFacet = isPaused ? emptySeedsFacet : sharedFacet; // The backend will give us a list of seed templates. However, the objects in that
  // array might not have an image to start with. They could be assigned later. Therefore,
  // we'll try to wait until we have enough images to cover a full grid.

  const hasEnoughImages = (0,react_facet_src.useFacetMap)(facet => {
    // If we haven't received any templates yet we cant have enough images to fill a grid.
    if (!facet.templates.length) {
      return false;
    } // Check to see if the first fold of templates has images


    if (facet.templates.length >= 9) {
      for (let i = 0; i < facet.templates.length; i++) {
        const template = facet.templates[i];

        if (template.image == null || !template.image.length) {
          return false;
        }
      }

      return true;
    } // If we don't have enough images for a full fold we'll try to wait for all of them.


    return every(facet.templates, template => template.image != null && template.image.length > 0);
  }, [], [seedsFacet]); // This is used to short-circuit the hasEnoughImages facet above. We
  // want all of the templates to have images, but we cant wait forever.

  const [hasExceededImageWaitTime, setHasExceededImageWaitTime] = (0,react_facet_src.useFacetState)(false);
  (0,react.useEffect)(() => {
    const timeout = setTimeout(() => setHasExceededImageWaitTime(true), WAIT_FOR_SEED_TEMPLATE_IMAGES_MS);
    return () => clearTimeout(timeout);
  }, [setHasExceededImageWaitTime]); // If the status is set to failed, the error message should be immediately shown

  const fetchFailed = (0,react_facet_src.useFacetMap)(seedTemplatesFacet => seedTemplatesFacet.failedToFetch, [], [sharedFacet]);
  const seedTemplates = (0,react_facet_src.useFacetMap)((seedsFacet, hasExceededImageWaitTime, hasEnoughImages, fetchFailed) => {
    if (fetchFailed) return [];
    const templates = []; // We will wait until we have either enough images, or we've exceeded the wait time.
    // As soon as we push items into the templates array we'll start the image preloader

    if (hasEnoughImages || hasExceededImageWaitTime) {
      for (let i = 0; i < seedsFacet.templates.length; i++) {
        const template = seedsFacet.templates[i]; // Don't add any duplicates.

        if (!templates.find(x => x.seedValue === template.seedValue)) {
          templates.push(template);
        }
      }
    }

    return templates;
  }, [], [seedsFacet, hasExceededImageWaitTime, hasEnoughImages, fetchFailed], () => () => false); // We'll prefetch the images so that they are cached when we render the
  // grid. That should, hopefully, make the rendering a lot smoother.

  const urlsFacet = (0,react_facet_src.useFacetMap)(templates => {
    // If an image receives an empty string in Gameface it will break
    const imageUrls = templates.filter(templateHasImage).map(template => template.image);

    if (templates.length) {
      // We also want to have the placeholder image preloaded.
      imageUrls.push(SeedTemplateCard_images_placeholder_namespaceObject);
    }

    return imageUrls;
  }, [], [seedTemplates]);
  const isPreloadingImages = useImagePreloading(urlsFacet, IMAGE_PRELOADING_TIMEOUT_MS);
  const imagesHaveLoaded = (0,react_facet_src.useFacetMap)((isPreloading, seedsFacet, fetchFailed) => {
    // If the fetch has failed, the timeout should exit early
    if (fetchFailed) return true;else return !isPreloading && seedsFacet.templates.length > 0 && !fetchFailed;
  }, [], [isPreloadingImages, seedsFacet, fetchFailed]);
  const loadingTimedOut = useTimeout(imagesHaveLoaded, SeedTemplatesRoute_LOADING_TIMEOUT);
  const showErrorMessage = (0,react_facet_src.useFacetMap)( // The loading timeout exits early if fetch has failed
  // In that case the error message should be shown
  (fetchFailed, loadingTimedOut) => fetchFailed || loadingTimedOut, [], [fetchFailed, loadingTimedOut]);
  const loadingTakingTime = useTimeout(imagesHaveLoaded, SeedTemplatesRoute_LOADING_WARNING);
  const narrateLoading = (0,react_facet_src.useFacetMap)((takingTime, isPreloadingImages) => takingTime && isPreloadingImages, [], [loadingTakingTime, isPreloadingImages]);
  const handleClick = (0,react_facet_src.useFacetCallback)(value => (newSeedValue, newImageValue) => {
    value.worldCreationData.advanced.worldSeed = newSeedValue;
    value.worldPreviewImagePath = newImageValue;
    historyAPI.goBack();
  }, [historyAPI], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: narrateLoading
  }, /*#__PURE__*/react.createElement(Narration, {
    text: t('.narration.loadingMessage')
  })), /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: historyAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.title')),
    gamepadAlias: "seed-layout-content",
    delegateByAlias: "seed-templates-grid",
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showErrorMessage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    imgSrc: creeper_cropped_namespaceObject,
    imgClass: narrowImage ? SeedTemplatesRoute.errorImage : SeedTemplatesRoute.errorImageBig,
    gamepadIndex: 0,
    title: t('.errorMessageTitle'),
    text: t('.errorMessageBody'),
    buttons: [{
      text: t('.errorBackButtonText'),
      inputLegend: t('.errorBackButtonInputLegend'),
      gamepadAlias: 'seed-temp-empty-state',
      onClick: () => historyAPI.goBack()
    }]
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showErrorMessage,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(GridList_GridList, {
    gamepadAlias: "seed-templates-grid",
    autofocus: true,
    loading: (0,react_facet_src.useFacetMap)(imagesHaveLoaded => !imagesHaveLoaded, [], [imagesHaveLoaded]),
    gamepadIndex: 0,
    data: seedTemplates,
    columns: breakpoint === 'narrow' ? 2 : 3,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }) // Used to stop the focus outline being hidden by the overflow
    ,
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 1 : 3
    }),
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    })),
    renderItem: ({
      itemFacet,
      columnIndex,
      rowIndex
    }) => /*#__PURE__*/react.createElement(SeedTemplateCard_SeedTemplateCard, {
      autofocus: columnIndex === 0 && rowIndex === 0,
      template: itemFacet,
      gamepadIndex: columnIndex,
      inputLegend: t('.selectTemplateInputLegend'),
      onSelect: handleClick
    }),
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    })
  }))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SeedTemplatesRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/RowWrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RowWrapper = ({"hidden":"N9BNb"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/RowWrapper.tsx







function RowWrapper_RowWrapper({
  Component,
  route,
  gamepadIndex,
  wideSize,
  narrowSize
}) {
  const rowWrapperRef = (0,react.useRef)(null);
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const visible = params.tab === route;
  const hiddenClass = (0,react_facet_src.useFacetWrap)(visible ? '' : RowWrapper.hidden);
  const parentRouteActive = useRouteActive();
  const isRouteActive = (0,react_facet_src.useFacetMap)(parentRouteActive => visible && parentRouteActive, [visible], [parentRouteActive]);
  const isRouteInactive = (0,react_facet_src.useFacetMap)(routeActive => !routeActive, [], [isRouteActive]);
  const mountedRef = (0,react.useRef)(visible);
  mountedRef.current = mountedRef.current || visible;
  const widePaddingSize = (12 - wideSize) / 2;
  const narrowPaddingSize = (8 - narrowSize) / 2;
  const MemoChild = (0,react.useMemo)(() => /*#__PURE__*/react.createElement(Component, null), [Component]);
  return mountedRef.current ? /*#__PURE__*/react.createElement(RouteActiveProvider, {
    active: isRouteActive
  }, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: rowWrapperRef,
    disabled: isRouteInactive
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    innerRef: rowWrapperRef,
    fullHeight: true,
    gamepadIndex: gamepadIndex,
    className: hiddenClass,
    disabled: !visible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: widePaddingSize,
    narrowSize: narrowPaddingSize,
    gamepadIndex: -1,
    disabled: true
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: wideSize,
    narrowSize: narrowSize,
    gamepadIndex: 0,
    disabled: !visible
  }, MemoChild), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: widePaddingSize,
    narrowSize: narrowPaddingSize,
    gamepadIndex: 1,
    disabled: true
  })))) : null;
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatarWrapper/PlayerAvatarWrapper.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerAvatarWrapper = ({"wrapper":"gj3Lw","additionalPlayers":"sVory","tagWrapper":"NN7aY","panel":"MRa9N"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/PlayerAvatarWrapper/PlayerAvatarWrapper.tsx








function PlayerAvatarWrapper_PlayerAvatarWrapper({
  players,
  full,
  totalAmountOfPlayers
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayerAvatarWrapper'); // Up to four players that are displayed in the wrapper

  const selectedPlayersLength = (0,react_facet_src.useFacetMap)(players => players.length, [], [players]);
  const selectedPlayersLengthRef = (0,react_facet_src.useFacetRef)(selectedPlayersLength); // Only the images of up to 4 players should be shown

  const playerImages = (0,react_facet_src.useFacetMap)(players => players.map(({
    img
  }) => img), [], [players]); // The total amount of players should be shown as a number if more than 4 are active in the world

  const showTotalAmountOfPlayers = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers > 4, [], [totalAmountOfPlayers]); // The total amount of players should be shown as a number if more than 4 are active in the world
  // appended with a '+'

  const amountOfPlayersVisual = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers + '+', [], [totalAmountOfPlayers]);
  return /*#__PURE__*/react.createElement("div", {
    className: PlayerAvatarWrapper.wrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: playerImages
  }, (img, index) => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    src: img,
    status: 'online'
  }), selectedPlayersLengthRef.current != react_facet_src.NO_VALUE && index < selectedPlayersLengthRef.current - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showTotalAmountOfPlayers
  }, /*#__PURE__*/react.createElement("div", {
    className: PlayerAvatarWrapper.additionalPlayers
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, amountOfPlayersVisual))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: full
  }, /*#__PURE__*/react.createElement("div", {
    className: PlayerAvatarWrapper.tagWrapper
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: 'informativeTint'
  }, t('.full')))));
}

function PlayerAvatarWrapper_Panel({
  children
}) {
  const semanticColors = hooks_useSemanticColors('neutral80');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PlayerAvatarWrapper.panel, semanticColors.background.base)
  }, children);
}

PlayerAvatarWrapper_PlayerAvatarWrapper.Panel = PlayerAvatarWrapper_Panel;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldListItem = ({"worldImageWrapper":"o_yQY","editIcon":"Fcaz7","border":"_XcCm","tagsWrapper":"krJgC"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/images/edit-icon.png
const edit_icon_namespaceObject = __webpack_require__.p + "assets/edit-icon-56235.png";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/useWorldTags.tsx




// Return translation key for corresponding GameMode type
function gameModeToLabelKey(key) {
  switch (key) {
    case GameMode.UNKNOWN:
      return '.unknown';

    case GameMode.ADVENTURE:
      return '.adventure';

    case GameMode.SURVIVAL:
      return '.survival';

    case GameMode.CREATIVE:
      return '.creative';
  }
}

function useWorldTags(item) {
  const {
    t
  } = useLocalization_useLocalization('WorldTag');
  return (0,react_facet_src.useFacetMap)(item => {
    const tags = []; // Game mode

    tags.push({
      label: t(gameModeToLabelKey(item.gameMode)),
      role: 'neutral100'
    }); // Experimental

    if (item.isExperimental) {
      tags.push({
        label: t('.experimental'),
        role: 'noticeTint'
      });
    }

    return tags;
  }, [t], [item]);
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/images/world-preview-default.jpg
const WorldItem_images_world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-03016.jpg";
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/images/cloud-sync-default.png
const cloud_sync_default_namespaceObject = __webpack_require__.p + "assets/cloud-sync-default-03fc5.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCloudSync/images/icon-cloud-sync.png
const icon_cloud_sync_namespaceObject = __webpack_require__.p + "assets/icon-cloud-sync-0d0d6.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCloudSync/IconCloudSync.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconCloudSync = ({"iconCloudSync":"ISFuU"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconCloudSync/IconCloudSync.tsx
function IconCloudSync_extends() { IconCloudSync_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconCloudSync_extends.apply(this, arguments); }

function IconCloudSync_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconCloudSync_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconCloudSync_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconCloudSync_IconCloudSync = (_ref) => {
  let {
    className
  } = _ref,
      props = IconCloudSync_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconCloudSync.iconCloudSync, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconCloudSync_extends({}, props, {
    className: classNames,
    src: icon_cloud_sync_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/CloudSyncIcon.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const CloudSyncIcon = ({"cloudSyncIconWrapper":"OiOCl"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/CloudSyncIcon.tsx





function CloudSyncIcon_CloudSyncIcon() {
  const semanticColors = hooks_useSemanticColors();
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(CloudSyncIcon.cloudSyncIconWrapper, semanticColors['neutral100'].background.base)
  }, /*#__PURE__*/react.createElement(IconCloudSync_IconCloudSync, null));
}
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldListItem.tsx

















function WorldListItem_WorldListItem({
  autofocus,
  item,
  onWorldClick,
  index,
  onEdit = () => {},
  containerListLength,
  totalAmountOfPlayers,
  worldFull,
  playersOnline
}) {
  const {
    t
  } = useLocalization_useLocalization('WorldListItem');
  const {
    t: narration
  } = useLocalization_useLocalization('WorldListItem.narration');
  const semanticColors = hooks_useSemanticColors('neutral');
  const tags = useWorldTags(item);
  const tagsLength = (0,react_facet_src.useFacetMap)(tags => tags.length, [], [tags]);
  const tagsLengthRef = (0,react_facet_src.useFacetRef)(tagsLength);
  const highlightedPlayers = (0,react_facet_src.useFacetWrap)(playersOnline !== null && playersOnline !== void 0 ? playersOnline : []);
  const worldFullWrapped = (0,react_facet_src.useFacetWrap)(worldFull !== null && worldFull !== void 0 ? worldFull : false);
  const showPlayersOnline = (0,react_facet_src.useFacetMap)(playersOnline => playersOnline != null && playersOnline.length > 0, [], [highlightedPlayers]);
  const numberOfPlayersOnline = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers - 4, [], [(0,react_facet_src.useFacetWrap)(totalAmountOfPlayers !== null && totalAmountOfPlayers !== void 0 ? totalAmountOfPlayers : 0)]); // We currently only show local worlds, that always show the edit button
  // The logic for when to show the button will need facet criteria or other logic for non local worlds

  const editAvailable = (0,react_facet_src.useFacetWrap)(true); // If a world is stored in the cloud and is not yet synced,
  // a specific world card should be shown and initiate a sync when the player presses Edit or Play

  const worldRequiresSync = (0,react_facet_src.useFacetMap)(item => item.requiresCloudSync, [], [item]);
  const worldId = (0,react_facet_src.useFacetMap)(item => item.id, [], [item]);
  const unwrappedId = (0,react_facet_src.useFacetUnwrap)(worldId);
  const worldIdRef = (0,react_facet_src.useFacetRef)(worldId);
  const worldName = (0,react_facet_src.useFacetMap)(item => item.name, [], [item]);
  const worldImageSrc = (0,react_facet_src.useFacetMap)((item, worldRequiresSync) => {
    if (worldRequiresSync) return cloud_sync_default_namespaceObject;
    return item.previewImgPath != null && item.previewImgPath.length > 0 ? item.previewImgPath : WorldItem_images_world_preview_default_namespaceObject;
  }, [], [item, worldRequiresSync]); // Narration: Contextual pack information, wrapping the list item

  const contextNarration = (0,react_facet_src.useFacetMap)((worldName, containerListLength, tags) => [worldName, narration('.componentRole'), containerListLength > 0 ? narration('.listLengthContext', [`${index + 1}`, `${containerListLength}`]) : undefined, tags.map(tag => tag.label).join(', ')] // Filter out any empty strings
  .filter(x => x != null && x !== '').join(' . '), [narration, index], [worldName, containerListLength, tags]); // To avoid deferred rendering being called twice inside ListItem when NarrationContext
  // changes prop key from fallback to worldId --> only render when worldId is available

  if (unwrappedId == react_facet_src.NO_VALUE) return null;
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: contextNarration,
    key: unwrappedId
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: index
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: 0,
    defaultFocusedChildBehavior: "grid",
    tall: true
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    autofocus: autofocus,
    inputLegend: t('.play'),
    narrationText: [narration('.play'), narration('.buttonSiblings', ['1', '2'])].join(' . '),
    onClick: onWorldClick,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldListItem.worldImageWrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldRequiresSync
  }, /*#__PURE__*/react.createElement(CloudSyncIcon_CloudSyncIcon, null)), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: worldImageSrc,
    className: classnames_default()(semanticColors.border.base, WorldListItem.border),
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, worldName)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldListItem.tagsWrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tags
  }, (tag, index) => /*#__PURE__*/react.createElement(WorldTag, {
    tag: tag,
    index: index,
    length: tagsLengthRef.current
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayersOnline
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper, {
    totalAmountOfPlayers: numberOfPlayersOnline,
    full: worldFullWrapped,
    players: highlightedPlayers
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: editAvailable
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    narrationText: [narration('.edit'), narration('.buttonSiblings', ['2', '2'])].join(' . '),
    inputLegend: t('.edit'),
    onClick: () => worldIdRef.current !== react_facet_src.NO_VALUE && onEdit(worldIdRef.current),
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: edit_icon_namespaceObject,
    className: WorldListItem.editIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, t('.edit')))))))));
}

function WorldTag({
  tag,
  index,
  length
}) {
  const role = (0,react_facet_src.useFacetMap)(tag => tag.role, [], [tag]);
  const label = (0,react_facet_src.useFacetMap)(tag => tag.label, [], [tag]);
  const isLastTag = length != react_facet_src.NO_VALUE && index === length - 1;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: role
  }, label), !isLastTag && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useEditLocalWorldWithPrerequisites.tsx



function useEditLocalWorldWithPrerequisites(world) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const worldCloudSync = (0,react_facet_src.useSharedFacet)(worldCloudSyncFacet);
  const syncProgress = (0,react_facet_src.useFacetMap)(worldCloudSync => worldCloudSync.syncWorldProgress, [], [worldCloudSync]);
  return useFacetCoroutine((worldCloudSync, world) => function* () {
    const worldId = world.id; // we cache this string because 'world' can change references after the cloud sync

    if (world.requiresCloudSync) {
      worldCloudSync.syncWorld(worldId);
      yield syncProgress;
      worldCloudSync.reset();
    }

    historyAPI.push(`/edit-world/${encodeURIComponent(worldId)}`);
  }, [syncProgress, historyAPI], [worldCloudSync, world]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/Modals/OutOfStorageModal.tsx




const OutOfStorageModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.outOfStorageModal');
  const CLOSE_BUTTON_GAMEPAD_ALIAS = 'pop-up-modal-outOfStorageModal';
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeInputLegend'),
    variant: "secondary",
    onClick: hideModal
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UpdateWorldModals/CopyingWorldModal.tsx





const FOCUS_ALIAS_CONTENT = 'cwm-modal-content';
const FOCUS_ALIAS_CLOSE = 'cwm-modal-content-close-focus';

const CopyingWorldModal_noop = () => {};

const CopyingWorldModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.copyingWorldModal');
  const body = t('.body');
  const title = t('.title'); // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the progress content and narrate that.

  const isNarrationEnabled = useNarrationEnabled();
  const onClose = isNarrationEnabled ? undefined : CopyingWorldModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: isNarrationEnabled ? FOCUS_ALIAS_CONTENT : FOCUS_ALIAS_CLOSE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: body,
    center: true
  }, body), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UpdateWorldModals/UpdateWorldModal.tsx





const UpdateWorldModal = registerModal(({
  onCopyWorldAndContinue,
  onContinue
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.updateWorldModal');
  const hideModal = useHideModal();
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-updateWorld';
  const [isMakeCopyEnabled, setIsMakeCopyEnabled] = (0,react_facet_src.useFacetState)(true);
  const updateAndPlay = (0,react_facet_src.useFacetCallback)(isMakeCopyEnabled => () => {
    if (isMakeCopyEnabled) {
      onCopyWorldAndContinue();
    } else {
      onContinue();
    }

    hideModal();
  }, [onCopyWorldAndContinue, onContinue, hideModal], [isMakeCopyEnabled]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: isMakeCopyEnabled,
      onChange: setIsMakeCopyEnabled,
      title: t('.checkboxTitle')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 1,
    inputLegend: t('.action'),
    variant: "primary",
    onClick: updateAndPlay
  }, t('.action'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UpdateWorldModals/InsufficientDiskSpaceModal.tsx







const InsufficientDiskSpaceModal = registerModal(({
  onHandleStorage
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.insufficientDiskSpaceModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-insufficientDiskSpaceModal';
  const onClose = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.backupThenStartLocalWorld.clear();
  }, [], [(0,react_facet_src.useSharedFacet)(worldStartupFacet)]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.action'),
    variant: "primary",
    onClick: onClose
  }, t('.action')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.secondaryAction'),
    variant: "secondary",
    onClick: () => {
      onHandleStorage();
      onClose();
    }
  }, t('.secondaryAction'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UpdateWorldModals/UnknownErrorModal.tsx






const UnknownErrorModal = registerModal(() => {
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-unknown-error';
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.unknownErrorModal');
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const errorCode = (0,react_facet_src.useFacetMap)(worldStartupFacet => {
    var _worldStartupFacet$ba;

    const result = (_worldStartupFacet$ba = worldStartupFacet.backupThenStartLocalWorld.result) === null || _worldStartupFacet$ba === void 0 ? void 0 : _worldStartupFacet$ba.backupResult;
    const code = result === BackupResult.IncorrectWorldId ? BackupResult.IncorrectWorldId : BackupResult.UnknownError;
    return t('.errorCode', [`${code}`]);
  }, [t], [worldStartup]);
  const onClose = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.backupThenStartLocalWorld.clear();
  }, [], [worldStartup]);
  const body = t('.body');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    center: true,
    narrationText: (0,react_facet_src.useFacetMap)(errorCode => [body, errorCode].join(' . '), [body], [errorCode]),
    spaceBetweenParagraphs: 2,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, body), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, errorCode))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.action'),
    variant: "secondary",
    onClick: onClose
  }, t('.action'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UpdateWorldModals/index.ts




;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useShouldShowControlSelection.tsx




function useShouldShowTouchControlScreen() {
  return (0,react_facet_src.useFacetMap)((input, options, deviceInformation) => {
    // note: due to an ESLint bug we have to have explicit type annotations here
    const isUsingTouch = input.currentInputType === types_InputMethod.TOUCH;
    const shouldShowScreen = options.showTouchControlSelectionScreen;
    const isNintendoSwitch = deviceInformation.platform === Platform.NX_HANDHELD; // only uses touch for hotbar

    return isUsingTouch && shouldShowScreen && !isNintendoSwitch;
  }, [], [(0,react_facet_src.useSharedFacet)(inputFacet_inputFacet), (0,react_facet_src.useSharedFacet)(optionsFacet), (0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/NonMultiplayerSkinModal.tsx




const NonMultiplayerSkinModal = registerModal(({
  onContinue,
  onChangeSkin
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.nonMultiplayerSkinModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-nonMultiplayerSkinModal';
  const hideModal = useHideModal();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.body'),
    gamepadIndex: 0,
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.continueAction'),
    variant: "primary",
    onClick: () => {
      hideModal();
      onContinue();
    }
  }, t('.continueAction')), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.changeAction'),
    variant: "secondary",
    onClick: () => {
      hideModal();
      onChangeSkin();
    }
  }, t('.changeAction'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/ExperimentalWorldLoadingModal.tsx





const ExperimentalWorldLoadingModal = registerModal(({
  onLoadWorld
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.experimentalWorldLoadingModal');
  const hideModal = useHideModal();
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-experimentalWorldLoadingModal';
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${t('.bodyFirstParagraph')}. ${t('.bodySecondParagraph')}`,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.bodyFirstParagraph')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.bodySecondParagraph')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.back'),
    variant: "primary",
    onClick: hideModal
  }, t('.goBackButtonText')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.action'),
    gamepadIndex: 1,
    variant: "secondary",
    onClick: () => {
      hideModal();
      onLoadWorld();
    }
  }, t('.loadWorld'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/hooks/useFormatBytes.ts


const SIZES = ['.bytes', '.kilobytes', '.megabytes', '.gigabytes', '.terabytes', '.petabytes'];
const BYTES_DECIMALS = 2;
const K = 1024;

function formatBytes(bytes, t) {
  if (bytes <= 0) return t(SIZES[0], ['0']);
  const dm = BYTES_DECIMALS < 0 ? 0 : BYTES_DECIMALS;
  const i = Math.floor(Math.log(bytes) / Math.log(K));
  const value = parseFloat((bytes / Math.pow(K, i)).toFixed(dm)).toString();
  const iClamped = Math.max(0, Math.min(i, SIZES.length - 1));
  return t(SIZES[iClamped], [value]);
} // grabs and decodes the world ID from the route URL


function useFormatBytes() {
  const {
    t
  } = useLocalization_useLocalization('StorageIndicator');
  return (0,react.useCallback)(bytes => formatBytes(bytes, t), [t]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useStartLocalWorldWithPrerequisites.tsx










const CAVES_AND_CLIFFS_UPDATE = {
  major: 1,
  minor: 18,
  patch: 0,
  revision: 0,
  isBeta: false
};
function useStartLocalWorldWithPrerequisites(world) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const worldStartupSharedFacet = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const worldCloudSync = (0,react_facet_src.useSharedFacet)(worldCloudSyncFacet);
  const showNonMultiplayerSkinModal = NonMultiplayerSkinModal.useShowModal();
  const showUpdateWorldModal = UpdateWorldModal.useShowModal();
  const showOutOfStorageModal = OutOfStorageModal.useShowModal();
  const showExperimentalWorldLoadingModal = ExperimentalWorldLoadingModal.useShowModal();
  const startWorld = useStartLocalWorld();
  const shouldShowControlSelection = useShouldShowTouchControlScreen();
  const shouldShowUpdateWorldModal = (0,react_facet_src.useFacetMap)((world, buildSettings) => {
    if (world == null) return false; // Check if the template version of the world is compatible with Caves & Cliffs update
    // If no template has been applied it's set to 0.0.0 and will be deemed compatible

    const templateIsCompatibleWithCC = world.isTemplateCompatibleWithAnyVersion || compareGameVersions(world.templateVersion, CAVES_AND_CLIFFS_UPDATE) >= 0; // Check if world version is older than the Caves & Cliffs update

    const worldIsOld = compareGameVersions(world.gameVersion, CAVES_AND_CLIFFS_UPDATE) < 0 && compareGameVersions(buildSettings.currentGameVersion, CAVES_AND_CLIFFS_UPDATE) >= 0;
    return templateIsCompatibleWithCC && worldIsOld;
  }, [], [world, buildSettings]);
  const shouldShowExperimentalModal = (0,react_facet_src.useFacetMap)((world, buildSettings) => {
    if (world == null) return false;
    const worldIsOld = compareGameVersions(world.gameVersion, buildSettings.currentGameVersion) < 0;
    return world.isExperimental && worldIsOld;
  }, [], [world, buildSettings]);
  const backupThenStartLocalWorld = (0,react_facet_src.useFacetCallback)((worldStartupFacet, world) => () => {
    if (world == null) return;
    worldStartupFacet.backupThenStartLocalWorld.run(world.id);
  }, [], [worldStartupSharedFacet, world]);
  const syncProgress = (0,react_facet_src.useFacetMap)(worldCloudSync => worldCloudSync.syncWorldProgress, [], [worldCloudSync]);
  const syncThenStartLocalWorld = useFacetCoroutine((worldCloudSync, world) => function* () {
    if (world == null) return;
    const worldId = world.id; // we cache this string because 'world' can change references after the cloud sync

    worldCloudSync.syncWorld(worldId);
    yield syncProgress;
    worldCloudSync.reset();
    startWorld(worldId);
  }, [startWorld, syncProgress], [worldCloudSync, world]);
  return (0,react_facet_src.useFacetCallback)((world, userAccount, deviceInformation, shouldShowControlSelection, shouldShowExperimentalModal, shouldShowUpdateWorldModal) => () => {
    if (world == null) return;
    const worldId = world.id;

    const startWorldWithId = () => startWorld(worldId);

    if (deviceInformation.isStorageLow) {
      showOutOfStorageModal();
    } else if (!userAccount.hasValidCrossPlatformSkin) {
      showNonMultiplayerSkinModal({
        onContinue: startWorldWithId,
        onChangeSkin: () => {
          historyAPI.push('/persona');
        }
      });
    } else if (shouldShowControlSelection) {
      historyAPI.push(`/play/touch-control-selection/${encodeURIComponent(worldId)}`);
    } else if (shouldShowExperimentalModal) {
      showExperimentalWorldLoadingModal({
        onLoadWorld: startWorldWithId
      });
    } else if (shouldShowUpdateWorldModal) {
      showUpdateWorldModal({
        onContinue: startWorldWithId,
        onCopyWorldAndContinue: backupThenStartLocalWorld
      });
    } else if (world.requiresCloudSync) {
      syncThenStartLocalWorld();
    } else {
      startWorldWithId();
    }
  }, [historyAPI, startWorld, backupThenStartLocalWorld, showOutOfStorageModal, showNonMultiplayerSkinModal, showExperimentalWorldLoadingModal, showUpdateWorldModal, syncThenStartLocalWorld], [world, userAccount, deviceInformation, shouldShowControlSelection, shouldShowExperimentalModal, shouldShowUpdateWorldModal]);
}
/**
 * Internal hook.
 *
 * The primary purpose of this hook is to return a function which, when invoked,
 * calls the worldStartupFacet.startLocalWorld method with the provided worldId as an argument.
 * Important: It will NOT execute any pre-checks to ensure that the world can be started without any issues.
 *
 * Additionally, it disables the "old worlds warning" notification after the world has been initiated.
 *
 * @returns A function that, when invoked, starts the provided world.
 */

function useStartLocalWorld() {
  const worldStartupSharedFacet = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const notificationOptionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const showResourcePacksDownloadModal = ResourcePacksDownloadModal.useShowModal();
  const formatBytes = useFormatBytes();
  const availableSize = (0,react_facet_src.useFacetMap)(({
    storageUsed,
    storageSize
  }) => formatBytes(Math.max(0, storageSize - storageUsed)), [formatBytes], [deviceInformationSharedFacet]);
  const packDownloadProgress = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadProgress, [], [worldPackagesSharedFacet]);
  const onDownloadPacksAndStartWorld = useFacetCoroutine((worldPackagesFacet, worldStartupFacet) => function* (worldId, packIds) {
    if (worldId != null) {
      // Download.
      worldPackagesFacet.downloadPacks(worldId, packIds);
      yield packDownloadProgress;

      switch (worldPackagesFacet.packDownloadProgress) {
        case FacetTaskProgress.DONE:
          // Reset download flags.
          worldPackagesFacet.cancelPackDownload(); // Play world.

          worldStartupFacet.startLocalWorld_v2(worldId);
          break;

        case FacetTaskProgress.CANCELLED:
          // Reset download flags.
          worldPackagesFacet.cancelPackDownload();
          break;
      }
    }
  }, [packDownloadProgress], [worldPackagesSharedFacet, worldStartupSharedFacet]);
  const getPackSizeProgress = (0,react_facet_src.useFacetMap)(facet => facet.lastConsultedPackSizesProgress, [], [worldPackagesSharedFacet]);
  const onGetPackSize = useFacetCoroutine(facet => function* (worldId, packIds, packNames) {
    if (worldId != null) {
      // Get Pack Size.
      facet.getPackSizes(packIds, worldId);
      yield getPackSizeProgress;
      let packSizes = '';

      if (facet.lastConsultedPackSizesError == null) {
        packSizes = facet.lastConsultedPackSizes; // Reset flags.

        facet.getPackSizesReset();
      } // Show modal.


      showResourcePacksDownloadModal({
        worldId: worldId,
        packIds: packIds,
        packNames: packNames,
        packSizes: packSizes,
        availableSize: availableSize,
        onAccept: onDownloadPacksAndStartWorld
      });
    }
  }, [getPackSizeProgress, showResourcePacksDownloadModal, availableSize, onDownloadPacksAndStartWorld], [worldPackagesSharedFacet]);
  return (0,react_facet_src.useFacetCallback)((worldStartupFacet, notificationOptionsFacet) => worldId => {
    // TODO: Remove this logic once the close button is available in the Banner component
    notificationOptionsFacet.doNotShowOldWorldsWarning = true;
    worldStartupFacet.startLocalWorld_v2(worldId);

    if (worldStartupFacet.startLocalWorldResult == StartLocalWorldResult.MissingDlcDependencies) {
      worldStartupFacet.clearStartLocalWorldResult();
      const packIds = worldStartupFacet.missingPacksToStart.map(option => {
        return option.id;
      });
      const packNames = worldStartupFacet.missingPacksToStart.map(option => {
        return option.name;
      });
      onGetPackSize(worldId, packIds, packNames);
    }
  }, [onGetPackSize], [worldStartupSharedFacet, notificationOptionsSharedFacet]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldList.tsx










function WorldItem({
  world,
  index,
  numberOfWorlds
}) {
  return /*#__PURE__*/react.createElement(WorldListItem_WorldListItem, {
    containerListLength: numberOfWorlds,
    index: index,
    item: world,
    onEdit: useEditLocalWorldWithPrerequisites(world),
    onWorldClick: useStartLocalWorldWithPrerequisites(world)
  });
}

function WorldList({
  worlds,
  gamepadIndex,
  Header,
  Footer,
  scrollViewRef
}) {
  const amountOfWorlds = (0,react_facet_src.useFacetMap)(facet => {
    var _facet$length;

    return (_facet$length = facet.length) !== null && _facet$length !== void 0 ? _facet$length : 0;
  }, [], [worlds]); // The + 2 is to offset for the header. We could build this into the FlatList component
  // but given that the visual navigation should be finished soon we might not want to add more
  // gamepad logic to core components.

  const footerIndex = (0,react_facet_src.useFacetMap)(amountOfWorlds => amountOfWorlds + 2, [], [amountOfWorlds]);
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(FlatList_FlatList, {
    gamepadAlias: "content-wrapper",
    delegateFocusByAlias: "play-cnw-button",
    defaultFocusedChildBehavior: "remember",
    gamepadIndex: 0,
    header: Header && /*#__PURE__*/react.createElement(Header, null),
    emptyMessage: /*#__PURE__*/react.createElement(react.Fragment, null, "Empty"),
    data: worlds,
    scrollViewRef: scrollViewRef,
    footer: Footer && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    }), /*#__PURE__*/react.createElement(Footer, {
      gamepadIndex: footerIndex
    })),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(WorldItem, {
      world: itemFacet,
      index: index,
      numberOfWorlds: amountOfWorlds
    }),
    itemSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    padSpinnerVertically: true,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    })
  }));
}
;// CONCATENATED MODULE: ./packages/ui/src/DetailedCard/DetailedCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const DetailedCard = ({"detailedCard":"Jc8Rm","information":"nDjUk","pressed":"H9mwe","additionalAction":"oxWWD","elevated":"DDpsY","elevatedAdditionalAction":"wESDB","pressedAction":"Iz5CA","pressedAdditionalAction":"pTz3U"});
;// CONCATENATED MODULE: ./packages/ui/src/DetailedCard/DetailedCard.tsx







function DetailedCard_DetailedCard({
  children,
  role = 'neutral'
}) {
  const semanticColors = hooks_useSemanticColors(role);
  const classes = classnames_default()(DetailedCard.main, semanticColors.text.base, semanticColors.border.base);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classes
  }, children));
}
const FALSE_FACET = (0,react_facet_src.createStaticFacet)(false);

function DetailedCardAction({
  autofocus,
  gamepadIndex,
  children,
  onClick,
  inputLegend,
  onFocusChanged,
  onHoverChanged,
  narrationText,
  gamepadAlias,
  focusStateOnElevatedFace = FALSE_FACET
}) {
  const semanticSounds = useSemanticSounds('neutral');
  return /*#__PURE__*/react.createElement(Pressable_Pressable, {
    focusStateOnElevatedFace: (0,react_facet_src.useFacetUnwrap)(focusStateOnElevatedFace) === true,
    variant: "neutral",
    isElevated: true,
    reflectionConfig: {
      top: false,
      bottom: false,
      left: false,
      right: false
    },
    autofocus: autofocus,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    classNameElevated: DetailedCard.elevated,
    classNameElevatedAndPressed: DetailedCard.pressedAction,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    onHoverChanged: onHoverChanged,
    soundEffectPressed: semanticSounds.press
  }, /*#__PURE__*/react.createElement("div", {
    className: DetailedCard.detailedCard
  }, children));
}

function DetailedCard_Information({
  children,
  innerRef,
  narrationText,
  role = 'inherit'
}) {
  // Set child string value as narration string
  useSetParentNarrationText(narrationText);
  const semanticColors = hooks_useSemanticColors(role);
  const classes = classnames_default()(DetailedCard.information, semanticColors.text.base, semanticColors.border.base);
  return /*#__PURE__*/react.createElement("div", {
    className: classes,
    ref: innerRef
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), children, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }));
}

function AdditionalAction({
  children,
  onClick,
  onMouseDown,
  inputLegend,
  narrationText,
  gamepadAlias,
  hidden = false,
  gamepadIndex = 0,
  innerRef,
  touchDetectionDelay,
  soundEffectPressed
}) {
  const hiddenFacet = (0,react_facet_src.useFacetWrap)(hidden);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(hidden => !hidden, [], [hiddenFacet])
  }, /*#__PURE__*/react.createElement(Pressable_Pressable, {
    innerRef: innerRef,
    variant: "neutral",
    isElevated: true,
    reflectionConfig: {
      top: true,
      bottom: false,
      left: false,
      right: false
    },
    classNameElevated: DetailedCard.elevatedAdditionalAction,
    classNameElevatedAndPressed: DetailedCard.pressedAdditionalAction,
    gamepadIndex: gamepadIndex,
    gamepadAlias: gamepadAlias,
    inputLegend: inputLegend,
    onClick: onClick,
    onMouseDown: onMouseDown,
    narrationText: narrationText,
    touchDetectionDelay: touchDetectionDelay,
    soundEffectPressed: soundEffectPressed
  }, /*#__PURE__*/react.createElement("div", {
    className: DetailedCard.detailedCard
  }, children)));
}

DetailedCard_DetailedCard.Information = DetailedCard_Information;
DetailedCard_DetailedCard.AdditionalAction = AdditionalAction;
DetailedCard_DetailedCard.Action = DetailedCardAction;
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldCard = ({"editIcon":"lE4AL","editButton":"UzBDX","editButtonFiller":"MltQY","players":"ngorA","tagsWrapper":"CXtm9","worldTagContainer":"F3pEA","row":"a2dlw"});
;// CONCATENATED MODULE: ./games/vanilla/ui/src/WorldItem/WorldCard.tsx

















function WorldCard_WorldCard({
  item,
  onWorldClick,
  narrationIndex,
  onEdit = () => {},
  containerListLength,
  totalAmountOfPlayers,
  worldFull,
  playersOnline
}) {
  const {
    t
  } = useLocalization_useLocalization('WorldCard');
  const {
    t: narration
  } = useLocalization_useLocalization('WorldCard.narration');
  const tags = useWorldTags(item);
  const tagsLength = (0,react_facet_src.useFacetMap)(tags => tags.length, [], [tags]);
  const tagsLengthRef = (0,react_facet_src.useFacetRef)(tagsLength);
  const highlightedPlayers = (0,react_facet_src.useFacetWrap)(playersOnline !== null && playersOnline !== void 0 ? playersOnline : []);
  const worldFullWrapped = (0,react_facet_src.useFacetWrap)(worldFull !== null && worldFull !== void 0 ? worldFull : false);
  const showPlayersOnline = (0,react_facet_src.useFacetMap)(playersOnline => playersOnline != null && playersOnline.length > 0, [], [highlightedPlayers]);
  const numberOfPlayersOnline = (0,react_facet_src.useFacetMap)(totalAmountOfPlayers => totalAmountOfPlayers - 4, [], [(0,react_facet_src.useFacetWrap)(totalAmountOfPlayers !== null && totalAmountOfPlayers !== void 0 ? totalAmountOfPlayers : 0)]); // Always show edit button for local worlds. Logic for non-local worlds might need different criteria.

  const isEditAvailable = (0,react_facet_src.useFacetWrap)(true);
  /*
  	World card behavior based on player input and rights:
  		1a. Non-gamepad user with edit rights:        Display edit button
  	1b. Non-gamepad user without edit rights:     Hide edit button, use filler
  	2a. Gamepad user with edit rights:            Hide edit button, show edit shortcut
  	2b. Gamepad user without edit rights:         Hide both the edit button and the edit shortcut
  */

  const isGamepadMode = useIsFocusInputGamepad();
  const isEditButtonVisible = (0,react_facet_src.useFacetMap)((isEditAvailable, isGamepadMode) => isEditAvailable && !isGamepadMode, [], [isEditAvailable, isGamepadMode]);
  const isEditButtonFillerVisible = (0,react_facet_src.useFacetMap)((isEditAvailable, isGamepadMode) => !isEditAvailable && !isGamepadMode, [], [isEditAvailable, isGamepadMode]);
  const isEditShortcutEnabled = (0,react_facet_src.useFacetMap)((isEditAvailable, isGamepadMode) => isEditAvailable && isGamepadMode, [], [isEditAvailable, isGamepadMode]);
  const worldId = (0,react_facet_src.useFacetMap)(item => item.id, [], [item]);
  const worldIdRef = (0,react_facet_src.useFacetRef)(worldId);
  const worldName = (0,react_facet_src.useFacetMap)(item => item.name, [], [item]); // Display a distinct world card for un-synced cloud-stored worlds, initiating sync on 'Edit' or 'Play'.

  const worldRequiresSync = (0,react_facet_src.useFacetMap)(item => item.requiresCloudSync, [], [item]);
  const contextNarration = (0,react_facet_src.useFacetMap)((worldName, containerListLength, tags) => [worldName, narration('.componentRole'), containerListLength > 0 ? narration('.gridAmountContext', [`${narrationIndex}`, `${containerListLength}`]) : undefined,, tags.map(tag => tag.label).join(', ')] // Filter out any empty strings
  .filter(x => x != null && x !== '').join(' . '), [narration, narrationIndex], [worldName, containerListLength, tags]);
  const worldImageSrc = (0,react_facet_src.useFacetMap)((item, worldRequiresSync) => {
    if (worldRequiresSync) return cloud_sync_default_namespaceObject;
    return item.previewImgPath != null && item.previewImgPath.length > 0 ? item.previewImgPath : WorldItem_images_world_preview_default_namespaceObject;
  }, [], [item, worldRequiresSync]);
  const worldEditor = (0,react_facet_src.useFacetCallback)(worldId => () => onEdit(worldId), [onEdit], [worldId]);
  const narrationText = (0,react_facet_src.useFacetMap)(isEditButtonVisible => // If the world card has a separate edit button, this should be reflected in the narration
  isEditButtonVisible ? [narration('.play'), narration('.buttonSiblings', ['1', '2'])].join(' . ') : [narration('.play'), t('.button')].join(' . '), [t, narration], [isEditButtonVisible]);
  return /*#__PURE__*/react.createElement(FocusGroup, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: contextNarration
  }, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard, null, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.Action, {
    // The focus should be on just the face to avoid it being cropped by the Edit button
    focusStateOnElevatedFace: isEditButtonVisible,
    gamepadIndex: 0,
    inputLegend: t('.play'),
    narrationText: narrationText,
    onClick: onWorldClick
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: worldImageSrc,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldRequiresSync
  }, /*#__PURE__*/react.createElement(CloudSyncIcon_CloudSyncIcon, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPlayersOnline
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.players
  }, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper.Panel, null, /*#__PURE__*/react.createElement(PlayerAvatarWrapper_PlayerAvatarWrapper, {
    totalAmountOfPlayers: numberOfPlayersOnline,
    full: worldFullWrapped,
    players: highlightedPlayers
  }))))), /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.Information, {
    narrationText: worldName
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, worldName)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldCard.tagsWrapper
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: tags
  }, (tag, index) => /*#__PURE__*/react.createElement(WorldCard_WorldTag, {
    tag: tag,
    index: index,
    length: tagsLengthRef.current
  }))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditButtonVisible
  }, /*#__PURE__*/react.createElement(DetailedCard_DetailedCard.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: [narration('.edit'), narration('.buttonSiblings', ['2', '2'])].join(' . '),
    inputLegend: t('.edit'),
    onClick: () => worldIdRef.current !== react_facet_src.NO_VALUE && onEdit(worldIdRef.current)
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.editButton
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: edit_icon_namespaceObject,
    className: WorldCard.editIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: "inherit",
    verticalAlign: "center"
  }, t('.edit'))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditButtonFillerVisible
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.editButtonFiller
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isEditShortcutEnabled
  }, /*#__PURE__*/react.createElement(ParentShortcut_ParentShortcut, {
    options: {
      button: types_ButtonType.X,
      inputLegend: t('.edit')
    },
    onClick: worldEditor
  })))));
}

function WorldCard_WorldTag({
  tag,
  index,
  length
}) {
  const role = (0,react_facet_src.useFacetMap)(tag => tag.role, [], [tag]);
  const label = (0,react_facet_src.useFacetMap)(tag => tag.label, [], [tag]);
  const isLastTag = length != react_facet_src.NO_VALUE && index === length - 1;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.worldTagContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: WorldCard.row
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: role
  }, label), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })), !isLastTag && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldGrid.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const WorldGrid = ({"row":"OufbE","column":"NMzdz","cell":"QDf02"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/WorldGrid.tsx










const NUMBER_OF_COLUMNS = 4;
const COLUMN_WIDTH = `${100 / NUMBER_OF_COLUMNS}%`;

function WorldCardItem({
  world,
  index,
  columnIndex,
  containerListLength
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, index > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldGrid.cell
  }, /*#__PURE__*/react.createElement(WorldCard_WorldCard, {
    containerListLength: containerListLength,
    item: world // The card's placement in the grid needs to be calculated using its index and column index
    ,
    narrationIndex: index * NUMBER_OF_COLUMNS + columnIndex + 1 // narrationIndex is calculated sequentially in the grid
    ,
    onEdit: useEditLocalWorldWithPrerequisites(world),
    onWorldClick: useStartLocalWorldWithPrerequisites(world)
  })));
}

function WorldCardColumn({
  worlds,
  index: columnIndex,
  containerListLength
}) {
  return /*#__PURE__*/react.createElement(react.Fragment, null, columnIndex > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: WorldGrid.column,
    style: {
      width: COLUMN_WIDTH
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      defaultFocusedChildBehavior: 'grid',
      index: columnIndex
    }
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: worlds
  }, (world, index) => /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(WorldCardItem, {
    world: world,
    index: index,
    columnIndex: columnIndex,
    containerListLength: containerListLength
  }))))));
}

function WorldGridInner({
  worlds: allWorlds,
  gamepadIndex,
  Header,
  Footer,
  scrollViewRef
}) {
  const isRenderingPaused = (0,deferred_mount_dist.useIsPaused)();
  const containerListLength = (0,react_facet_src.useFacetMap)(allWorlds => {
    var _allWorlds$length;

    return (_allWorlds$length = allWorlds.length) !== null && _allWorlds$length !== void 0 ? _allWorlds$length : 0;
  }, [], [allWorlds]);
  const dataMatrix = (0,react_facet_src.useFacetMemo)(data => {
    const matrix = [...new Array(NUMBER_OF_COLUMNS)].map(() => []);
    data.forEach((item, index) => {
      const matrixIndex = index % NUMBER_OF_COLUMNS;
      matrix[matrixIndex].push(item);
    });
    return matrix;
  }, [], [allWorlds]);
  const scrollRef = (0,react.useRef)(null);
  const isLoading = (0,react_facet_src.useFacetMap)(isDeferring => isDeferring || isRenderingPaused, [isRenderingPaused], [(0,deferred_mount_dist.useIsDeferring)()]);
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    loading: isLoading,
    gamepadIndex: 0,
    innerRef: scrollViewRef,
    gamepadAlias: "content-wrapper",
    delegateFocusByAlias: "play-cnw-button",
    defaultFocusedChildBehavior: "remember",
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    })
  }, Header && /*#__PURE__*/react.createElement(Header, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: scrollRef,
    defaultFocusedChildBehavior: "remember",
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement("div", {
    ref: scrollRef,
    className: WorldGrid.row
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataMatrix
  }, (columnWorlds, index) => /*#__PURE__*/react.createElement(WorldCardColumn, {
    worlds: columnWorlds,
    containerListLength: containerListLength,
    index: index
  })))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), Footer && /*#__PURE__*/react.createElement(Footer, {
    gamepadIndex: 2
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })));
}

function WorldGrid_WorldGrid(props) {
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(WorldGridInner, props));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/no-worlds-yet-art.png
const no_worlds_yet_art_namespaceObject = __webpack_require__.p + "assets/no-worlds-yet-art-38524.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/EmptyStateMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AllWorlds_EmptyStateMessage = ({"emptyStateArt":"zvmmk","emptyStateArtBig":"kcpRz"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/EmptyState.tsx






function EmptyState({
  gamepadIndex,
  navigationButtons
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.allWorlds'); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 224
  });
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: gamepadIndex,
    title: t('.emptyStateTitle'),
    text: t('.emptyStateText'),
    imgSrc: no_worlds_yet_art_namespaceObject,
    imgClass: narrowImage ? AllWorlds_EmptyStateMessage.emptyStateArt : AllWorlds_EmptyStateMessage.emptyStateArtBig,
    buttons: navigationButtons
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/DesignPreview.tsx





function DesignPreview({
  tab,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const openFeedbackPage = useOpenFeedbackPage();
  const optOut = useOptOut(tab);
  return /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton, {
    gamepadIndex: gamepadIndex,
    defaultFocusedChildBehavior: "first",
    title: t('.designPreviewTitle'),
    description: t('.designPreviewDescription'),
    buttons: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: `${t('.designPreviewInputLegend')}`,
      horizontal: true,
      onClick: openFeedbackPage,
      imgSrc: external_link_namespaceObject,
      gamepadIndex: 0
    }, t('.feedbackButton')), /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton.ButtonSpacing, null), /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: `${t('.designPreviewInputLegend')}`,
      horizontal: true,
      onClick: optOut,
      gamepadIndex: 1
    }, t('.optOutButton')))
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useLocalWorlds.ts


function useLocalWorlds() {
  const localWorldList = (0,react_facet_src.useSharedFacet)(localWorldListFacet);
  const localWorlds = (0,react_facet_src.useFacetMap)(({
    localWorlds
  }) => localWorlds.filter(world => world.allContentOwned), [], [localWorldList]); // TODO: This also has to take loading into consideration because the array might be empty to start with.

  const isEmptyListOfWorlds = (0,react_facet_src.useFacetMap)(localWorlds => localWorlds.length < 1, [], [localWorlds]);
  const alternativeStorageHasWorlds = (0,react_facet_src.useFacetMap)(localWorldList => localWorldList.otherStorageTypeHasWorlds, [], [localWorldList]);
  return {
    data: localWorlds,
    isEmpty: isEmptyListOfWorlds,
    alternativeStorageHasWorlds: alternativeStorageHasWorlds
  };
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useAlternativeStorageConfig.ts





/**
 * Custom React hook to check the user's device storages for worlds, and return boolean values
 * indicating their state. These booleans can be utilized to present specific information
 * tailored to the user's storage settings, allowing a more personalized user experience.
 */

function useAlternativeStorageConfig() {
  const localWorlds = useLocalWorlds();
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const alternativeStorage = (0,react_facet_src.useFacetMap)(device => device.storageType, [], [deviceInformation]); // If the player is on a console and the old worlds warning has not been shown

  const possiblyOldWorldsAvailable = (0,react_facet_src.useFacetMap)((deviceInformationFacet, notificationOptionsFacet) => !notificationOptionsFacet.doNotShowOldWorldsWarning && isConsolePlatform(deviceInformationFacet.platform), [], [deviceInformation, (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet)]); // Player has worlds on both current and alternative storage

  const worldsOnAlternativeStorageAndCurrentStorage = (0,react_facet_src.useFacetMap)((alternativeStorageHasWorlds, isEmptyListOfWorlds) => !isEmptyListOfWorlds && alternativeStorageHasWorlds, [], [localWorlds.alternativeStorageHasWorlds, localWorlds.isEmpty]); // There are local worlds, the player is on the _alternative storage_ and there are no worlds on the regular storage

  const worldsUsingAlternativeStorage = (0,react_facet_src.useFacetMap)((alternativeStorage, isEmptyListOfWorlds, alternativeStorageHasWorlds) => !isEmptyListOfWorlds && alternativeStorage === StorageType.EXTERNAL && !alternativeStorageHasWorlds, [], [alternativeStorage, localWorlds.isEmpty, localWorlds.alternativeStorageHasWorlds]); // There are local worlds, the player is on the _alternative storage_ and there are worlds on an alternative storage

  const worldsOnBothStoragesUsingAlternativeStorage = (0,react_facet_src.useFacetMap)((alternativeStorage, worldsOnAlternativeStorageAndCurrentStorage) => alternativeStorage === StorageType.EXTERNAL && worldsOnAlternativeStorageAndCurrentStorage, [], [alternativeStorage, worldsOnAlternativeStorageAndCurrentStorage]); // There are local worlds, the player is on the _regular storage_ and there are worlds on an alternative storage

  const worldsOnBothStoragesUsingRegularStorage = (0,react_facet_src.useFacetMap)((alternativeStorage, worldsOnAlternativeStorageAndCurrentStorage) => alternativeStorage === StorageType.APPDATA && worldsOnAlternativeStorageAndCurrentStorage, [], [alternativeStorage, worldsOnAlternativeStorageAndCurrentStorage]);
  return {
    possiblyOldWorldsAvailable,
    worldsOnAlternativeStorageAndCurrentStorage,
    alternativeStorageHasWorlds: localWorlds.alternativeStorageHasWorlds,
    worldsUsingAlternativeStorage,
    worldsOnBothStoragesUsingAlternativeStorage,
    worldsOnBothStoragesUsingRegularStorage
  };
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/ButtonHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ButtonHeader = ({"buttonsCenter":"IAVEv","buttonsEnd":"UjHH5","button":"mVSiw"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/ButtonHeader.tsx









function ButtonHeader_noop() {}

function HeaderButton({
  item,
  index,
  numberOfButtons,
  t: narration,
  breakpoint
}) {
  const narrationSuffix = (0,react_facet_src.useFacetMap)(({
    narrationSuffix
  }, numberOfButtons) => [narration('.buttonSiblings', [`${index + 1}`, `${numberOfButtons}`]), narrationSuffix].join(' . '), [narration, index], [item, numberOfButtons]);
  const text = (0,react_facet_src.useFacetMap)(({
    text
  }) => text, [], [item]);
  const imgSrc = (0,react_facet_src.useFacetMap)(({
    imgSrc
  }) => imgSrc, [], [item]);
  const gamepadAlias = (0,react_facet_src.useFacetMap)(({
    gamepadAlias
  }) => gamepadAlias, [], [item]);
  const inputLegend = (0,react_facet_src.useFacetMap)(({
    inputLegend,
    text
  }) => inputLegend !== null && inputLegend !== void 0 ? inputLegend : text, [], [item]);
  const isLastItem = (0,react_facet_src.useFacetMap)(numberOfButtons => index < numberOfButtons - 1, [index], [numberOfButtons]);
  const onClick = (0,react_facet_src.useFacetCallback)(({
    onClick
  }) => onClick !== null && onClick !== void 0 ? onClick : ButtonHeader_noop, [], [item]); // Would be nice to not unwrap this variant, but looks like a deeper piece of work
  // to make the Pressable accept Facets for this prop and measure the performance impact of that.

  const variant = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(({
    variant
  }) => variant, [], [item]));
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: ButtonHeader.button
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: inputLegend,
    gamepadIndex: index,
    narrationSuffix: narrationSuffix,
    variant: variant == react_facet_src.NO_VALUE ? 'secondary' : variant,
    onClick: onClick,
    imgSrc: imgSrc,
    gamepadAlias: gamepadAlias
  }, text)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLastItem
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 4
  })));
}

function ButtonHeader_ButtonHeader({
  buttons,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.ButtonHeader.narration');
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const numberOfButtons = (0,react_facet_src.useFacetMap)(buttons => buttons.length, [], [buttons]);
  const centerAlignButtons = (0,react_facet_src.useFacetMap)(buttons => buttons.length > 2, [], [buttons]);
  const horizontalPadding = /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing.Facet, {
    size: (0,react_facet_src.useFacetMap)(centerAlignButtons => breakpoint === 'narrow' && centerAlignButtons ? 7 : 0, [breakpoint], [centerAlignButtons])
  });
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: gamepadIndex,
      defaultFocusedChildBehavior: 'first'
    }
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(centerAlignButtons => centerAlignButtons ? ButtonHeader.buttonsCenter : ButtonHeader.buttonsEnd, [], [centerAlignButtons])
  }, horizontalPadding, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: buttons
  }, (button, index) => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(HeaderButton, {
    t: t,
    breakpoint: breakpoint,
    item: button,
    index: index,
    numberOfButtons: numberOfButtons
  }))), horizontalPadding));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageBanner.tsx




function StorageBanner({
  text,
  link
}) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  return /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "neutral100",
    narrationId: "allWorldsTab:externalStorageWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, text), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => historyAPI.push('/settings/storage')
  }, link));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/images/settings-icon.png
const StorageIndicator_images_settings_icon_namespaceObject = __webpack_require__.p + "assets/settings-icon-af819.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/StorageIndicator.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StorageIndicator = ({"container":"LtuVe","flexBetween":"M6QIX","leftContentWrapper":"Mm3Zd","settingsButton":"XUQjt","settingsIcon":"jf7d7"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/StorageIndicator.tsx













function StorageIndicator_StorageIndicator({
  gamepadIndex,
  role = 'inherit'
}) {
  const {
    t
  } = useLocalization_useLocalization('StorageIndicator');
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const percentage = (0,react_facet_src.useFacetMap)(({
    storageUsed,
    storageSize
  }) => storageSize <= 0 ? 1 : storageUsed / storageSize, // Prevent division by zero
  [], [deviceInformation]);
  const formatBytes = useFormatBytes();
  const storageLabel = (0,react_facet_src.useFacetMap)(({
    storageSize,
    storageUsed
  }) => t('.storageSpace', [formatBytes(Math.max(0, storageUsed)), formatBytes(Math.max(0, storageSize))]), [t, formatBytes], [deviceInformation]);
  const isStorageFull = (0,react_facet_src.useFacetMap)(({
    isStorageFull,
    storageSize,
    storageUsed
  }) => isStorageFull || storageSize <= 0 || storageUsed >= storageSize, [], [deviceInformation]);
  const semanticColors = hooks_useSemanticColors(role);
  const success = useSemanticColorValues('success');
  const notice = useSemanticColorValues('notice');
  const destructive = useSemanticColorValues('destructive');
  const progressBarColor = (0,react_facet_src.useFacetMap)(({
    isStorageLow
  }, isStorageFull) => {
    var _destructive$backgrou, _notice$background$de, _success$background$d;

    return isStorageFull ? (_destructive$backgrou = destructive.background.default) !== null && _destructive$backgrou !== void 0 ? _destructive$backgrou : 'var(--red50)' : isStorageLow ? (_notice$background$de = notice.background.default) !== null && _notice$background$de !== void 0 ? _notice$background$de : 'var(--orange20)' : (_success$background$d = success.background.default) !== null && _success$background$d !== void 0 ? _success$background$d : 'var(--green50)';
  }, [success, notice, destructive], [deviceInformation, isStorageFull]);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(StorageIndicator.container, semanticColors.border.base, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: StorageIndicator.flexBetween
  }, /*#__PURE__*/react.createElement("div", {
    className: StorageIndicator.leftContentWrapper
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "secondaryButton"
  }, /*#__PURE__*/react.createElement("fast-text", {
    text: storageLabel
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isStorageFull
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: "destructiveTint"
  }, t('.fullStorageTag')))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(ProgressBar_ProgressBar_ProgressBar, {
    percentage: percentage,
    fillColor: progressBarColor
  })), /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    className: StorageIndicator.settingsButton,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.settings'),
    narrationText: t('.settings'),
    onClick: () => {
      historyAPI.push('/settings/storage');
    },
    role: role
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: StorageIndicator_images_settings_icon_namespaceObject,
    className: StorageIndicator.settingsIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.settings'))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/StorageIndicator/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/AllWorldsButtonHeader.tsx












function OldWorldsBanner() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.oldWorldsBanner');
  return /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "informative",
    narrationId: "allWorldsTab:oldWorldsWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.text')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: () => historyAPI.push('/settings/storage')
  }, t('.link')));
}

function AllWorldsButtonHeader({
  navigationButtons,
  showUsingExternalStorageWarning,
  showHiddenLocalWorldsWarning,
  showHiddenAlternativeStorageWorldsWarning,
  showOldWorldsNotification
}) {
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.storageBanner');
  const showStorageIndicator = (0,react_facet_src.useFacetMap)( // Only show the storage indicator on consoles when the storage is low or full
  ({
    platform,
    isStorageFull,
    isStorageLow
  }) => isConsolePlatform(platform) && (isStorageFull || isStorageLow), [], [deviceInformation]);
  return /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 0
    }
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showStorageIndicator
  }, /*#__PURE__*/react.createElement(StorageIndicator_StorageIndicator, {
    gamepadIndex: 0
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showUsingExternalStorageWarning
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(StorageBanner, {
    text: t('.externalStorageWarningText'),
    link: t('.manageStorageLink')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showHiddenAlternativeStorageWorldsWarning
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(StorageBanner, {
    text: t('.alternativeStorageWorldsHiddenText'),
    link: t('.changeStorageLink')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showHiddenLocalWorldsWarning
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(StorageBanner, {
    text: t('.localWorldsHiddenText'),
    link: t('.changeStorageLink')
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showOldWorldsNotification
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(OldWorldsBanner, null))), /*#__PURE__*/react.createElement(ButtonHeader_ButtonHeader, {
    gamepadIndex: 1,
    buttons: navigationButtons
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/UnexpectedLaunchErrorModal.tsx






const UnexpectedLaunchErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.unexpectedLaunchErrorModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-unexpectedLaunchErrorModal';
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const onClose = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.clearStartLocalWorldResult();
  }, [], [worldStartup]);
  const errorCodeMsg = (0,react_facet_src.useFacetMap)(worldStartup => {
    var _worldStartup$startLo;

    const errorCode = `${(_worldStartup$startLo = worldStartup.startLocalWorldResult) !== null && _worldStartup$startLo !== void 0 ? _worldStartup$startLo : 'n/a'}`;
    return t('.body2', [errorCode]);
  }, [t], [worldStartup]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: (0,react_facet_src.useFacetMap)(errorMsg => `${t('.body')} . ${errorMsg}`, [t], [errorCodeMsg]),
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, t('.body')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, errorCodeMsg))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/WorldMissingEntitlementModal.tsx







const WorldMissingEntitlementModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.worldMissingEntitlementModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-worldMissingEntitlementModal';
  const localWorldList = (0,react_facet_src.useSharedFacet)(localWorldListFacet);
  const hideModal = useHideModal();
  const [doNotShowAgain, setDoNotShowAgain] = (0,react_facet_src.useFacetState)(false);
  const worldsWithoutEntitlement = (0,react_facet_src.useFacetMap)(localWorldList => localWorldList.localWorlds.filter(world => !world.allContentOwned), [], [localWorldList]);
  const amountOfWorldsWithoutEntitlement = (0,react_facet_src.useFacetMap)(worldsWithoutEntitlement => worldsWithoutEntitlement.length, [], [worldsWithoutEntitlement]);
  const worldNamesWithoutEntitlement = (0,react_facet_src.useFacetMemo)(worldsWithoutEntitlement => worldsWithoutEntitlement.map(({
    name
  }) => name), [], [worldsWithoutEntitlement]);
  const modalText = (0,react_facet_src.useFacetMap)(amountOfWorldsWithoutEntitlement => t('.body', [`${amountOfWorldsWithoutEntitlement}`]), [t], [amountOfWorldsWithoutEntitlement]);
  const closeAndConfirmChoiceModal = (0,react_facet_src.useFacetCallback)((notificationOptions, doNotShowAgain) => () => {
    notificationOptions.doNotShowEntitlementsWarning = doNotShowAgain;
    hideModal();
  }, [hideModal], [(0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet), doNotShowAgain]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: hideModal,
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, (0,react_facet_src.useFacetMap)(amountOfWorldsWithoutEntitlement => t('.title', [`${amountOfWorldsWithoutEntitlement}`]), [t], [amountOfWorldsWithoutEntitlement])), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: modalText
  }, modalText), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: worldNamesWithoutEntitlement,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: doNotShowAgain,
      onChange: value => setDoNotShowAgain(!!value),
      title: t('.doNotShowAgain')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: closeAndConfirmChoiceModal
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/CloudSyncWorldConnectionErrorModal.tsx






const CloudSyncWorldConnectionErrorModal = registerModal(() => {
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-cloudSyncWorldConnectionError';
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.cloudSyncWorldConnectionError');
  const worldCloudSync = (0,react_facet_src.useSharedFacet)(worldCloudSyncFacet);
  const hideModal = useHideModal();
  const onClick = (0,react_facet_src.useFacetCallback)(worldCloudSync => () => {
    worldCloudSync.reset();
    hideModal();
  }, [hideModal], [worldCloudSync]);
  const modalText = t('.text');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: onClick,
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClick
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: modalText,
    center: true
  }, modalText)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClick
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/CloudSyncWorldProgressModal.tsx






function CloudSyncWorldProgressModal_noop() {}
/**
 * The CloudSyncWorldProgressModal component represents a modal that becomes visible during the
 * synchronization of world data with cloud storage. The synchronization is triggered when a user
 * tries to edit or start a world that is not yet synced with the cloud storage.
 */


const CloudSyncWorldProgressModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.cloudSyncWorldProgressModal');
  const isNarrationEnabled = useNarrationEnabled();
  const FOCUS_ALIAS_CONTENT = 'cloud-sync-world-progress-content-focus';
  const FOCUS_ALIAS_CLOSE = 'cloud-sync-world-progress-close-focus'; // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the content and narrate that.

  const onClose = isNarrationEnabled ? undefined : CloudSyncWorldProgressModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: isNarrationEnabled ? FOCUS_ALIAS_CONTENT : FOCUS_ALIAS_CLOSE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/index.ts





;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/Modals.tsx









function Modals() {
  const history = RouterEngineProvider_useRouteHistory();
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const worldCloudSync = (0,react_facet_src.useSharedFacet)(worldCloudSyncFacet);
  const localWorlds = (0,react_facet_src.useSharedFacet)(localWorldListFacet);
  const notifications = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet); // If one or more worlds are missing entitlement, show the entitlement warning modal

  const worldMissingEntitlement = (0,react_facet_src.useFacetMap)((localWorldList, {
    doNotShowEntitlementsWarning
  }) => {
    // If the player has decided to hide this warning modal it should not be shown
    const existWorldsWithUnownedContent = localWorldList.localWorlds.filter(world => !world.allContentOwned).length > 0;
    return !doNotShowEntitlementsWarning && existWorldsWithUnownedContent;
  }, [], [localWorlds, notifications]); // If there is an error when starting the world, show an error modal
  // A generic error can occur when starting a world regularly

  const showWorldStartErrorModal = (0,react_facet_src.useFacetMap)(worldStartup => {
    const result = worldStartup.startLocalWorldResult;
    return result != null && result === StartLocalWorldResult.WorldNotInLevelList;
  }, [], [worldStartup]);
  const showCloudSyncProgressModal = (0,react_facet_src.useFacetMap)(worldCloudSync => worldCloudSync.syncWorldProgress === FacetTaskProgress.RUNNING, [], [worldCloudSync]);
  const showCloudSyncErrorModal = (0,react_facet_src.useFacetMap)(worldCloudSync => worldCloudSync.syncWorldProgress === FacetTaskProgress.FAILED, [], [worldCloudSync]); // Update world modals for worlds older than Caves & Cliffs

  const showCopyWorldModal = (0,react_facet_src.useFacetMap)(worldStartupFacet => worldStartupFacet.backupThenStartLocalWorld.state === types_AsyncStatefulFunctionState.InProgress, [], [worldStartup]);
  const showInsufficientDiskSpaceForWorldBackupErrorModal = (0,react_facet_src.useFacetMap)(worldStartupFacet => {
    var _worldStartupFacet$ba;

    return ((_worldStartupFacet$ba = worldStartupFacet.backupThenStartLocalWorld.result) === null || _worldStartupFacet$ba === void 0 ? void 0 : _worldStartupFacet$ba.backupResult) === BackupResult.InsufficientDiskSpace;
  }, [], [worldStartup]);
  const showUnknownErrorForWorldBackupModal = (0,react_facet_src.useFacetMap)(worldStartupFacet => {
    var _worldStartupFacet$ba2, _worldStartupFacet$ba3;

    return ((_worldStartupFacet$ba2 = worldStartupFacet.backupThenStartLocalWorld.result) === null || _worldStartupFacet$ba2 === void 0 ? void 0 : _worldStartupFacet$ba2.backupResult) === BackupResult.IncorrectWorldId || ((_worldStartupFacet$ba3 = worldStartupFacet.backupThenStartLocalWorld.result) === null || _worldStartupFacet$ba3 === void 0 ? void 0 : _worldStartupFacet$ba3.backupResult) === BackupResult.UnknownError;
  }, [], [worldStartup]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showWorldStartErrorModal
  }, /*#__PURE__*/react.createElement(UnexpectedLaunchErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldMissingEntitlement
  }, /*#__PURE__*/react.createElement(WorldMissingEntitlementModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showCloudSyncProgressModal
  }, /*#__PURE__*/react.createElement(CloudSyncWorldProgressModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showCloudSyncErrorModal
  }, /*#__PURE__*/react.createElement(CloudSyncWorldConnectionErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showCopyWorldModal
  }, /*#__PURE__*/react.createElement(CopyingWorldModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showInsufficientDiskSpaceForWorldBackupErrorModal
  }, /*#__PURE__*/react.createElement(InsufficientDiskSpaceModal.Component, {
    onHandleStorage: () => history.push('/settings/storage')
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showUnknownErrorForWorldBackupModal
  }, /*#__PURE__*/react.createElement(UnknownErrorModal.Component, null)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/images/import-world-icon.png
const import_world_icon_namespaceObject = __webpack_require__.p + "assets/import-world-icon-4e8aa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useNavigationButtons.ts









function useNavigationButtons() {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.AllWorldsTab.ButtonHeader');
  const buttonTelemetry = useButtonTelemetry();
  const deviceInformation = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const hideTemplateButton = useFeatureFlag(FeatureFlag.NewPlayScreenWithoutTemplateButton);
  const navigateToCreateNewWorld = useNavigateToCreateNewWorld(); // The copy for the button leading to templates says "Worlds by Creators"
  // These worlds are templates and referred to as such in the code
  // Phrasing is to make it easier for players to understand what the templates are

  const navigateToCreateFromTemplate = useNavigateToCreateFromTemplate();
  const importWorld = (0,react_facet_src.useFacetCallback)(({
    importWorld
  }) => () => {
    buttonTelemetry({
      button: 'ImportWorld',
      screen: 'Play'
    });
    importWorld.run();
  }, [buttonTelemetry], [worldTransfer]);
  const isDesktopPlatform = (0,react_facet_src.useFacetMap)(facet => isWindowsPlatform(facet.platform) && facet.arvrPlatform == ARVRPlatform.ARVR_None, [], [deviceInformation]);
  const navigationButtons = (0,react_facet_src.useFacetMemo)(isDesktopPlatform => {
    const buttons = hideTemplateButton ? [{
      variant: 'primary',
      text: t('.createNewWorld'),
      narrationSuffix: t('.createNewWorldNarration'),
      onClick: navigateToCreateNewWorld
    }] : [{
      variant: 'primary',
      text: t('.createNewWorld'),
      narrationSuffix: t('.createNewWorldNarration'),
      onClick: navigateToCreateNewWorld
    }, {
      variant: 'secondary',
      text: t('.createWorldByCreator'),
      narrationSuffix: t('.createWorldByCreatorNarration'),
      onClick: navigateToCreateFromTemplate
    }];

    if (isDesktopPlatform) {
      const importWorldButton = {
        text: t('.importWorld'),
        variant: 'secondary',
        narrationSuffix: t('.importWorldNarration'),
        onClick: importWorld,
        imgSrc: import_world_icon_namespaceObject
      };
      buttons.push(importWorldButton);
    }

    return buttons;
  }, [hideTemplateButton, navigateToCreateFromTemplate, navigateToCreateNewWorld, t, importWorld], [isDesktopPlatform]);
  return navigationButtons;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/hooks/useOnWorldImportFinishClearResult.ts


/**
 * This hook is designed to manage and reset the import world result when the import operation
 * successfully concludes or is manually interrupted by the user.
 *
 * By invoking this hook, the state of world import operation is monitored. When the import operation
 * concludes with a 'Success' or 'InterruptedByUser' status, the 'clear' function is triggered,
 * effectively resetting the world import action result.
 */

function useOnWorldImportFinishClearResult() {
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const clearImportWorldAction = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.importWorld.clear();
  }, [], [worldTransfer]);
  const importWorldResult = (0,react_facet_src.useFacetMap)(facet => facet.importWorld.result, [], [worldTransfer]);
  (0,react_facet_src.useFacetEffect)(result => {
    if (result === WorldTransferResult.Success || WorldTransferResult.InterruptedByUser) {
      clearImportWorldAction();
    }
  }, [clearImportWorldAction], [importWorldResult]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/AllWorldsTab.tsx


















function AllWorldsTab() {
  const {
    t: banner
  } = useLocalization_useLocalization('PlayScreen.storageBanner');
  const navigationButtons = useNavigationButtons();
  const alternativeStorageConfig = useAlternativeStorageConfig();
  const scrollRef = useResetScrollOnTabChange();
  const localWorlds = useLocalWorlds();
  useOnWorldImportFinishClearResult();
  const AllWorlds = useWindowBreakpoint_useWindowBreakpoint(102) === 'narrow' ? WorldList : WorldGrid_WorldGrid;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: localWorlds.isEmpty
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true,
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingDelay, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    })
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: alternativeStorageConfig.alternativeStorageHasWorlds
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(StorageBanner, {
    text: banner('.changeStorageText'),
    link: banner('.changeStorageLink')
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyState, {
    navigationButtons: navigationButtons,
    gamepadIndex: 0
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(DesignPreview, {
    tab: "all",
    gamepadIndex: 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: localWorlds.isEmpty,
    condition: false
  }, /*#__PURE__*/react.createElement(AllWorlds, {
    worlds: localWorlds.data,
    gamepadIndex: 0,
    Header: () => /*#__PURE__*/react.createElement(AllWorldsButtonHeader, {
      navigationButtons: navigationButtons,
      showOldWorldsNotification: alternativeStorageConfig.possiblyOldWorldsAvailable,
      showHiddenLocalWorldsWarning: alternativeStorageConfig.worldsOnBothStoragesUsingAlternativeStorage,
      showHiddenAlternativeStorageWorldsWarning: alternativeStorageConfig.worldsOnBothStoragesUsingRegularStorage,
      showUsingExternalStorageWarning: alternativeStorageConfig.worldsUsingAlternativeStorage
    }),
    Footer: ({
      gamepadIndex
    }) => /*#__PURE__*/react.createElement(DesignPreview, {
      tab: "all",
      gamepadIndex: gamepadIndex
    }),
    scrollViewRef: scrollRef
  })), /*#__PURE__*/react.createElement(Modals, null), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }));
}
/**
 * Returns a ref to be used as a scrolling element, and resets the
 * scroll position of that element whenever the route becomes inactive.
 * @returns ref for scrolling element
 */

function useResetScrollOnTabChange() {
  const scrollViewRef = (0,react.useRef)(null);
  (0,react_facet_src.useFacetLayoutEffect)(active => {
    // When we switch to another tab we'll reset the scroll position.
    if (!active && scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [], [useRouteActive()]);
  return scrollViewRef;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/under-construction-art-realms-cropped.png
const under_construction_art_realms_cropped_namespaceObject = __webpack_require__.p + "assets/under-construction-art-realms-cropped-6c23e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/UnderConstructionMessage.tsx














function UnderConstructionMessage_UnderConstructionMessage() {
  return /*#__PURE__*/react.createElement(CustomUnderConstructionMessage, {
    tab: "servers",
    imgSrc: under_construction_art_cropped_namespaceObject,
    imgClassNarrow: UnderConstructionMessage.emptyStateArt,
    imgClassWide: UnderConstructionMessage.emptyStateArtBig
  });
}
function UnderConstructionMessageRealms() {
  const buildSettings = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const isRealmsFeatureFlagEnabled = useFeatureFlag(FeatureFlag.HasRealmsEnabled);
  const isPreviewRealmsAvailableOnBuild = (0,react_facet_src.useFacetMap)(buildSettings => buildSettings.isPreviewBuild && isRealmsFeatureFlagEnabled, [isRealmsFeatureFlagEnabled], [buildSettings]); // We branch and do a maybe check, because the shared facets might
  // not be available if the feature flag isn't enabled. Even if it
  // is available, we might still want to show them the unavailable
  // message because they have no realms (see ADO:1046074 for more info)

  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPreviewRealmsAvailableOnBuild
  }, /*#__PURE__*/react.createElement(UnderConstructionMessageRealmsMaybeAvailable, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPreviewRealmsAvailableOnBuild,
    condition: false
  }, /*#__PURE__*/react.createElement(UnderConstructionMessageRealmsUnavailable, null)));
}

function UnderConstructionMessageRealmsMaybeAvailable() {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const realmsList = (0,react_facet_src.useSharedFacet)(realmsListFacet);
  const unpairedRealmsList = (0,react_facet_src.useSharedFacet)(unpairedRealmsListFacet);
  const isRealmsLoading = (0,react_facet_src.useFacetMap)((realmsList, unpairedRealmsList) => realmsList.isLoading || unpairedRealmsList.isLoading, [], [realmsList, unpairedRealmsList]);
  const text = (0,react_facet_src.useFacetMap)((realmsList, unpairedRealmsList, isRealmsLoading) => isRealmsLoading ? '' : realmsList.realms.length == 0 && unpairedRealmsList.realms.length > 0 ? t('.underConstructionMessageRealmsAvailable') : t('.underConstructionMessageRealmsUnavailable'), [t], [realmsList, unpairedRealmsList, isRealmsLoading]);
  return /*#__PURE__*/react.createElement(CustomUnderConstructionMessage, {
    isLoading: isRealmsLoading,
    tab: "all",
    imgSrc: under_construction_art_realms_cropped_namespaceObject,
    imgClassNarrow: UnderConstructionMessage.emptyStateRealmsArt,
    imgClassWide: UnderConstructionMessage.emptyStateRealmsArtBig,
    text: text
  });
}

function UnderConstructionMessageRealmsUnavailable() {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  return /*#__PURE__*/react.createElement(CustomUnderConstructionMessage, {
    tab: "all",
    imgSrc: under_construction_art_realms_cropped_namespaceObject,
    imgClassNarrow: UnderConstructionMessage.emptyStateRealmsArt,
    imgClassWide: UnderConstructionMessage.emptyStateRealmsArtBig,
    text: t('.underConstructionMessageRealmsUnavailable')
  });
}

function CustomUnderConstructionMessage({
  imgSrc,
  imgClassNarrow,
  imgClassWide,
  tab,
  text,
  isLoading
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const openFeedbackPage = useOpenFeedbackPage();
  const optOut = useOptOut(tab); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: 8,
    narrow: 6,
    width: 260
  });
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true,
    loading: isLoading
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.underConstructionTitle'),
    text: text !== null && text !== void 0 ? text : t('.underConstructionMessage'),
    imgSrc: imgSrc,
    imgClass: narrowImage ? imgClassNarrow : imgClassWide,
    buttons: [{
      imgSrc: external_link_namespaceObject,
      text: t('.feedbackButton'),
      onClick: openFeedbackPage
    }, {
      text: t('.optOutButton'),
      onClick: optOut
    }]
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  })), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Realms/hooks/useNavigationButtons.ts




function useNavigationButtons_noop() {}

function useNavigationButtons_useNavigationButtons() {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.RealmsTab.ButtonHeader');
  const routerAPI = hooks_useRouterAPI();
  const navigationButtons = (0,react_facet_src.useFacetWrap)([{
    variant: 'primary',
    text: t('.addRealm'),
    onClick: () => routerAPI.push('/realms-pdp')
  }, {
    variant: 'secondary',
    text: t('.joinRealm'),
    onClick: useNavigationButtons_noop
  }, {
    variant: 'secondary',
    text: t('.invitations', ['0']),
    onClick: useNavigationButtons_noop
  }]);
  return navigationButtons;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Realms/RealmsTab.tsx










function RealmsTabContent() {
  const navigationButtons = useNavigationButtons_useNavigationButtons();
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(ButtonHeader_ButtonHeader, {
    buttons: navigationButtons,
    gamepadIndex: 0
  }));
}

function RealmsTab() {
  const isUnderConstruction = !useFeatureFlag(FeatureFlag.PlayScreenRealmsTab);
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, isUnderConstruction ? /*#__PURE__*/react.createElement(UnderConstructionMessageRealms, null) : /*#__PURE__*/react.createElement(RealmsTabContent, null));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/plus-icon.png
const plus_icon_namespaceObject = __webpack_require__.p + "assets/plus-icon-432ff.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/DisclaimerModal.tsx







const DisclaimerModal = registerModal(({
  onProceed
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.disclaimerModal');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-disclaimer-modal';
  const hideModal = useHideModal();
  const [doNotShowAgain, setDoNotShowAgain] = (0,react_facet_src.useFacetState)(false);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const onPrimaryAction = (0,react_facet_src.useFacetCallback)((doNotShowAgain, optionsSharedFacet) => () => {
    if (doNotShowAgain) {
      optionsSharedFacet.doNotShowMultiplayerIpSafetyWarning = true;
    }

    onProceed();
    hideModal();
  }, [onProceed, hideModal], [doNotShowAgain, optionsSharedFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: doNotShowAgain,
      onChange: setDoNotShowAgain,
      title: t('.checkbox')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "primary",
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.action'),
    onClick: onPrimaryAction
  }, t('.action')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.back'),
    onClick: hideModal
  }, t('.back'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerSideMenu/ServerSideMenu.tsx












function ServerSideMenu_SideMenuItem({
  item,
  gamepadIndex
}) {
  const historyAPI = hooks_useRouterAPI();
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab');
  const label = (0,react_facet_src.useFacetMap)(item => item.label, [], [item]);
  const value = (0,react_facet_src.useFacetMap)(item => item.value, [], [item]);
  const hasImage = (0,react_facet_src.useFacetMap)(item => Boolean(item.image), [], [item]);
  const image = (0,react_facet_src.useFacetMap)(item => item.image != null ? item.image : react_facet_src.NO_VALUE, [], [item]);
  const selected = (0,react_facet_src.useFacetMap)((value, networkDetailsFacet) => value === networkDetailsFacet.networkDetails.id, [], [value, networkDetailsFacet]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ListItem, {
    narrationText: label,
    selected: selected,
    value: value,
    onSelect: (0,react_facet_src.useFacetCallback)(item => () => {
      historyAPI.replace(`/play/servers/${item.value}/${item.type}`);
    }, [historyAPI], [item]),
    gamepadIndex: gamepadIndex,
    inputLegend: t('.sideMenuInputLegend')
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasImage
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemCell, null, /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
    iconSrc: image,
    selected: selected
  })))), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemMain, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, label))));
}

function ServerSideMenu() {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab');
  const thirdPartyWorldListSharedFacet = (0,react_facet_src.useSharedFacet)(thirdPartyWorldListFacet_thirdPartyWorldListFacet);
  const externalWorldListSharedFacet = (0,react_facet_src.useSharedFacet)(externalServerWorldListFacet_externalServerWorldListFacet);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const showDisclaimerModal = DisclaimerModal.useShowModal();
  const addServerLabel = t('.addServer');
  const historyAPI = hooks_useRouterAPI();
  const doNotShowMultiplayerOnlineSafetyWarning = (0,react_facet_src.useFacetMap)(optionsSharedFacet => optionsSharedFacet.doNotShowMultiplayerIpSafetyWarning, [], [optionsSharedFacet]);
  const onAddServer = (0,react_facet_src.useFacetCallback)(doNotShowWarning => () => {
    if (doNotShowWarning) {
      historyAPI.push('/servers/alter');
    } else {
      showDisclaimerModal({
        onProceed: () => historyAPI.push('/servers/alter')
      });
    }
  }, [showDisclaimerModal, historyAPI], [doNotShowMultiplayerOnlineSafetyWarning]);
  const mappedThirdPartyServerList = (0,react_facet_src.useFacetMap)(thirdPartyWorldListSharedFacet => {
    return thirdPartyWorldListSharedFacet.thirdPartyWorlds.map(thirdPartyWorld => ({
      label: thirdPartyWorld.name,
      value: thirdPartyWorld.id,
      image: thirdPartyWorld.image,
      type: types_NetworkWorldType.thirdParty
    }));
  }, [], [thirdPartyWorldListSharedFacet]);
  const featuredServersLabel = (0,react_facet_src.useFacetMap)(facet => t('.featuredServer', [facet.thirdPartyWorlds.length.toString()]), [t], [thirdPartyWorldListSharedFacet]);
  const mappedExternalServerList = (0,react_facet_src.useFacetMap)(externalWorldListSharedFacet => {
    return externalWorldListSharedFacet.externalServerWorlds.map(externalServerWorld => ({
      label: externalServerWorld.name,
      value: externalServerWorld.id,
      type: types_NetworkWorldType.external
    }));
  }, [], [externalWorldListSharedFacet]);
  const externalServersLabel = (0,react_facet_src.useFacetMap)(facet => t('.externalServer', [facet.externalServerWorlds.length.toString()]), [t], [externalWorldListSharedFacet]);
  const hasExternalServer = (0,react_facet_src.useFacetMap)(facet => facet.externalServerWorlds.length > 0, [], [externalWorldListSharedFacet]);
  const otherServersInitialGamepadIndex = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(facet => facet.thirdPartyWorlds.length + 1, [], [thirdPartyWorldListSharedFacet]));
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    hideInputLegendSpace: true
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: onAddServer,
    imgSrc: plus_icon_namespaceObject,
    inputLegend: addServerLabel,
    variant: "secondary"
  }, addServerLabel)), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Divider, {
    label: /*#__PURE__*/react.createElement("fast-text", {
      text: featuredServersLabel
    })
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemList, {
    initialGamepadIndex: 1,
    items: mappedThirdPartyServerList,
    renderItem: ServerSideMenu_SideMenuItem
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasExternalServer
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Divider, {
    label: /*#__PURE__*/react.createElement("fast-text", {
      text: externalServersLabel
    })
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemList, {
    initialGamepadIndex: otherServersInitialGamepadIndex === react_facet_src.NO_VALUE ? 0 : otherServersInitialGamepadIndex,
    items: mappedExternalServerList,
    renderItem: ServerSideMenu_SideMenuItem
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerDescription/ServerDescription.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ServerDescription = ({"thirdPartyHeader":"Aj0gS","serverDescriptionImage":"KqFKC","wrapper":"UUeAS","serverInformationComponent":"CMuWR"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerActivity/ServerActivity.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ServerActivity = ({"activityContainer":"F5nsF","imageContainer":"PRLig","textContainer":"DsnFG"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerActivity/ServerActivity.tsx






function ServerActivity_ServerActivity({
  activity
}) {
  const activityTitle = (0,react_facet_src.useFacetMap)(activity => activity.title, [], [activity]);
  const activitySubtitle = (0,react_facet_src.useFacetMap)(activity => activity.subtitle, [], [activity]);
  const activityDescription = (0,react_facet_src.useFacetMap)(activity => activity.description, [], [activity]);
  const activityImage = (0,react_facet_src.useFacetMap)(activity => activity.imagePath, [], [activity]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: ServerActivity.activityContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: ServerActivity.imageContainer
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    aspectRatio: Image_Image_Image.AspectRatio["1:1"],
    src: activityImage
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement("div", {
    className: ServerActivity.textContainer
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, activityTitle), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    variant: "dimmer"
  }, activitySubtitle), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, activityDescription))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerNews.tsx







function ServerNews({
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab');
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const title = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.newsTitle, [], [networkDetailsFacet]);
  const description = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.newsDescription, [], [networkDetailsFacet]);
  const newsNarration = (0,react_facet_src.useFacetMap)((title, description) => {
    return `${t('.newsTitle')} . ${title} . ${description}`;
  }, [t], [title, description]);
  const isNarrationEnabled = useNarrationEnabled();
  return /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    role: "neutral80",
    focusable: isNarrationEnabled,
    gamepadIndex: gamepadIndex,
    narrationText: newsNarration
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.newsTitle')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, title), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(PanelDescription_PanelDescription, null, description), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ExternalServerDescription/ExternalServerDescription.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ExternalServerDescription = ({"buttonBorder":"icxbw","externalButtons":"BLVBU"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPanel/ServerPanel.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ServerPanel = ({"serverButton":"ccXBo","serverIcons":"XmeST","serverIconsNarrow":"_4N24","serverPanel":"ZpESj"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayer/images/playerImage.png
const playerImage_namespaceObject = __webpack_require__.p + "assets/playerImage-3978b.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayer/IconPlayer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconPlayer = ({"iconPlayer":"k3Gz1"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconPlayer/IconPlayer.tsx
function IconPlayer_extends() { IconPlayer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconPlayer_extends.apply(this, arguments); }

function IconPlayer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconPlayer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconPlayer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconPlayer_IconPlayer = (_ref) => {
  let {
    className
  } = _ref,
      props = IconPlayer_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconPlayer.iconPlayer, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconPlayer_extends({}, props, {
    className: classNames,
    src: playerImage_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerCapacity/ServerCapacity.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ServerCapacity = ({"container":"mSFBx"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerCapacity/ServerCapacity.tsx







function ServerCapacity_ServerCapacity({
  playerCount,
  maximumCapacity
}) {
  const serverIsFull = (0,react_facet_src.useFacetMap)((playerCount, maximumCapacity) => playerCount !== 0 && playerCount === maximumCapacity, [], [playerCount, maximumCapacity]);
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverCapacity');
  return /*#__PURE__*/react.createElement("div", {
    className: ServerCapacity.container
  }, /*#__PURE__*/react.createElement(IconPlayer_IconPlayer, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, playerCount), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: serverIsFull
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: "destructiveTint"
  }, t('.fullLabel')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/JoinServerModal.tsx







const JoinServerModal = registerModal(({
  joinServer,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.joinServerModal');
  const [doNotShowAgain, setDoNotShowAgain] = (0,react_facet_src.useFacetState)(false);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const handleProceed = (0,react_facet_src.useFacetCallback)((optionsSharedFacet, doNotShowAgain) => () => {
    if (doNotShowAgain) {
      optionsSharedFacet.doNotShowMultiplayerOnlineSafetyWarning = true;
    }

    joinServer();
    onClose();
  }, [joinServer, onClose], [optionsSharedFacet, doNotShowAgain]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.body'),
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: doNotShowAgain,
      onChange: setDoNotShowAgain,
      title: t('.checkbox')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.proceed'),
    variant: "primary",
    delayedClick: true,
    onClick: handleProceed
  }, t('.proceed')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    variant: "secondary",
    onClick: onClose
  }, t('.cancel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Modals/JoinServerErrorModal.tsx







// TODO: add translations from the UX team after they have done them
// we display generic message for now
function getTranslationKey(errorName) {
  switch (errorName) {
    case JoinServerWorldResult.InvalidUserError:
    case JoinServerWorldResult.NoInternetError:
    case JoinServerWorldResult.UserNeedsToBeSignedInError:
    case JoinServerWorldResult.BlockedByPlatformError:
    case JoinServerWorldResult.BlockedByXBLError:
    case JoinServerWorldResult.BlockedByVersionError:
    case JoinServerWorldResult.UserBannedError:
    case JoinServerWorldResult.ThirdPartyBadIPError:
    case JoinServerWorldResult.ThirdPartyNoServerOrServerLockedError:
    case JoinServerWorldResult.UnknownError:
    default:
      return '.UnknownError';
  }
}

const JoinServerErrorModal = registerModal(({
  onClose
}) => {
  const networkJoinerFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const [joinServerError, setJoinServerError] = (0,react_facet_src.useFacetState)(undefined);
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.joinServerErrorModal');
  const thirdPartyJoinerResult = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinThirdPartyServerResult, [], [networkJoinerFacet]);
  const externalServerJoinerResult = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinExternalServerResult, [], [networkJoinerFacet]);
  (0,react_facet_src.useFacetEffect)((thirdPartyJoinerResult, externalServerJoinerResult) => {
    const isThirdPartyServerError = thirdPartyJoinerResult != null && thirdPartyJoinerResult !== JoinServerWorldResult.OK;
    const isExternalServerError = externalServerJoinerResult != null && externalServerJoinerResult !== JoinServerWorldResult.OK;

    if (isThirdPartyServerError || isExternalServerError) {
      setJoinServerError(isThirdPartyServerError ? thirdPartyJoinerResult : externalServerJoinerResult);
    }
  }, [setJoinServerError], [thirdPartyJoinerResult, externalServerJoinerResult]);
  const headerKey = (0,react_facet_src.useFacetMap)(error => t(`${getTranslationKey(error)}.title`), [t], [joinServerError]);
  const textKey = (0,react_facet_src.useFacetMap)(error => t(`${getTranslationKey(error)}.message`), [t], [joinServerError]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, headerKey), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: textKey,
    center: true
  }, textKey)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    variant: "secondary",
    onClick: onClose
  }, t('.cancel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPing/ServerPing.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ServerPing = ({"serverPing":"J_ke4"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/pingAnimation.png
const pingAnimation_namespaceObject = __webpack_require__.p + "assets/pingAnimation-4d7a0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPing/PingAnimation.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PingAnimation = ({"loadingPingAnimation":"JEokF"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPing/PingAnimation.tsx




const PingAnimation_PingAnimation = () => /*#__PURE__*/react.createElement("div", {
  className: PingAnimation.loadingPingAnimation
}, /*#__PURE__*/react.createElement(Spritesheet_Spritesheet, {
  src: pingAnimation_namespaceObject,
  frames: 6,
  duration: 700,
  width: 11.2,
  height: 2,
  repeat: 'infinite',
  imageRendering: 'pixelated'
}));
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPing/ServerPing.tsx










const ServerPing_getIcon = type => {
  switch (type) {
    case WorldPingStatus.Low:
      return /*#__PURE__*/react.createElement(IconPingGreen_IconPingGreen, null);

    case WorldPingStatus.High:
      return /*#__PURE__*/react.createElement(IconPingRed_IconPingRed, null);

    case WorldPingStatus.Medium:
      return /*#__PURE__*/react.createElement(IconPingYellow_IconPingYellow, null);

    default:
      return /*#__PURE__*/react.createElement(PingAnimation_PingAnimation, null);
  }
};

function ServerPing_ServerPing({
  pingStatus
}) {
  const pingLabel = useLabel(pingStatus);
  return /*#__PURE__*/react.createElement("div", {
    className: ServerPing.serverPing
  }, /*#__PURE__*/react.createElement(Unwrap, {
    data: pingStatus,
    children: ServerPing_getIcon
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "dimmer"
  }, pingLabel));
}

const useLabel = pingStatus => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.ServerPing');
  return (0,react_facet_src.useFacetMap)(pingStatus => {
    switch (pingStatus) {
      case WorldPingStatus.Low:
        return t('.lowPing');

      case WorldPingStatus.Medium:
        return t('.mediumPing');

      case WorldPingStatus.High:
        return t('.highPing');

      default:
        return t('.loadingPing');
    }
  }, [t], [pingStatus]);
};

ServerPing_ServerPing.useLabel = useLabel;
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerPanel/ServerPanel.tsx














function ServerPanel_ServerPanel() {
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const networkJoinerFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const [isShowingJoinServerModal, setIsShowingJoinServerModal] = (0,react_facet_src.useFacetState)(false);
  const [isShowingJoinServerErrorModal, setIsShowingJoinServerErrorModal] = (0,react_facet_src.useFacetState)(false);
  const semanticColors = hooks_useSemanticColors('neutral100');
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab');
  const isNarrow = useWindowBreakpoint_useWindowBreakpoint() === 'narrow';
  const playerCount = (0,react_facet_src.useFacetMap)(networkDetailsFacet => networkDetailsFacet.networkDetails.playerCount, [], [networkDetailsFacet]);
  const maximumCapacity = (0,react_facet_src.useFacetMap)(networkDetailsFacet => networkDetailsFacet.networkDetails.capacity, [], [networkDetailsFacet]);
  const doNotShowMultiplayerOnlineSafetyWarning = (0,react_facet_src.useFacetMap)(optionsSharedFacet => optionsSharedFacet.doNotShowMultiplayerOnlineSafetyWarning, [], [optionsSharedFacet]);
  const thirdPartyJoinerProgress = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinThirdPartyServerProgress, [], [networkJoinerFacet]);
  const externalServerJoinerProgress = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinExternalServerProgress, [], [networkJoinerFacet]);
  const thirdPartyJoinerResult = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinThirdPartyServerResult, [], [networkJoinerFacet]);
  const externalServerJoinerResult = (0,react_facet_src.useFacetMap)(networkJoinerFacet => networkJoinerFacet.joinExternalServerResult, [], [networkJoinerFacet]);
  (0,react_facet_src.useFacetEffect)((thirdPartyJoinerResult, externalServerJoinerResult) => {
    const isThirdPartyServerError = thirdPartyJoinerResult != null && thirdPartyJoinerResult !== JoinServerWorldResult.OK;
    const isExternalServerError = externalServerJoinerResult != null && externalServerJoinerResult !== JoinServerWorldResult.OK;

    if (isThirdPartyServerError || isExternalServerError) {
      setIsShowingJoinServerErrorModal(true);
      return;
    }
  }, [setIsShowingJoinServerErrorModal], [thirdPartyJoinerResult, externalServerJoinerResult]);
  const closeJoinServerErrorModal = (0,react_facet_src.useFacetCallback)(networkJoinerFacet => () => {
    networkJoinerFacet.clearJoinThirdPartyServerState();
    networkJoinerFacet.clearJoinExternalServerState();
    setIsShowingJoinServerErrorModal(false);
  }, [setIsShowingJoinServerErrorModal], [networkJoinerFacet]);
  const joinThirdPartyServer = useFacetCoroutine(networkJoinerFacet => function* (serverId) {
    networkJoinerFacet.joinThirdPartyServer(serverId);
    yield thirdPartyJoinerProgress;
    networkJoinerFacet.clearJoinThirdPartyServerState();
  }, [thirdPartyJoinerProgress], [networkJoinerFacet]);
  const joinExternalServer = useFacetCoroutine(networkJoinerFacet => function* (serverId) {
    networkJoinerFacet.joinExternalServer(serverId);
    yield externalServerJoinerProgress;
    networkJoinerFacet.clearJoinExternalServerState();
  }, [externalServerJoinerProgress], [networkJoinerFacet]);
  const joinServer = (0,react_facet_src.useFacetCallback)(networkDetailsFacet => () => {
    if (networkDetailsFacet.networkDetails.type === types_NetworkWorldType.thirdParty) {
      joinThirdPartyServer(networkDetailsFacet.networkDetails.id);
    }

    if (networkDetailsFacet.networkDetails.type === types_NetworkWorldType.external) {
      joinExternalServer(networkDetailsFacet.networkDetails.id);
    }
  }, [joinExternalServer, joinThirdPartyServer], [networkDetailsFacet]);
  const onPlay = (0,react_facet_src.useFacetCallback)(doNotShowWarning => () => {
    if (doNotShowWarning) {
      joinServer();
    } else {
      setIsShowingJoinServerModal(true);
    }
  }, [joinServer, setIsShowingJoinServerModal], [doNotShowMultiplayerOnlineSafetyWarning]);
  const pingStatus = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.pingStatus, [], [networkDetailsFacet]);
  const isPingHigh = (0,react_facet_src.useFacetMap)(status => status === WorldPingStatus.High, [], [pingStatus]);
  const onPlayNarrationSuffix = (0,react_facet_src.useFacetMap)((networkDetails, pingStatus) => {
    if (networkDetails.networkDetails.type === types_NetworkWorldType.external) {
      const playerCount = networkDetails.networkDetails.playerCount;
      return getNarrationSuffixTranslation(pingStatus, playerCount, t);
    }

    return t('.PlaySuffix');
  }, [t], [networkDetailsFacet, pingStatus]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ServerPanel.serverPanel, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: isNarrow ? ServerPanel.serverIconsNarrow : ServerPanel.serverIcons
  }, /*#__PURE__*/react.createElement(ServerPing_ServerPing, {
    pingStatus: pingStatus
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: isNarrow ? 1 : 6
  }), /*#__PURE__*/react.createElement(ServerCapacity_ServerCapacity, {
    playerCount: playerCount,
    maximumCapacity: maximumCapacity
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: ServerPanel.serverButton
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.Play'),
    variant: "hero",
    delayedClick: true,
    horizontal: true,
    onClick: onPlay,
    narrationSuffix: onPlayNarrationSuffix
  }, t('.Play'))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingJoinServerModal
  }, /*#__PURE__*/react.createElement(JoinServerModal.Component, {
    joinServer: joinServer,
    onClose: () => setIsShowingJoinServerModal(false)
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingJoinServerErrorModal
  }, /*#__PURE__*/react.createElement(JoinServerErrorModal.Component, {
    onClose: closeJoinServerErrorModal
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPingHigh
  }, /*#__PURE__*/react.createElement(Banner_Banner, {
    role: "noticeTint",
    narrationId: "serverInformation:highPingWarning"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, t('.highPingWarning')))));
}

function getNarrationSuffixTranslation(pingStatus, playerCount, t) {
  function getFirstSentence() {
    switch (pingStatus) {
      case WorldPingStatus.Low:
        return t('.PlaySuffixExtServerLowPing');

      case WorldPingStatus.Medium:
        return t('.PlaySuffixExtServerMediumPing');

      case WorldPingStatus.High:
        return t('.PlaySuffixExtServerHighPing');

      default:
        return t('.PlaySuffixExtServerUnavailablePing');
    }
  }

  const secondSentence = playerCount === 1 ? t('.PlaySuffixExtServerOnePlayer', [String(playerCount)]) : t('.PlaySuffixExtServerManyPlayers', [String(playerCount)]);
  return `${getFirstSentence()} ${secondSentence}`;
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ExternalServerDescription/ExternalServerDescription.tsx















function ExternalServerDescription_ExternalServerDescription() {
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const showDisclaimerModal = DisclaimerModal.useShowModal();
  const doNotShowMultiplayerOnlineSafetyWarning = (0,react_facet_src.useFacetMap)(optionsSharedFacet => optionsSharedFacet.doNotShowMultiplayerIpSafetyWarning, [], [optionsSharedFacet]);
  const networkDetails = (0,react_facet_src.useFacetMap)(networkDetailsFacet => networkDetailsFacet.networkDetails, [], [networkDetailsFacet]);
  const historyAPI = hooks_useRouterAPI();
  const serverDetailsItems = (0,react_facet_src.useFacetMap)(networkDetails => {
    return [{
      fieldData: networkDetails.name,
      fieldName: 'name'
    }, {
      fieldData: networkDetails.address,
      fieldName: 'address'
    }, {
      fieldData: networkDetails.port.toString(),
      fieldName: 'port'
    }];
  }, [], [networkDetails]);
  const serverID = (0,react_facet_src.useFacetMap)(networkDetails => networkDetails.id, [], [networkDetails]);
  const goToEditServer = (0,react_facet_src.useFacetCallback)(serverID => () => {
    historyAPI.push(`/servers/alter/${serverID}`);
  }, [historyAPI], [serverID]);
  const handleOnClick = (0,react_facet_src.useFacetCallback)(doNotShowWarning => () => {
    if (doNotShowWarning) {
      goToEditServer();
    } else {
      showDisclaimerModal({
        onProceed: goToEditServer
      });
    }
  }, [showDisclaimerModal, goToEditServer], [doNotShowMultiplayerOnlineSafetyWarning]);
  const isNarrow = useWindowBreakpoint_useWindowBreakpoint() === 'narrow';
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(FlatList_FlatList, {
    header: /*#__PURE__*/react.createElement(ServerPanel_ServerPanel, null),
    data: serverDetailsItems,
    renderItem: ({
      itemFacet,
      index
    }) => ServerDetailsItem({
      itemFacet,
      index,
      gamepadIndexOverflow: 1
    }),
    gamepadIndex: 1,
    footer: !isNarrow && /*#__PURE__*/react.createElement(ExternalServerDescription_Buttons, {
      handleOnClick: handleOnClick
    })
  }), isNarrow && /*#__PURE__*/react.createElement(ExternalServerDescription_Buttons, {
    handleOnClick: handleOnClick
  }));
}

function ServerDetailsItem({
  itemFacet,
  index,
  gamepadIndexOverflow
}) {
  const isNarrationEnabled = useNarrationEnabled();
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.externalServerDetails');
  const item = (0,react_facet_src.useFacetMap)(itemFacet => itemFacet.fieldData, [], [itemFacet]);
  const itemLabel = (0,react_facet_src.useFacetMap)(itemFacet => t(`.${itemFacet.fieldName.toLowerCase()}`), [t], [itemFacet]);
  const narrationText = (0,react_facet_src.useFacetMap)(itemFacet => t(`.${itemFacet.fieldName.toLowerCase()}`) + ' . ' + itemFacet.fieldData, [t], [itemFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    role: "neutral80",
    focusable: isNarrationEnabled,
    gamepadIndex: index + gamepadIndexOverflow,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, item), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, itemLabel)));
}

function ExternalServerDescription_Buttons({
  handleOnClick
}) {
  const semanticClassNamesButton = hooks_useSemanticColors('neutral');
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.externalServerDetails');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ExternalServerDescription.externalButtons, ExternalServerDescription.buttonBorder, semanticClassNamesButton.background.base, semanticClassNamesButton.border.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    left: false,
    right: false
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.editButton'),
    onClick: handleOnClick
  }, t('.editButton')));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/ServerDescription/ServerDescription.tsx


















function ServerDescription_ServerDescription({
  loading,
  scrollViewRef
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab');
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const serverActivity = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.activities, [], [networkDetailsFacet]);
  const hasActivities = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.activities.length > 0, [], [networkDetailsFacet]);
  const selectedIsExternal = (0,react_facet_src.useFacetMap)(networkDetailsFacet => networkDetailsFacet.networkDetails.type === types_NetworkWorldType.external, [], [networkDetailsFacet]);
  const hasNews = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.newsTitle != null || facet.networkDetails.newsTitle != '', [], [networkDetailsFacet]);
  const semanticColors = hooks_useSemanticColors('neutral80');
  const serverName = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.name, [], [networkDetailsFacet]);
  const narrationText = (0,react_facet_src.useFacetMap)(serverName => [serverName, t('.narrationScreen')].join(' . '), [t], [serverName]);
  const isNarrationEnabled = useNarrationEnabled();
  const activitiesNarration = (0,react_facet_src.useFacetMap)(facet => {
    const activityDetails = facet.networkDetails.activities.map((element, index) => {
      const enumeration = facet.networkDetails.activities.length > 1 ? t('.sectionEnumeration', [`${index + 1}`, `${facet.networkDetails.activities.length}`]) : null;
      return [element.title, element.subtitle, element.description, enumeration].filter(x => x).join(' . ');
    });
    return [t('.narrationTitleActivities'), ...activityDetails].join(' . ');
  }, [t], [networkDetailsFacet]);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const adaptiveSpacing = /*#__PURE__*/react.createElement(react.Fragment, null, breakpoint === 'narrow' && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), (breakpoint === 'desktop' || breakpoint === 'tablet') && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }));
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: loading
  }, adaptiveSpacing), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    loading: loading,
    innerRef: scrollViewRef
  }, adaptiveSpacing, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: selectedIsExternal,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationText
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ServerDescription.wrapper, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(ServerInformation, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasActivities
  }, /*#__PURE__*/react.createElement(Panel_Panel_Panel, {
    focusable: isNarrationEnabled,
    gamepadIndex: 0,
    role: "neutral80",
    narrationText: activitiesNarration
  }, /*#__PURE__*/react.createElement(PanelLabel_PanelLabel, null, t('.Activities')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: serverActivity
  }, activity => /*#__PURE__*/react.createElement(ServerActivity_ServerActivity, {
    activity: activity
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasNews
  }, /*#__PURE__*/react.createElement(ServerNews, {
    gamepadIndex: 1
  })))), /*#__PURE__*/react.createElement(DesignPreview, {
    tab: "servers",
    gamepadIndex: 2
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: selectedIsExternal,
    condition: true
  }, /*#__PURE__*/react.createElement(ExternalServerDescription_ExternalServerDescription, null))));
}

function ServerInformation() {
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const semanticColors = hooks_useSemanticColors('neutral80');
  const serverName = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.name, [], [networkDetailsFacet]);
  const backgroundImage = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.imagePath, [], [networkDetailsFacet]);
  const serverDescription = (0,react_facet_src.useFacetMap)(facet => facet.networkDetails.description, [], [networkDetailsFacet]);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ServerDescription.serverInformationComponent, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(ServerPanel_ServerPanel, null), /*#__PURE__*/react.createElement(Image_Image_Image, {
    aspectRatio: Image_Image_Image.AspectRatio["10:3"],
    src: backgroundImage,
    className: ServerDescription.serverDescriptionImage
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement("div", {
    className: ServerDescription.thirdPartyHeader
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, serverName), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, serverDescription), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/components/index.ts






;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/NotLoggedInWarning/NotLoggedInWarning.tsx







function NotLoggedInWarning({
  tab
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.notLoggedInWarning');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI], [userAccount]);
  const text = `${t('.message.' + tab)}`;
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Banner_Banner, {
    role: 'noticeTint',
    narrationId: "banner-message:not-login"
  }, /*#__PURE__*/react.createElement(Banner_Banner.Text, null, text), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Banner_Banner.Link, {
    onClick: signIn
  }, t('.loginLink'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/Servers/ServersTab.tsx














function ServersTab() {
  // While developing this screen we are showing the UnderConstructionMessage for the end user and the ServerTab for the dev builds
  const developerBuild = "publish" === 'release';
  const featureFlag = useFeatureFlag(SERVER_TAB_FEATURE_FLAG);
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const showBannedMessage = (0,react_facet_src.useFacetMap)(userAccount => userAccount.isBanned, [], [userAccount]);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const thirdPartyWorldListSharedFacet = (0,react_facet_src.useSharedFacet)(thirdPartyWorldListFacet_thirdPartyWorldListFacet);
  const networkDetailsFacet = (0,react_facet_src.useSharedFacet)(networkWorldDetailsFacet_networkWorldDetailsSharedFacet);
  const isOnline = (0,react_facet_src.useFacetMap)(deviceInformation => deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  const paramsFacet = hooks_useRouteParams();
  const serverId = (0,react_facet_src.useFacetMap)(paramsFacet => paramsFacet === null || paramsFacet === void 0 ? void 0 : paramsFacet.id, [], [paramsFacet]);
  const serverType = (0,react_facet_src.useFacetMap)(paramsFacet => paramsFacet === null || paramsFacet === void 0 ? void 0 : paramsFacet.type, [], [paramsFacet]);
  const shouldShowParentalPermissionMessage = (0,react_facet_src.useFacetMap)(userAccount => {
    return userAccount.isParentalPermissionRequiredForMultiplayer;
  }, [], [userAccount]);
  const hasPremiumNetworkAccess = (0,react_facet_src.useFacetMap)(userAccount => userAccount.hasPremiumNetworkAccess, [], [userAccount]);
  const defaultServerID = (0,react_facet_src.useFacetMap)(thirdPartyWorldListSharedFacet => thirdPartyWorldListSharedFacet.thirdPartyWorlds.length > 0 ? thirdPartyWorldListSharedFacet.thirdPartyWorlds[0].id : '', [], [thirdPartyWorldListSharedFacet]);
  const showSpinner = (0,react_facet_src.useFacetMap)(facet => {
    return !facet.hasLoadedDetails;
  }, [], [networkDetailsFacet]);
  const showNotLoggedBanner = (0,react_facet_src.useFacetMap)(userAccount => !userAccount.isLoggedInWithMicrosoftAccount, [], [userAccount]);
  const scrollViewRef = (0,react.useRef)(null);
  const updateServerDetails = (0,react_facet_src.useFacetCallback)(networkDetailsFacet => (id, type) => {
    networkDetailsFacet.loadNetworkWorldDetails(id, type);

    if (scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [], [networkDetailsFacet]);
  (0,react_facet_src.useFacetEffect)((defaultServerID, serverId, serverType) => {
    if (serverId == null || serverType == null) {
      updateServerDetails(defaultServerID, types_NetworkWorldType.thirdParty);
    } else {
      updateServerDetails(serverId, parseInt(serverType));
    }
  }, [updateServerDetails], [defaultServerID, serverId, serverType]);
  const tabContentState = (0,react_facet_src.useFacetMap)((shouldShowParentalPermissionMessage, hasPremiumNetworkAccess, isOnline, showBannedMessage) => {
    if (!(developerBuild && featureFlag)) return 'under-construction';
    if (showBannedMessage) return 'banned';
    if (!isOnline) return 'offline';
    if (shouldShowParentalPermissionMessage) return 'parental-permission';
    if (!hasPremiumNetworkAccess && isOnline) return 'playstation-missing-subscription';
    return 'server-details';
  }, [developerBuild, featureFlag], [shouldShowParentalPermissionMessage, hasPremiumNetworkAccess, isOnline, showBannedMessage]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNotLoggedBanner
  }, /*#__PURE__*/react.createElement(NotLoggedInWarning, {
    tab: "servers"
  })), /*#__PURE__*/react.createElement(Unwrap, {
    data: tabContentState
  }, tabContentState => {
    switch (tabContentState) {
      case 'banned':
        return /*#__PURE__*/react.createElement(BannedMessage_BannedMessage, null);

      case 'offline':
        return /*#__PURE__*/react.createElement(MessageScrollWrapper, null, /*#__PURE__*/react.createElement(NoInternetMessage_NoInternetMessage, {
          tab: "servers"
        }));

      case 'parental-permission':
        return /*#__PURE__*/react.createElement(MessageScrollWrapper, null, /*#__PURE__*/react.createElement(ParentalPermissionMessage_ParentalPermissionMessage, null));

      case 'playstation-missing-subscription':
        return /*#__PURE__*/react.createElement(MessageScrollWrapper, null, /*#__PURE__*/react.createElement(NoSubscriptionMessage_NoSubscriptionMessage, null));

      case 'server-details':
        return /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
          gamepadIndex: 0
        }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
          gamepadIndex: 0,
          wideSize: 4,
          narrowSize: 3
        }, /*#__PURE__*/react.createElement(ServerSideMenu, null)), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
          gamepadIndex: 1,
          wideSize: 8,
          narrowSize: 5
        }, /*#__PURE__*/react.createElement(ServerDescription_ServerDescription, {
          loading: showSpinner,
          scrollViewRef: scrollViewRef
        })));

      case 'under-construction':
      default:
        return /*#__PURE__*/react.createElement(UnderConstructionMessage_UnderConstructionMessage, null);
    }
  }));
}

function MessageScrollWrapper({
  children
}) {
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    floating: true
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), children);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/index.ts



;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_ServerTab.png
const UI_Menu_ServerTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_ServerTab-657bb.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_RealmsTab.png
const UI_Menu_RealmsTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_RealmsTab-93444.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab.png
const UI_Menu_WorldsTab_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab-8d953.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab_Alt01.png
const UI_Menu_WorldsTab_Alt01_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab_Alt01-bb1fa.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/images/UI_Menu_WorldsTab_Alt02.png
const UI_Menu_WorldsTab_Alt02_namespaceObject = __webpack_require__.p + "assets/UI_Menu_WorldsTab_Alt02-8a362.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/Modals/ImportWorldProgressModal.tsx








function ImportWorldProgressModal_noop() {}

const ImportWorldProgressModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.importWorldProgressModal');
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const isNarrationEnabled = useNarrationEnabled();
  const FOCUS_ALIAS_CONTENT = 'import-world-progress-content-focus';
  const FOCUS_ALIAS_CLOSE = 'import-world-progress-close-focus';
  const progress = (0,react_facet_src.useFacetMap)(worldTransfer => {
    var _worldTransfer$import;

    return (_worldTransfer$import = worldTransfer.importWorld.progress) !== null && _worldTransfer$import !== void 0 ? _worldTransfer$import : 0;
  }, [], [worldTransfer]);
  const importingLabel = t('.body'); // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the progress content and narrate that.

  const onClose = isNarrationEnabled ? undefined : ImportWorldProgressModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: isNarrationEnabled ? FOCUS_ALIAS_CONTENT : FOCUS_ALIAS_CLOSE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: importingLabel,
    center: true
  }, importingLabel), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Progress, {
    percentage: progress
  })));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/Tabs/AllWorlds/Modals/ImportWorldErrorModal.tsx






/**
 * Currently the worldTransferFacet can only throw the WorldTransferResult.FailureUnknown
 * error, which is a fairly ambiguous error.
 */

const ImportWorldErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.importWorldErrorModal');
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const FOCUS_ALIAS_BUTTON = 'import-world-error-button-focus';
  const onClose = (0,react_facet_src.useFacetCallback)(worldTransfer => () => {
    worldTransfer.importWorld.clear();
  }, [], [worldTransfer]);
  const closeLabel = t('.close');
  const bodyLabel = t('.unknownError.body');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: FOCUS_ALIAS_BUTTON
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.unknownError.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyLabel,
    center: true
  }, bodyLabel)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "secondary",
    inputLegend: closeLabel,
    onClick: onClose,
    gamepadAlias: FOCUS_ALIAS_BUTTON
  }, closeLabel)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/PlayScreenRouteModals.tsx






function PlayScreenRouteModals_Modals() {
  const worldTransfer = (0,react_facet_src.useSharedFacet)(worldTransferFacet);
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const showWorldImportProgressModal = (0,react_facet_src.useFacetMap)(worldTransfer => {
    var _worldTransfer$import;

    return worldTransfer.importWorld.state === types_AsyncStatefulFunctionState.InProgress && ((_worldTransfer$import = worldTransfer.importWorld.progress) !== null && _worldTransfer$import !== void 0 ? _worldTransfer$import : 0) > 0;
  }, [], [worldTransfer]);
  const showImportWorldErrorModal = (0,react_facet_src.useFacetMap)(worldTransfer => worldTransfer.importWorld.result != null && worldTransfer.importWorld.result !== WorldTransferResult.Success && worldTransfer.importWorld.result !== WorldTransferResult.InterruptedByUser, [], [worldTransfer]); // Download pack orogress.

  const showDownloadPackProgressModal = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadProgress != FacetTaskProgress.IDLE, [], [worldPackagesSharedFacet]);
  const packDownloadName = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadName, [], [worldPackagesSharedFacet]);
  const packDownloadPercentage = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadPercentage, [], [worldPackagesSharedFacet]);
  const isImportingPack = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadStatus === PackDownloadStatus.Importing, [], [worldPackagesSharedFacet]);
  const onDownloadPackCancel = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.cancelPackDownload();
  }, [], [worldPackagesSharedFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackProgressModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadProgressModal.Component, {
    title: packDownloadName,
    percentage: packDownloadPercentage,
    isImportingPack: isImportingPack,
    onCancel: onDownloadPackCancel
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showWorldImportProgressModal
  }, /*#__PURE__*/react.createElement(ImportWorldProgressModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showImportWorldErrorModal
  }, /*#__PURE__*/react.createElement(ImportWorldErrorModal.Component, null)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/PlayScreenRoute.tsx





















const CREATE_BUTTON_ALIAS = 'play-create-button';
const CREATE_TEMPLATE_BUTTON_ALIAS = 'play-template-create-button';
var PlayScreenTabs;

(function (PlayScreenTabs) {
  PlayScreenTabs["All"] = "all";
  PlayScreenTabs["Realms"] = "realms";
  PlayScreenTabs["Servers"] = "servers";
})(PlayScreenTabs || (PlayScreenTabs = {}));

const TabBarTelemetryEventNames = {
  [PlayScreenTabs.All]: 'AllWorldsTab',
  [PlayScreenTabs.Servers]: 'ServersTab',
  [PlayScreenTabs.Realms]: 'RealmsTab'
};
const PlayScreenRoute = () => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const parentRouteActive = useRouteActive();
  const playScreenHasBeenShown = (0,react.useRef)(false); // TODO: Remove this logic once the close button is available in the Banner component

  (0,react_facet_src.useFacetEffect)((parentRouteActive, notificationOptions) => {
    // Set the flag for showing the old worlds banner to false if it is true, the screen has been shown once and the route is no longer active
    if (!notificationOptions.doNotShowOldWorldsWarning && !parentRouteActive && playScreenHasBeenShown.current) notificationOptions.doNotShowOldWorldsWarning = true;
    if (parentRouteActive && !playScreenHasBeenShown.current) playScreenHasBeenShown.current = true;
  }, [], [parentRouteActive, (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet)]);
  return /*#__PURE__*/react.createElement(VanillaScreenLayout_VanillaScreenLayout, {
    debugDrawer: ['create-test-world'],
    friendsDrawer: true,
    gamepadAlias: "play-layout-content",
    screenAnalyticsId: "Play",
    title: t('.title')
  }, ({
    isAnyDrawerOpen
  }) => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(PlayScreenRoute_Tabs, {
    disableShortcuts: isAnyDrawerOpen
  }))), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'all',
    Component: AllWorldsTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'realms',
    Component: RealmsTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(RowWrapper_RowWrapper, {
    route: 'servers',
    Component: ServersTab,
    gamepadIndex: 1,
    wideSize: 12,
    narrowSize: 8
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null)), /*#__PURE__*/react.createElement(PlayScreenRouteModals_Modals, null)));
}; // 1/100 chance of showing the sunset icon for all worlds

const RANDOM_SUNSET_WORLD = Math.ceil(Math.random() * 100); // 1/9600 chance of showing the retro icon for all worlds

const RANDOM_RETRO_WORLD = Math.ceil(Math.random() * 9600);

function getWorldIcon() {
  if (RANDOM_RETRO_WORLD === 9600) return UI_Menu_WorldsTab_Alt02_namespaceObject;
  if (RANDOM_SUNSET_WORLD === 10) return UI_Menu_WorldsTab_Alt01_namespaceObject;else return UI_Menu_WorldsTab_namespaceObject;
}

const WORLD_ICON = getWorldIcon();

const PlayScreenRoute_Tabs = ({
  disableShortcuts
}) => {
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const tabBarNamespaceAlias = 'play-screen';
  const {
    t
  } = useLocalization_useLocalization('PlayScreen');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const buttonTelemetry = useButtonTelemetry();
  const enableGamepadShortcuts = (0,react_facet_src.useFacetMap)(x => !x, [], [disableShortcuts]);
  const onChangeTabCallback = (0,react.useCallback)(newValue => {
    buttonTelemetry({
      button: TabBarTelemetryEventNames[newValue],
      screen: 'Play'
    });
    historyAPI.replace(`/play/${newValue}`);
    setFocusedId(TabBar_TabBar_TabBar.getFocusAlias(tabBarNamespaceAlias, newValue));
  }, [historyAPI, setFocusedId, buttonTelemetry]);
  const localWorlds = useLocalWorlds();
  const friendsDrawerHint = (0,react_facet_src.useFacetMap)(device => {
    if (isWindowsPlatform(device.platform)) return [t('.narration.title'), t('.friendsDrawerShortcut', ['F'])].join(' . ');
    if (isTouchscreenPlatform(device.inputMethods)) return [t('.narration.title'), t('.mobileFriendsDrawerNarration')].join(' . ');
    return ``;
  }, [t], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const allWorldLabel = (0,react_facet_src.useFacetMap)(localWorlds => {
    return t('.allWorlds', [`${localWorlds.length}`]);
  }, [t], [localWorlds.data]);
  const tabs = (0,react_facet_src.useFacetMap)(allWorldLabel => [{
    label: allWorldLabel,
    value: PlayScreenTabs.All,
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: WORLD_ICON,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: WORLD_ICON,
        selected: false
      })
    }
  }, {
    label: t('.realms'),
    value: PlayScreenTabs.Realms,
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_RealmsTab_namespaceObject,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_RealmsTab_namespaceObject,
        selected: false
      })
    }
  }, {
    label: t('.servers'),
    value: PlayScreenTabs.Servers,
    icons: {
      selected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_ServerTab_namespaceObject,
        selected: true
      }),
      unselected: /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
        iconSrc: UI_Menu_ServerTab_namespaceObject,
        selected: false
      })
    }
  }], [t], [allWorldLabel]);
  return /*#__PURE__*/react.createElement(TabBar_TabBar_TabBar, {
    gamepadAliasNamespace: tabBarNamespaceAlias,
    gamepadIndex: 0,
    value: params.tab ? params.tab : PlayScreenTabs.All,
    onChange: onChangeTabCallback,
    tabs: tabs,
    enableGamepadShortcuts: enableGamepadShortcuts,
    narrationTitle: friendsDrawerHint
  });
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayScreenRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/TabType.tsx
const realmsStoriesTabValues = ['feed', 'members', 'timeline'];
let RealmsStoriesTabs;

(function (RealmsStoriesTabs) {
  RealmsStoriesTabs["Feed"] = "feed";
  RealmsStoriesTabs["Members"] = "members";
  RealmsStoriesTabs["Timeline"] = "timeline";
})(RealmsStoriesTabs || (RealmsStoriesTabs = {}));
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/hooks/useGroupRealmPlayersByFilter.ts


/**
 * The purpose of this hook is to group the realm players by the different realm member filter groups.
 */
const useGroupRealmPlayersByFilter = realmPlayers => {
  const groupedRealmPlayers = (0,react_facet_src.useFacetMemo)(players => {
    const all = [];
    const online = [];
    const optedIn = [];
    const optedOut = [];
    players.forEach(player => {
      if (player.isOnline) {
        online.push(player);
      }

      if (player.hasOptedIn) {
        optedIn.push(player);
      } else {
        optedOut.push(player);
      }

      all.push(player);
    });
    return {
      allMembers: all,
      onlinePlayers: online,
      optedInPlayers: optedIn,
      optedOutPlayers: optedOut
    };
  }, [], [realmPlayers]);
  return groupedRealmPlayers;
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-villager.png
const gamer_icon_villager_namespaceObject = __webpack_require__.p + "assets/gamer-icon-villager-856f0.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmPlayerListItem/RealmPlayerListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmPlayerListItem = ({"grayFilter":"QOZQW"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmPlayerListItem/RealmPlayerListItem.tsx













function RealmPlayerListItem_RealmPlayerListItem({
  realmPlayer,
  index,
  role = 'neutral80',
  isSimpleLayout = false,
  totalPlayers
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories');
  const gamerTag = (0,react_facet_src.useFacetMap)(player => player.gamerTag, [], [realmPlayer]);
  const gamerIcon = (0,react_facet_src.useFacetMap)(player => {
    var _player$gamerIcon;

    return (_player$gamerIcon = player.gamerIcon) !== null && _player$gamerIcon !== void 0 ? _player$gamerIcon : gamer_icon_villager_namespaceObject;
  }, [], [realmPlayer]);
  const onlineStatus = (0,react_facet_src.useFacetMap)(player => player.isOnline ? 'online' : 'offline', [], [realmPlayer]);
  const realmRoleLabel = (0,react_facet_src.useFacetMap)(player => {
    switch (player.role) {
      case RealmPlayerRoleEnum.OWNER:
        return '';

      case RealmPlayerRoleEnum.OPERATOR:
        return t('.members.operator');

      case RealmPlayerRoleEnum.MEMBER:
        return t('.members.member');

      case RealmPlayerRoleEnum.VISITOR:
      default:
        return t('.members.visitor');
    }
  }, [t], [realmPlayer]);
  const onlineStatusText = (0,react_facet_src.useFacetMap)(player => {
    if (player.hasOptedIn === false) {
      return t('.members.notMemberRealmsStories');
    }

    return player.isOnline ? t('.feed.online') : t('.feed.offline');
  }, [t], [realmPlayer]);
  const narrationText = (0,react_facet_src.useFacetMap)((gamerTag, onlineStatus, roleLabel, totalPlayers) => [gamerTag, t('.gamerTag'), onlineStatus, isSimpleLayout ? undefined : roleLabel, totalPlayers != null ? t('.narrationPlayerXOfY', [index.toString(), totalPlayers.toString()]) : undefined].filter(text => text).join(' . '), [t, index, isSimpleLayout], [gamerTag, onlineStatusText, realmRoleLabel, (0,react_facet_src.useFacetWrap)(totalPlayers)]);
  const showRoleLabel = (0,react_facet_src.useFacetMap)(player => player.role !== RealmPlayerRoleEnum.OWNER && isSimpleLayout === false, [isSimpleLayout], [realmPlayer]);
  const labelRole = (0,react_facet_src.useFacetMap)(player => player.role === RealmPlayerRoleEnum.VISITOR ? 'neutral100' : 'primaryTint', [], [realmPlayer]);
  const playerRoleTag = /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: labelRole
  }, realmRoleLabel);
  const isOperator = (0,react_facet_src.useFacetUnwrap)((0,react_facet_src.useFacetMap)(player => player.role === RealmPlayerRoleEnum.OPERATOR, [], [realmPlayer]));
  const tokenCollection = isOperator != react_facet_src.NO_VALUE && isOperator ? vanillaCollection : realmsCollection;
  const colorValues = useSemanticColorValues(role);
  const isNarrationEnabled = useNarrationEnabled();
  const isFocusable = !isSimpleLayout || isNarrationEnabled;
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    isFocusable: isFocusable,
    gamepadIndex: index,
    narrationText: narrationText,
    role: role,
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement("fast-div", {
    className: (0,react_facet_src.useFacetMap)(player => classnames_default()(colorValues.border.regular, {
      [RealmPlayerListItem.grayFilter]: player.hasOptedIn === false
    }), [colorValues], [realmPlayer])
  }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    src: gamerIcon,
    variant: "large",
    status: onlineStatus
  }))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, gamerTag), isSimpleLayout === false && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, onlineStatusText)))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRoleLabel
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: tokenCollection
  }, playerRoleTag))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmPlayerListItem/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Messages/StoriesNoInternetMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StoriesNoInternetMessage = ({"emptyStateArt":"cXP1g","emptyStateArtBig":"uHp81"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/images/no-internet-art.png
const RealmsStoriesRoute_images_no_internet_art_namespaceObject = __webpack_require__.p + "assets/no-internet-art-6e094.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Messages/StoriesNoInternetMessage.tsx






function StoriesNoInternetMessage_StoriesNoInternetMessage({
  wide,
  narrow
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories'); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: wide,
    narrow: narrow,
    width: 256
  });
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.messages.title'),
    text: t('.messages.noInternetBody'),
    imgSrc: RealmsStoriesRoute_images_no_internet_art_namespaceObject,
    imgClass: narrowImage ? StoriesNoInternetMessage.emptyStateArt : StoriesNoInternetMessage.emptyStateArtBig
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Messages/StoriesUnknownErrorMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StoriesUnknownErrorMessage = ({"emptyStateArt":"SWWRX","emptyStateArtBig":"JYOi5"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/images/GenericError.png
const GenericError_namespaceObject = __webpack_require__.p + "assets/GenericError-2a9c9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Messages/StoriesUnknownErrorMessage.tsx







function StoriesUnknownErrorMessage_StoriesUnknownErrorMessage({
  onClick,
  wide,
  narrow,
  pageName
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories');
  const pageNameWrapped = (0,react_facet_src.useFacetWrap)(pageName !== null && pageName !== void 0 ? pageName : ''); // To enable a bigger image size on bigger devices

  const narrowImage = useImageBreakpoint({
    wide: wide,
    narrow: narrow,
    width: 260
  });
  const title = (0,react_facet_src.useFacetMap)(name => name !== '' ? t('.messages.titleWithArg', [name]) : t('.messages.title'), [t], [pageNameWrapped]);
  return /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    autofocus: true,
    title: title,
    text: t('.messages.unknownErrorBody'),
    imgSrc: GenericError_namespaceObject,
    imgClass: narrowImage ? StoriesUnknownErrorMessage.emptyStateArt : StoriesUnknownErrorMessage.emptyStateArtBig,
    buttons: [{
      text: t('.messages.button'),
      onClick: onClick,
      inputLegend: t('.messages.button')
    }]
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Messages/index.tsx


;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/images/members-empty.png
const members_empty_namespaceObject = __webpack_require__.p + "assets/members-empty-32029.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/MembersTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const MembersTab = ({"emptyMessageImage":"rUeuF"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/MembersTab.tsx
















function MemberTab() {
  const persistentFacet = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const realmFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.members');
  const currentUserXuid = (0,react_facet_src.useFacetMap)(data => data.userXuid, [], [realmFacet]);
  const realmOwnerXuid = (0,react_facet_src.useFacetMap)(data => data.ownerXuid, [], [realmFacet]);
  const isOwner = (0,react_facet_src.useFacetMap)((userXuid, ownerXuid) => userXuid === ownerXuid, [], [currentUserXuid, realmOwnerXuid]);
  const filterOption = (0,react_facet_src.useFacetMap)(persistentData => persistentData.currentMemberFilterOption, [], [persistentFacet]);
  const searchTerm = (0,react_facet_src.useFacetMap)(persistentData => persistentData.currentMemberSearchText, [], [persistentFacet]);
  const sortOption = (0,react_facet_src.useFacetMap)(persistentData => persistentData.currentMemberSortOption, [], [persistentFacet]);
  const memberSortOptions = (0,react_facet_src.useFacetMap)(filterOption => [...(filterOption === RealmMemberFilterOption.OptedOut || filterOption === RealmMemberFilterOption.Online ? [] : [{
    label: t('.recentlyPlayed'),
    value: RealmMemberSortOption.MostRecent
  }, {
    label: t('.leastRecentlyPlayed'),
    value: RealmMemberSortOption.LeastRecent
  }]), {
    label: t('.fromAtoZ'),
    value: RealmMemberSortOption.AlphabeticalAscending
  }, {
    label: t('.fromZtoA'),
    value: RealmMemberSortOption.AlphabeticalDescending
  }], [t], [filterOption]);
  const resetSortOnOptedOutFilter = (0,react_facet_src.useFacetCallback)(persistentData => () => {
    persistentData.currentMemberSortOption = RealmMemberSortOption.AlphabeticalAscending;
  }, [], [persistentFacet]);
  const allRealmPlayers = (0,react_facet_src.useFacetMap)((facet, userXuid, ownerXuid) => filter(facet.players, player => player.xuid !== userXuid && player.xuid != ownerXuid), [], [playersFacet, currentUserXuid, realmOwnerXuid]);
  const groupedPlayers = useGroupRealmPlayersByFilter(allRealmPlayers);
  const sortedRealmMembers = (0,react_facet_src.useFacetMap)((groupedPlayers, filterOption, sortOption, searchTerm) => {
    let unsortedPlayers = groupedPlayers.allMembers;
    if (unsortedPlayers == null) return unsortedPlayers;

    switch (filterOption) {
      case RealmMemberFilterOption.Online:
        unsortedPlayers = groupedPlayers.onlinePlayers;
        break;

      case RealmMemberFilterOption.OptedIn:
        unsortedPlayers = groupedPlayers.optedInPlayers;
        break;

      case RealmMemberFilterOption.OptedOut:
        unsortedPlayers = groupedPlayers.optedOutPlayers;
        break;
    }

    if (searchTerm !== '') {
      unsortedPlayers = filter(unsortedPlayers, player => player.gamerTag.toLocaleLowerCase().includes(searchTerm.toLocaleLowerCase()));
    }

    let sortedPlayers = [];

    switch (sortOption) {
      case RealmMemberSortOption.AlphabeticalAscending:
        sortedPlayers = sortRealmPlayerGamerTagAlphabeticallyAscending(unsortedPlayers);
        break;

      case RealmMemberSortOption.AlphabeticalDescending:
        sortedPlayers = sortRealmPlayerGamerTagAlphabeticallyDescending(unsortedPlayers);
        break;

      case RealmMemberSortOption.LeastRecent:
        sortedPlayers = sortRealmPlayerByLeastActive(unsortedPlayers);
        break;

      case RealmMemberSortOption.MostRecent:
      default:
        sortedPlayers = sortRealmPlayerByMostRecent(unsortedPlayers);
        break;
    }

    return sortedPlayers;
  }, [], [groupedPlayers, filterOption, sortOption, searchTerm]);
  (0,react_facet_src.useFacetEffect)((filterOption, sortOption) => {
    // Change sorting option to alphabetical ascending if sort is set to an unavailable option.
    if ((filterOption === RealmMemberFilterOption.OptedOut || filterOption === RealmMemberFilterOption.Online) && (sortOption === RealmMemberSortOption.LeastRecent || sortOption === RealmMemberSortOption.MostRecent)) {
      resetSortOnOptedOutFilter();
    }
  }, [resetSortOnOptedOutFilter], [filterOption, sortOption]);
  const hasRealmPlayers = (0,react_facet_src.useFacetMap)(players => players.length > 0, [], [sortedRealmMembers]);
  const isLoadingProfiles = (0,react_facet_src.useFacetMap)(players => find_find(players, player => player.fetchProfileStatus === FetchStatus.InProgress) != null, [], [sortedRealmMembers]);
  const isLoadingPlayers = (0,react_facet_src.useFacetMap)((facet, isLoadingProfiles) => facet.fetchMembersStatus === FetchStatus.InProgress || facet.fetchOnlineMembersStatus === FetchStatus.InProgress || isLoadingProfiles, [], [playersFacet, isLoadingProfiles]);
  const realmOwner = (0,react_facet_src.useFacetMap)((facet, ownerXuid) => find_find(facet.players, player => player.xuid === ownerXuid), [], [playersFacet, realmOwnerXuid]);
  const showRealmOwner = (0,react_facet_src.useFacetMap)((owner, filterOption, searchTerm) => {
    // Check if owner is undefined
    if (owner == null) return false; // Check for if owner should be filtered out

    if (filterOption === RealmMemberFilterOption.Online && !owner.isOnline || filterOption === RealmMemberFilterOption.OptedIn && !owner.hasOptedIn || filterOption === RealmMemberFilterOption.OptedOut && owner.hasOptedIn) {
      return false;
    } // Check for if the search term is blank, or if owner's gamertag includes the search term


    return searchTerm.length === 0 || owner.gamerTag.toLocaleLowerCase().includes(searchTerm.toLocaleLowerCase());
  }, [], [realmOwner, filterOption, searchTerm]);
  const showRealmPlayers = (0,react_facet_src.useFacetMap)((hasRealmPlayers, showRealmOwner) => hasRealmPlayers || showRealmOwner, [], [hasRealmPlayers, showRealmOwner]);
  const onSearchTextChange = (0,react_facet_src.useFacetCallback)(persistentData => newValue => {
    persistentData.currentMemberSearchText = newValue;
  }, [], [persistentFacet]);
  const realmOwnerNarration = `${t('.realmOwner')} . ${t('.section')}`;
  const realmMembersNarration = `${t('.realmMembers')} . ${t('.section')}`; // Scroll view props

  const isDeferringFacet = (0,deferred_mount_dist.useIsDeferring)();
  const isPaused = (0,deferred_mount_dist.useIsPaused)();
  const isLoading = (0,react_facet_src.useFacetMap)((isDeferring, isLoadingPlayers) => isLoadingPlayers || isDeferring || isPaused, [isPaused], [isDeferringFacet, isLoadingPlayers]);
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  const unknownErrorVisible = (0,react_facet_src.useFacetMap)((facet, noInternet) => (facet.fetchMembersStatus === FetchStatus.InternalError || facet.fetchMembersStatus === FetchStatus.FetchFailed || facet.fetchMembersStatus === FetchStatus.RateLimit) && !noInternet, [], [playersFacet, noInternetMessageVisible]);
  const errorMessageVisible = (0,react_facet_src.useFacetMap)((noInternet, unknownError) => noInternet || unknownError, [], [noInternetMessageVisible, unknownErrorVisible]);
  const retryFailedFetch = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.fetchMembers();
  }, [], [actionsFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 10,
    narrowSize: 8,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 10,
    narrow: 8
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: unknownErrorVisible
  }, /*#__PURE__*/react.createElement(StoriesUnknownErrorMessage_StoriesUnknownErrorMessage, {
    wide: 10,
    narrow: 8,
    onClick: retryFailedFetch,
    pageName: s('.members')
  }))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 8,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    placeholder: t('.search'),
    narrationText: t('.search'),
    placeholderIcon: BaseTextField_PlaceholderIcon.MagnifyingGlass,
    value: searchTerm,
    onBlur: onSearchTextChange,
    maxLength: 20,
    shouldBlurOnEscape: true,
    shouldBlurOnEnter: true
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 4,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 0
  }), /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    options: [{
      label: t('.allMembers'),
      value: RealmMemberFilterOption.All
    }, {
      label: t('.onlineMembers'),
      value: RealmMemberFilterOption.Online
    }, {
      label: t('.realmStoriesMembers'),
      value: RealmMemberFilterOption.OptedIn
    }, {
      label: t('.optedOutMembers'),
      value: RealmMemberFilterOption.OptedOut
    }],
    value: (0,react_facet_src.useFacetMap)(persistentData => persistentData.currentMemberFilterOption, [], [persistentFacet]),
    onChange: (0,react_facet_src.useFacetCallback)(persistentData => newValue => {
      persistentData.currentMemberFilterOption = newValue;
    }, [], [persistentFacet])
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 4,
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 0
  }), /*#__PURE__*/react.createElement(BaseDropdown_BaseDropdown, {
    options: memberSortOptions,
    value: (0,react_facet_src.useFacetMap)(persistentData => persistentData.currentMemberSortOption, [], [persistentFacet]),
    onChange: (0,react_facet_src.useFacetCallback)(persistentData => newValue => {
      persistentData.currentMemberSortOption = newValue;
    }, [], [persistentFacet])
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 6
  }), /*#__PURE__*/react.createElement(MembersListWrapper, {
    isOwner: isOwner
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    loading: isLoading,
    defaultFocusedChildBehavior: "first"
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRealmPlayers
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRealmOwner
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: realmOwnerNarration
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
    role: "primary",
    label: t('.realmOwner')
  }), /*#__PURE__*/react.createElement(react_facet_src.With, {
    data: realmOwner
  }, realmOwner => /*#__PURE__*/react.createElement(RealmPlayerListItem_RealmPlayerListItem, {
    realmPlayer: realmOwner,
    index: 0
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasRealmPlayers
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: realmMembersNarration
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
    role: "primary",
    label: t('.realmMembers')
  }), isPaused === false && /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: sortedRealmMembers
  }, (itemFacet, index) => /*#__PURE__*/react.createElement(RealmPlayerListItem_RealmPlayerListItem, {
    realmPlayer: itemFacet,
    index: index + 1
  }))))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRealmPlayers,
    condition: false
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.noMembersFound'),
    imgSrc: members_empty_namespaceObject,
    imgClass: MembersTab.emptyMessageImage
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })))))));
}

function MembersListWrapper({
  children,
  isOwner
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.members');
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const openManageMembers = (0,react_facet_src.useFacetCallback)(actionsFacet => () => {
    actionsFacet.openManageMembersScreen();
  }, [], [actionsFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOwner
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 1,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 3,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.manage'),
    variant: "secondary",
    gamepadAlias: "manage-members-button",
    onClick: openManageMembers,
    gamepadIndex: 0
  }, t('.manage'))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 8,
    narrowSize: 5,
    gamepadIndex: 1
  }, children))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOwner,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 1,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0,
    gamepadIndex: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 10,
    narrowSize: 8,
    gamepadIndex: 1
  }, children), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0,
    gamepadIndex: 2
  }))));
}
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/images/arrowForward.png
const arrowForward_namespaceObject = __webpack_require__.p + "assets/arrowForward-03da5.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/images/arrowForwardDisabled.png
const arrowForwardDisabled_namespaceObject = __webpack_require__.p + "assets/arrowForwardDisabled-779d8.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForward = ({"iconArrowForward":"FHUZr"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForward/IconArrowForward.tsx
function IconArrowForward_extends() { IconArrowForward_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowForward_extends.apply(this, arguments); }

function IconArrowForward_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowForward_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowForward_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }








const IconArrowForward_IconArrowForward = (_ref) => {
  let {
    className,
    disabled
  } = _ref,
      props = IconArrowForward_objectWithoutProperties(_ref, ["className", "disabled"]);

  const disabledFacet = (0,react_facet_src.useFacetWrap)(disabled !== null && disabled !== void 0 ? disabled : false);
  const classNames = useCombinedClassNames(IconArrowForward.iconArrowForward, className);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: disabledFacet
  }, /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowForward_extends({}, props, {
    className: classNames,
    src: arrowForwardDisabled_namespaceObject,
    imageRendering: "pixelated"
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: disabledFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowForward_extends({}, props, {
    className: classNames,
    src: arrowForward_namespaceObject,
    imageRendering: "pixelated"
  }))));
};
;// CONCATENATED MODULE: ./packages/ui/src/Pagination/Pagination.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Pagination = ({"container":"EH7DY","indicesContainer":"A_Lrf","indexElementsContainer":"hqAey","activeIndexContainer":"fBAuV","activeIndex":"UNmNG","indexContainer":"lQDP_","button":"zHOXo","buttonContainer":"XM_PG","backButton":"KCWC4","nextButton":"AYHNu","isActive":"uvCnl","disabledFocus":"ypqL0"});
;// CONCATENATED MODULE: ./packages/ui/src/Pagination/Pagination.tsx
function Pagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Pagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Pagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }














const INDICES_MAX = 7;
const ELLIPSIS = '...';

const getIndexText = (totalPages, currentPage, index) => {
  const textIndex = String(index + 1);
  if (index === 0) return textIndex; // Always return the first value

  if (index === INDICES_MAX - 1) return String(totalPages); // Always return the last

  if (totalPages <= 7) return textIndex; // Return the intial indicies if no truncation required

  if (currentPage >= 4 && index === 1) return ELLIPSIS; // Return the left ellipsis

  if (currentPage <= totalPages - 3) {
    if (index === INDICES_MAX - 2) return ELLIPSIS; // Return the right ellipsis

    if (Array.from({
      length: totalPages - 6
    }, (_, i) => i + 4).includes(currentPage)) {
      // Rotate the middle indicies
      switch (index) {
        case INDICES_MAX - 5:
          return String(currentPage + 4 - 5);

        case INDICES_MAX - 4:
          return String(currentPage + 4 - 4);

        case INDICES_MAX - 3:
          return String(currentPage + 4 - 3);
      }
    }

    return textIndex; // Return initial index value ( usually the 2nd index)
  }

  return String(index + (totalPages - (INDICES_MAX - 1))); // Return trailing index value ( usually total pages - 1)
};

const PaginationIndexItem = ({
  index,
  totalPages,
  currentPage,
  onChange,
  role = 'neutral'
}) => {
  const semanticSounds = useSemanticSounds(role);
  const semanticClassNames = hooks_useSemanticColors(role);
  const {
    t
  } = useLocalization_useLocalization('Pagination');
  const indexText = (0,react_facet_src.useFacetMap)((page, pages) => getIndexText(pages, page, index), [index], [currentPage, totalPages]);
  const isActive = (0,react_facet_src.useFacetMap)((indexText, page) => indexText === String(page), [], [indexText, currentPage]);
  const jumpNavigation = (0,react_facet_src.useFacetCallback)((indexText, isActive, page, pages) => () => {
    if (isActive) return;

    if (indexText === ELLIPSIS && index === 1) {
      return void onChange(Math.max(page - 5, 1));
    }

    if (indexText === ELLIPSIS && index === INDICES_MAX - 2) {
      return void onChange(Math.min(page + 5, pages));
    }

    return void onChange(Number(indexText));
  }, [index, onChange], [indexText, isActive, currentPage, totalPages]);
  const narrationText = (0,react_facet_src.useFacetMap)((indexText, isActive, currentPage, totalPages) => {
    if (indexText === ELLIPSIS && index === 1) {
      return t('.skipPrevious', [String(Math.max(currentPage - 5, 0))]);
    }

    if (indexText === ELLIPSIS && index === INDICES_MAX - 2) {
      return t('.skipNext', [String(Math.min(currentPage + 5, totalPages)), String(totalPages)]);
    }

    return t('.index', [indexText, String(totalPages), isActive ? t('.selected') : t('.unselected')]);
  }, [index, t], [indexText, isActive, currentPage, totalPages]);
  const classNames = (0,react_facet_src.useFacetMap)(isActive => {
    return classnames_default()(semanticClassNames.background.base, semanticClassNames.text.base, semanticClassNames.border.base, isActive ? Pagination.isActive : [semanticClassNames.background.hover, semanticClassNames.background.press, semanticClassNames.text.hover, semanticClassNames.text.press, semanticClassNames.border.hover, semanticClassNames.border.press]);
  }, [semanticClassNames], [isActive]);
  const soundEffectPressed = (0,react_facet_src.useFacetMap)(isActive => isActive === false ? semanticSounds.press : undefined, [semanticSounds], [isActive]);
  const soundEffectHovered = (0,react_facet_src.useFacetMap)(isActive => isActive === false ? semanticSounds.hover : undefined, [semanticSounds], [isActive]);
  const soundEffectFocused = (0,react_facet_src.useFacetMap)(isActive => isActive === false ? semanticSounds.focus : undefined, [semanticSounds], [isActive]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    narrationText: narrationText,
    "data-testid": `pagination-index-${index}`,
    gamepadIndex: index + 1,
    inputLegend: (0,react_facet_src.useFacetMap)(page => t('.currentPage', [String(page)]), [t], [currentPage]),
    onClick: jumpNavigation,
    classNameFocused: focusClass,
    className: classNames,
    soundEffectPressed: soundEffectPressed,
    soundEffectHovered: soundEffectHovered,
    soundEffectFocused: soundEffectFocused
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    condition: false,
    when: isActive
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel"
  })), /*#__PURE__*/react.createElement("div", {
    className: Pagination.activeIndexContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isActive
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(Pagination.activeIndex, semanticClassNames.icon.base)
  })), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, indexText)));
};

const PaginationButton = (_ref) => {
  let {
    direction,
    narrationText,
    disabled,
    inputLegend,
    onClick,
    gamepadIndex,
    disabledNarration
  } = _ref,
      props = Pagination_objectWithoutProperties(_ref, ["direction", "narrationText", "disabled", "inputLegend", "onClick", "gamepadIndex", "disabledNarration"]);

  const isNarrationEnabled = useNarrationEnabled();
  const isInteractive = (0,react_facet_src.useFacetMap)(disabled => isNarrationEnabled && disabled, [isNarrationEnabled], [disabled]);
  return /*#__PURE__*/react.createElement("div", {
    className: Pagination.buttonContainer
  }, /*#__PURE__*/react.createElement(InteractivePrimitiveMaybe, {
    isInteractive: isInteractive,
    gamepadIndex: gamepadIndex,
    narrationText: disabledNarration,
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, {
    withoutBorders: true,
    className: Pagination.disabledFocus
  }), /*#__PURE__*/react.createElement(Pressable_Pressable, {
    height: 4,
    isElevated: true,
    narrationText: narrationText,
    variant: 'secondary',
    "data-testid": props['data-testid'],
    disabled: disabled,
    inputLegend: inputLegend,
    onClick: onClick,
    gamepadIndex: gamepadIndex
  }, /*#__PURE__*/react.createElement("div", {
    className: Pagination.button
  }, direction === 'next' ? /*#__PURE__*/react.createElement(IconArrowForward_IconArrowForward, {
    disabled: disabled,
    className: Pagination.nextButton
  }) : /*#__PURE__*/react.createElement(IconArrowBack_IconArrowBack, {
    className: Pagination.backButton,
    disabled: disabled
  })))));
};

const Pagination_Pagination = ({
  onChange,
  totalPages = 1,
  currentPage = 1,
  role = 'neutral',
  hideIndices = false
}) => {
  const hideInicesFacet = (0,react_facet_src.useFacetWrap)(hideIndices);
  const currentPageFacet = (0,react_facet_src.useFacetWrap)(currentPage);
  const totalPagesFacet = (0,react_facet_src.useFacetWrap)(totalPages);
  const isMouseFacet = useIsPointerInputMouse();
  const isTouchFacet = useIsPointerInputTouch();
  const {
    narrateText
  } = useNarrateText_useNarrateText();
  const {
    t
  } = useLocalization_useLocalization('Pagination');
  const gamepadContainer = (0,react.useRef)(null);
  const pageArray = (0,react_facet_src.useFacetMap)(pages => Array.from({
    length: Math.min(pages, INDICES_MAX)
  }, (_, i) => i), [], [totalPagesFacet]);
  const previousPage = (0,react_facet_src.useFacetCallback)(page => () => {
    if (page > 0) {
      onChange(Math.max(page - 1, 0));

      if (page > 2) {
        narrateText(t('.previousPage', [String(page - 2)]));
      }
    }
  }, [narrateText, onChange, t], [currentPageFacet]);
  const nextPage = (0,react_facet_src.useFacetCallback)((page, pages) => () => {
    if (page < pages) {
      narrateText(t('.nextPage', [String(page + 2)]));
      onChange(Math.min(page + 1, pages));
    }
  }, [narrateText, onChange, t], [currentPageFacet, totalPagesFacet]);
  const narrationContext = (0,react_facet_src.useFacetMap)((isMouse, isTouch) => {
    if (isMouse || isTouch) {
      return `${t('.context')} . ${t('.contextHintMouse')}`;
    }

    return `${t('.context')} . ${t('.contextHintGamepad')}`;
  }, [t], [isMouseFacet, isTouchFacet]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((pages, hiddenIndices) => pages > 1 || hiddenIndices, [], [totalPagesFacet, hideInicesFacet])
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narrationContext
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    scrollRef: gamepadContainer
  }, /*#__PURE__*/react.createElement("div", {
    ref: gamepadContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: Pagination.container
  }, /*#__PURE__*/react.createElement(PaginationButton, {
    direction: "previous",
    disabled: (0,react_facet_src.useFacetMap)(page => page === 1, [], [currentPageFacet]),
    disabledNarration: (0,react_facet_src.useFacetMap)(() => t('.previousPageDisabled'), [t], []),
    inputLegend: t('.previousPage'),
    narrationText: (0,react_facet_src.useFacetMap)(page => t('.previousPage', [String(page - 1)]), [t], [currentPageFacet]),
    onClick: previousPage,
    "data-testid": "pagination-button-left",
    gamepadIndex: 0
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(hideIndices => hideIndices, [], [hideInicesFacet]),
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: Pagination.indexContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: Pagination.indicesContainer
  }, /*#__PURE__*/react.createElement("div", {
    className: Pagination.indexElementsContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: pageArray
  }, (_, index) => /*#__PURE__*/react.createElement(PaginationIndexItem, {
    role: role,
    currentPage: currentPageFacet,
    totalPages: totalPagesFacet,
    index: index,
    onChange: onChange
  }))))))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(PaginationButton, {
    direction: "next",
    disabled: (0,react_facet_src.useFacetMap)((page, pages) => page === pages, [], [currentPageFacet, totalPagesFacet]),
    disabledNarration: (0,react_facet_src.useFacetMap)(() => t('.nextPageDisabled'), [t], []),
    inputLegend: t('.nextPage'),
    narrationText: (0,react_facet_src.useFacetMap)(page => t('.nextPage', [String(page + 1)]), [t], [currentPageFacet]),
    onClick: nextPage,
    "data-testid": "pagination-button-right",
    gamepadIndex: (0,react_facet_src.useFacetMap)(pages => pages + 2, [], [totalPagesFacet])
  }))))));
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/rewardImages/index.ts
const rewardImages = [__webpack_require__(40949), __webpack_require__(36577), __webpack_require__(59001)];
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/achievementImages/index.ts
const achievementImages = [__webpack_require__(53603), __webpack_require__(73217), __webpack_require__(18376), __webpack_require__(43218), __webpack_require__(67464), __webpack_require__(827), __webpack_require__(52133), __webpack_require__(41988), __webpack_require__(81346), __webpack_require__(811), __webpack_require__(67982), __webpack_require__(19119), __webpack_require__(69501), __webpack_require__(68592), __webpack_require__(47461), __webpack_require__(33732), __webpack_require__(77563), __webpack_require__(86795), __webpack_require__(9071), __webpack_require__(72844), __webpack_require__(3139), __webpack_require__(67607), __webpack_require__(48677), __webpack_require__(8348), __webpack_require__(33231), __webpack_require__(18905), __webpack_require__(57098), __webpack_require__(76844), __webpack_require__(27149), __webpack_require__(16996), __webpack_require__(55671), __webpack_require__(84115), __webpack_require__(6454), __webpack_require__(28110), __webpack_require__(94267), __webpack_require__(90796), __webpack_require__(29655), __webpack_require__(57185), __webpack_require__(29199), __webpack_require__(65975), __webpack_require__(32236), __webpack_require__(92857), __webpack_require__(72312), __webpack_require__(32261), __webpack_require__(66893), __webpack_require__(36719), __webpack_require__(72127), __webpack_require__(91731), __webpack_require__(7850), __webpack_require__(55112), __webpack_require__(37), __webpack_require__(93457), __webpack_require__(28556), __webpack_require__(7424), __webpack_require__(61851), __webpack_require__(24273), __webpack_require__(50459), __webpack_require__(95541), __webpack_require__(71507), __webpack_require__(45981), __webpack_require__(15168), __webpack_require__(39216), __webpack_require__(81568), __webpack_require__(92011), __webpack_require__(75394), __webpack_require__(96121), __webpack_require__(91330), __webpack_require__(49678), __webpack_require__(66862), __webpack_require__(3664), __webpack_require__(45459), __webpack_require__(16013), __webpack_require__(73682), __webpack_require__(72486), __webpack_require__(48853), __webpack_require__(38735), __webpack_require__(10068), __webpack_require__(90261), __webpack_require__(8003), __webpack_require__(46175), __webpack_require__(38537), __webpack_require__(96350), __webpack_require__(34924), __webpack_require__(57213), __webpack_require__(8072), __webpack_require__(18460), __webpack_require__(10988), __webpack_require__(66570), __webpack_require__(786), __webpack_require__(90678), __webpack_require__(661), __webpack_require__(78965), __webpack_require__(81023), __webpack_require__(56377), __webpack_require__(68956), __webpack_require__(47419), __webpack_require__(42539), __webpack_require__(32539), __webpack_require__(59906), __webpack_require__(43450), __webpack_require__(70040), __webpack_require__(50611), __webpack_require__(93870), __webpack_require__(30280), __webpack_require__(29553), __webpack_require__(90104), __webpack_require__(13921), __webpack_require__(93624), __webpack_require__(18324), __webpack_require__(41395), __webpack_require__(87126), __webpack_require__(94239)];
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/achievements.ts



// new Date('December 17, 2018 03:24:00').getTime() / 1000
const date = 1545013440; //2019-02-04T20:34:12.000Z

const dateII = 1549312452; //2018-10-31T19:17:20.000Z

const dateIII = 1545013440; //2018-07-08T01:30:40.000Z

const dateIV = 1531013440; // Not unlocked

const dateV = 0;
const dateSelection = [date, dateII, dateIII, dateIV];
const shouldUseRealisticNames = undefined === 'true';
const realisticAchievements = [{
  title: 'Into the Nether',
  description: 'Build a portal to the Nether.'
}, {
  title: 'MOAR Tools',
  description: 'Construct one type of each tool (one pickaxe, one shovel, one ax, one hoe).'
}, {
  title: 'Dispense with this',
  description: 'Construct a dispenser.'
}, {
  title: 'Leader of the Pack',
  description: 'Befriend five wolves.'
}, {
  title: 'Awarded all Trophies',
  description: 'All trophies have been awarded.'
}, {
  title: 'Pork Chop',
  description: 'Cook and eat a Porkchop'
}, {
  title: 'Passing The Time',
  description: 'Play for 100 days.'
}, {
  title: 'The Haggler',
  description: 'Obtain 30 Emeralds.'
}, {
  title: 'Pot Planter',
  description: 'Craft and place a Flower Pot.'
}, {
  title: "It's A Sign",
  description: 'Craft and place a Sign.'
}, {
  title: 'Iron Belly',
  description: 'Stop starvation by eating Rotten Flesh.'
}, {
  title: 'Have A Shearful Day',
  description: 'Use Shears to obtain Wool from a sheep.'
}, {
  title: 'Rainbow Collection',
  description: 'Gather 16 colors of Wool.'
}, {
  title: "Stayin' Frosty",
  description: 'Swim in lava while affected by a Fire Resistance effect.'
}, {
  title: 'Chestful Of Cobblestone',
  description: 'Mine and place 1728 Cobblestone in a Chest.'
}, {
  title: 'Renewable Energy',
  description: 'Smelt Wood logs in a Furnace, using Charcoal as the fuel source.'
}, {
  title: 'Music To My Ears',
  description: 'Play a Music Disc in a Jukebox.'
}, {
  title: 'BodyGuard',
  description: 'Create an Iron Golem.'
}, {
  title: 'Iron Man',
  description: 'Equip a full set of Iron Armor.'
}, {
  title: 'Zombie Doctor',
  description: 'Cure a Zombie Villager.'
}, {
  title: 'Lion Tamer',
  description: 'Tame an Ocelot.'
}, {
  title: 'Archer',
  description: 'Kill a Creeper with Arrows.'
}, {
  title: 'Tie-Dye Outfit',
  description: 'Dye a full 4-piece set of Leather Armor.'
}, {
  title: 'Trampoline',
  description: 'Bounce 30 blocks high off a Slime Block.'
}, {
  title: 'Camouflage',
  description: 'Kill a mob while wearing the head of that type of mob.'
}, {
  title: 'Map Room',
  description: 'Place 9 fully explored, adjacent maps into item frames in the shape of a 3x3 square.'
}, {
  title: 'Freight Station',
  description: 'Move an item from a Minecart chest, into a regular Chest using a Hopper.'
}, {
  title: 'Smelt Everything!',
  description: 'Connect 3 Chests to a single Furnace using Hoppers.'
}, {
  title: 'Taste Of Your Own Medicine',
  description: 'Poison a Witch with a Splash Potion.'
}, {
  title: 'Beam Me Up',
  description: 'Teleport over 100 meters from a single throw of an Ender Pearl.'
}, {
  title: 'Super Sonic',
  description: 'Use Elytra to fly through a 1 by 1 gap while moving faster than 40 m/s,'
}, {
  title: 'Great View From Up Here',
  description: 'Levitate up 50 blocks from the attacks of a Shulker.'
}, {
  title: 'The End... Again...',
  description: 'Respawn the Ender Dragon.'
}, {
  title: 'You Need a Mint',
  description: 'Collect dragons breath in a glass bottle.'
}, {
  title: 'The Deep End',
  description: 'Defeat an Elder Guardian.'
}, {
  title: 'Artificial Selection',
  description: 'Breed a mule from a horse and donkey.'
}, {
  title: 'Bee our guest',
  description: 'Use a Campfire to collect Honey from a Beehive using a Bottle without aggravating the bees.'
}]; // The fixture data has 100 achievements, where 59 are unlocked, 31 in progress and 10 are locked. There are 90 rewards in total, and out of those 53 are unlocked, 38 are locked.

const achievementsSharedFacetDefaultState = {
  status: achievementsFacet_AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 59,
    maxAchievements: 100,
    hoursPlayed: 400,
    currentGamerScore: 1170,
    maxGamerScore: 2038,
    achievements: Array.from(Array(100).keys()).map(key => {
      const progress = key < 10 ? 0 : key > 40 ? 100 : key;
      const isLocked = progress !== 100;
      const noReward = key % 11 === 0;
      const normalisedIndex = key % realisticAchievements.length;
      const descriptionLong = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const descriptionMedium = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const descriptionShort = shouldUseRealisticNames ? realisticAchievements[normalisedIndex].description : 'Description';
      const rewardNameShort = 'Reward name';
      const rewardNameMedium = 'Reward';
      const rewardNameLong = 'Reward';
      return {
        id: `${key}`,
        name: shouldUseRealisticNames ? realisticAchievements[normalisedIndex].title : 'About',
        description: key % 10 === 0 ? descriptionLong : key % 3 === 0 ? descriptionMedium : descriptionShort,
        gamerScore: 30,
        progress: progress / 100,
        progressTarget: 3,
        isLocked: isLocked,
        isSecret: false,
        dateUnlocked: isLocked ? 0 : dateSelection[key % dateSelection.length],
        hasReward: !noReward,
        rewardImage: noReward ? undefined : rewardImages[key % rewardImages.length],
        rewardName: noReward ? undefined : key % 2 === 0 ? rewardNameShort : key % 3 === 0 ? rewardNameLong : rewardNameMedium,
        isRewardOwned: !noReward && !isLocked,
        rewardId: !noReward ? 'afef6035-74c3-4c32-9c31-33853cad886e' : undefined,
        image: achievementImages[key % achievementImages.length],
        suggestedOrder: key
      };
    })
  }
}; // The fixture data has 10 achievements, where 0 are unlocked, 0 in progress and 10 are locked. No rewards.

const achievementsFacetNoCompleted = {
  status: achievementsFacet_AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 0,
    maxAchievements: 10,
    hoursPlayed: 400,
    currentGamerScore: 0,
    maxGamerScore: 300,
    achievements: Array.from(Array(10).keys()).map(key => {
      const description = 'Spend a day under water';
      return {
        id: `${key}`,
        name: 'Sleeping with the fishes',
        description: description,
        gamerScore: 30,
        progress: 0,
        progressTarget: 1,
        isLocked: true,
        isSecret: false,
        dateUnlocked: dateV,
        hasReward: false,
        rewardImage: '',
        rewardName: '',
        isRewardOwned: false,
        image: achievementImages[key % achievementImages.length],
        suggestedOrder: key
      };
    })
  }
}; // The fixture data has 10 achievements, where 10 are unlocked, 0 in progress and 0 are locked. No rewards.

const achievementsFacetAllCompleted = {
  status: achievementsFacet_AchievementFacetStatus.LOADED,
  data: {
    achievementsUnlocked: 10,
    maxAchievements: 10,
    hoursPlayed: 400,
    currentGamerScore: 300,
    maxGamerScore: 300,
    achievements: Array.from(Array(10).keys()).map(key => {
      const description = 'Spend a day under water';
      return {
        id: `${key}`,
        name: 'Sleeping with the fishes',
        description: description,
        gamerScore: 30,
        progress: 1,
        progressTarget: 1,
        isLocked: false,
        isSecret: false,
        dateUnlocked: date,
        hasReward: false,
        rewardImage: '',
        rewardName: '',
        isRewardOwned: false,
        image: achievementImages[key % achievementImages.length],
        suggestedOrder: key
      };
    })
  }
};
const achievementsFacetLoading = {
  status: achievementsFacet_AchievementFacetStatus.LOADING,
  data: {
    achievementsUnlocked: 0,
    maxAchievements: 0,
    hoursPlayed: 0,
    currentGamerScore: 0,
    maxGamerScore: 0,
    achievements: []
  }
};
const states = {
  default: achievementsSharedFacetDefaultState,
  loading: achievementsFacetLoading,
  allCompleted: achievementsFacetAllCompleted,
  noneCompleted: achievementsFacetNoCompleted
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/externalServerWorldList.ts
function externalServerWorldList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function externalServerWorldList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { externalServerWorldList_ownKeys(Object(source), true).forEach(function (key) { externalServerWorldList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { externalServerWorldList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function externalServerWorldList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const serverNames = ['Other server Nº1', 'Other Server with a really long string that we should handle with an ellipsis'];
const defaultExternalWorldList = [...new Array(2)].map((_, i) => ({
  id: `external-id${i}`,
  name: serverNames[i],
  ping: 123,
  capacity: 5000,
  playerCount: 543
}));
const externalWorldListDefaultState = {
  externalServerWorlds: defaultExternalWorldList,
  addExternalServerWorld: () => undefined,
  editExternalServerWorld: () => undefined,
  removeExternalServerWorld: () => undefined,
  addedServerId: undefined
};

const externalWorldListEmptyState = externalServerWorldList_objectSpread(externalServerWorldList_objectSpread({}, externalWorldListDefaultState), {}, {
  externalServerWorlds: []
});

const externalServerWorldList_states = {
  default: externalWorldListDefaultState,
  emptyState: externalWorldListEmptyState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/serverWorldDetails/1_1_ratio.png
const _1_1_ratio_namespaceObject = __webpack_require__.p + "assets/1_1_ratio-fd8f8.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/serverWorldDetails/10_3_ratio.png
const _10_3_ratio_namespaceObject = __webpack_require__.p + "assets/10_3_ratio-16d67.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/serverWorldDetails/hive-cover.png
const hive_cover_namespaceObject = __webpack_require__.p + "assets/hive-cover-802a1.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/networkWorldDetails.ts
function networkWorldDetails_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function networkWorldDetails_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { networkWorldDetails_ownKeys(Object(source), true).forEach(function (key) { networkWorldDetails_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { networkWorldDetails_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function networkWorldDetails_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





const defaultActivities = [{
  description: 'This activity includes some random events that will happening along the day, we have event 24/7',
  imagePath: _1_1_ratio_namespaceObject,
  subtitle: 'Subtitle',
  title: 'Random activity!'
}, {
  description: 'We will go dungeon hunting on the 24/5, we will record stats of number of dungeons discovered, number of mob killed and we will have prizes for everyone participating',
  imagePath: _1_1_ratio_namespaceObject,
  subtitle: 'Available on 24/05',
  title: 'Dungeon hunter'
}];
const networkWorldDetailsDefaultState = {
  networkDetails: {
    name: 'Server with all the fields',
    ping: '12',
    imagePath: _10_3_ratio_namespaceObject,
    pingStatus: WorldPingStatus.Low,
    playerCount: 999999,
    capacity: 5000,
    newsTitle: 'Big news here!',
    description: 'Home of Prophunt, Planets and Fill The Gaps! ',
    newsDescription: 'We have some big news here, we will going under maintenance the 07/07 and the server will not be available that day. Everything done that day will be discarded',
    type: types_NetworkWorldType.thirdParty,
    activities: defaultActivities,
    address: '',
    port: 0,
    id: 'id1'
  },
  hasLoadedDetails: true,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetailsDefaultStateID0 = {
  networkDetails: {
    name: 'The Hive',
    ping: '12344',
    imagePath: hive_cover_namespaceObject,
    pingStatus: WorldPingStatus.High,
    playerCount: 3464,
    capacity: 5000,
    newsTitle: 'Big news here!',
    description: 'The Hive offers fun & polished minigames, with advanced social features.',
    newsDescription: 'We have some big news here, we will going under maintenance the 07/07 and the server will not be available that day. Everything done that day will be discarded',
    type: types_NetworkWorldType.thirdParty,
    activities: defaultActivities,
    address: '',
    port: 0,
    id: 'id0'
  },
  hasLoadedDetails: true,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetailsLoadingState = {
  networkDetails: {
    name: 'Server with all the fields',
    ping: '12',
    imagePath: _10_3_ratio_namespaceObject,
    pingStatus: 3,
    playerCount: 120,
    capacity: 5000,
    newsTitle: 'Big news here!',
    description: 'Class is back in Session! Play with your friends in High School Roleplay, Prisons, Skyblock, and More!',
    newsDescription: 'We have some big news here, we will going under maintenance the 07/07 and the server will not be available that day. Everything done that day will be discarded',
    type: types_NetworkWorldType.thirdParty,
    activities: defaultActivities,
    address: '',
    port: 0,
    id: 'id1'
  },
  hasLoadedDetails: false,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetailsExternalServer = {
  networkDetails: {
    name: 'External server',
    imagePath: '',
    ping: '12',
    pingStatus: WorldPingStatus.Unavailable,
    playerCount: 55,
    capacity: 100,
    newsTitle: '',
    description: 'The Hive offers fun & polished minigames, with advanced social features.',
    newsDescription: '',
    type: types_NetworkWorldType.external,
    activities: [],
    address: 'random.server.play.com',
    port: 19123,
    id: 'external-id-1'
  },
  hasLoadedDetails: true,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetailsExternalServerID0 = {
  networkDetails: networkWorldDetails_objectSpread(networkWorldDetails_objectSpread({}, networkWorldDetailsExternalServer.networkDetails), {}, {
    name: 'External server with really long name',
    address: 'longname.server.com',
    port: 23432
  }),
  hasLoadedDetails: true,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetailsHighPingState = {
  networkDetails: networkWorldDetails_objectSpread(networkWorldDetails_objectSpread({}, networkWorldDetailsDefaultState.networkDetails), {}, {
    pingStatus: WorldPingStatus.High
  }),
  hasLoadedDetails: true,
  loadNetworkWorldDetails: () => {}
};
const networkWorldDetails_states = {
  default: networkWorldDetailsDefaultState,
  externalServer: networkWorldDetailsExternalServer,
  loadingState: networkWorldDetailsLoadingState,
  highPing: networkWorldDetailsHighPingState,
  id0: networkWorldDetailsDefaultStateID0,
  ['external-id1']: networkWorldDetailsExternalServerID0
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/networkWorldJoiner.ts
function networkWorldJoiner_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function networkWorldJoiner_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { networkWorldJoiner_ownKeys(Object(source), true).forEach(function (key) { networkWorldJoiner_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { networkWorldJoiner_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function networkWorldJoiner_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



const networkWorldJoinerDefaultState = {
  joinFriendServer: () => {},
  joinFriendServerProgress: FacetTaskProgress.IDLE,
  clearJoinFriendServerState: () => {},
  joinThirdPartyServer: () => {},
  clearJoinThirdPartyServerState: () => {},
  joinThirdPartyServerResult: undefined,
  joinThirdPartyServerProgress: FacetTaskProgress.IDLE,
  joinExternalServer: () => {},
  clearJoinExternalServerState: () => {},
  joinExternalServerResult: undefined,
  joinExternalServerProgress: FacetTaskProgress.IDLE,
  joinRealmWorld: () => {},
  clearJoinRealmState: () => {},
  joinRealmResult: undefined,
  joinRealmProgress: FacetTaskProgress.IDLE
};

const networkWorldJoinerJoinRealmMemberOfTooManyRealmsErrorState = networkWorldJoiner_objectSpread(networkWorldJoiner_objectSpread({}, networkWorldJoinerDefaultState), {}, {
  joinRealmProgress: FacetTaskProgress.DONE,
  joinRealmResult: JoinRealmWorldResult.MemberOfTooManyRealms
});

const networkWorldJoinerJoinRealmGenericErrorState = networkWorldJoiner_objectSpread(networkWorldJoiner_objectSpread({}, networkWorldJoinerDefaultState), {}, {
  joinRealmProgress: FacetTaskProgress.DONE,
  joinRealmResult: JoinRealmWorldResult.UnknownError
});

const networkWorldJoinerCannotConnectToRealm = networkWorldJoiner_objectSpread(networkWorldJoiner_objectSpread({}, networkWorldJoinerDefaultState), {}, {
  joinRealmProgress: FacetTaskProgress.DONE,
  joinRealmResult: JoinRealmWorldResult.CannotConnectToRealm
});

const networkWorldJoiner_states = {
  default: networkWorldJoinerDefaultState,
  cannotConnectToRealmError: networkWorldJoinerCannotConnectToRealm,
  realmsGenericError: networkWorldJoinerJoinRealmGenericErrorState,
  realmsTooManyRealmsError: networkWorldJoinerJoinRealmMemberOfTooManyRealmsErrorState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/notificationOptions.ts
const notificationOptionsSharedFacetDefaultState = {
  doNotShowEntitlementsWarning: false,
  doNotShowOldWorldsWarning: false,
  doNotShowMultiplayerIpSafetyWarning: false,
  doNotShowMultiplayerOnlineSafetyWarning: false,
  doNotShowAddFriendTutorialMessage: false
};
const notificationOptions_states = {
  default: notificationOptionsSharedFacetDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmsList.ts
function realmsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function realmsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { realmsList_ownKeys(Object(source), true).forEach(function (key) { realmsList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { realmsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function realmsList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const defaultState = {
  isLoading: false,
  realms: [{
    isOwner: true,
    world: {
      id: 0,
      realmName: 'Realm 0',
      slotName: 'My World 0',
      ownerName: 'Foo',
      ownerXuid: 'abc123',
      maxPlayers: 12,
      daysLeft: 12,
      expired: false,
      gameMode: GameMode.ADVENTURE,
      isInitialized: true,
      players: {
        gamerpicLocation: '/foo',
        hasAccepted: true,
        isOnline: true,
        isOperator: true,
        name: 'Gamer123',
        permission: realmsListFacet_PlayerPermissionLevel.Operator,
        realName: 'Alex Gamer',
        xuid: '321abc'
      }
    }
  }]
};
const emptyState = {
  isLoading: false,
  realms: []
};
const realmsList_states = {
  default: defaultState,
  loading: realmsList_objectSpread(realmsList_objectSpread({}, defaultState), {}, {
    isLoading: true
  }),
  empty: emptyState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/screenTechStack.ts

const screenTechStackFacetDefaultState = {
  getTechStackForScreen: () => UITechStack.OreUI,
  selectTechStackForScreen: () => {}
};
const screenTechStack_states = {
  default: screenTechStackFacetDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/telemetry.ts
const telemetrySharedFacetDefaultState = {
  fireEventButtonPressed: (buttonName, details) => {
    console.log(buttonName, details);
  }
};
const telemetry_states = {
  default: telemetrySharedFacetDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/servers/server-image.png
const server_image_namespaceObject = __webpack_require__.p + "assets/server-image-c20e4.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/thirdPartyWorldList.ts

const thirdPartyWorldList_serverNames = ['The Hive', 'Featured Server Nº2'];
const defaultThirdPartyList = [...new Array(2)].map((_, i) => ({
  id: `id${i}`,
  name: thirdPartyWorldList_serverNames[i],
  ping: 12,
  capacity: 5000,
  playerCount: 1200,
  image: server_image_namespaceObject
}));
const thirdPartyWorldListDefaultState = {
  thirdPartyWorlds: defaultThirdPartyList
};
const thirdPartyWorldList_states = {
  default: thirdPartyWorldListDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/unpairedRealmsList.ts
function unpairedRealmsList_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function unpairedRealmsList_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { unpairedRealmsList_ownKeys(Object(source), true).forEach(function (key) { unpairedRealmsList_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { unpairedRealmsList_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function unpairedRealmsList_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const unpairedRealmsList_defaultState = {
  isLoading: false,
  realms: [{
    isOwner: true,
    world: {
      id: 0,
      realmName: 'Realm 0',
      slotName: 'My World 0',
      ownerName: 'Foo',
      ownerXuid: 'abc123',
      maxPlayers: 12,
      daysLeft: 12,
      expired: false,
      gameMode: GameMode.ADVENTURE,
      isInitialized: true,
      players: {
        gamerpicLocation: '/foo',
        hasAccepted: true,
        isOnline: true,
        isOperator: true,
        name: 'Gamer123',
        permission: realmsListFacet_PlayerPermissionLevel.Operator,
        realName: 'Alex Gamer',
        xuid: '321abc'
      }
    }
  }]
};
const unpairedRealmsList_states = {
  default: unpairedRealmsList_defaultState,
  loading: unpairedRealmsList_objectSpread(unpairedRealmsList_objectSpread({}, unpairedRealmsList_defaultState), {}, {
    isLoading: true
  })
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/webBrowser.ts
const webBrowserFacetDefaultState = {
  openLink: link => {
    console.log(`Clicked on link ${link}`);
  }
};
const webBrowser_states = {
  default: webBrowserFacetDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerSocialManager.ts
const playerSocialManagerFacetDefaultState = {
  addFriend: playerId => {
    console.log('Add friend: ', playerId);
  },
  removeFriend: playerId => {
    console.log('Remove friend: ', playerId);
  },
  block: playerId => {
    console.log('Block: ', playerId);
  },
  unblock: playerId => {
    console.log('Unblock: ', playerId);
  },
  mute: playerId => {
    console.log('Mute: ', playerId);
  },
  unmute: playerId => {
    console.log('Unmute: ', playerId);
  }
};
const playerSocialManager_states = {
  default: playerSocialManagerFacetDefaultState
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerAchievements.ts
function playerAchievements_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function playerAchievements_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { playerAchievements_ownKeys(Object(source), true).forEach(function (key) { playerAchievements_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { playerAchievements_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function playerAchievements_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const defaultLoad = {
  load: id => console.log('Load player achievements: ', id),
  unload: () => console.log('Unload player achievements')
};
const playerAchievements_states = {
  default: playerAchievements_objectSpread(playerAchievements_objectSpread({}, states["default"]), defaultLoad),
  loading: playerAchievements_objectSpread(playerAchievements_objectSpread({}, states.loading), defaultLoad),
  allCompleted: playerAchievements_objectSpread(playerAchievements_objectSpread({}, states.allCompleted), defaultLoad),
  noneCompleted: playerAchievements_objectSpread(playerAchievements_objectSpread({}, states.noneCompleted), defaultLoad)
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/buildSettings.ts
const currentGameVersion = {
  major: 1,
  minor: 19,
  patch: 0,
  revision: 0,
  isBeta: false
};
const buildSettingsSharedFacetDefaultState = {
  isDevBuild: false,
  isEduBuild: false,
  isPreviewBuild: false,
  isBetaBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsDevBuild = {
  isDevBuild: true,
  isEduBuild: false,
  isPreviewBuild: false,
  isBetaBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsEduBuild = {
  isDevBuild: false,
  isEduBuild: true,
  isPreviewBuild: false,
  isBetaBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsPreviewBuild = {
  isDevBuild: false,
  isEduBuild: false,
  isPreviewBuild: true,
  isBetaBuild: false,
  currentGameVersion: currentGameVersion
};
const buildSettingsFacetIsBetaBuild = {
  isDevBuild: false,
  isEduBuild: false,
  isPreviewBuild: false,
  isBetaBuild: true,
  currentGameVersion: currentGameVersion
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/clipboard.ts
const clipboardSharedFacetDefaultState = {
  copyToClipboard: () => {}
};
// EXTERNAL MODULE: ./node_modules/ramda/src/mergeDeepRight.js
var mergeDeepRight = __webpack_require__(57046);
var mergeDeepRight_default = /*#__PURE__*/__webpack_require__.n(mergeDeepRight);
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/createNewWorld.ts


 // Internal helper functions

const initialGeneralData = {
  worldName: '',
  gameMode: GameMode.SURVIVAL,
  difficulty: DifficultyEnum.EASY
};
const initialBetaFeaturesData = [{
  id: '0',
  title: 'Caves and cliffs blocks',
  description: 'Goats, snowier snow and what else might lurk behind the next block?',
  isEnabled: false,
  category: ExperimentalFeatureCategory.GAMEPLAY
}, {
  id: '1',
  title: 'Cave generation',
  description: 'Explore the new varied cave generation',
  isEnabled: false,
  category: ExperimentalFeatureCategory.GAMEPLAY
}, {
  id: '2',
  title: 'Custom Biomes',
  description: 'Create custom biomes and change world generation in your add-ons',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '3',
  title: 'Additional modding capabilities',
  description: 'Doing a lot of repetitive things? This might help creating your add-on',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '4',
  title: 'GameTest Framework',
  description: 'What is this?',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}, {
  id: '5',
  title: 'Holiday Creator Features',
  description: 'Includes actor properties and data-driven fog volumes for add-ons',
  isEnabled: false,
  category: ExperimentalFeatureCategory.ADD_ON_CREATORS
}];
const initialAdvancedData = {
  useFlatWorld: false,
  // simulationDistance depends on a facet value from SimulationDistanceFacet
  simulationDistance: 8,
  startWithMap: false,
  bonusChest: false,
  showCoordinates: false,
  recipesUnlock: true,
  firesSpreads: true,
  tntExplodes: true,
  respawnBlocksExplode: true,
  mobLoot: true,
  naturalRegeneration: true,
  tileDrops: true,
  immediateRespawn: false,
  respawnRadius: '5',
  worldSeed: ''
};
const initialCreateNewWorldFacet = {
  createWorld_v2: () => {},
  createOnRealms_v2: () => {},
  clearErrors: () => {},
  unlockTemplateSettings: () => {},
  consumeResetFlag: false,
  isLockedTemplate: false,
  isUsingTemplate: false,
  isRandomSeedAllowed: false,
  isAchievementsDisabled: false,
  isEditorWorld: false,
  selectRealmToCreateOn: realmId => {
    console.log(realmId);
  },
  createWorldOnPreviewRealm: realmId => {
    console.log(realmId);
  },
  isCreatingWorld: false,
  applyTemplate: templateId => {
    return templateId;
  },
  applyTemplateProgress: FacetTaskProgress.IDLE,
  checkIfUserHasChangedSettings: () => true,
  levelId: '',
  showedAchievementWarning: false,
  inWorldCreation: false,
  worldPreviewImagePath: '',
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerSupported: true,
      playerPermissions: PlayerPermissions.MEMBER,
      multiplayerGame: true,
      playerAccess: PlayerAccess.FRIENDS,
      visibleToLanPlayers: true,
      friendlyFire: true,
      platformPlayerAccess: PlayerAccess.FRIENDS,
      platformPlayerAccessSupported: false,
      platformPlayerAccessEnabled: true,
      platformPlayerInviteAccessSupported: true
    },
    general: initialGeneralData,
    betaFeatures: initialBetaFeaturesData,
    cheats: {
      cheatsEnabled: false,
      commandsEnabled: true,
      daylightCycle: DaylightCycleEnum.NORMAL,
      keepInventory: false,
      mobSpawning: false,
      mobGriefing: false,
      entitiesDropLoot: false,
      weather: false,
      commandBlocks: false,
      educationEdition: false,
      tickSpeed: '1'
    },
    scriptingCoding: {
      codeBuilderEnabled: false
    },
    advanced: initialAdvancedData
  }
};

function createNewWorldData(overrides) {
  return mergeDeepRight_default()(initialCreateNewWorldFacet, overrides);
}

const createNewWorldSharedFacetDefaultState = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true,
      platformPlayerAccessSupported: true
    },
    cheats: {
      cheatsEnabled: false
    }
  }
});
const createNewWorldFacetMultiplayerEnabledState = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true
    }
  }
});
const createNewWorldFacetMultiplayerDisabledState = createNewWorldData({
  worldCreationData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: false
    }
  }
});
function createNewWorldFacetMultiplayerWarning(warning) {
  return createNewWorldData({
    worldCreationData: {
      multiplayer: {
        generalWarningState: warning,
        multiplayerGame: true
      }
    }
  });
}
const createNewWorldFacetCheatsEnabledState = createNewWorldData({
  worldCreationData: {
    cheats: {
      cheatsEnabled: true
    }
  },
  isAchievementsDisabled: true
});
const createNewWorldFacetCheatsDisabledState = createNewWorldData({
  worldCreationData: {
    cheats: {
      cheatsEnabled: false
    }
  }
}); // Create on realms: Fixtures for error modal specific variants

function createNewWorldFacetWithRealmsError(error) {
  return createNewWorldData({
    createOnRealmsError: error
  });
} // Create new world: Fixtures for error modal specific variants

function createNewWorldFacetWithCreateWorldError(error) {
  return createNewWorldData({
    createWorldError: error
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/createPreviewRealm.ts


const createPreviewRealmFacetDefaultState = {
  createPreviewRealmFromSubscriptionProgress: FacetTaskProgress.IDLE,
  createPreviewRealmFromSubscriptionResult: undefined,
  reset: () => {},
  getCreatedPreviewRealmId: () => '',
  activateNewPreviewRealm: isCreatingNewWorld => {
    console.log(isCreatingNewWorld);
  },
  createPreviewRealmFromSubscriptionId: selectedSubscriptionId => {
    console.log(selectedSubscriptionId);
  }
};
const createPreviewRealmFacetBusyState = {
  createPreviewRealmFromSubscriptionProgress: FacetTaskProgress.RUNNING,
  createPreviewRealmFromSubscriptionResult: CreatePreviewRealmFromSubscriptionResult.CreatingPreviewRealm,
  reset: () => {},
  getCreatedPreviewRealmId: () => '',
  activateNewPreviewRealm: isCreatingNewWorld => {
    console.log(isCreatingNewWorld);
  },
  createPreviewRealmFromSubscriptionId: selectedSubscriptionId => {
    console.log(selectedSubscriptionId);
  }
};
const createPreviewRealmFacetRetrievingState = {
  createPreviewRealmFromSubscriptionProgress: FacetTaskProgress.RUNNING,
  createPreviewRealmFromSubscriptionResult: CreatePreviewRealmFromSubscriptionResult.RetrievingCreatedPreviewRealm,
  reset: () => {},
  getCreatedPreviewRealmId: () => '',
  activateNewPreviewRealm: isCreatingNewWorld => {
    console.log(isCreatingNewWorld);
  },
  createPreviewRealmFromSubscriptionId: selectedSubscriptionId => {
    console.log(selectedSubscriptionId);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/debugSettings.ts

const allBiomes = [{
  label: 'Nether 1',
  id: 0,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 2',
  id: 1,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 3',
  id: 2,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Nether 4',
  id: 3,
  dimension: BiomeDimension.NETHER
}, {
  label: 'Random overworld biome',
  id: 4,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 2',
  id: 5,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 3',
  id: 6,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 4',
  id: 7,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 5',
  id: 8,
  dimension: BiomeDimension.OVERWORLD
}, {
  label: 'Overworld 6',
  id: 9,
  dimension: BiomeDimension.OVERWORLD
}];
const debugSettingsSharedFacetDefaultState = {
  flatNether: false,
  enableGameVersionOverride: false,
  gameVersionOverride: '',
  spawnDimensionId: 0,
  spawnBiomeId: 0,
  biomeOverrideId: 0,
  allBiomes: allBiomes,
  defaultSpawnBiome: true,
  isBiomeOverrideActive: false
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldEditor.ts




const worldEditorSharedFacetDefaultState = {
  currentWorldId: 'world-id-fixture',
  closeWorld: () => {},
  loadWorld: () => undefined,
  worldData: {
    general: {
      worldName: 'my own world',
      gameMode: GameMode.SURVIVAL,
      difficulty: DifficultyEnum.EASY
    },
    advanced: {
      worldSeed: '54MP1E5EED',
      useFlatWorld: false,
      startWithMap: false,
      bonusChest: false,
      showCoordinates: false,
      recipesUnlock: false,
      firesSpreads: true,
      tntExplodes: true,
      respawnBlocksExplode: true,
      mobLoot: true,
      naturalRegeneration: true,
      tileDrops: true,
      immediateRespawn: false,
      respawnRadius: '5',
      simulationDistance: 8
    },
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerSupported: true,
      playerPermissions: PlayerPermissions.MEMBER,
      multiplayerGame: true,
      playerAccess: PlayerAccess.FRIENDS,
      visibleToLanPlayers: true,
      friendlyFire: true,
      platformPlayerAccess: PlayerAccess.FRIENDS,
      platformPlayerAccessSupported: false,
      platformPlayerAccessEnabled: true,
      platformPlayerInviteAccessSupported: true
    },
    cheats: {
      cheatsEnabled: false,
      commandsEnabled: true,
      daylightCycle: DaylightCycleEnum.NORMAL,
      keepInventory: false,
      mobSpawning: false,
      mobGriefing: false,
      entitiesDropLoot: false,
      weather: false,
      commandBlocks: false,
      educationEdition: false,
      tickSpeed: '1'
    },
    betaFeatures: initialBetaFeaturesData,
    lockedTemplate: false,
    isUsingTemplate: false
  },
  worldSummary: {
    fileSize: '300 MB',
    lastPlayed: '2 Jan 2023',
    worldIconPath: ''
  },
  isAchievementsEditDisabled: false,
  worldIsInitialized: true,
  addWorld: () => {},
  startSaveLocalWorld: () => {},
  clearSaveLocalWorld: () => {},
  saveLocalWorldError: undefined,
  saveLocalWorldProgress: FacetTaskProgress.IDLE,
  isEditorWorld: false,
  worldHasBeenModified: false,
  reloadWorld: () => {}
};

function worldEditorData(overrides) {
  return mergeDeepRight_default()(worldEditorSharedFacetDefaultState, overrides);
}

const worldEditorFacetCheatsEnabled = worldEditorData({
  isAchievementsEditDisabled: true,
  worldData: {
    cheats: {
      cheatsEnabled: true
    }
  }
});
const worldEditorFacetCheatsDisabled = worldEditorData({
  worldData: {
    cheats: {
      cheatsEnabled: false
    }
  }
});
const worldEditorFacetMultiplayerEnabledState = worldEditorData({
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: true
    }
  }
});
const worldEditorFacetMultiplayerDisabledState = worldEditorData({
  worldData: {
    multiplayer: {
      generalWarningState: GeneralMultiplayerWarningStateEnum.NONE,
      multiplayerGame: false
    }
  }
});
const worldEditorSharedFacetError = worldEditorData({
  saveLocalWorldError: WriteWorldError.IncorrectWorldId
});
function worldEditorFacetMultiplayerWarning(warning) {
  return worldEditorData({
    worldData: {
      multiplayer: {
        generalWarningState: warning,
        multiplayerGame: true
      }
    }
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/familyMembersList.ts
const familyMembersListFacetDefaultState = {
  playerList: [{
    xuid: '0',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '1',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: true,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '2',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '3',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: true,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '4',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '5',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '6',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '7',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '8',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/followersList.ts
const followersListFacetDefaultState = {
  playerList: [{
    xuid: '0',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '1',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '2',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '3',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '4',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '5',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '6',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '7',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '8',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '9',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '10',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '11',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '12',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '13',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '14',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '15',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '16',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '17',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '18',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/images/avatar_example.png
const avatar_example_namespaceObject = __webpack_require__.p + "assets/avatar_example-a39ca.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/images/xbox_avatar_example.png
const xbox_avatar_example_namespaceObject = __webpack_require__.p + "assets/xbox_avatar_example-be671.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/friendsList.ts



const mockFriends = [{
  xuid: '0',
  gamerTag: 'OnlineFriend_a',
  gamerIcon: avatar_example_namespaceObject,
  isOnline: true,
  playingOnServerId: undefined,
  isCurrentlyPlaying: true,
  titleHistory: PlayerTitleHistory.HasPlayed
}, {
  xuid: '0',
  gamerTag: 'OnlineFriend_b',
  gamerIcon: xbox_avatar_example_namespaceObject,
  isOnline: true,
  playingOnServerId: undefined,
  isCurrentlyPlaying: false,
  titleHistory: PlayerTitleHistory.NotPlayed
}, {
  xuid: '1',
  gamerTag: 'OnlineFriend_b',
  gamerIcon: xbox_avatar_example_namespaceObject,
  isOnline: true,
  playingOnServerId: '1',
  isCurrentlyPlaying: true,
  titleHistory: PlayerTitleHistory.HasPlayed
}, {
  xuid: '2',
  gamerTag: 'OnlineFriend_c',
  gamerIcon: avatar_example_namespaceObject,
  playingOnServerId: '2',
  isOnline: true,
  isCurrentlyPlaying: true,
  titleHistory: PlayerTitleHistory.HasPlayed
}, {
  xuid: '3',
  gamerTag: 'OnlineFriend_d',
  gamerIcon: avatar_example_namespaceObject,
  playingOnServerId: undefined,
  isOnline: true,
  isCurrentlyPlaying: true,
  titleHistory: PlayerTitleHistory.HasPlayed
}, {
  xuid: '4',
  gamerTag: 'OfflineFriend_a',
  gamerIcon: avatar_example_namespaceObject,
  playingOnServerId: undefined,
  isOnline: false,
  isCurrentlyPlaying: false,
  titleHistory: PlayerTitleHistory.NotPlayed
}, {
  xuid: '5',
  gamerTag: 'OfflineFriend_b',
  gamerIcon: xbox_avatar_example_namespaceObject,
  playingOnServerId: undefined,
  isOnline: false,
  isCurrentlyPlaying: false,
  titleHistory: PlayerTitleHistory.HasPlayed
}];
const friendsListFacetDefaultState = {
  isLoaded: true,
  friends: mockFriends
};
const friendsListFacetEmptyState = {
  isLoaded: true,
  friends: []
};
const friendsListFacetLoadingState = {
  isLoaded: false,
  friends: mockFriends
};
const friendsListFacetManyFriendsState = {
  isLoaded: true,
  friends: Array.from(Array(60).keys()).map(index => {
    return {
      xuid: `${index + 4}`,
      gamerTag: `OnlineFriend_b_${index + 4}`,
      gamerIcon: xbox_avatar_example_namespaceObject,
      isOnline: index < 30,
      isCurrentlyPlaying: false,
      titleHistory: PlayerTitleHistory.HasPlayed
    };
  })
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/friendsManager.ts
const friendsManagerFacetDefaultState = {
  acceptRequest: playerId => {
    console.log('Accepted player: ', playerId);
  },
  rejectRequest: playerId => {
    console.log('Rejected player: ', playerId);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/announcementImages/index.ts
const announcementImages = [__webpack_require__(76243), __webpack_require__(54705)];
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/inbox.ts


const inbox_ONE_WEEK = 604800;
const ONE_DAY = 86400;
const singleNullImageList = [{
  id: '',
  url: '',
  isLoaded: true
}];
const singleNullButtonList = [{
  id: '',
  text: '',
  reportClick: () => null
}];
const exampleImages = [{
  id: 'Primary',
  url: announcementImages[0],
  isLoaded: true
}, {
  id: 'Secondary',
  url: announcementImages[1],
  isLoaded: true
}, {
  id: 'Primary',
  url: announcementImages[1],
  isLoaded: true
}];
const longContent = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut lectus arcu bibendum at varius vel. Dolor sit amet consectetur adipiscing elit. Ut faucibus pulvinar elementum integer enim neque volutpat ac tincidunt. Morbi tristique senectus et netus et malesuada. Id venenatis a condimentum vitae. Nibh ipsum consequat nisl vel pretium lectus quam id. Nibh tellus molestie nunc non blandit massa enim nec. Nibh nisl condimentum id venenatis. Et malesuada fames ac turpis. Aliquam nulla facilisi cras fermentum odio eu feugiat pretium nibh. Vivamus at augue eget arcu. Porttitor massa id neque aliquam vestibulum morbi blandit. Mauris pharetra et ultrices neque ornare aenean euismod elementum. Facilisis volutpat est velit egestas dui id ornare arcu odio. Phasellus faucibus scelerisque eleifend donec. Semper auctor neque vitae tempus quam pellentesque nec nam aliquam. Tellus mauris a diam maecenas sed. Porttitor massa id neque aliquam vestibulum morbi blandit cursus risus. Pellentesque eu tincidunt tortor aliquam nulla facilisi cras.\
Dolor morbi non arcu risus quis varius quam. Scelerisque eleifend donec pretium vulputate sapien. Eget est lorem ipsum dolor sit amet consectetur adipiscing elit. Amet est placerat in egestas erat imperdiet sed euismod. Vestibulum morbi blandit cursus risus. Ac odio tempor orci dapibus ultrices in iaculis nunc sed. Adipiscing elit pellentesque habitant morbi tristique senectus. Mi in nulla posuere sollicitudin aliquam. Molestie a iaculis at erat pellentesque. Eu volutpat odio facilisis mauris sit amet massa vitae tortor. Et leo duis ut diam. Cursus sit amet dictum sit amet justo donec enim. Faucibus ornare suspendisse sed nisi lacus sed.\
Mauris sit amet massa vitae tortor condimentum lacinia. Pellentesque massa placerat duis ultricies lacus sed turpis tincidunt id. Elementum curabitur vitae nunc sed velit dignissim sodales ut eu. Morbi tristique senectus et netus et malesuada fames. Iaculis eu non diam phasellus vestibulum lorem sed risus ultricies. Lectus sit amet est placerat in egestas. Tellus in hac habitasse platea dictumst vestibulum. Cursus in hac habitasse platea dictumst quisque sagittis purus sit. Mattis pellentesque id nibh tortor id aliquet. Dictum sit amet justo donec enim. Ut diam quam nulla porttitor massa id neque aliquam. Nisi quis eleifend quam adipiscing vitae. Maecenas volutpat blandit aliquam etiam erat. Dolor morbi non arcu risus quis varius quam. Viverra adipiscing at in tellus integer feugiat scelerisque. Sapien et ligula ullamcorper malesuada proin libero nunc consequat.\
Diam quam nulla porttitor massa id. Fermentum odio eu feugiat pretium nibh ipsum consequat nisl vel. Quis viverra nibh cras pulvinar mattis nunc sed. Consequat interdum varius sit amet mattis vulputate enim nulla. Bibendum ut tristique et egestas quis. Euismod nisi porta lorem mollis aliquam ut porttitor. Justo donec enim diam vulputate ut pharetra sit amet. Sagittis vitae et leo duis ut diam. Erat velit scelerisque in dictum. Interdum posuere lorem ipsum dolor sit. Nec tincidunt praesent semper feugiat. Metus aliquam eleifend mi in nulla posuere.\
Adipiscing tristique risus nec feugiat in fermentum. Nullam non nisi est sit amet facilisis magna etiam. Sit amet tellus cras adipiscing. Amet venenatis urna cursus eget. Ut porttitor leo a diam sollicitudin. Porta non pulvinar neque laoreet suspendisse. Scelerisque viverra mauris in aliquam sem. Aliquam vestibulum morbi blandit cursus risus at ultrices. Urna molestie at elementum eu facilisis sed odio morbi. Amet mattis vulputate enim nulla aliquet porttitor lacus luctus. Purus in massa tempor nec feugiat. Egestas sed sed risus pretium quam. Tempus quam pellentesque nec nam aliquam sem.';
const getTestData = [{
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '09/05/2023',
  title: 'News History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '0',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY - ONE_DAY,
  dateString: '09/05/2023',
  title: 'News History Test2 Long content',
  sender: 'Gamertag0123456',
  content: longContent,
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 3,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '1',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY,
  dateString: '09/05/2023',
  title: 'News Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 0,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '2',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK + ONE_DAY,
  dateString: '09/05/2023',
  title: 'Invite Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.ACCEPTED,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '3',
  images: singleNullImageList,
  buttons: []
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '09/05/2023',
  title: 'Invite History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.REJECTED,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '4',
  images: singleNullImageList,
  buttons: []
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - 4 * ONE_DAY,
  dateString: '09/05/2023',
  title: 'Invite Recent Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.ACCEPTED,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '5',
  images: singleNullImageList,
  buttons: []
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY - ONE_DAY,
  dateString: '09/05/2023',
  title: 'Invite History Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '6',
  images: singleNullImageList,
  buttons: []
}, {
  id: 'HistoryTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - inbox_ONE_WEEK - ONE_DAY,
  dateString: '11:39 am',
  title: 'Realms History Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 0,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '7',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY - ONE_DAY - ONE_DAY,
  dateString: '09/05/2023',
  title: 'Realms Recent Test1',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 4,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '8',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'RecentTestingValue',
  dateReceived: Math.floor(Date.now() / 1000) - ONE_DAY - ONE_DAY - ONE_DAY - ONE_DAY,
  dateString: '09/05/2023',
  title: 'Realms Recent Test2',
  sender: 'Gamertag0123456',
  content: 'ContentTest',
  read: true,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '9',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '09/05/2023',
  title: 'Message Details Test Title',
  sender: 'Gamertag0123456',
  content: 'This is the content portion of the Message details test message. Hopefully this renders correctly.',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '10',
  images: [exampleImages[0]],
  buttons: []
}, {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '09/05/2023',
  title: 'This title should not render',
  sender: 'Gamertag0123456',
  content: 'This content should not render. Should display realms message.',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.NONE,
  instanceId: '11',
  images: singleNullImageList,
  buttons: []
}, {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '11:35 am',
  dateLabel: 'Mon, Sep 5, 11:35 AM',
  title: 'Hero Image CTA Title',
  sender: 'Gamertag0123456',
  content: 'This is the content portion of the Hero Image CTA template. ',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.HEROIMAGECTA,
  instanceId: '12',
  images: singleNullImageList,
  buttons: [{
    id: '123',
    text: 'Click here!',
    link: 'http://www.minecraft.net',
    action: 'external',
    reportClick: function () {
      console.log('reportClick() called.');
    }
  }]
}, {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '11:35 am',
  dateLabel: 'Mon, Sep 5, 11:35 AM',
  title: 'Image Thumbnail CTA Title',
  sender: 'Gamertag0123456',
  content: 'This is the content portion of the Image Thumbnail CTA template. ',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.IMAGETNAILCTA,
  instanceId: '13',
  images: singleNullImageList,
  buttons: [{
    id: '123',
    text: 'Click here!',
    link: 'http://www.minecraft.net',
    action: 'external',
    reportClick: function () {
      console.log('reportClick() called.');
    }
  }]
}];
const getSortedTestData = {
  recent: [{
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK,
    dateString: '09/05/2023',
    title: 'Realms Invite',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.ACCEPTED,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 3,
    dateString: '09/05/2023',
    title: 'Timed Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: false,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE,
    inviteDaysLeft: 5,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 2,
    dateString: '09/05/2023',
    title: 'Expiring Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK - 3,
    dateString: '09/05/2023',
    title: 'Expired Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.REJECTED,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }],
  history: [{
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 8,
    dateString: '09/05/2023',
    title: 'Realms Invite',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.ACCEPTED,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 9,
    dateString: '09/05/2023',
    title: 'Timed Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: false,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 11,
    dateString: '09/05/2023',
    title: 'Expiring Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.NONE,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }, {
    id: 'TestingValue',
    dateReceived: inbox_ONE_WEEK + 10,
    dateString: '09/05/2023',
    title: 'Expired Event',
    sender: 'Gamertag0123456',
    content: 'ContentTest',
    read: true,
    invitationId: 'InvIdTest',
    announcementType: InboxMessageType.INVITES,
    imgSource: '',
    invType: InvitationType.REALMS,
    invStatus: InvitationStatus.EXPIRED,
    inviteDaysLeft: -2,
    template: InboxTemplate.IMAGETEXT,
    instanceId: '',
    images: singleNullImageList,
    buttons: []
  }]
};
const getInboxCounterData = {
  NEWS: 1,
  INVITES: 3,
  REALMS: 1
};
const inboxSharedFacetDefaultState = {
  inboxMessages: getTestData,
  realmsSubscriber: false,
  settings: {
    showInvitesBadges: false,
    showNewsBadges: false,
    showRealmsBadges: false,
    showOnlyFriendInvites: false,
    enableAll: false
  },
  deleteNotification: instanceId => {
    return instanceId;
  },
  markAllRead: function () {
    console.log('Mark All Read Clicked');
  },
  deleteAllRead: function () {
    console.log('Delete All Read Clicked');
  },
  saveSettings: function () {
    console.log('Save Settings Clicked');
  },
  setNotificationRead: id => {
    return id;
  },
  categoryUnreadMessages: getInboxCounterData,
  setInvitationStatus: function () {
    console.log('Set Invitation Status Clicked');
  },
  reloadInvites: function () {
    console.log('Reload Invites');
  }
};
const defaultMessage = {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '12/21/2023',
  title: 'Message Details Test Title',
  sender: 'Gamertag0123456',
  content: 'This is the content portion of the news message details test message.',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.NONE,
  instanceId: '10',
  images: singleNullImageList,
  buttons: []
};
const defaultInviteMessage = {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: '09/05/2023',
  title: 'This title should not render',
  sender: 'Gamertag0123456',
  content: 'This content should not render. Should display realms message.',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.INVITES,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.NONE,
  instanceId: '11',
  images: [{
    id: '',
    url: '',
    isLoaded: true
  }],
  buttons: []
};
const defaultRealmsMessage = {
  id: 'defaultMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: 'Mon, Sep 5, 11:35 AM',
  title: 'Realms message title',
  sender: 'Gamertag0123456',
  content: 'This is the content portion of the realms message details test message.',
  read: false,
  invitationId: '',
  announcementType: InboxMessageType.REALMS,
  imgSource: '',
  invType: InvitationType.REALMS,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.IMAGETEXT,
  instanceId: '12',
  images: [{
    id: '',
    url: '',
    isLoaded: true
  }],
  buttons: []
};
const defaultCTAMessage = {
  id: 'defaultCTAMessageId',
  dateReceived: inbox_ONE_WEEK - 3,
  dateString: 'Mon, Sep 5, 11:35 AM',
  title: 'This title should not render',
  sender: 'Gamertag0123456',
  content: 'This content should not render. Should display realms message.',
  read: false,
  invitationId: 'InvIdTest',
  announcementType: InboxMessageType.NEWS,
  imgSource: '',
  invType: InvitationType.NONE,
  invStatus: InvitationStatus.NONE,
  inviteDaysLeft: 5,
  template: InboxTemplate.IMAGETNAILCTA,
  instanceId: '13',
  images: [{
    id: '',
    url: '',
    isLoaded: true
  }, {
    id: '',
    url: '',
    isLoaded: true
  }],
  buttons: [{
    id: '',
    text: 'CTA Button',
    reportClick: () => console.log('clicked CTA button')
  }]
};
const inboxSharedFacetEmptySubbedState = {
  inboxMessages: [],
  realmsSubscriber: true,
  settings: {
    showInvitesBadges: false,
    showNewsBadges: false,
    showRealmsBadges: false,
    showOnlyFriendInvites: false,
    enableAll: false
  },
  deleteNotification: instanceId => {
    return instanceId;
  },
  markAllRead: function () {
    console.log('Mark All Read Clicked');
  },
  deleteAllRead: function () {
    console.log('Delete All Read Clicked');
  },
  saveSettings: function () {
    console.log('Save Settings Clicked');
  },
  setNotificationRead: id => {
    return id;
  },
  categoryUnreadMessages: getInboxCounterData,
  setInvitationStatus: function () {
    console.log('Set Invitation Status Clicked');
  },
  reloadInvites: function () {
    console.log('Reload Invites');
  }
};
const inboxSharedFacetEmptyNotSubbedState = {
  inboxMessages: [],
  realmsSubscriber: false,
  settings: {
    showInvitesBadges: false,
    showNewsBadges: false,
    showRealmsBadges: false,
    showOnlyFriendInvites: false,
    enableAll: false
  },
  deleteNotification: instanceId => {
    return instanceId;
  },
  markAllRead: function () {
    console.log('Mark All Read Clicked');
  },
  deleteAllRead: function () {
    console.log('Delete All Read Clicked');
  },
  saveSettings: function () {
    console.log('Save Settings Clicked');
  },
  setNotificationRead: id => {
    return id;
  },
  categoryUnreadMessages: getInboxCounterData,
  setInvitationStatus: function () {
    console.log('Set Invitation Status Clicked');
  },
  reloadInvites: function () {
    console.log('Reload Invites');
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/armor-trims-night.png
const armor_trims_night_namespaceObject = __webpack_require__.p + "assets/armor-trims-night-c2937.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/castle-village.jpg
const castle_village_namespaceObject = __webpack_require__.p + "assets/castle-village-8f6fa.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/desert-fauna.png
const desert_fauna_namespaceObject = __webpack_require__.p + "assets/desert-fauna-fd939.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/fake-world-preview.jpg
const fake_world_preview_namespaceObject = __webpack_require__.p + "assets/fake-world-preview-1eac4.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/grassland-pond.jpg
const grassland_pond_namespaceObject = __webpack_require__.p + "assets/grassland-pond-74fee.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/infinity-dungeon.jpg
const infinity_dungeon_namespaceObject = __webpack_require__.p + "assets/infinity-dungeon-45451.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/realms/nether-portal.jpg
const nether_portal_namespaceObject = __webpack_require__.p + "assets/nether-portal-9acc8.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/localScreenshots.ts







const CURRENT_TIME_SECONDS = Math.floor(Date.now() / 1000);
const YESTERDAY = CURRENT_TIME_SECONDS - 86400;
const STATIC_DATES = [1690020960, // July 22nd at 3:16pm (15:16)
1686365100, // June 9th 2023 at 08:20am (8:20)
1685322420, // May 28th 2023 at 6:07pm (18:07)
1681587000, // April 15th 2023 at 12:30pm (12:30)
1680246000 // March 31st 2023 at 12:00am (00:00)
];
const demoLocalScreenshots = [{
  image: armor_trims_night_namespaceObject,
  filePath: armor_trims_night_namespaceObject,
  lastModifiedTime: CURRENT_TIME_SECONDS,
  printableModifiedTime: 'Today at 10:30',
  valid: true
}, {
  image: desert_fauna_namespaceObject,
  filePath: desert_fauna_namespaceObject,
  lastModifiedTime: YESTERDAY,
  printableModifiedTime: 'Yesterday at 19:45',
  valid: true
}, {
  image: castle_village_namespaceObject,
  filePath: castle_village_namespaceObject,
  lastModifiedTime: STATIC_DATES[0],
  printableModifiedTime: '7/22/2023 at 15:16',
  valid: true
}, {
  image: nether_portal_namespaceObject,
  filePath: nether_portal_namespaceObject,
  lastModifiedTime: STATIC_DATES[1],
  printableModifiedTime: '6/09/2023 at 08:20',
  valid: true
}, {
  image: grassland_pond_namespaceObject,
  filePath: grassland_pond_namespaceObject,
  lastModifiedTime: STATIC_DATES[2],
  printableModifiedTime: '5/28/2023 at 18:07',
  valid: true
}, {
  image: infinity_dungeon_namespaceObject,
  filePath: infinity_dungeon_namespaceObject,
  lastModifiedTime: STATIC_DATES[3],
  printableModifiedTime: '4/15/2023 at 12:30',
  valid: true
}, {
  image: fake_world_preview_namespaceObject,
  filePath: fake_world_preview_namespaceObject,
  lastModifiedTime: STATIC_DATES[6],
  printableModifiedTime: '3/31/2023 at 00:00',
  valid: true
}];
const localScreenshotsSharedDefaultFacetState = {
  localScreenshots: demoLocalScreenshots
};
const localScreenshotsSharedEmptyState = {
  localScreenshots: []
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/abandoned-village.png
const abandoned_village_namespaceObject = __webpack_require__.p + "assets/abandoned-village-a58af.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/coastal-village.png
const coastal_village_namespaceObject = __webpack_require__.p + "assets/coastal-village-d7104.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/desert-village.png
const desert_village_namespaceObject = __webpack_require__.p + "assets/desert-village-c7d0b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-default.jpg
const seedTemplateImages_world_preview_default_namespaceObject = __webpack_require__.p + "assets/world-preview-default-03016.jpg";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/outpost-ahead.png
const outpost_ahead_namespaceObject = __webpack_require__.p + "assets/outpost-ahead-d8b8f.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-wrong-dimensions_1.png
const world_preview_wrong_dimensions_1_namespaceObject = __webpack_require__.p + "assets/world-preview-wrong-dimensions_1-29081.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/seedTemplateImages/world-preview-wrong-dimensions_2.png
const world_preview_wrong_dimensions_2_namespaceObject = __webpack_require__.p + "assets/world-preview-wrong-dimensions_2-2a704.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/localWorldList.ts








const localWorldList_currentGameVersion = {
  major: 1,
  minor: 19,
  patch: 0,
  revision: 0,
  isBeta: false
};
const oldGameVersion = {
  major: 1,
  minor: 18,
  patch: 0,
  revision: 0,
  isBeta: false
};
const preCavesAndCliffsVersion = {
  major: 1,
  minor: 15,
  patch: 0,
  revision: 0,
  isBeta: false
};
const noTemplateApplied = {
  major: 0,
  minor: 0,
  patch: 0,
  revision: 0,
  isBeta: false
};
const localWorldList_images = [seedTemplateImages_world_preview_default_namespaceObject, seedTemplateImages_world_preview_default_namespaceObject, abandoned_village_namespaceObject, world_preview_wrong_dimensions_1_namespaceObject, coastal_village_namespaceObject, desert_village_namespaceObject, seedTemplateImages_world_preview_default_namespaceObject, outpost_ahead_namespaceObject, world_preview_wrong_dimensions_2_namespaceObject];
const worldIDs = ['world-stored-in-cloud', 'failed-cloud-sync-world', 'L1XqY0sPAQA=', 'L1XqY0sPAQA=', 'L4XqY0sPAQA=', 'L5XqY0sPAQA=', 'L6XqY0sPAQA=', 'L7XqY0sPAQA=', 'bad-world', 'old-world', 'old-world-no-disk-space', 'old-world-unknown-error'];
const worldNames = ['World stored in cloud', 'Bad world stored in cloud', 'Fail to start after sync', 'My world', 'My world 2', 'My world but with a long name 3', 'My world 4', 'Copy My world', 'Experimental World', 'Old world', 'No storage old world', 'Generic error old world', 'Pre C&C World no disk space', 'Generic error pre C&C World'];
const gameVersion = [localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, localWorldList_currentGameVersion, oldGameVersion, oldGameVersion, oldGameVersion];
const isExperimental = [false, false, false, false, false, false, false, true, false];
const lastPlayedDates = [1665460196, 1665461196, 1665462196, 1665463196, 1665464196, 1665465196, 1665466196, 1665467196, 1665468196, 1665469196, 1665470196, 1665471196];
const defaultWorld = {
  id: 'generic-world-id',
  name: 'My world',
  lastPlayed: 1665460196,
  gameMode: 0,
  fileSize: '30 MB',
  previewImgPath: localWorldList_images[0],
  isExperimental: false,
  gameVersion: localWorldList_currentGameVersion,
  allContentOwned: true,
  templateVersion: localWorldList_currentGameVersion,
  isTemplateCompatibleWithAnyVersion: true
};
const preCCWorld = {
  id: worldIDs[0],
  name: 'My old world',
  lastPlayed: lastPlayedDates[0],
  gameMode: 2,
  fileSize: '30 MB',
  previewImgPath: localWorldList_images[0],
  isExperimental: false,
  gameVersion: preCavesAndCliffsVersion,
  allContentOwned: true,
  templateVersion: noTemplateApplied,
  isTemplateCompatibleWithAnyVersion: true
};
const worldInCloudStorage = {
  id: 'world-not-cloud-stored',
  name: 'World stored in the cloud',
  lastPlayed: 1665460196,
  gameMode: -1,
  fileSize: '30 MB',
  previewImgPath: undefined,
  isExperimental: false,
  gameVersion: localWorldList_currentGameVersion,
  templateVersion: localWorldList_currentGameVersion,
  allContentOwned: true,
  isTemplateCompatibleWithAnyVersion: true,
  requiresCloudSync: true
};
const defaultWorldList = [...new Array(12)].map((_, i) => ({
  id: worldIDs[i],
  name: worldNames[i],
  lastPlayed: lastPlayedDates[i],
  gameMode: i === 2 ? GameMode.UNKNOWN : i % 3,
  fileSize: '30 MB',
  previewImgPath: localWorldList_images[i % localWorldList_images.length],
  isExperimental: isExperimental[i],
  gameVersion: i > 8 ? preCavesAndCliffsVersion : localWorldList_currentGameVersion,
  allContentOwned: true,
  templateVersion: noTemplateApplied,
  isTemplateCompatibleWithAnyVersion: true,
  requiresCloudSync: worldIDs[i].includes('cloud')
}));
const cloudWorldList = [...new Array(11)].map((_, i) => ({
  id: worldIDs[i],
  name: worldNames[i],
  lastPlayed: lastPlayedDates[i],
  gameMode: i < 3 ? GameMode.UNKNOWN : GameMode.SURVIVAL,
  fileSize: '30 MB',
  previewImgPath: localWorldList_images[i % localWorldList_images.length],
  isExperimental: isExperimental[i],
  allContentOwned: true,
  gameVersion: i > 7 ? preCavesAndCliffsVersion : localWorldList_currentGameVersion,
  templateVersion: noTemplateApplied,
  isTemplateCompatibleWithAnyVersion: true,
  requiresCloudSync: i < 3 ? true : false
}));
const worldsMissingEntitlement = [...new Array(5)].map((_, i) => ({
  id: worldIDs[i],
  name: `World ${i + 1} missing entitlement `,
  lastPlayed: lastPlayedDates[i],
  gameMode: i % 3,
  fileSize: '30 MB',
  previewImgPath: localWorldList_images[i % localWorldList_images.length],
  isExperimental: isExperimental[i],
  gameVersion: gameVersion[i],
  allContentOwned: false,
  templateVersion: preCavesAndCliffsVersion,
  isTemplateCompatibleWithAnyVersion: true
}));
const localWorldListSharedFacetDefaultState = {
  localWorlds: defaultWorldList,
  otherStorageTypeHasWorlds: false
};
const localWorldListSharedFacetEmptyState = {
  localWorlds: [],
  otherStorageTypeHasWorlds: false
};
const localWorldListSharedFacetEmptyStateWorldsOnOtherStorage = {
  localWorlds: [],
  otherStorageTypeHasWorlds: true
};
const localWorldListSharedFacetWorldsOnOtherStorage = {
  localWorlds: defaultWorldList,
  otherStorageTypeHasWorlds: true
};
const localWorldListSharedFacetMissingEntitlementState = {
  localWorlds: worldsMissingEntitlement,
  otherStorageTypeHasWorlds: false
};
const localWorldListSharedFacetOlderThanCCState = {
  localWorlds: [preCCWorld],
  otherStorageTypeHasWorlds: false
};
const localWorldListSharedFacetCloudStored = {
  localWorlds: cloudWorldList,
  otherStorageTypeHasWorlds: false
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/marketplaceSuggestions.ts
const marketplaceSuggestionsSharedFacetDefaultState = {
  getMorePacks: {
    pageId: 'mock-id',
    title: 'Mock Title'
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/mutualFriendsList.ts
const mutualFriendsListFacetDefaultState = {
  playerList: [{
    xuid: '0',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '1',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '2',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '3',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '4',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '5',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '6',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '7',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '8',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '9',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '10',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '11',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '12',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '13',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '14',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '15',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '16',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '17',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '18',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '19',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '20',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/notifications.ts
const notificationsSharedFacetDefaultState = {
  queueSnackbar: msg => {
    console.log('Snack bar message: ', msg);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/options.ts
function options_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function options_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { options_ownKeys(Object(source), true).forEach(function (key) { options_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { options_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function options_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const optionsSharedFacetDefaultState = {
  renderDistance: 17,
  defaultRenderDistance: 8,
  maxRenderDistance: 16,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  useMobileDataOnce: false,
  playVideoInTouchControlSelectionScreen: true
};
const singularValuesOptionsFacet = options_objectSpread(options_objectSpread({}, optionsSharedFacetDefaultState), {}, {
  renderDistance: 1,
  defaultRenderDistance: 1,
  maxRenderDistance: 1,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  playVideoInTouchControlSelectionScreen: true
});
const lessThanMaxOptionsFacet = options_objectSpread(options_objectSpread({}, optionsSharedFacetDefaultState), {}, {
  renderDistance: 7,
  defaultRenderDistance: 5,
  maxRenderDistance: 10,
  showRenderDistanceWarningModal: true,
  touchControlScheme: TouchControlSchemeEnum.TOUCH,
  showTouchControlSelectionScreen: false,
  playVideoInTouchControlSelectionScreen: true
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerMessagingService.ts


const exampleLongText = 'The Caves & Cliffs: Part II update has arrived, bringing new features and more to explore!\n\n• Increased the world height and depth, adding 50% more vertical space to build and explore\n• New cave generation to explore below your existing worlds\n• New cave and mountain biomes like Lush Caves and Jagged Peaks\n• Fixed over 70 bugs, issues, and parity changes\n\nTo see the full changelog, head to aka.ms/MinecraftUpdate.\nPlease search for any bugs you find on bugs.mojang.com and let us know what you think at feedback.minecraft.net!';
const exampleButtons = [{
  id: 'Dismiss',
  text: '',
  link: '',
  action: 'dismiss',
  reportClick: () => {
    console.log(`Messaging Service - clicked Dismiss Button`);
  }
}, {
  id: 'CallToAction',
  text: '',
  link: 'ebbead54-7b4f-46ff-9839-e715e482a88d',
  action: 'productId',
  reportClick: () => {
    console.log(`Messaging Service - clicked Unlock Button`);
  }
}];
const playerMessagingService_exampleImages = [{
  id: 'Primary',
  url: announcementImages[0],
  isLoaded: true
}, {
  id: 'Secondary',
  url: announcementImages[1],
  isLoaded: true
}, {
  id: 'Primary',
  url: announcementImages[1],
  isLoaded: true
}];
const exampleAnnouncementMessages = [//template 1
{
  id: 'ImageText',
  surface: 'LoginAnnouncement',
  template: 'ImageText',
  header: '1.14.0 Update',
  body: exampleLongText,
  images: [playerMessagingService_exampleImages[0]],
  buttons: [exampleButtons[0]]
}, //template 2
{
  id: 'ImageThumbnailCTA',
  surface: 'LoginAnnouncement',
  template: 'ImageThumbnailCTA',
  header: 'Minecraft Spring Sale',
  body: exampleLongText,
  images: [playerMessagingService_exampleImages[0], playerMessagingService_exampleImages[1]],
  buttons: [exampleButtons[0], exampleButtons[1]]
}, //template 3
{
  id: 'HeroImageCTA',
  surface: 'LoginAnnouncement',
  template: 'HeroImageCTA',
  header: 'Special Gift',
  body: 'Dress up as a Nether denizen with this free pack!',
  images: [playerMessagingService_exampleImages[2]],
  buttons: [exampleButtons[0], exampleButtons[1]]
}];

function logClick(messageID, buttonID) {
  console.log(`Messaging Service - reporting click for message "${messageID}" on button "${buttonID}"`);
}

function logDismiss(messageID) {
  console.log(`Messaging Service - reporting dismiss for message "${messageID}"`);
} // The fixture data contains the basic versions of the message templates


const playerMessagingServiceSharedFacetDefaultState = {
  status: PlayerMessagingServiceFacetStatus.LOADED,
  data: {
    messageCount: exampleAnnouncementMessages.length,
    messages: Array.from(Array(exampleAnnouncementMessages.length).keys()).map(key => {
      const message = {
        id: exampleAnnouncementMessages[key].id,
        surface: exampleAnnouncementMessages[key].surface,
        template: exampleAnnouncementMessages[key].template,
        header: exampleAnnouncementMessages[key].header,
        body: exampleAnnouncementMessages[key].body,
        images: exampleAnnouncementMessages[key].images,
        buttons: exampleAnnouncementMessages[key].buttons
      };
      return message;
    })
  },
  reportClick: (messageID, buttonID) => {
    logClick(messageID, buttonID);
  },
  reportDismiss: messageID => {
    logDismiss(messageID);
  }
};
const playerMessagingServiceFacetLoading = {
  status: PlayerMessagingServiceFacetStatus.LOADING,
  data: {
    messageCount: 0,
    messages: []
  },
  reportClick: (messageID, buttonID) => {
    logClick(messageID, buttonID);
  },
  reportDismiss: messageID => {
    logDismiss(messageID);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerReport.ts
const playerReportFacetDefaultState = {
  isChatAvailable: () => {
    return true;
  },

  decideReportReasonOptions() {
    console.log('decideReportReasonOptions()');
  },

  reportPlayer: () => {
    console.log('reportPlayer()');
  },
  reportArea: 0,
  reportReason: 0,
  reportMessage: '',
  xuid: '',
  uuid: '',
  selectedChatMessages: [],
  reportableChatMessages: [{
    message: 'Hello there',
    author: 'Steve',
    isAuthorBeingReported: false
  }, {
    message: 'Yo',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'This is a fake message',
    author: 'Steve',
    isAuthorBeingReported: false
  }, {
    message: 'Very nice',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Test 123',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Lorem ipsum',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Hey',
    author: 'Alex',
    isAuthorBeingReported: true
  }, {
    message: 'Howdy',
    author: 'Grubba',
    isAuthorBeingReported: false
  }],
  // Note that the values in these options correspond with backend IDs
  reportAreaOptions: [{
    label: 'xbox.report.area.chat',
    value: 0
  }, {
    label: 'xbox.report.area.skin',
    value: 1
  }, {
    label: 'xbox.report.area.gameplay',
    value: 2
  }, {
    label: 'xbox.report.area.ingame',
    value: 3
  }, {
    label: 'xbox.report.area.nameOrGamertag',
    value: 4
  }, {
    label: 'xbox.report.area.other',
    value: 5
  }],
  reportReasonOptions: [{
    label: 'wantToReportThem',
    value: 11
  }, {
    label: 'hateSpeech',
    value: 8
  }, {
    label: 'bullying',
    value: 12
  }, {
    label: 'selfHarmOrSuicide',
    value: 13
  }, {
    label: 'sexuallyInappropriate',
    value: 14
  }, {
    label: 'imminentHarm',
    value: 9
  }, {
    label: 'unsportingBehavior',
    value: 4
  }, {
    label: 'cheating',
    value: 1
  }, {
    label: 'impersonation',
    value: 15
  }, {
    label: 'drugsOrAlcohol',
    value: 16
  }, {
    label: 'childSexualExploitationOrAbuse',
    value: 6
  }, {
    label: 'terrorismOrViolentExtremism',
    value: 7
  }, {
    label: 'nonConsensualIntimateImagery',
    value: 10
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/privacyAndOnlineSafety.ts
function privacyAndOnlineSafety_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function privacyAndOnlineSafety_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { privacyAndOnlineSafety_ownKeys(Object(source), true).forEach(function (key) { privacyAndOnlineSafety_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { privacyAndOnlineSafety_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function privacyAndOnlineSafety_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const privacyAndOnlineSafetySharedFacetDefaultState = {
  isCheckingCompleted: true,
  getClubCheckResult: true,
  getMultiplayerCheckResult: true,
  checkClubAndMultiplayerPermissions: () => {
    console.log('checking permissions!');
  }
};
const privacyAndOnlineSafetySharedFacetMultiplayerDisabledState = privacyAndOnlineSafety_objectSpread(privacyAndOnlineSafety_objectSpread({}, privacyAndOnlineSafetySharedFacetDefaultState), {}, {
  getClubCheckResult: true,
  getMultiplayerCheckResult: false
});
const privacyAndOnlineSafetySharedFacetClubDisabledState = privacyAndOnlineSafety_objectSpread(privacyAndOnlineSafety_objectSpread({}, privacyAndOnlineSafetySharedFacetDefaultState), {}, {
  getClubCheckResult: false,
  getMultiplayerCheckResult: true
});
const privacyAndOnlineSafetySharedFacetBothDisabledState = privacyAndOnlineSafety_objectSpread(privacyAndOnlineSafety_objectSpread({}, privacyAndOnlineSafetySharedFacetDefaultState), {}, {
  getClubCheckResult: false,
  getMultiplayerCheckResult: false
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/profanityFilter.ts
const profanityFilterDefaultState = {
  isProfanityInString: stringToCheck => {
    return !!stringToCheck && stringToCheck.includes('bummer');
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmActions.ts
const realmActionsSharedDefaultFacetState = {
  init: realmId => {
    console.log(realmId);
  },
  reset: () => {},
  postStory: () => {},
  clearPostStoryStatus: () => {},
  postComment: () => {},
  clearPostCommentStatus: () => {},
  fetchStories: () => {},
  fetchMembers: () => {},
  fetchStoryImage: storyId => {
    console.log(`Fetched image for story #${storyId}.`);
  },
  fetchStoryComments: storyId => {
    console.log(`Fetched comments for story #${storyId}.`);
  },
  setViewed: (feedItemId, parentId) => {
    if (parentId === '') {
      console.log(`Set story #${feedItemId} as viewed.`);
    } else {
      console.log(`Set comment #${feedItemId} of story #${parentId} as viewed.`);
    }
  },
  clearSetViewedStatus: feedItemId => {
    console.log(`The setViewed() post status of item #${feedItemId} has been reset.`);
  },
  toggleLike: (feedItemId, parentId) => {
    if (parentId === '') {
      console.log(`The "like" on story #${feedItemId} has been toggled.`);
    } else {
      console.log(`The "like" comment #${feedItemId} of story #${parentId} has been toggled.`);
    }
  },
  clearToggleLikeStatus: feedItemId => {
    console.log(`The toggleLike() post status of item #${feedItemId} has been reset.`);
  },
  delete: (feedItemId, parentId) => {
    if (parentId === '') {
      console.log(`Story #${feedItemId} has been deleted.`);
    } else {
      console.log(`Comment #${feedItemId} of story #${parentId} has been deleted.`);
    }
  },
  clearDeleteStatus: feedItemId => {
    console.log(`The delete() post status of realms stories item #${feedItemId} has been reset.`);
  },
  reportToClubOwner: (feedItemId, parentId) => {
    if (parentId === '') {
      console.log(`Story #${feedItemId} has been reported to the club owner.`);
    } else {
      console.log(`Comment #${feedItemId} of story #${parentId} has been reported to the club owner.`);
    }
  },
  clearReportToClubOwnerStatus: feedItemId => {
    console.log(`The reportToClubOwner() post status of realms stories item #${feedItemId} has been reset.`);
  },
  reportToXbox: (feedItemId, parentId) => {
    if (parentId === '') {
      console.log(`Story #${feedItemId} has been reported to xbox.`);
    } else {
      console.log(`Comment #${feedItemId} of story #${parentId} has been reported to xbox.`);
    }
  },
  clearReportToXboxStatus: feedItemId => {
    console.log(`The reportToXbox() post status of realms stories item #${feedItemId} has been reset.`);
  },
  setRealmsOptInStatus: state => {
    console.log(state);
  },
  setPlayerOptInStatus: state => {
    console.log(state);
  },
  setRealmEventsStatus: state => {
    console.log(state);
  },
  setRealmTimelineStatus: state => {
    console.log(state);
  },
  setRealmCoordinatesStatus: state => {
    console.log(state);
  },
  setRealmNotificationStatus: state => {
    console.log(state);
  },
  postSettings: () => {
    console.log('posted');
  },
  postSettingsOnExit: () => {
    console.log('posted on exit');
  },
  fetchSettings: () => {
    console.log('fetched');
  },
  clearSettingsStatus: () => {
    console.log(`The POST and FETCH status of realms stories settings has been reset.`);
  },
  openManageMembersScreen: () => {
    console.log('Opened Manage Members Screen');
  },
  loadStoriesSlice: (from, to) => {
    console.log(`get stories from index ${from} to ${to}`);
  }
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmData.ts
const realmDataSharedDefaultFacetState = {
  name: 'Ore-UI Debug Realm',
  description: 'Test realm, please ignore',
  ownerXuid: '1playeruno6885',
  userXuid: '6deviouslich7737',
  isRealmWorldValid: true,
  isFetchingRealmWorld: false
};
const realmDataSharedMemberFacetState = {
  name: 'Ore-UI Debug Realm',
  description: 'Test realm, please ignore',
  ownerXuid: '0',
  userXuid: '1',
  isRealmWorldValid: true,
  isFetchingRealmWorld: false
};
const realmDataFetchingWorldFacetState = {
  name: 'Ore-UI Debug Realm',
  description: 'Test realm, please ignore',
  ownerXuid: '0',
  userXuid: '1',
  isRealmWorldValid: false,
  isFetchingRealmWorld: true
};
const realmDataWorldInvalidFacetState = {
  name: 'Ore-UI Debug Realm',
  description: 'Test realm, please ignore',
  ownerXuid: '0',
  userXuid: '1',
  isRealmWorldValid: false,
  isFetchingRealmWorld: false
};
const realmDataSharedOwnerFacetState = {
  name: 'Ore-UI Debug Realm',
  description: 'Test realm, please ignore',
  ownerXuid: '1playeruno6885',
  userXuid: '1playeruno6885',
  isRealmWorldValid: true,
  isFetchingRealmWorld: false
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmList.ts

const realmListFacetDefaultState = {
  forceFetchRealmList: () => {},
  realms: [{
    id: 'test_0',
    realmName: 'preview realm 0',
    slotName: 'My World 0',
    maxPlayers: 2,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_1',
    realmName: 'preview realm 1',
    slotName: 'My World 1',
    maxPlayers: 10,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }],
  unpairedParentRealms: [{
    id: 'test_2',
    realmName: 'retail realm 2',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: false,
    expired: false
  }, {
    id: 'test_3',
    realmName: 'retail realm 3',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_4',
    realmName: 'retail realm 4',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_5',
    realmName: 'retail realm 5',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: true
  }, {
    id: 'test_6',
    realmName: 'retail realm 6',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_7',
    realmName: 'retail realm 7',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }],
  isLoading: false
};
const realmListFacetNoMoreUnpairedParentState = {
  forceFetchRealmList: () => {},
  realms: [{
    id: 'test_0',
    realmName: 'preview realm 0',
    slotName: 'My World 0',
    maxPlayers: 2,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_1',
    realmName: 'preview realm 1',
    slotName: 'My World 1',
    maxPlayers: 10,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }],
  unpairedParentRealms: [],
  isLoading: false
};
const realmListFacetNoPreviewState = {
  forceFetchRealmList: () => {},
  realms: [],
  unpairedParentRealms: [{
    id: 'test_2',
    realmName: 'retail realm 2',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: false,
    expired: false
  }, {
    id: 'test_3',
    realmName: 'retail realm 3',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_4',
    realmName: 'retail realm 4',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_5',
    realmName: 'retail realm 5',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: true
  }, {
    id: 'test_6',
    realmName: 'retail realm 6',
    slotName: '',
    maxPlayers: 2,
    gameMode: GameMode.SURVIVAL,
    isInitialized: true,
    isOwner: true,
    expired: false
  }, {
    id: 'test_7',
    realmName: 'retail realm 7',
    slotName: '',
    maxPlayers: 10,
    gameMode: GameMode.CREATIVE,
    isInitialized: true,
    isOwner: true,
    expired: false
  }],
  isLoading: false
};
const realmListFacetLoadingState = {
  forceFetchRealmList: () => {},
  realms: [],
  unpairedParentRealms: [],
  isLoading: true
};
const realmListFacetNonSubscriber = {
  forceFetchRealmList: () => {},
  realms: [],
  unpairedParentRealms: [],
  isLoading: true
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmMembersList.ts
const realmMembersListFacetDefaultState = {
  playerList: [{
    xuid: '0',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '1',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '2',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '3',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmPersistentData.ts


const realmPersistentDataSharedDefaultFacetState = {
  currentStoryId: '',
  postInProgressBody: '',
  storyScreenshotSelectionFilePath: '',
  currentMemberSearchText: '',
  currentMemberFilterOption: RealmMemberFilterOption.All,
  currentMemberSortOption: RealmMemberSortOption.MostRecent
};
const realmPersistentDataStoryImageFacetState = {
  currentStoryId: '',
  postInProgressBody: '',
  storyScreenshotSelectionFilePath: desert_fauna_namespaceObject,
  currentMemberSearchText: '',
  currentMemberFilterOption: RealmMemberFilterOption.All,
  currentMemberSortOption: RealmMemberSortOption.MostRecent
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/helpers/realmStoriesHelpers.ts
const DEMO_PLAYER_GAMER_TAGS = [{
  xuid: '7binghost9319',
  gamerTag: 'Binghost',
  hasOptedIn: true
}, {
  xuid: '8caribooboo6062',
  gamerTag: 'Caribooboo',
  hasOptedIn: true
}, {
  xuid: '9thortoise8029',
  gamerTag: 'Thortoise',
  hasOptedIn: true
}, {
  xuid: '10patrio9912',
  gamerTag: 'Patrio',
  hasOptedIn: true
}, {
  xuid: '11elegantplant5318',
  gamerTag: 'ElegantPlant',
  hasOptedIn: true
}, {
  xuid: '12musicdove4100',
  gamerTag: 'MusicDove',
  hasOptedIn: true
}, {
  xuid: '13funkydonkey2057',
  gamerTag: 'FunkyDonkey',
  hasOptedIn: true
}, {
  xuid: '14rundownjonny8780',
  gamerTag: 'RundownJonny',
  hasOptedIn: true
}, {
  xuid: '15steamlarva4716',
  gamerTag: 'SteamLarva',
  hasOptedIn: true
}, {
  xuid: '16albin078225',
  gamerTag: 'Albin07',
  hasOptedIn: true
}, {
  xuid: '17starfishht3954',
  gamerTag: 'Starfishht',
  hasOptedIn: true
}, {
  xuid: '18zebrawl8442',
  gamerTag: 'Zebrawl',
  hasOptedIn: true
}, {
  xuid: '19bachelord1060',
  gamerTag: 'Bachelord',
  hasOptedIn: true
}, {
  xuid: '20onionknight8159',
  gamerTag: 'OnionKnight',
  hasOptedIn: true
}, {
  xuid: '21crookedmelon7867',
  gamerTag: 'CrookedMelon',
  hasOptedIn: true
}, {
  xuid: '22vainduckling8870',
  gamerTag: 'VainDuckling',
  hasOptedIn: true
}, {
  xuid: '23controlsage9659',
  gamerTag: 'ControlSage',
  hasOptedIn: true
}, {
  xuid: '24firsthaunt4398',
  gamerTag: 'FirstHaunt',
  hasOptedIn: true
}, {
  xuid: '25showbirdie5275',
  gamerTag: 'ShowBirdie',
  hasOptedIn: true
}, {
  xuid: '26wimpeee1124',
  gamerTag: 'Wimpeee',
  hasOptedIn: true
}, {
  xuid: '27geishadow4652',
  gamerTag: 'Geishadow',
  hasOptedIn: true
}, {
  xuid: '28kaosdragon6485',
  gamerTag: 'KaosDragon',
  hasOptedIn: true
}, {
  xuid: '29donkiwi5383',
  gamerTag: 'DonKiwi',
  hasOptedIn: true
}, {
  xuid: '30falconartist4153',
  gamerTag: 'Falconartist',
  hasOptedIn: true
}, {
  xuid: '31blandwarlock7682',
  gamerTag: 'BlandWarlock',
  hasOptedIn: true
}, {
  xuid: '32ickyox4616',
  gamerTag: 'IckyOx',
  hasOptedIn: true
}, {
  xuid: '33quinn20008914',
  gamerTag: 'Quinn2000',
  hasOptedIn: true
}, {
  xuid: '34laserwarhawk3476',
  gamerTag: 'LaserWarhawk',
  hasOptedIn: true
}, {
  xuid: '35jellybeaver7360',
  gamerTag: 'JellyBeaver',
  hasOptedIn: true
}, {
  xuid: '36farmelf9898',
  gamerTag: 'FarmElf',
  hasOptedIn: true
}, {
  xuid: '37antiger3437',
  gamerTag: 'Antiger',
  hasOptedIn: true
}, {
  xuid: '38pionearly5777',
  gamerTag: 'Pionearly',
  hasOptedIn: true
}, {
  xuid: '39gamermaid2418',
  gamerTag: 'Gamermaid',
  hasOptedIn: true
}, {
  xuid: '40armydillo1136',
  gamerTag: 'Armydillo',
  hasOptedIn: true
}, {
  xuid: '41nosyvillager5294',
  gamerTag: 'NosyVillager',
  hasOptedIn: true
}, {
  xuid: '42marblehornet4463',
  gamerTag: 'MarbleHornet',
  hasOptedIn: true
}, {
  xuid: '43xtremekeith2010',
  gamerTag: 'XtremeKeith',
  hasOptedIn: true
}, {
  xuid: '44luchabeetle6104',
  gamerTag: 'LuchaBeetle',
  hasOptedIn: true
}, {
  xuid: '45rabidraccoon6769',
  gamerTag: 'RabidRaccoon',
  hasOptedIn: true
}, {
  xuid: '46beesdotgov3023',
  gamerTag: 'BeesDotGov',
  hasOptedIn: true
}, {
  xuid: '47spaladin8799',
  gamerTag: 'Spaladin',
  hasOptedIn: true
}, {
  xuid: '48beastlee2764',
  gamerTag: 'BeastLee',
  hasOptedIn: true
}, {
  xuid: '49cyborne2399',
  gamerTag: 'Cyborne',
  hasOptedIn: true
}, {
  xuid: '50vipersia4848',
  gamerTag: 'Vipersia',
  hasOptedIn: true
}, {
  xuid: '51advicedwarf4426',
  gamerTag: 'AdviceDwarf',
  hasOptedIn: true
}, {
  xuid: '52lasermantis5516',
  gamerTag: 'LaserMantis',
  hasOptedIn: true
}, {
  xuid: '53yungbevy1657',
  gamerTag: 'YungBevy',
  hasOptedIn: true
}, {
  xuid: '54formalwarden1321',
  gamerTag: 'FormalWarden',
  hasOptedIn: true
}, {
  xuid: '55uthando7170',
  gamerTag: 'Uthando',
  hasOptedIn: true
}, {
  xuid: '56ofcourseiluvu4891',
  gamerTag: 'OfCourseILuvU',
  hasOptedIn: true
}, {
  xuid: '57nomomicantpause6011',
  gamerTag: 'NoMomICantPause',
  hasOptedIn: true
}, {
  xuid: '58marshmadness3056',
  gamerTag: 'MarshMadness',
  hasOptedIn: true
}, {
  xuid: '59tolietcommander5744',
  gamerTag: 'TolietCommander',
  hasOptedIn: true
}, {
  xuid: '60emotionalbear3408',
  gamerTag: 'EmotionalBear',
  hasOptedIn: false
}, {
  xuid: '61sneakypete5688',
  gamerTag: 'SneakyPete',
  hasOptedIn: false
}, {
  xuid: '62lockedcharcter6577',
  gamerTag: 'LockedCharcter',
  hasOptedIn: false
}, {
  xuid: '63captparanoid7953',
  gamerTag: 'CaptParanoid',
  hasOptedIn: false
}, {
  xuid: '64l33tg4m3r2661',
  gamerTag: 'L33tG4M3R',
  hasOptedIn: false
}, {
  xuid: '65dontatme5607',
  gamerTag: 'DontAtMe',
  hasOptedIn: false
}];
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmSessions.ts

const TEST_DATE = 1691240400000; // Fixed date for when the logic is run in test environment. Make sure to pick a time where daylight savings don't occur in the past 7 days wherever we're running the test from (e.g. August, January).

function session(xuid, loginSegmentsAgo, logoutSegmentsAgo) {
  return {
    userXuid: xuid,
    login: loginSegmentsAgo,
    logout: logoutSegmentsAgo
  };
}

function userSessionsFor(xuid, numberOfSessions, sessionDuration, sessionSeparation, offset, currentDate) {
  const array = [];

  for (let i = numberOfSessions - 1; i >= 0; i--) {
    const startDate = new Date();
    startDate.setTime((currentDate - (offset + i * (sessionDuration + sessionSeparation) + sessionDuration)) * 1000);
    const endDate = new Date();
    endDate.setTime((currentDate - (offset + i * (sessionDuration + sessionSeparation))) * 1000);
    array.push(session(xuid, startDate.getTime() / 1000, endDate.getTime() / 1000));
  }

  return array;
}

const sampleCurrentDate = ( false ? 0 : new Date().getTime()) / 1000;
const realmSessionsSharedDefaultFacetState = {
  sessions: [...userSessionsFor('1playeruno6885', 60, 10800, 86400, 0, sampleCurrentDate), ...userSessionsFor('2alexandria3603', 60, 21600, 86400, 0, sampleCurrentDate), ...userSessionsFor('3doom3rboi4114', 60, 14400, 28800, 0, sampleCurrentDate), ...userSessionsFor('5piggysmalls8926', 60, 3600, 10800, 0, sampleCurrentDate), ...userSessionsFor('6deviouslich7737', 60, 28800, 86400, 7200, sampleCurrentDate), ...userSessionsFor('4forkknife6387', 60, 57600, 86400, 3600, sampleCurrentDate), ...userSessionsFor('0LeaveMeAnon1243', 60, 3600, 86400, 172800, sampleCurrentDate)],
  fetchSessionStatus: FetchStatus.Success
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-alex.png
const gamer_icon_alex_namespaceObject = __webpack_require__.p + "assets/gamer-icon-alex-d725b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-creeper.png
const gamer_icon_creeper_namespaceObject = __webpack_require__.p + "assets/gamer-icon-creeper-ff16b.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-enderman.png
const gamer_icon_enderman_namespaceObject = __webpack_require__.p + "assets/gamer-icon-enderman-4ae2c.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-pig.png
const gamer_icon_pig_namespaceObject = __webpack_require__.p + "assets/gamer-icon-pig-04391.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-sheep.png
const gamer_icon_sheep_namespaceObject = __webpack_require__.p + "assets/gamer-icon-sheep-6f790.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/gamer-icons/gamer-icon-steve.png
const gamer_icon_steve_namespaceObject = __webpack_require__.p + "assets/gamer-icon-steve-db6c7.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmPlayers.ts











const GAMER_ICONS = [gamer_icon_alex_namespaceObject, gamer_icon_creeper_namespaceObject, gamer_icon_enderman_namespaceObject, gamer_icon_pig_namespaceObject, gamer_icon_sheep_namespaceObject, gamer_icon_steve_namespaceObject, gamer_icon_villager_namespaceObject];
const realmPlayers_CURRENT_TIME_SECONDS = Math.floor(new Date().getTime() / 1000);
const THIRTY_MINUTES_SECONDS = 1800;

function realmPlayer({
  xuid,
  gamerTag,
  gamerIcon,
  role,
  isOnline,
  hasOptedIn
}) {
  const sessions = realmSessionsSharedDefaultFacetState.sessions.filter(session => session.userXuid === xuid);
  const lastSeenTime = sessions.length > 0 ? sessions[sessions.length - 1].logout : 0;
  return {
    xuid,
    gamerTag,
    gamerIcon,
    role,
    isOnline,
    fetchProfileStatus: FetchStatus.Success,
    lastSeenTime,
    hasOptedIn
  };
}

const realmPlayerOperators = [realmPlayer({
  xuid: '1playeruno6885',
  gamerTag: 'PlayerUno',
  gamerIcon: gamer_icon_steve_namespaceObject,
  role: RealmPlayerRoleEnum.OWNER,
  isOnline: true,
  hasOptedIn: true
}), realmPlayer({
  xuid: '2alexandria3603',
  gamerTag: 'Alexandria',
  gamerIcon: gamer_icon_alex_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: true,
  hasOptedIn: true
}), realmPlayer({
  xuid: '3doom3rboi4114',
  gamerTag: 'Doom3rboi',
  gamerIcon: gamer_icon_creeper_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: true,
  hasOptedIn: true
}), realmPlayer({
  xuid: '4forkknife6387',
  gamerTag: 'ForkKnife',
  gamerIcon: gamer_icon_villager_namespaceObject,
  role: RealmPlayerRoleEnum.OPERATOR,
  isOnline: false,
  hasOptedIn: true
})];
const ExampleRealmPlayerOne = realmPlayer({
  xuid: '5piggysmalls8926',
  gamerTag: 'PiggySmalls',
  gamerIcon: gamer_icon_pig_namespaceObject,
  role: RealmPlayerRoleEnum.MEMBER,
  isOnline: true,
  hasOptedIn: true
});
const ExampleRealmPlayerTwo = realmPlayer({
  xuid: '6deviouslich7737',
  gamerTag: 'DeviousLich',
  gamerIcon: gamer_icon_enderman_namespaceObject,
  role: RealmPlayerRoleEnum.VISITOR,
  isOnline: false,
  hasOptedIn: true
});
const OptedOutExampleRealmPlayer = realmPlayer({
  xuid: '0LeaveMeAnon1243',
  gamerTag: 'LeaveMeAnon12',
  gamerIcon: gamer_icon_alex_namespaceObject,
  role: RealmPlayerRoleEnum.VISITOR,
  isOnline: false,
  hasOptedIn: false
});
const unknownRealmPlayer = realmPlayer({
  xuid: '0UnknownPlayer',
  gamerTag: 'unknownPlayer',
  gamerIcon: gamer_icon_villager_namespaceObject,
  role: RealmPlayerRoleEnum.VISITOR,
  isOnline: false,
  hasOptedIn: false
});
const fakeRealmMembers = generatePlayersFromList();
const randomGeneratedPlayers = generateRandomPlayers(5); // Pass in a non-zero number to generate additional fake realm players.

const fullDemoRealmPlayerList = [...realmPlayerOperators, ExampleRealmPlayerOne, ExampleRealmPlayerTwo, OptedOutExampleRealmPlayer, ...fakeRealmMembers, ...randomGeneratedPlayers];
const realmPlayersSharedDefaultFacetState = {
  players: fullDemoRealmPlayerList,
  fetchMembersStatus: FetchStatus.Success,
  fetchOnlineMembersStatus: FetchStatus.Success
};
const realmStaticPlayersShareFacetState = {
  players: [...realmPlayerOperators, ExampleRealmPlayerOne, ExampleRealmPlayerTwo],
  fetchMembersStatus: FetchStatus.Success,
  fetchOnlineMembersStatus: FetchStatus.Success
};
const realmPlayersEmptyFacetState = {
  players: [],
  fetchMembersStatus: FetchStatus.Success,
  fetchOnlineMembersStatus: FetchStatus.Success
};
const realmPlayersSharedInternalErrorFacetState = {
  players: [],
  fetchMembersStatus: FetchStatus.InternalError,
  fetchOnlineMembersStatus: FetchStatus.InternalError
};

function generatePlayersFromList() {
  const playersList = DEMO_PLAYER_GAMER_TAGS.map((player, index) => {
    const iconIndex = index % GAMER_ICONS.length;
    return {
      xuid: player.xuid,
      gamerTag: player.gamerTag,
      gamerIcon: GAMER_ICONS[iconIndex],
      role: index % 5 == 0 ? RealmPlayerRoleEnum.VISITOR : RealmPlayerRoleEnum.MEMBER,
      isOnline: false,
      fetchProfileStatus: FetchStatus.Success,
      lastSeenTime: generateLastSeenTimeStamp(6 + index),
      hasOptedIn: true
    };
  });
  return playersList;
}

function generateRandomPlayers(amount) {
  const startID = realmPlayerOperators.length + DEMO_PLAYER_GAMER_TAGS.length + 1;
  const generatedPlayers = Array.from(Array(amount).keys()).map(key => {
    const id = startID + key;
    const iconIndex = key % GAMER_ICONS.length;
    const xuidPadding = getRandomIntegerInRange(99, 1000);
    return {
      xuid: `${xuidPadding}realmplayer${id}`,
      gamerTag: `RealmPlayer${id}`,
      gamerIcon: GAMER_ICONS[iconIndex],
      role: RealmPlayerRoleEnum.VISITOR,
      isOnline: false,
      fetchProfileStatus: FetchStatus.Success,
      lastSeenTime: generateLastSeenTimeStamp(id),
      hasOptedIn: false
    };
  });
  return generatedPlayers;
}

function getRandomIntegerInRange(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}
/**
 *  This method creates last seen timestamps for the last seen property.
 * @param: increment is how many thirty minute segments will the timestamp be older than the current time.
 * */

function generateLastSeenTimeStamp(increment) {
  return realmPlayers_CURRENT_TIME_SECONDS - increment * THIRTY_MINUTES_SECONDS;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmSlots.ts
const realmSlotsFacetDefaultState = {
  realmSlots: [{
    id: 1,
    worldName: 'My World',
    slotImage: ''
  }, {
    id: -1,
    worldName: 'New World',
    slotImage: ''
  }, {
    id: 3,
    worldName: 'Celebration Map',
    slotImage: 'https://packsbedrockstage-endpoint.azureedge.net/pack-images/celebration_world_icon.jpg'
  }],
  selectedRealmName: 'My Realm',
  getSelectedRealmDetails: realmId => {
    console.log(realmId);
  },
  selectSlot: index => {
    console.log(index);
  },
  reset: () => {},
  confirm: () => {},
  isLoading: false,
  isSlotSelected: false,
  isShowingConfirmationModal: false,
  didFailToActivateSlot: false,
  didFailToQuerySelectedRealmDetails: false
};
const realmSlotsFacetConfirmationState = {
  realmSlots: [{
    id: 1,
    worldName: 'My World',
    slotImage: ''
  }, {
    id: -1,
    worldName: 'New World',
    slotImage: ''
  }, {
    id: 3,
    worldName: 'Celebration Map',
    slotImage: 'https://packsbedrockstage-endpoint.azureedge.net/pack-images/celebration_world_icon.jpg'
  }],
  selectedRealmName: 'My Realm',
  getSelectedRealmDetails: realmId => {
    console.log(realmId);
  },
  selectSlot: index => {
    console.log(index);
  },
  reset: () => {},
  confirm: () => {},
  isLoading: false,
  isSlotSelected: false,
  isShowingConfirmationModal: true,
  didFailToActivateSlot: false,
  didFailToQuerySelectedRealmDetails: false
};
const realmSlotsFacetLoadingState = {
  realmSlots: [],
  selectedRealmName: '',
  getSelectedRealmDetails: realmId => {
    console.log(realmId);
  },
  selectSlot: index => {
    console.log(index);
  },
  reset: () => {},
  confirm: () => {},
  isLoading: true,
  isSlotSelected: false,
  isShowingConfirmationModal: false,
  didFailToActivateSlot: false,
  didFailToQuerySelectedRealmDetails: false
};
const realmSlotsFacetNoSlotsErrorState = {
  realmSlots: [],
  selectedRealmName: '',
  getSelectedRealmDetails: realmId => {
    console.log(realmId);
  },
  selectSlot: index => {
    console.log(index);
  },
  reset: () => {},
  confirm: () => {},
  isLoading: false,
  isSlotSelected: false,
  isShowingConfirmationModal: false,
  didFailToActivateSlot: false,
  didFailToQuerySelectedRealmDetails: true
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmStoriesPosts.ts






const demoRealmStoriesPosts = [{
  id: 'rspf8ac3eb5',
  authorXuid: '1playeruno6885',
  timePosted: '1 hour ago',
  image: armor_trims_night_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'Hey miners, next week this realm will be updated to run the newest version of Minecraft. For those who have not heard, the new release will include the armor trim designs that can be found throughout the world. Happy hunting!',
  totalLikes: 42,
  totalComments: 4,
  commentsStatus: FetchStatus.Success,
  hasViewed: false,
  setViewedStatus: PostStatus.Success,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rspd89fab68',
  authorXuid: '6deviouslich7737',
  timePosted: '8 hours ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam aliquet pulvinar velit et tincidunt. Donec id nisi justo. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam condimentum ex elit. Quisque rhoncus, lorem at malesuada convallis, erat metus vulputate dolor, quis dapibus ex nulla vel nisl. In dapibus condimentum scelerisque.',
  totalLikes: 1,
  totalComments: 47,
  commentsStatus: FetchStatus.Success,
  hasViewed: false,
  setViewedStatus: PostStatus.Success,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp7e61f457',
  authorXuid: '2alexandria3603',
  timePosted: 'yesterday',
  image: desert_fauna_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: '',
  totalLikes: 120,
  totalComments: 18,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Success,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp87855341',
  authorXuid: '4forkknife6387',
  timePosted: '3 days ago',
  image: castle_village_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'Progress update on the village of the castle Granite Keep. All block donations are appreciated!',
  totalLikes: 56,
  totalComments: 15,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Success,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp31e8f25f',
  authorXuid: '5piggysmalls8926',
  timePosted: '2 weeks ago',
  image: grassland_pond_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'HELP, SOMEONE STOLE MY DIAMONDS! Who ever did it GIVE IT BACK NOW !!1!1',
  totalLikes: 4,
  totalComments: 80,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Success,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8d7',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: nether_portal_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'Doom3rboi created the first Nether Portal in this realm.',
  totalLikes: 108,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Success,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8d7',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'This post has 1 like and 1 comment',
  totalLikes: 1,
  totalComments: 1,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8d7',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'Hello World',
  totalLikes: 0,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8d8',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'Doom3rboi created the second Nether Portal in this realm.',
  totalLikes: 108,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8d9',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'Doom3rboi created the third Nether Portal in this realm.',
  totalLikes: 108,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp2645d8e2',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: nether_portal_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'Doom3rboi created the fourth Nether Portal in this realm.',
  totalLikes: 108,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'thisis10',
  authorXuid: '3doom3rboi4114',
  timePosted: '1 month ago',
  image: nether_portal_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'THIS IS 10',
  totalLikes: 108,
  totalComments: 0,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rspf8ac3eb6',
  authorXuid: '1playeruno6885',
  timePosted: '1 hour ago',
  image: armor_trims_night_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: 'So great I wanted to post again!',
  totalLikes: 42,
  totalComments: 4,
  commentsStatus: FetchStatus.Success,
  hasViewed: false,
  setViewedStatus: PostStatus.Idle,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rspd89fab69',
  authorXuid: '6deviouslich7737',
  timePosted: '8 hours ago',
  image: '',
  imageStatus: FetchStatus.Success,
  body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam aliquet pulvinar velit et tincidunt. Donec id nisi justo. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam condimentum ex elit. Quisque rhoncus, lorem at malesuada convallis, erat metus vulputate dolor, quis dapibus ex nulla vel nisl. In dapibus condimentum scelerisque.',
  totalLikes: 1,
  totalComments: 47,
  commentsStatus: FetchStatus.Success,
  setViewedStatus: PostStatus.Idle,
  hasViewed: false,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'rsp7e61f458',
  authorXuid: '2alexandria3603',
  timePosted: 'yesterday',
  image: desert_fauna_namespaceObject,
  imageStatus: FetchStatus.Success,
  body: '',
  totalLikes: 120,
  totalComments: 18,
  commentsStatus: FetchStatus.Success,
  hasViewed: true,
  setViewedStatus: PostStatus.Idle,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}];
const realmStoriesPostsSharedDefaultFacetState = {
  stories: demoRealmStoriesPosts,
  storiesStatus: FetchStatus.Success,
  postStoryStatus: PostStatus.Idle,
  totalStories: demoRealmStoriesPosts.length,
  storiesInitialLoadStatus: FetchStatus.Success
};
const realmStoriesPostsSharedInternalErrorFacetState = {
  stories: demoRealmStoriesPosts,
  storiesStatus: FetchStatus.InternalError,
  postStoryStatus: PostStatus.InternalError,
  totalStories: 0,
  storiesInitialLoadStatus: FetchStatus.Idle
};
const realmStoriesPostsSharedRateLimitFacetState = {
  stories: demoRealmStoriesPosts,
  storiesStatus: FetchStatus.Success,
  postStoryStatus: PostStatus.RateLimit,
  totalStories: 0,
  storiesInitialLoadStatus: FetchStatus.RateLimit
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmStoriesSettings.ts

const realmStoriesSettingsSharedDefaultEmptyFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Idle,
  currentPostState: postStatus.Idle
};
const realmStoriesSettingsSharedDefaultFacetState = {
  realmOptIn: optInState.OptedIn,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsBothOptInSharedFacetState = {
  realmOptIn: optInState.OptedIn,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsBothOptOutSharedFacetState = {
  realmOptIn: optInState.OptedOut,
  playerOptIn: optInState.OptedOut,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsMemberInOwnerOutSharedFacetState = {
  realmOptIn: optInState.OptedOut,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsSharedLoadingFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.InProgress,
  currentPostState: postStatus.InProgress
};
const realmStoriesSettingsFetchLoadingFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.InProgress,
  currentPostState: postStatus.Idle
};
const realmStoriesSettingsPostLoadingFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.InProgress
};
const realmStoriesSettingsSharedErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.FetchFailed,
  currentPostState: postStatus.PostingFailed
};
const realmStoriesSettingsFetchErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.FetchFailed,
  currentPostState: postStatus.Idle
};
const realmStoriesSettingsUnknownErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.InternalError,
  currentPostState: postStatus.Idle
};
const realmStoriesSettingsPostErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.PostingFailed
};
const realmStoriesSettingsPostRateLimitErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.RateLimit
};
const realmStoriesSettingsSharedFetchingFailedFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.FetchFailed,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsSharedFetchRateLimitErrorFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.None,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.RateLimit,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsSharedOpenFeedFacetState = {
  realmOptIn: optInState.OptedIn,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsSharedShowNoticeModalFacetState = {
  realmOptIn: optInState.None,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: false,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
const realmStoriesSettingsTimelineOnFacetState = {
  realmOptIn: optInState.OptedIn,
  playerOptIn: optInState.OptedIn,
  realmEventsStatus: false,
  realmCoordinatesStatus: false,
  realmNotificationsStatus: false,
  realmTimelineStatus: true,
  currentFetchState: fetchStatus.Success,
  currentPostState: postStatus.Success
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmStoryComments.ts

const demoStoriesComments = [{
  id: 'sc818d1dec',
  parentId: 'rspf8ac3eb5',
  authorXuid: '2alexandria3603',
  timePosted: 'just now',
  body: 'Neat! I really like coastal trim',
  totalLikes: 4,
  hasViewed: false,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'sc387793b5',
  parentId: 'rspf8ac3eb5',
  authorXuid: '3doom3rboi4114',
  timePosted: 'just now',
  body: 'I used to be an adventurer, until I took an arrow to the knee',
  totalLikes: 0,
  hasViewed: false,
  hasLiked: false,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'sc739d34ce',
  parentId: 'rspf8ac3eb5',
  authorXuid: '6deviouslich7737',
  timePosted: '1 hour ago',
  body: 'Ur telling me an eye made this armor trim?!',
  totalLikes: 3,
  hasViewed: true,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}, {
  id: 'sc807b47a1',
  parentId: 'rspf8ac3eb5',
  authorXuid: '5piggysmalls8926',
  timePosted: '2 hour ago',
  body: 'This is cool! I cant wait to explore and find these!',
  totalLikes: 1,
  hasViewed: true,
  hasLiked: true,
  toggleLikeStatus: PostStatus.Idle,
  deleteStatus: PostStatus.Idle,
  reportToClubOwnerStatus: PostStatus.Idle,
  reportToXboxStatus: PostStatus.Idle
}];
const storyCommentsSharedDefaultFacetState = {
  comments: [...demoStoriesComments],
  postCommentStatus: PostStatus.Idle
};
const storyCommentsSharedPostingFailedFacetState = {
  comments: [...demoStoriesComments],
  postCommentStatus: PostStatus.PostingFailed
};
const storyCommentsSharedPostingRateLimitFacetState = {
  comments: [...demoStoriesComments],
  postCommentStatus: PostStatus.RateLimit
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/realmWorldUploader.ts

const realmWorldUploaderFacetDefaultState = {
  uploadWorldToRealm: () => {},
  uploadRealmWorldError: undefined,
  uploadRealmWorldTaskStatus: FacetTaskProgress.IDLE,
  uploadedRealmWorld: 1234,
  clearUploadRealmWorldState: () => {}
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/recentlyPlayedWithList.ts
const recentlyPlayedWithListFacetDefaultState = {
  playerList: [{
    xuid: '0',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '1',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '2',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '3',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '4',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '5',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '6',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '7',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '8',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '9',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '10',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '11',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '12',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '13',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '14',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '15',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '16',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '17',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '18',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '19',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '20',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '21',
    gamertag: 'MasterCrafter',
    description: 'Member of Realm: The HIVE',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '22',
    gamertag: 'SymphonicMuse',
    description: 'Online',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: false
  }, {
    xuid: '23',
    gamertag: 'Syx',
    description: 'Online',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '24',
    gamertag: 'xDirigiblePlums',
    description: '11 Mutual Friends',
    isFollowingMe: true,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }, {
    xuid: '25',
    gamertag: 'CherryPie',
    description: 'Met in Realm: Sprung & Friends',
    isFollowingMe: false,
    isFollowedByMe: false,
    gamerIcon: '',
    isOnline: true
  }]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/images/resource-pack-images/mock-package.png
const mock_package_namespaceObject = __webpack_require__.p + "assets/mock-package-dab74.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/resourcePacks.ts



const platFormLockedPackIds = ['resource-pack-6'];
const packsWithSettings = ['resource-pack-5'];
const resourcePacks_createMockPack = packId => {
  return {
    id: packId,
    contentId: packId,
    name: `Mock Pack ${packId}`,
    creator: 'Creator',
    description: `This is a pack description for ${packId}.`,
    size: '3.5MB',
    image: mock_package_namespaceObject,
    error: undefined,
    isMarketplaceItem: true,
    isPlatformLocked: platFormLockedPackIds.includes(packId),
    hasSettings: packsWithSettings.includes(packId)
  };
};
const defaultResourcePack = resourcePacks_createMockPack('default-id');
const resourcePacks_MOCK_DOWNLOAD_SPEED = 100;
const resourcePacksSharedFacetDefaultState = {
  texturePacks: {
    global: [],
    active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
    realms: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 6}`)),
    unowned: []
  },
  behaviorPacks: {
    active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`))
  },
  realmsPlusSupported: true,
  realmsSubscriber: true,
  sharedPacks: false,
  resourcePackToDownload: {
    title: '',
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.Idle,
  downloadProgress: 0,
  importProgress: 0,
  marketplacePackId: '1',
  prompt: {
    actions: [],
    active: false,
    body: '',
    handleAction: () => {},
    id: 'prompt',
    title: ''
  },
  activate: () => {},
  deactivate: () => {},
  cancelDownload: () => false,
  confirmDownload: () => false,
  changePackPriority: () => {},
  showSettings: () => {}
};
const resourcePacksSharedFacetDownloadPackState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  status: resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks,
  resourcePackToDownload: {
    title: 'Example pack',
    body: 'This pack will do things to your game.'
  },
  downloadProgress: 0.4
});
const resourcePacksSharedFacetActivePacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    global: [],
    active: [],
    available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    realms: [],
    unowned: []
  }
});
const resourcePacksSharedFacetAvailablePacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    global: [],
    active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    available: [],
    realms: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
    unowned: []
  }
});
const resourcePacksSharedFacetRealmsPacksEmptyState = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    global: [],
    active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
    realms: [],
    unowned: []
  }
});
const resourcePacksSharedFacetRealmsPacksNotSubscriber = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  texturePacks: {
    global: [],
    active: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i}`)),
    available: [...new Array(3)].map((_, i) => resourcePacks_createMockPack(`${i + 3}`)),
    realms: [],
    unowned: []
  },
  realmsPlusSupported: true,
  realmsSubscriber: false
});
const resourcePacksSharedFacetDownloadConfirmation = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  prompt: {
    id: 'prompt',
    active: true,
    title: 'Ready to download?',
    body: `${resourcePacks_createMockPack('1').name} needs to be downloaded before it can be activated.`,
    actions: [{
      id: 0,
      label: 'Download and activate pack',
      variant: types_PromptActionVariant.Primary
    }, {
      id: 1,
      label: 'Cancel',
      variant: types_PromptActionVariant.Secondary
    }],
    handleAction: () => {}
  },
  resourcePackToDownload: {
    title: resourcePacks_createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.CheckingResourcePacks
});
const resourcePacksSharedFacetDownloading = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  resourcePackToDownload: {
    title: resourcePacks_createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.StartDownload,
  downloadProgress: 0.4
});
const resourcePacksSharedFacetImporting = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  resourcePackToDownload: {
    title: resourcePacks_createMockPack('1').name,
    body: ''
  },
  status: resourcePacksFacet_ResourcePacksFacetStatus.DownloadingResourcePacks,
  downloadProgress: 1.0,
  importProgress: 0.7
});
const resourcePacksSharedFacetEmptyBehaviorPacks = mergeDeepRight_default()(resourcePacksSharedFacetDefaultState, {
  behaviorPacks: {
    active: [],
    available: []
  },
  texturePacks: {
    global: [],
    active: [],
    available: [],
    realms: [],
    unowned: []
  }
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/seedTemplates.ts




const fakeSeedTemplateData = [{
  title: 'Snowy Village',
  image: undefined,
  seedValue: '22061'
}, {
  title: 'Epic Jungle',
  image: undefined,
  seedValue: '-786098485'
}, {
  title: 'Taiga Village',
  image: undefined,
  seedValue: '-1943825025'
}, {
  title: 'Desert Village',
  image: desert_village_namespaceObject,
  seedValue: '1738801'
}, {
  title: 'Survival Island',
  image: undefined,
  seedValue: '-509091417'
}, {
  title: 'Outpost Ahead',
  image: outpost_ahead_namespaceObject,
  seedValue: '300746916'
}, {
  title: 'Coastal Village',
  image: coastal_village_namespaceObject,
  seedValue: '280548954'
}, {
  title: 'Abandoned Village',
  image: abandoned_village_namespaceObject,
  seedValue: '0'
}, {
  title: 'Taiga Bay',
  image: undefined,
  seedValue: '1371621129'
}];
const seedTemplatesSharedFacetDefaultState = {
  templates: fakeSeedTemplateData,
  failedToFetch: false
};
const seedTemplatesSharedFacetEmptyState = {
  templates: [],
  failedToFetch: false
};
const seedTemplatesSharedFacetFailedState = {
  templates: [],
  failedToFetch: true
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/simulationDistance.ts
const simulationDistanceSharedFacetDefaultState = {
  simulationDistanceOptions: [4, 6, 8, 10]
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/userAccount.ts
function userAccount_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function userAccount_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { userAccount_ownKeys(Object(source), true).forEach(function (key) { userAccount_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { userAccount_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function userAccount_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const userAccountSharedFacetDefaultState = {
  hasPremiumNetworkAccess: true,
  isLoggedInWithMicrosoftAccount: true,
  isTrialAccount: false,
  hasValidCrossPlatformSkin: true,
  isParentalPermissionRequiredForMultiplayer: false,
  isBanned: false,
  banReason: '',
  banExpiration: '',

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {},

  isAllowedToAddFriends: true,
  isSignedInPlatformNetwork: true
};
const userAccountFacetTrialMode = userAccount_objectSpread(userAccount_objectSpread({}, userAccountSharedFacetDefaultState), {}, {
  isLoggedInWithMicrosoftAccount: false,
  isTrialAccount: true,
  hasValidCrossPlatformSkin: true,
  isParentalPermissionRequiredForMultiplayer: false,
  isBanned: false,
  banReason: '',
  banExpiration: '',

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {},

  isAllowedToAddFriends: true,
  isSignedInPlatformNetwork: true
});
const userAccountParentPermissionActiveState = userAccount_objectSpread(userAccount_objectSpread({}, userAccountSharedFacetDefaultState), {}, {
  isLoggedInWithMicrosoftAccount: true,
  isTrialAccount: false,
  isParentalPermissionRequiredForMultiplayer: true,
  isBanned: false,
  banReason: '',
  banExpiration: '',

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {},

  isAllowedToAddFriends: true,
  isSignedInPlatformNetwork: true
});
const userAccountFacetUserBannedStatus = userAccount_objectSpread(userAccount_objectSpread({}, userAccountSharedFacetDefaultState), {}, {
  isLoggedInWithMicrosoftAccount: true,
  isBanned: true,
  banReason: 'xbox.report.falseReporting',
  banExpiration: '12:34:56',

  showPremiumNetworkUpsellModal() {},

  showMicrosoftAccountLogInScreen() {},

  isAllowedToAddFriends: true,
  isSignedInPlatformNetwork: true
}); // Function to make visual regression testing easier

function getUserAccountFacetData({
  hasPremiumNetworkAccess = false,
  isLoggedInWithMicrosoftAccount = true
} = {}) {
  return {
    hasPremiumNetworkAccess: hasPremiumNetworkAccess,
    isLoggedInWithMicrosoftAccount: isLoggedInWithMicrosoftAccount,
    isTrialAccount: false,
    hasValidCrossPlatformSkin: true,
    isParentalPermissionRequiredForMultiplayer: false,
    isBanned: false,
    banReason: '',
    banExpiration: '',

    showPremiumNetworkUpsellModal() {},

    showMicrosoftAccountLogInScreen() {},

    isAllowedToAddFriends: true,
    isSignedInPlatformNetwork: true
  };
}
const userAccountSharedFacetDefaultStateCustomState = overrides => userAccount_objectSpread(userAccount_objectSpread({}, userAccountSharedFacetDefaultState), overrides);
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldCloudSync.ts



function worldCloudSync_noop() {}

const worldCloudSyncDefaultState = {
  reset: worldCloudSync_noop,
  syncWorldProgress: FacetTaskProgress.IDLE,
  syncWorldResult: undefined,
  syncWorld: worldCloudSync_noop
};
const worldCloudSyncErrorState = {
  reset: worldCloudSync_noop,
  syncWorldProgress: FacetTaskProgress.FAILED,
  syncWorldResult: WorldCloudSyncResult.WorldNotCloudStored,
  syncWorld: worldCloudSync_noop
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldOperations.ts


const worldOperationsDefaultState = {
  startDuplicateWorld: () => {},
  clearDuplicateWorld: () => {},
  duplicateWorldError: undefined,
  duplicateWorldProgress: FacetTaskProgress.IDLE,
  deleteWorld: () => {},
  exportWorld: () => {},
  exportWorldAsTemplate: () => {},
  clearExportWorldState: () => {},
  exportWorldResult: null,
  exportWorldStatus: ExportWorldStatus.Idle,
  clearPlayerData: () => {},
  resetClearPlayerData: () => {},
  startClearPlayerDataError: null,
  clearPlayerDataStatus: FacetTaskProgress.IDLE
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/factories/resourcePacks.ts
function resourcePacks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function resourcePacks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { resourcePacks_ownKeys(Object(source), true).forEach(function (key) { resourcePacks_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { resourcePacks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function resourcePacks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




let ResourcePackDlcCheckResult;

(function (ResourcePackDlcCheckResult) {
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["Valid"] = 0] = "Valid";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["MissingWorldTemplate"] = 1] = "MissingWorldTemplate";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["MissingDependencies"] = 2] = "MissingDependencies";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["NoStorage"] = 3] = "NoStorage";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["NoInternet"] = 4] = "NoInternet";
  ResourcePackDlcCheckResult[ResourcePackDlcCheckResult["DevicePerformanceTooLow"] = 5] = "DevicePerformanceTooLow";
})(ResourcePackDlcCheckResult || (ResourcePackDlcCheckResult = {}));

/**
 * These debug constants can be changed to help test various scenarios
 */
const Debug = {
  NUM_ACTIVE_PACKS: 3,
  EMPTY_GLOBAL_RESOURCE_PACKS: false,
  REALMS_PLUS_SUPPORTED: true,
  REALMS_PLUS_SUBSCRIBER: false,
  DLC_CHECK_RESPONSE: ResourcePackDlcCheckResult.Valid,
  ACTIVATION_RESPONSE: 'success',
  SHOW_PACK_DOWNLOAD_CONFIRMATION: false
};
const resourcePacks_platFormLockedPackIds = ['resource-pack-6'];
const resourcePacks_packsWithSettings = ['resource-pack-5', 'behavior-pack-2'];
const factories_resourcePacks_createMockPack = packId => {
  return {
    id: packId,
    contentId: packId,
    name: `Mock Pack ${packId}`,
    creator: 'Creator',
    description: `This is a pack description for ${packId}.`,
    size: '3.5MB',
    image: mock_package_namespaceObject,
    error: undefined,
    isMarketplaceItem: true,
    isPlatformLocked: resourcePacks_platFormLockedPackIds.includes(packId),
    hasSettings: resourcePacks_packsWithSettings.includes(packId)
  };
};
function resourcePacksFacetFactory(proxy) {
  // Resource packs
  const resourcePacks = [...new Array(12)].map((_, i) => factories_resourcePacks_createMockPack(i ? `resource-pack-${i}` : 'global-pack')).reverse().reduce((acc, cur) => resourcePacks_objectSpread(resourcePacks_objectSpread({}, acc), {}, {
    [cur.id]: resourcePacks_objectSpread({}, cur)
  }), {});
  const originalAvailableResourcePacks = [resourcePacks['resource-pack-1'], resourcePacks['resource-pack-2'], resourcePacks['resource-pack-4'], resourcePacks['resource-pack-5'], resourcePacks['resource-pack-6']];
  const availableResourcePacks = originalAvailableResourcePacks.slice();
  const originalRealmsPacks = [resourcePacks['resource-pack-3'], resourcePacks['resource-pack-7'], resourcePacks['resource-pack-8'], resourcePacks['resource-pack-9']];
  const realmsPacks = originalRealmsPacks.slice();
  const originalUnownedPacks = [resourcePacks['resource-pack-10'], resourcePacks['resource-pack-11'], resourcePacks['resource-pack-12']];
  const unownedPacks = originalUnownedPacks.slice();
  const globalPacks = Debug.EMPTY_GLOBAL_RESOURCE_PACKS ? [] : [resourcePacks['global-pack']];
  const activeResourcePacks = [...availableResourcePacks.splice(0, Debug.NUM_ACTIVE_PACKS)]; // Behavior packs

  const behaviorPacks = [...new Array(12)].map((_, i) => factories_resourcePacks_createMockPack(`behavior-pack-${i + 1}`)).reverse().reduce((acc, cur) => resourcePacks_objectSpread(resourcePacks_objectSpread({}, acc), {}, {
    [cur.id]: resourcePacks_objectSpread({}, cur)
  }), {});
  const originalAvailableBehaviorPacks = [behaviorPacks['behavior-pack-1'], behaviorPacks['behavior-pack-2'], behaviorPacks['behavior-pack-4'], behaviorPacks['behavior-pack-5'], behaviorPacks['behavior-pack-6']];
  const availableBehaviorPacks = originalAvailableBehaviorPacks.slice();
  const activeBehaviorPacks = [...availableBehaviorPacks.splice(0, Debug.NUM_ACTIVE_PACKS)];
  let activatingId = null;
  let downloadInterval;
  proxy.prompt = {
    id: 'helloWorld',
    active: false,
    body: '',
    title: '',
    handleAction: id => {
      console.log('Handling prompt option: ', id);
      proxy.prompt.active = false;

      if (id === 0) {
        proxy.confirmDownload();
      }
    },
    actions: []
  };
  proxy.texturePacks = {};
  proxy.behaviorPacks = {};
  proxy.sharedPacks = false;
  proxy.realmsPlusSupported = Debug.REALMS_PLUS_SUPPORTED;
  proxy.realmsSubscriber = Debug.REALMS_PLUS_SUBSCRIBER;
  proxy.status = ResourcePacksFacetStatus.Idle;
  proxy.marketplacePackId = '';
  proxy.texturePacks.active = activeResourcePacks;
  proxy.texturePacks.global = globalPacks;
  proxy.texturePacks.available = availableResourcePacks;
  proxy.texturePacks.realms = realmsPacks;
  proxy.texturePacks.unowned = unownedPacks;
  proxy.behaviorPacks.active = activeBehaviorPacks;
  proxy.behaviorPacks.available = availableBehaviorPacks;
  proxy.resourcePackToDownload = {
    title: '',
    body: ''
  };
  proxy.downloadProgress = 0;
  proxy.importProgress = 0;

  proxy.activate = id => {
    activatingId = id; // In the behavior packs tab the behavior packs should be used

    if (window.location.href.indexOf('behavior-packs') !== -1) {
      let index, targetArray;

      if (proxy.behaviorPacks.available.findIndex(pack => pack.id === activatingId) != -1) {
        targetArray = proxy.behaviorPacks.available;
      } else {
        // trying to activate unknown pack
        return false;
      }

      if (activatingId != null) {
        index = targetArray.findIndex(pack => pack.id === activatingId);
        targetArray.splice(index, 1);
        proxy.behaviorPacks.active.unshift(behaviorPacks[activatingId]);
      }

      return true;
    }

    const targetPack = resourcePacks[id];
    proxy.resourcePackToDownload.title = targetPack.name; // If there is no pack validation error

    switch (Debug.DLC_CHECK_RESPONSE) {
      case ResourcePackDlcCheckResult.Valid:
        // You don't have the pack downloaded already
        if (Debug.SHOW_PACK_DOWNLOAD_CONFIRMATION) {
          proxy.status = ResourcePacksFacetStatus.WaitingForPrompt;
          proxy.marketplacePackId = id;
          setTimeout(() => {
            proxy.status = ResourcePacksFacetStatus.CheckingResourcePacks; // @Vii, is this the correct status at this time?

            proxy.prompt.active = true;
            proxy.prompt.title = 'Ready to download?';
            proxy.prompt.body = `${targetPack.name} needs to be downloaded before it can be activated.`;
            proxy.prompt.actions = [{
              id: 0,
              label: 'Download and activate pack',
              variant: PromptActionVariant.Primary
            }, {
              id: 1,
              label: 'Cancel',
              variant: PromptActionVariant.Secondary
            }];
          }, 50);
        } // If already downloaded, jump straight to the activation
        else {
            proxy.confirmDownload();
          }

        return;
    } // If the above didn't trigger, we can trust it's one of the errors


    proxy.prompt.active = true;
    proxy.prompt.title = 'Lorem';
    proxy.prompt.body = 'Ipsum';
    proxy.prompt.actions = [{
      id: 0,
      label: 'Activate anyway',
      variant: PromptActionVariant.Primary
    }, {
      id: 1,
      label: 'Go back',
      variant: PromptActionVariant.Secondary
    }];
  };

  proxy.deactivate = id => {
    let targetArray; // In the behavior packs tab the pack activation should not emulate a download

    if (window.location.href.indexOf('behavior-packs') !== -1) {
      // Remove the pack from active packs
      const index = proxy.behaviorPacks.active.findIndex(pack => pack.id === id);

      if (index != -1) {
        proxy.behaviorPacks.active.splice(index, 1);
      } // Find which group that pack previously belonged to


      if (originalAvailableBehaviorPacks.findIndex(pack => pack.id === id) != -1) {
        targetArray = proxy.behaviorPacks.available;
      } else {
        // trying to deactivate unknown pack
        return;
      }

      targetArray.unshift(behaviorPacks[id]);
      return;
    } // Remove the pack from active packs


    const index = proxy.texturePacks.active.findIndex(pack => pack.id === id);

    if (index != -1) {
      proxy.texturePacks.active.splice(index, 1);
    } // Find which group that pack previously belonged to


    if (originalAvailableResourcePacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.available;
    } else if (originalRealmsPacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.realms;
    } else if (originalUnownedPacks.findIndex(pack => pack.id === id) != -1) {
      targetArray = proxy.texturePacks.unowned;
    } else {
      // trying to deactivate unknown pack
      return;
    }

    targetArray.unshift(resourcePacks[id]);
  };

  proxy.showSettings = id => {
    console.log(`Showing settings for pack ${id}`);
  };

  proxy.confirmDownload = () => {
    let index, targetArray;
    if (activatingId == null) return false;

    if (proxy.texturePacks.available.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.available;
    } else if (proxy.texturePacks.realms.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.realms;
    } else if (proxy.texturePacks.unowned.findIndex(pack => pack.id === activatingId) != -1) {
      targetArray = proxy.texturePacks.unowned;
    } else {
      // trying to activate unknown pack
      return false;
    }

    proxy.status = ResourcePacksFacetStatus.DownloadingResourcePacks;
    downloadInterval = setInterval(() => {
      // When download is complete
      if (proxy.downloadProgress >= 1.0) {
        proxy.downloadProgress = 1.0;

        if (proxy.importProgress < 1) {
          proxy.importProgress = (proxy.importProgress * 10 + 1) / 10;
        } // When import is complete
        else {
            proxy.importProgress = 1.0;
            proxy.status = ResourcePacksFacetStatus.ActivateDownloadedPack;
            clearInterval(downloadInterval);

            if (Debug.ACTIVATION_RESPONSE === 'success') {
              // Successful download/import
              setTimeout(() => {
                proxy.downloadProgress = 0;
                proxy.importProgress = 0;

                if (activatingId != null) {
                  index = targetArray.findIndex(pack => pack.id === activatingId);
                  targetArray.splice(index, 1);
                  proxy.texturePacks.active.unshift(resourcePacks[activatingId]);
                }

                proxy.status = ResourcePacksFacetStatus.Idle;
              }, MOCK_DOWNLOAD_SPEED);
            } // On activation failure
            else {
                // Set the prompt to show an error and listen for a response
                proxy.prompt.active = true;
                proxy.prompt.title = 'CreateNewWorld.dynamicModal.title';
                proxy.prompt.body = 'CreateNewWorld.dynamicModal.body';
              }
          }
      } else {
        proxy.downloadProgress = (proxy.downloadProgress * 10 + 1) / 10;
      }
    }, MOCK_DOWNLOAD_SPEED);
    return true;
  };

  proxy.cancelDownload = () => {
    clearInterval(downloadInterval);
    proxy.downloadProgress = 0;
    proxy.importProgress = 0;
    proxy.status = ResourcePacksFacetStatus.Idle;
    return true;
  };

  proxy.changePackPriority = (_, prevIndex, newIndex) => {
    const packs = ~window.location.href.indexOf('behavior-packs') ? proxy.behaviorPacks : proxy.texturePacks;
    const element = packs.active[prevIndex];
    packs.active.splice(prevIndex, 1);
    packs.active.splice(newIndex, 0, element);
  };

  return proxy;
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldPackages.ts




const worldPackagesDefaultState = {
  loadPacksData: () => {},
  continuePackActivation: () => undefined,
  continuePackDeactivation: () => undefined,
  changePackPriority: () => undefined,
  activatePack: () => undefined,
  deactivatePack: () => undefined,
  downloadPacks: () => {},
  cancelPackDownload: () => {},
  packDownloadError: undefined,
  packDownloadName: '',
  packDownloadStatus: PackDownloadStatus.Idle,
  packDownloadPercentage: 0,
  packDownloadProgress: FacetTaskProgress.IDLE,
  worldPacksData: {
    texturePacks: {
      global: [],
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`)),
      realms: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 6}`)),
      unowned: []
    },
    behaviorPacks: {
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`))
    },
    realmsPlusSupported: true,
    realmsSubscriber: true,
    sharedPacks: false
  },
  isInitialized: true,
  getPackSizes: () => {},
  getPackSizesReset: () => {},
  lastConsultedPackSizesError: undefined,
  lastConsultedPackSizesProgress: FacetTaskProgress.IDLE,
  lastConsultedPackSizes: ''
};

function worldPackagesData(overrides) {
  return mergeDeepRight_default()(worldPackagesDefaultState, overrides);
}

const worldPackagesResourcePackDownloading = worldPackagesData({
  packDownloadProgress: FacetTaskProgress.RUNNING,
  packDownloadStatus: PackDownloadStatus.Downloading,
  packDownloadPercentage: 0.4
});
const worldPackagesResourcePackImporting = worldPackagesData({
  packDownloadProgress: FacetTaskProgress.RUNNING,
  packDownloadStatus: PackDownloadStatus.Importing,
  packDownloadPercentage: 0.7
});
const worldPackagesActivePacksEmptyState = worldPackagesData({
  worldPacksData: {
    texturePacks: {
      global: [],
      active: [],
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      realms: [],
      unowned: []
    },
    behaviorPacks: {
      active: [],
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`))
    },
    realmsPlusSupported: true,
    realmsSubscriber: true,
    sharedPacks: false
  }
});
const worldPackagesAvailablePacksEmptyState = worldPackagesData({
  worldPacksData: {
    texturePacks: {
      global: [],
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [],
      realms: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`)),
      unowned: []
    },
    behaviorPacks: {
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: []
    },
    realmsPlusSupported: true,
    realmsSubscriber: true,
    sharedPacks: false
  }
});
const worldPackagesRealmsPacksEmptyState = worldPackagesData({
  worldPacksData: {
    texturePacks: {
      global: [],
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`)),
      realms: [],
      unowned: []
    },
    behaviorPacks: {
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`))
    },
    realmsPlusSupported: true,
    realmsSubscriber: true,
    sharedPacks: false
  }
});
const worldPackagesRealmsPacksNotSubscriber = worldPackagesData({
  worldPacksData: {
    texturePacks: {
      global: [],
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`)),
      realms: [],
      unowned: []
    },
    behaviorPacks: {
      active: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i}`)),
      available: [...new Array(3)].map((_, i) => factories_resourcePacks_createMockPack(`${i + 3}`))
    },
    realmsPlusSupported: true,
    realmsSubscriber: false,
    sharedPacks: false
  }
});
const worldPackagesDownloadPerformanceIssues = worldPackagesData({
  packDownloadError: PackDownloadError.HasPerformanceIssues
});
const worldPackagesDownloadMissingDlcWorldTemplate = worldPackagesData({
  packDownloadError: PackDownloadError.MissingDlcWorldTemplate
});
const worldPackagesDownloadNoInternet = worldPackagesData({
  packDownloadError: PackDownloadError.NoInternet
});
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldStartup.ts


const worldStartupSharedFacetDefaultState = {
  startLocalWorld_v2: worldId => {
    if (false) {}
  },
  clearStartLocalWorldResult: () => {},
  backupThenStartLocalWorld: {
    run: () => {},
    clear: () => {},
    cancel: () => true,
    result: undefined,
    state: types_AsyncStatefulFunctionState.Idle
  },
  missingPacksSize: '',
  missingPacksToStart: []
};
function worldStartupSharedFacetWithResult(result) {
  return {
    startLocalWorld_v2: worldId => {
      if (false) {}
    },
    startLocalWorldResult: result,
    clearStartLocalWorldResult: () => {},
    backupThenStartLocalWorld: {
      run: () => {},
      clear: () => {},
      cancel: () => true,
      result: undefined,
      state: AsyncStatefulFunctionState.Idle
    },
    missingPacksSize: '100Mb',
    missingPacksToStart: [...new Array(3)].map((_, i) => createMockPack(`${i}`))
  };
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldTemplateList.ts
const templateNames = ['SkyBlocks', 'Furniture Fury', 'Minecraft Fortress 2'];
const worldTemplateListSharedFacetDefaultState = {
  premiumTemplates: templateNames.map(name => ({
    name
  })),
  customTemplates: []
};
const worldTemplateListSharedFacetEmptyState = {
  premiumTemplates: [],
  customTemplates: []
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/worldTransfer.ts
function worldTransfer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function worldTransfer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { worldTransfer_ownKeys(Object(source), true).forEach(function (key) { worldTransfer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { worldTransfer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function worldTransfer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


const worldTransferSharedFacetDefaultState = {
  importWorld: {
    progress: 0,
    result: undefined,
    state: types_AsyncStatefulFunctionState.Idle,
    run: () => {
      console.log(`Import world from local files`);
    },
    clear: () => {},
    cancel: () => true
  }
};
function worldTransferSharedFacetWithProgress(progress) {
  return worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState), {}, {
    importWorld: worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState.importWorld), {}, {
      progress
    })
  });
}
function worldTransferSharedFacetWithResult(result) {
  return worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState), {}, {
    importWorld: worldTransfer_objectSpread(worldTransfer_objectSpread({}, worldTransferSharedFacetDefaultState.importWorld), {}, {
      result
    })
  });
}
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/images/headshot1.png
const headshot1_namespaceObject = __webpack_require__.p + "assets/headshot1-349f3.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/images/headshot2.png
const headshot2_namespaceObject = __webpack_require__.p + "assets/headshot2-08577.png";
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/facets/states/playerProfile.ts



const mockPlayerSelf = {
  xuid: '0',
  gamerTag: 'CoolGamer123',
  gamerIcon: headshot1_namespaceObject,
  isOnline: true,
  isCurrentlyPlaying: false,
  relation: playerProfileFacet_PlayerRelation.Self,
  realName: 'Really McReal',
  isBlocked: false,
  isMuted: false
};
const mockPlayerFriend = {
  xuid: '0',
  gamerTag: 'BestFriend321',
  gamerIcon: headshot2_namespaceObject,
  isOnline: false,
  isCurrentlyPlaying: false,
  relation: playerProfileFacet_PlayerRelation.Friend,
  realName: 'Friendy McFriend',
  isBlocked: false,
  isMuted: false
};
const mockPlayerPlaying = {
  xuid: '0',
  gamerTag: 'FriendPlaying321',
  gamerIcon: headshot2_namespaceObject,
  isOnline: true,
  isCurrentlyPlaying: true,
  relation: playerProfileFacet_PlayerRelation.Friend,
  realName: 'Friendy McPlaying',
  isBlocked: false,
  isMuted: false
};
const mockPlayerStranger = {
  xuid: '0',
  gamerTag: 'StrangeGuy321',
  gamerIcon: headshot2_namespaceObject,
  isOnline: false,
  isCurrentlyPlaying: false,
  relation: playerProfileFacet_PlayerRelation.Stranger,
  realName: '',
  isBlocked: true,
  isMuted: true
};
const mockPlayerFollowing = {
  xuid: '0',
  gamerTag: 'Following321',
  gamerIcon: headshot2_namespaceObject,
  isOnline: true,
  isCurrentlyPlaying: false,
  relation: playerProfileFacet_PlayerRelation.Following,
  realName: 'Randy McFollowing',
  isMuted: true,
  isBlocked: false
};
const mockPlayerFollower = {
  xuid: '0',
  gamerTag: 'Follower321',
  gamerIcon: headshot2_namespaceObject,
  isOnline: true,
  isCurrentlyPlaying: false,
  relation: playerProfileFacet_PlayerRelation.Follower,
  realName: 'Randy McFollower',
  isBlocked: false,
  isMuted: false
};

function defaultLoadForPlayer(playerId) {
  console.log('Load profile for player id:', playerId);
}

function defaultLoadForCurrentPlayer() {
  console.log('Load profile for current player');
}

const playerProfileFacetSelfState = {
  loadForCurrentPlayer: defaultLoadForCurrentPlayer,
  loadForPlayer: defaultLoadForPlayer,
  data: mockPlayerSelf,
  loaded: true
};
const playerProfileFacetFriendState = {
  loadForCurrentPlayer: defaultLoadForCurrentPlayer,
  loadForPlayer: defaultLoadForPlayer,
  data: mockPlayerFriend,
  loaded: true
};
;// CONCATENATED MODULE: ./games/vanilla/engine/dev/fixtures/index.ts
function fixtures_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function fixtures_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { fixtures_ownKeys(Object(source), true).forEach(function (key) { fixtures_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { fixtures_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function fixtures_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















const fixtures_states = createStatesWithDefault({
  [ACHIEVEMENTS_FACET]: states,
  [EXTERNAL_SERVER_WORLD_LIST_FACET]: externalServerWorldList_states,
  [NETWORK_WORLD_JOINER_FACET]: networkWorldJoiner_states,
  [NETWORK_WORLD_DETAILS_FACET]: networkWorldDetails_states,
  [NOTIFICATION_OPTIONS_FACET]: notificationOptions_states,
  [REALMS_LIST_FACET]: realmsList_states,
  [SCREEN_TECH_STACK_FACET]: screenTechStack_states,
  [TELEMETRY_FACET]: telemetry_states,
  [THIRD_PARTY_WORLD_LIST_FACET]: thirdPartyWorldList_states,
  [UNPAIRED_REALMS_LIST_FACET]: unpairedRealmsList_states,
  [WEB_BROWSER_FACET]: webBrowser_states,
  [PLAYER_SOCIAL_MANAGER_FACET]: playerSocialManager_states,
  [PLAYER_ACHIEVEMENTS_FACET]: playerAchievements_states
});
/**
 * Helper function used to create a state mapping object with a 'default' property.
 */

function createStatesWithDefault(states) {
  return fixtures_objectSpread(fixtures_objectSpread({}, states), {}, {
    // Create a 'defaults' property which maps to the
    // default state for each fixture. This can be used
    // for a quick setup of fixtures in docs/tests.
    default: Object.keys(states).reduce((defaults, key) => fixtures_objectSpread(fixtures_objectSpread({}, defaults), {}, {
      [key]: states[key].default
    }), {})
  });
}
























































;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/hooks/useClearLikeStatusOnSuccess.tsx


/**
 * Hook that clears the status of a toggle like call for a realm story.
 * Will only trigger when the "toggle like" post status on the story is set to success.
 */

function useClearStoryLikeStatusOnSuccess(realmStory) {
  const actions = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const storyId = (0,react_facet_src.useFacetMap)(story => story.id, [], [realmStory]);
  const status = (0,react_facet_src.useFacetMap)(story => story.toggleLikeStatus, [], [realmStory]);
  (0,react_facet_src.useFacetEffect)((status, actions, storyId) => {
    if (status === PostStatus.Success) {
      actions.clearToggleLikeStatus(storyId);
    }
  }, [], [status, actions, storyId]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/hooks/useLoadStoryImage.tsx


/**
 * Hook that loads a realm story's image.
 * Will only trigger when the fetch status of the image is idle.
 */

function useLoadStoryImage(realmStory) {
  const actions = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const storyId = (0,react_facet_src.useFacetMap)(story => story.id, [], [realmStory]);
  const status = (0,react_facet_src.useFacetMap)(story => story.imageStatus, [], [realmStory]);
  (0,react_facet_src.useFacetEffect)((status, actions, storyId) => {
    if (status === FetchStatus.Idle) {
      actions.fetchStoryImage(storyId);
    }
  }, [], [status, actions, storyId]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/hooks/useSetStoryViewed.tsx


/**
 * Hook that loads a realm story's image.
 * Will only trigger when the fetch status of the image is idle.
 */

function useSetStoryViewed(realmStory) {
  const actions = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const setViewed = (0,react_facet_src.useFacetCallback)(actions => storyId => {
    actions.setViewed(storyId, '');
  }, [], [actions]);
  (0,react_facet_src.useFacetEffect)(story => {
    if (story.setViewedStatus === PostStatus.Idle) {
      setViewed(story.id);
    }
  }, [setViewed], [realmStory]);
}
;// CONCATENATED MODULE: ./packages/ui/src/Badge/Badge.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Badge = ({"badge":"Fb8kl","badgeWithCounterWrapper":"RlfkW","badgeWithCounter":"Fp9K8"});
;// CONCATENATED MODULE: ./packages/ui/src/Badge/Badge.tsx






function Badge_Badge({
  role = 'destructiveTint',
  children,
  overflowCount = 99
}) {
  const semanticColors = hooks_useSemanticColors(role); // If a number is passed in as a child, the badge gets a counter

  const counter = children != null;
  const badgeClasses = classnames_default()(semanticColors.border.base, semanticColors.background.base, semanticColors.text.base, counter ? Badge.badgeWithCounter : Badge.badge);
  const childText = (0,react_facet_src.useFacetMap)(children => children > overflowCount && overflowCount != false ? `+${overflowCount}` : `${children}`, [overflowCount], [(0,react_facet_src.useFacetWrap)(children !== null && children !== void 0 ? children : 0)]);

  if (counter) {
    return /*#__PURE__*/react.createElement("div", {
      className: badgeClasses
    }, /*#__PURE__*/react.createElement("div", {
      className: Badge.badgeWithCounterWrapper
    }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "body",
      role: role,
      align: "center"
    }, childText)));
  }

  return /*#__PURE__*/react.createElement("div", {
    className: badgeClasses
  }, /*#__PURE__*/react.createElement("div", {
    className: Badge.badge
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/RealmStoryFeed.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmStoryFeed = ({"storyPostContainer":"yj3gN","storyPostWrapper":"Ut00y","storyContentWrapper":"AiExz","row":"nfvoC","border":"OMEzJ","detailsSection":"fvA94","totalLikesContainer":"sfaY_","icon":"_KSgM","gamerTagContainer":"sGhk5","gamerTagNarrowContainer":"uAyem","timePostedContainer":"tyngs","timePostedNarrowContainer":"i5oiR","newBadgeContainer":"PknE8"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/images/comments_light.png
const comments_light_namespaceObject = __webpack_require__.p + "assets/comments_light-88de7.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/images/heart_sprite.png
const heart_sprite_namespaceObject = __webpack_require__.p + "assets/heart_sprite-88957.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/images/heart_outline.png
const heart_outline_namespaceObject = __webpack_require__.p + "assets/heart_outline-84139.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/images/options.png
const images_options_namespaceObject = __webpack_require__.p + "assets/options-9456a.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/RealmStoryFeed.tsx
















function RealmStoryFeed_RealmStoryFeed({
  index,
  content,
  totalComments = '',
  totalLikes,
  hasLiked,
  hideLikes,
  likedNarration,
  openCommentsCallback = () => {},
  toggleLikeCallback,
  openOptionsCallback
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost');
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const isNarrationEnabled = useNarrationEnabled();
  const commentButtonNarration = (0,react_facet_src.useFacetMap)(() => {
    return `${t('.comments')} . ${t('.buttonEnumeration', ['2'])} . ${t('.commentsHint')}`;
  }, [t], []);
  const optionsButtonNarration = (0,react_facet_src.useFacetMap)(() => {
    return `${t('.options')} . ${t('.buttonEnumeration', ['3'])} . ${t('.collapsed')} . ${t('.optionsHint')}`;
  }, [t], []);
  const likeButtonText = (0,react_facet_src.useFacetMap)(facet => facet ? t('.liked') : t('.like'), [t], [hasLiked]);
  const likeButtonIcon = (0,react_facet_src.useFacetMap)(facet => facet ? heart_sprite_namespaceObject : heart_outline_namespaceObject, [], [hasLiked]);
  const hasLikedUnwrapped = (0,react_facet_src.useFacetUnwrap)(hasLiked);
  const likeButtonSelected = hasLikedUnwrapped === react_facet_src.NO_VALUE ? false : hasLikedUnwrapped;
  const likeButtonRole = likeButtonSelected ? 'primary' : 'neutral';
  const neutralColors = hooks_useSemanticColors('neutral');
  const likesCommentsNarration = (0,react_facet_src.useFacetMap)((totalLikes, totalComments) => t('.likesCommentsNarration', [totalLikes, totalComments]), [t], [totalLikes, (0,react_facet_src.useFacetWrap)(totalComments)]);
  return /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: index
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, content), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: 1,
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isNarrationEnabled,
    narrationText: likesCommentsNarration,
    className: classnames_default()(RealmStoryFeed.border, RealmStoryFeed.detailsSection, neutralColors.background.base, neutralColors.bevel.base),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hideLikes,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryFeed.totalLikesContainer
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: heart_sprite_namespaceObject,
    className: RealmStoryFeed.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "left",
    role: "neutral"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, totalLikes))))), breakpoint !== 'narrow' && /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "right",
    role: "neutral"
  }, totalComments))), /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.postActions')
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: likedNarration,
    inputLegend: t('.like'),
    onClick: toggleLikeCallback,
    role: likeButtonRole,
    isSelected: likeButtonSelected
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: likeButtonIcon,
    className: RealmStoryFeed.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny",
    role: likeButtonRole
  }, likeButtonText)), totalComments !== '' && /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 1,
    narrationText: commentButtonNarration,
    inputLegend: t('.viewComments'),
    onClick: openCommentsCallback
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: comments_light_namespaceObject,
    className: RealmStoryFeed.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.comments'))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 2,
    narrationText: optionsButtonNarration,
    inputLegend: t('.options'),
    onClick: openOptionsCallback
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: images_options_namespaceObject,
    className: RealmStoryFeed.icon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.options')))))));
}
function RealmStoryFeedContent({
  body,
  timePosted,
  hasViewed,
  image = (0,react_facet_src.createStaticFacet)(''),
  author,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost');
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const authorGamerTag = (0,react_facet_src.useFacetMap)(facet => facet.gamerTag, [], [author]);
  const authorGamerIcon = (0,react_facet_src.useFacetMap)(facet => facet.gamerIcon, [], [author]);
  const authorOnlineStatus = (0,react_facet_src.useFacetMap)(facet => facet.isOnline === true && facet.hasOptedIn === true ? 'online' : 'offline', [], [author]);
  const storyNarrationText = (0,react_facet_src.useFacetMap)((body, authorGamerTag, timePosted, hasViewed) => ` ${t('.storyPostNarration', [hasViewed === false ? t('.unreadPost') : '', timePosted, authorGamerTag, body])}`, [t], [body, authorGamerTag, timePosted, hasViewed]);
  const neutralColors = hooks_useSemanticColors('neutral');
  const neutral80Colors = hooks_useSemanticColors('neutral80');
  const isNarrationEnabled = useNarrationEnabled();
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: t('.groupNarration')
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: isNarrationEnabled,
    gamepadIndex: gamepadIndex,
    narrationText: storyNarrationText,
    className: classnames_default()(RealmStoryFeed.storyPostContainer, neutralColors.border.base, neutral80Colors.background.base),
    classNameFocused: focusClass
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: RealmStoryFeed.storyPostWrapper
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    src: authorGamerIcon,
    status: authorOnlineStatus,
    variant: "large"
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: RealmStoryFeed.storyContentWrapper
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryFeed.row
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [RealmStoryFeed.gamerTagContainer]: breakpoint !== 'narrow',
      [RealmStoryFeed.gamerTagNarrowContainer]: breakpoint === 'narrow'
    })
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "left",
    role: "neutral80"
  }, authorGamerTag)), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoryFeed.timePostedContainer, {
      [RealmStoryFeed.timePostedNarrowContainer]: breakpoint === 'narrow'
    })
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    align: breakpoint === 'narrow' ? 'left' : 'right',
    role: "neutral80",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, timePosted)))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(image => image !== '', [], [image])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive.Maybe, {
    isInteractive: !isNarrationEnabled,
    gamepadIndex: gamepadIndex,
    narrationText: false,
    className: classnames_default()(RealmStoryFeed.border, neutralColors.border.base),
    classNameFocused: focusClass
  }, isNarrationEnabled === false && /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })))))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 2
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    role: "neutral80"
  }, body))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasViewed,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmStoryFeed.newBadgeContainer
  }, /*#__PURE__*/react.createElement(Badge_Badge, null)))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryFeed/index.ts


;// CONCATENATED MODULE: ./packages/ui/src/ModalMenu/ModalMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ModalMenu = ({"modalMenuContentBottomBorder":"NrdmD","modalMenuContent":"iXek1","modalMenuContentWrapper":"wZqdF","modalMenuScrollbar":"c0ycF"});
;// CONCATENATED MODULE: ./packages/ui/src/ModalMenu/ModalMenu.tsx
function ModalMenu_extends() { ModalMenu_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ModalMenu_extends.apply(this, arguments); }

function ModalMenu_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ModalMenu_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function ModalMenu_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }












/**
 * If the options overflow the container the container will be sized so the last visible item will be clipped in half.
 * This is so the player has an visual aid that the list is scrollable.
 * This is especially important for touch input users where the scrollbar isn’t always visible.
 */
function useModalContentHeight(wrapperRef) {
  const [maxHeight, setMaxHeight] = (0,react_facet_src.useFacetState)('');
  const dropdownItemHeight = useSizeInPixelsFacet(DROPDOWN_ITEM_HEIGHT_REM);
  const calculateMaxHeight = (0,react_facet_src.useFacetCallback)(itemHeight => () => {
    var _wrapperRef$current;

    const wrapper = wrapperRef === null || wrapperRef === void 0 ? void 0 : wrapperRef.current;
    const parent = wrapperRef === null || wrapperRef === void 0 ? void 0 : (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.parentElement;

    if (!wrapper || !parent) {
      return;
    }

    const wrapperHeight = wrapper.getBoundingClientRect().height;
    const parentHeight = parent.getBoundingClientRect().height;

    if (parentHeight < wrapperHeight) {
      const nextMaxHeight = Math.floor(parentHeight / itemHeight) * itemHeight - itemHeight / 2;
      setMaxHeight(`${nextMaxHeight}px`);
    }
  }, [wrapperRef, setMaxHeight], [dropdownItemHeight]);
  return [maxHeight, calculateMaxHeight];
}

function ModalMenu_ModalMenu({
  title,
  isOpen,
  items,
  onClose,
  onItemSelect
}) {
  const isOpenFacet = (0,react_facet_src.useFacetWrap)(isOpen);
  const itemsFacet = (0,react_facet_src.useFacetWrap)(items);
  const semanticColors = hooks_useSemanticColors('neutral50');
  const wrappingRef = (0,react.useRef)(null);
  const disabledFacet = (0,react_facet_src.useFacetWrap)(false);
  const columnOptions = (0,react_facet_src.useFacetMap)(disabled => {
    return {
      index: 1,
      disabled,
      bounded: true
    };
  }, [], [disabledFacet]);
  const [maxHeight, calculateMaxHeight] = useModalContentHeight(wrappingRef);
  useOnComponentResize_useOnComponentResize(wrappingRef, calculateMaxHeight);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOpenFacet
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'modal-menu',
    onOverlayClick: onClose
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    role: "neutral100",
    scrollbarBackgroundRole: "neutral80",
    scrollbarClassName: ModalMenu.modalMenuScrollbar,
    className: ModalMenu.modalMenuContent
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: columnOptions,
    scrollRef: wrappingRef
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: wrappingRef,
    className: ModalMenu.modalMenuContentWrapper,
    style: {
      maxHeight
    }
  }, /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: 'neutral60'
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: itemsFacet
  }, (item, index) => /*#__PURE__*/react.createElement(ModalMenuItem, {
    key: index,
    item: item,
    gamepadIndex: index,
    onChange: onItemSelect
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ModalMenu.modalMenuContentBottomBorder, semanticColors.background.base)
  })))))));
}

const ModalMenuItem = (_ref) => {
  let {
    item
  } = _ref,
      props = ModalMenu_objectWithoutProperties(_ref, ["item"]);

  const semanticSounds = useSemanticSounds('neutral');
  const itemFacet = (0,react_facet_src.useFacetWrap)(item);
  const disabled = (0,react_facet_src.useFacetMap)(({
    disabled
  }) => !!disabled, [], [itemFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(DropdownItemWrapper, ModalMenu_extends({}, props, {
    item: itemFacet,
    currentValue: -1,
    isSelectable: (0,react_facet_src.useFacetMap)(item => item.isSelectable === true, [], [itemFacet]),
    soundEffectPressed: semanticSounds.press,
    soundEffectHovered: semanticSounds.hover,
    disabled: disabled
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/modals/RealmsStoriesOptionsModal/RealmsStoriesOptionsModal.tsx





var RealmsStoriesOptions;

(function (RealmsStoriesOptions) {
  RealmsStoriesOptions[RealmsStoriesOptions["DELETE"] = 0] = "DELETE";
  RealmsStoriesOptions[RealmsStoriesOptions["NOTIFY"] = 1] = "NOTIFY";
  RealmsStoriesOptions[RealmsStoriesOptions["REPORT"] = 2] = "REPORT";
})(RealmsStoriesOptions || (RealmsStoriesOptions = {}));

const DELETE_OPTION_ALIAS = 'OPTION-DELETE';
const NOTIFY_OPTION_ALIAS = 'OPTION-NOTIFY';
const REPORT_OPTION_ALIAS = 'OPTION-REPORT';
const RealmsStoriesOptionsModal = registerModal(({
  isAuthor,
  isRealmOwner,
  isCommentOptions,
  onClose,
  onDelete,
  onNotify,
  onReport
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost');
  const deleteLabel = isCommentOptions ? t('.options.comment.delete') : t('.options.delete');
  const storyOptions = (0,react_facet_src.useFacetMap)((author, owner) => {
    const realmStoryOptions = [{
      isVisible: owner || author,
      gamepadAlias: DELETE_OPTION_ALIAS,
      label: deleteLabel,
      value: RealmsStoriesOptions.DELETE
    }, {
      isVisible: !owner,
      gamepadAlias: NOTIFY_OPTION_ALIAS,
      label: t('.options.notify'),
      value: RealmsStoriesOptions.NOTIFY
    }, {
      isVisible: !author,
      gamepadAlias: REPORT_OPTION_ALIAS,
      label: t('.options.report'),
      value: RealmsStoriesOptions.REPORT
    }];
    const visibleStoryOptions = realmStoryOptions.filter(option => option.isVisible);
    const totalOptionsVisible = visibleStoryOptions.length;
    return visibleStoryOptions.map((realmOption, index) => {
      return {
        enumeration: t('.options.enumeration', [`${index + 1}`, `${totalOptionsVisible}`]),
        gamepadAlias: realmOption.gamepadAlias,
        label: realmOption.label,
        value: realmOption.value
      };
    });
  }, [t, deleteLabel], [(0,react_facet_src.useFacetWrap)(isAuthor), (0,react_facet_src.useFacetWrap)(isRealmOwner)]);
  const onItemSelect = (0,react.useCallback)(optionValue => {
    switch (optionValue) {
      case RealmsStoriesOptions.DELETE:
        onDelete();
        break;

      case RealmsStoriesOptions.NOTIFY:
        onNotify();
        break;

      case RealmsStoriesOptions.REPORT:
        onReport();
        break;
    }
  }, [onDelete, onNotify, onReport]);
  return /*#__PURE__*/react.createElement(ModalMenu_ModalMenu, {
    onClose: onClose,
    onItemSelect: onItemSelect,
    isOpen: true,
    title: t('.options'),
    items: storyOptions
  });
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/modals/RealmsStoriesOptionsConfirmModals/RealmsStoriesOptionsConfirmModals.tsx





const CONFIRM_DELETE_ALIAS = 'confirm-delete-story-modal';
const ConfirmDeleteStoryModal = registerModal(({
  onConfirm,
  onCancel,
  isCommentOptions
}) => {
  const {
    t
  } = isCommentOptions ? useLocalization_useLocalization('RealmsStories.feedPost.options.comment') : useLocalization_useLocalization('RealmsStories.feedPost.options');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CONFIRM_DELETE_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onCancel
  }, t('.delete.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.delete.message'),
    gamepadIndex: 0,
    center: true
  }, t('.delete.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: CONFIRM_DELETE_ALIAS,
    inputLegend: t('.delete'),
    variant: "destructive",
    onClick: onConfirm
  }, t('.delete')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.delete.cancel'),
    variant: "secondary",
    onClick: onCancel
  }, t('.delete.cancel'))));
});
const CONFIRM_NOTIFY_ALIAS = 'confirm-notify-story-modal';
const ConfirmNotifyStoryModal = registerModal(({
  onConfirm,
  onCancel,
  isCommentOptions
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost.options.notify');
  const message = isCommentOptions ? t('.message.comment') : t('.message');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CONFIRM_NOTIFY_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onCancel
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: message,
    gamepadIndex: 0,
    center: true
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: CONFIRM_NOTIFY_ALIAS,
    inputLegend: t('.confirm'),
    variant: "destructive",
    onClick: onConfirm
  }, t('.confirm')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    variant: "secondary",
    onClick: onCancel
  }, t('.cancel'))));
});
const CONFIRM_REPORT_ALIAS = 'confirm-report-story-modal';
const ConfirmReportStoryModal = registerModal(({
  onConfirm,
  onCancel,
  isCommentOptions
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost.options.report');
  const confirm = isCommentOptions ? t('.confirm.comment') : t('.confirm');
  const message = isCommentOptions ? t('.message.comment') : t('.message');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: CONFIRM_REPORT_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onCancel
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: message,
    gamepadIndex: 0,
    center: true
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: CONFIRM_REPORT_ALIAS,
    inputLegend: confirm,
    variant: "destructive",
    onClick: onConfirm
  }, confirm), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    variant: "secondary",
    onClick: onCancel
  }, t('.cancel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/modals/RealmsStoriesOptionsFailedModals/RealmsStoriesOptionsFailedModals.tsx




const DELETE_FAILED_ALIAS = 'delete-failed-modal';
const DeleteStoryFailedModals = registerModal(({
  onClose,
  isCommentOptions
}) => {
  const {
    t
  } = isCommentOptions ? useLocalization_useLocalization('RealmsStories.feedPost.options.failed.comment') : useLocalization_useLocalization('RealmsStories.feedPost.options.failed');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DELETE_FAILED_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.deleteTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.deleteMessage'),
    gamepadIndex: 0
  }, t('.deleteMessage'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: DELETE_FAILED_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
const NOTIFY_FAILED_ALIAS = 'notify-failed-modal';
const NotifyStoryFailedModals = registerModal(({
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost.options.failed');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: NOTIFY_FAILED_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.notifyTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.notifyMessage'),
    gamepadIndex: 0
  }, t('.notifyMessage'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: NOTIFY_FAILED_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
const REPORT_FAILED_ALIAS = 'report-failed-modal';
const ReportStoryFailedModals = registerModal(({
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost.options.failed');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: REPORT_FAILED_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.reportTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.reportMessage'),
    gamepadIndex: 0
  }, t('.reportMessage'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: REPORT_FAILED_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/modals/index.ts



;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/RealmStoryPost.tsx














function StoryPostContent({
  realmStory,
  gamepadIndex
}) {
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const storyBody = (0,react_facet_src.useFacetMap)(facet => facet.body, [], [realmStory]);
  const storyTimePosted = (0,react_facet_src.useFacetMap)(facet => facet.timePosted, [], [realmStory]);
  const storyImage = (0,react_facet_src.useFacetMap)(facet => facet.image, [], [realmStory]);
  const hasViewed = (0,react_facet_src.useFacetMap)(facet => facet.hasViewed, [], [realmStory]);
  const author = (0,react_facet_src.useFacetMap)((story, players) => {
    const player = find_find(players.players, player => player.xuid === story.authorXuid);
    return player != null && (player === null || player === void 0 ? void 0 : player.fetchProfileStatus) === FetchStatus.Success ? player : unknownRealmPlayer;
  }, [], [realmStory, playersFacet]);
  return /*#__PURE__*/react.createElement(RealmStoryFeedContent, {
    body: storyBody,
    timePosted: storyTimePosted,
    hasViewed: hasViewed,
    image: storyImage,
    author: author,
    gamepadIndex: gamepadIndex
  });
}

function RealmStoryPost({
  realmStory,
  index
}) {
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const persistentFacet = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const realmFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost'); // useFacetEffect hooks

  useClearStoryLikeStatusOnSuccess(realmStory);
  useLoadStoryImage(realmStory);
  useSetStoryViewed(realmStory);
  const totalComments = (0,react_facet_src.useFacetMap)(facet => facet.totalComments === 1 ? t('.totalComment', [facet.totalComments.toString()]) : t('.totalComments', [facet.totalComments.toString()]), [t], [realmStory]);
  const totalLikes = (0,react_facet_src.useFacetMap)(facet => facet.totalLikes === 1 ? t('.totalLike', [facet.totalLikes.toString()]) : t('.totalLikes', [facet.totalLikes.toString()]), [t], [realmStory]);
  const hasLiked = (0,react_facet_src.useFacetMap)(story => story.hasLiked, [], [realmStory]);
  const hideLikes = (0,react_facet_src.useFacetMap)(facet => facet.totalLikes === 0, [], [realmStory]);
  const likedStoryNarration = (0,react_facet_src.useFacetMap)(story => {
    return `${t('.like')} . ${t('.buttonEnumeration', ['1'])} . ${story.hasLiked ? t('.unlikeHint') : t('.likeHint')}`;
  }, [t], [realmStory]);
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const postsFacet = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const openStoryCommentsHandler = (0,react_facet_src.useFacetCallback)((story, persistentData, posts) => () => {
    persistentData.currentStoryId = story.id;
    setRealmStoriesPostsAsViewed(posts.stories);
    historyAPI.push(`/realms-story-comments/${encodeURIComponent(story.id)}`);
  }, [historyAPI], [realmStory, persistentFacet, postsFacet]);
  const toggleStoryLike = (0,react_facet_src.useFacetCallback)((story, actions) => () => {
    if (story.toggleLikeStatus === PostStatus.Idle) {
      actions.toggleLike(story.id, '');
    }
  }, [], [realmStory, actionsFacet]);
  const realmsStoriesOptionsModal = RealmsStoriesOptionsModal.useModal();
  const isAuthor = (0,react_facet_src.useFacetMap)((story, realmData) => story.authorXuid === realmData.userXuid, [], [realmStory, realmFacet]);
  const isRealmOwner = (0,react_facet_src.useFacetMap)(realmData => realmData.ownerXuid === realmData.userXuid, [], [realmFacet]); //Delete Story

  const confirmDeleteModal = ConfirmDeleteStoryModal.useModal();
  const onCloseDeleteModal = (0,react.useCallback)(() => {
    confirmDeleteModal.hide();
    realmsStoriesOptionsModal.hide();
  }, [confirmDeleteModal, realmsStoriesOptionsModal]);
  const onDeleteConfirm = (0,react_facet_src.useFacetCallback)((story, actions) => () => {
    actions.delete(story.id, '');
    onCloseDeleteModal();
  }, [onCloseDeleteModal], [realmStory, actionsFacet]);
  const showDeleteError = (0,react_facet_src.useFacetMap)(story => story.deleteStatus == PostStatus.InputInvalid || story.deleteStatus == PostStatus.InternalError || story.deleteStatus == PostStatus.UploadFailed || story.deleteStatus == PostStatus.PostingFailed, [], [realmStory]);
  const onCloseDeleteFailed = (0,react_facet_src.useFacetCallback)((story, actions) => () => actions.clearDeleteStatus(story.id), [], [realmStory, actionsFacet]); //Report Story to Realm Owner

  const confirmNotifyModal = ConfirmNotifyStoryModal.useModal();
  const onCloseNotifyModal = (0,react.useCallback)(() => {
    confirmNotifyModal.hide();
    realmsStoriesOptionsModal.hide();
  }, [confirmNotifyModal, realmsStoriesOptionsModal]);
  const onNotifyConfirm = (0,react_facet_src.useFacetCallback)((story, actions) => () => {
    actions.reportToClubOwner(story.id, '');
    onCloseNotifyModal();
  }, [onCloseNotifyModal], [realmStory, actionsFacet]);
  const showNotifyError = (0,react_facet_src.useFacetMap)(story => story.reportToClubOwnerStatus == PostStatus.InputInvalid || story.reportToClubOwnerStatus == PostStatus.InternalError || story.reportToClubOwnerStatus == PostStatus.UploadFailed || story.reportToClubOwnerStatus == PostStatus.PostingFailed, [], [realmStory]);
  const onCloseNotifyFailed = (0,react_facet_src.useFacetCallback)((story, actions) => () => actions.clearReportToClubOwnerStatus(story.id), [], [realmStory, actionsFacet]); //Report to Xbox Enforcers Option

  const confirmReportModal = ConfirmReportStoryModal.useModal();
  const onCloseReportModal = (0,react.useCallback)(() => {
    confirmReportModal.hide();
    realmsStoriesOptionsModal.hide();
  }, [confirmReportModal, realmsStoriesOptionsModal]);
  const onReportConfirm = (0,react_facet_src.useFacetCallback)((story, actions) => () => {
    actions.reportToXbox(story.id, '');
    onCloseReportModal();
  }, [onCloseReportModal], [realmStory, actionsFacet]);
  const showReportError = (0,react_facet_src.useFacetMap)(story => story.reportToXboxStatus == PostStatus.InputInvalid || story.reportToXboxStatus == PostStatus.InternalError || story.reportToXboxStatus == PostStatus.UploadFailed || story.reportToXboxStatus == PostStatus.PostingFailed, [], [realmStory]);
  const onCloseReportFailed = (0,react_facet_src.useFacetCallback)((story, actions) => () => {
    actions.clearReportToXboxStatus(story.id);
  }, [], [realmStory, actionsFacet]);
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  (0,react_facet_src.useFacetEffect)((story, notification, actions) => {
    if (story.reportToClubOwnerStatus === PostStatus.Success) {
      notification.queueSnackbar(t('.options.notify.toast'));
      actions.clearReportToClubOwnerStatus(story.id);
    } else if (story.reportToXboxStatus === PostStatus.Success) {
      notification.queueSnackbar(t('.options.report.toast'));
      actions.clearReportToXboxStatus(story.id);
    }
  }, [t], [realmStory, notificationsSharedFacet, actionsFacet]);
  const showRateLimitError = (0,react_facet_src.useFacetMap)(story => story.deleteStatus == PostStatus.RateLimit || story.reportToClubOwnerStatus == PostStatus.RateLimit || story.reportToXboxStatus == PostStatus.RateLimit, [], [realmStory]);
  const onCloseRateLimitError = (0,react_facet_src.useFacetCallback)(story => () => {
    if (story.deleteStatus == PostStatus.RateLimit) {
      onCloseDeleteFailed();
    }

    if (story.reportToClubOwnerStatus == PostStatus.RateLimit) {
      onCloseNotifyFailed();
    }

    if (story.reportToXboxStatus == PostStatus.RateLimit) {
      onCloseReportFailed();
    }
  }, [onCloseDeleteFailed, onCloseNotifyFailed, onCloseReportFailed], [realmStory]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RealmStoryFeed_RealmStoryFeed, {
    content: /*#__PURE__*/react.createElement(StoryPostContent, {
      realmStory: realmStory,
      gamepadIndex: index
    }),
    index: index,
    totalComments: totalComments,
    totalLikes: totalLikes,
    hasLiked: hasLiked,
    hideLikes: hideLikes,
    likedNarration: likedStoryNarration,
    openCommentsCallback: openStoryCommentsHandler,
    toggleLikeCallback: toggleStoryLike,
    openOptionsCallback: realmsStoriesOptionsModal.show
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsStoriesOptionsModal.isVisible
  }, /*#__PURE__*/react.createElement(RealmsStoriesOptionsModal.Component, {
    isAuthor: isAuthor,
    isRealmOwner: isRealmOwner,
    isCommentOptions: false,
    onClose: realmsStoriesOptionsModal.hide,
    onDelete: confirmDeleteModal.show,
    onNotify: confirmNotifyModal.show,
    onReport: confirmReportModal.show
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmDeleteModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmDeleteStoryModal.Component, {
    onConfirm: onDeleteConfirm,
    onCancel: onCloseDeleteModal,
    isCommentOptions: false
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmNotifyModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmNotifyStoryModal.Component, {
    onConfirm: onNotifyConfirm,
    onCancel: onCloseNotifyModal,
    isCommentOptions: false
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmReportModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmReportStoryModal.Component, {
    onConfirm: onReportConfirm,
    onCancel: onCloseReportModal,
    isCommentOptions: false
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDeleteError
  }, /*#__PURE__*/react.createElement(DeleteStoryFailedModals.Component, {
    onClose: onCloseDeleteFailed,
    isCommentOptions: false
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNotifyError
  }, /*#__PURE__*/react.createElement(NotifyStoryFailedModals.Component, {
    onClose: onCloseNotifyFailed
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showReportError
  }, /*#__PURE__*/react.createElement(ReportStoryFailedModals.Component, {
    onClose: onCloseReportFailed
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitError
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onCloseRateLimitError
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmStoryPost/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/StoryFeedTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StoryFeedTab = ({"storyFeedContainer":"rKBkk"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/StoryFeedTab.tsx

















const STORIES_PER_PAGE = 10;
function StoryFeedTab_StoryFeedTab() {
  const isNarrow = useIsWindowNarrow(102.4);
  const storiesFacet = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const sessFacet = (0,react_facet_src.useSharedFacet)(sessionsFacet);
  const dataFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const actionFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.feed');
  const routerAPI = hooks_useRouterAPI();
  const firstTimeEnteringTab = (0,react.useRef)(true);
  (0,react_facet_src.useFacetEffect)(facet => {
    if (firstTimeEnteringTab.current) {
      facet.loadStoriesSlice(0, STORIES_PER_PAGE);
      firstTimeEnteringTab.current = false;
    }
  }, [], [actionFacet]);
  const RECENT_PLAYERS_TO_DISPLAY = isNarrow ? 2 : 7;
  const isStoriesLoading = (0,react_facet_src.useFacetMap)(facet => facet.storiesInitialLoadStatus === FetchStatus.InProgress, [], [storiesFacet]);
  const loadedRealmStories = (0,react_facet_src.useFacetMap)(facet => facet.stories, [], [storiesFacet], () => () => false);
  const totalStoryPosts = (0,react_facet_src.useFacetMap)(facet => {
    var _facet$stories$length;

    return (_facet$stories$length = facet.stories.length) !== null && _facet$stories$length !== void 0 ? _facet$stories$length : 0;
  }, [], [storiesFacet]);
  const [currentPage, setCurrentPage] = (0,react.useState)(1);
  const scrollViewRef = (0,react.useRef)(null);
  const totalPages = (0,react_facet_src.useFacetMap)(facet => Math.ceil(facet.totalStories / STORIES_PER_PAGE), [], [storiesFacet]);
  const changeStoryFeedPage = (0,react_facet_src.useFacetCallback)(facet => newPage => {
    setCurrentPage(newPage);
    const rangeStart = (newPage - 1) * STORIES_PER_PAGE;
    const rangeEnd = rangeStart + STORIES_PER_PAGE;
    facet.loadStoriesSlice(rangeStart, rangeEnd);

    if (scrollViewRef.current) {
      scrollViewRef.current.scrollTop = 0;
    }
  }, [setCurrentPage], [actionFacet]);
  const isStoryFeedEmpty = (0,react_facet_src.useFacetMap)(stories => stories.length === 0, [], [loadedRealmStories]);
  const recentRealmPlayers = (0,react_facet_src.useFacetMap)((facet, data) => {
    const sortedPlayers = sortRealmPlayerByMostRecent(filter(facet.players, player => player.lastSeenTime !== 0 && player.xuid !== data.userXuid));
    const max = Math.min(RECENT_PLAYERS_TO_DISPLAY, sortedPlayers.length);
    return slice(sortedPlayers, 0, max);
  }, [RECENT_PLAYERS_TO_DISPLAY], [playersFacet, dataFacet]);
  const recentPlayerCount = (0,react_facet_src.useFacetMap)(recentPlayers => recentPlayers.length, [], [recentRealmPlayers]);
  const isRecentPlayersLoading = (0,react_facet_src.useFacetMap)((players, sessions, recent) => players.fetchMembersStatus !== FetchStatus.Success || sessions.fetchSessionStatus !== FetchStatus.Success || !recent.every(player => player.fetchProfileStatus === FetchStatus.Success), [], [playersFacet, sessFacet, recentRealmPlayers]);
  const showRecentPlayersSection = (0,react_facet_src.useFacetMap)(recentPlayers => {
    return recentPlayers.length > 0;
  }, [], [recentRealmPlayers]);
  const goToWriteNewStory = (0,react_facet_src.useFacetCallback)(facet => () => {
    setRealmStoriesPostsAsViewed(facet.stories);
    routerAPI.push(`/realms-new-story`);
  }, [routerAPI], [storiesFacet]);
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  const unknownErrorVisible = (0,react_facet_src.useFacetMap)((stories, noInternet) => (stories.storiesStatus === FetchStatus.InternalError || stories.storiesStatus === FetchStatus.FetchFailed || stories.storiesStatus === FetchStatus.RateLimit) && !noInternet, [], [storiesFacet, noInternetMessageVisible]);
  const errorMessageVisible = (0,react_facet_src.useFacetMap)((noInternet, unknownError) => noInternet || unknownError, [], [noInternetMessageVisible, unknownErrorVisible]);
  const retryFailedFetch = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.fetchStories();
  }, [], [actionsFacet]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMountProvider, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 10,
    narrowSize: 8,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 10,
    narrow: 8
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: unknownErrorVisible
  }, /*#__PURE__*/react.createElement(StoriesUnknownErrorMessage_StoriesUnknownErrorMessage, {
    wide: 10,
    narrow: 8,
    onClick: retryFailedFetch,
    pageName: s('.storyFeed')
  }))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    className: StoryFeedTab.storyFeedContainer,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 4,
    narrowSize: 3,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.addStory'),
    variant: "hero",
    gamepadAlias: "add-story-button",
    onClick: goToWriteNewStory,
    gamepadIndex: 0
  }, t('.addStory')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRecentPlayersSection
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: `${t('.recentlyPlayed')} . ${t('.recentlyPlayedComponentRole')}`
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 1,
    loading: isRecentPlayersLoading,
    disableScrolling: true,
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
    role: "primary",
    label: t('.recentlyPlayed')
  }), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: recentRealmPlayers
  }, (item, index) => /*#__PURE__*/react.createElement(RealmPlayerListItem_RealmPlayerListItem, {
    realmPlayer: item,
    index: index + 1,
    isSimpleLayout: true,
    totalPlayers: recentPlayerCount
  })))))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 8,
    narrowSize: 5,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isStoryFeedEmpty
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadIndex: 0,
    title: t('.emptyStoryFeedTitle'),
    text: t('.emptyStoryFeedText')
  })), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    innerRef: scrollViewRef,
    loading: isStoriesLoading,
    scrollIntoViewAlign: "start",
    gamepadAlias: "story-feed-posts-wrapper",
    delegateFocusByAlias: "add-story-button",
    defaultFocusedChildBehavior: "remember",
    renderTracker: isContentShown => /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
      renderingCompleted: isContentShown,
      type: "meaningful"
    })
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: loadedRealmStories
  }, (item, index) => /*#__PURE__*/react.createElement(StoryPostWrapper, {
    storyPost: item,
    totalStories: totalStoryPosts,
    index: index
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  }), /*#__PURE__*/react.createElement(Pagination_Pagination, {
    totalPages: totalPages,
    currentPage: currentPage,
    onChange: changeStoryFeedPage
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 3
  })))))))))));
}

function StoryPostWrapper({
  storyPost,
  totalStories,
  index
}) {
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const isLastStory = (0,react_facet_src.useFacetMap)(total => index === total - 1, [index], [totalStories]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, index === 0 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), index > 0 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 4
  }), /*#__PURE__*/react.createElement(RealmStoryPost, {
    realmStory: storyPost,
    index: index
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLastStory
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/images/generic-empty.png
const generic_empty_namespaceObject = __webpack_require__.p + "assets/generic-empty-a8ab9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TwoRowSpreadSheetHeader/TwoRowSpreadSheetHeader.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TwoRowSpreadSheetHeader = ({"headerSegmentBorder":"DvTbb","headerSegmentContainer":"bOw5t","focus":"iebbx","headerRowContainer":"V6V4L"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TwoRowSpreadSheetHeader/TwoRowSpreadSheetHeader.tsx











function HeaderSegment({
  gamepadIndex,
  gamepadIndexOffset = 0,
  headerSegmentData = (0,react_facet_src.createStaticFacet)({
    text1: 'text1',
    text2: 'text2',
    narrationText: '',
    darkenLevel: 0,
    size: 1
  })
}) {
  const neutral60Colors = hooks_useSemanticColors('neutral60');
  const neutral70Colors = hooks_useSemanticColors('neutral');
  const neutral80Colors = hooks_useSemanticColors('neutral80');
  const gamepadIndexWrapped = (0,react_facet_src.useFacetWrap)(gamepadIndex);
  const gamepadIndexOffsetWrapped = (0,react_facet_src.useFacetWrap)(gamepadIndexOffset);
  const calibratedGamepadIndex = (0,react_facet_src.useFacetMap)((index, indexOffset) => index + indexOffset, [], [gamepadIndexWrapped, gamepadIndexOffsetWrapped]);
  const headerSegmentStyles = (0,react_facet_src.useFacetMap)(facet => `${TwoRowSpreadSheetHeader.headerSegmentBorder} ${neutral70Colors.border.base} ${facet.darkenLevel === 0 ? neutral60Colors.background.base : facet.darkenLevel === 1 ? neutral70Colors.background.base : neutral80Colors.background.base}`, [neutral60Colors, neutral70Colors, neutral80Colors], [headerSegmentData]);
  const segmentNarration = (0,react_facet_src.useFacetMap)(facet => facet.narrationText, [], [headerSegmentData]);
  const text1 = (0,react_facet_src.useFacetMap)(facet => facet.text1, [], [headerSegmentData]);
  const text2 = (0,react_facet_src.useFacetMap)(facet => facet.text2, [], [headerSegmentData]);
  const isText2Supplied = (0,react_facet_src.useFacetMap)(facet => facet.text2 !== '', [], [headerSegmentData]);
  return /*#__PURE__*/react.createElement("fast-div", {
    className: TwoRowSpreadSheetHeader.headerSegmentContainer,
    style: {
      width: (0,react_facet_src.useFacetMap)(facet => `${facet.size * 100}%`, [], [headerSegmentData])
    }
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: headerSegmentStyles
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "center"
  }, text1), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isText2Supplied
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "center",
    variant: "dimmer"
  }, text2)))), useNarrationEnabled() ? /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    classNameFocused: classnames_default()(TwoRowSpreadSheetHeader.focus, neutral70Colors.outline.base),
    gamepadIndex: calibratedGamepadIndex,
    inputLegend: false,
    narrationText: segmentNarration,
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, null)) : null);
}

function TwoRowSpreadSheetHeader_TwoRowSpreadSheetHeader({
  firstRowData,
  secondRowData
}) {
  const firstRowCount = (0,react_facet_src.useFacetMap)(facet => facet.length, [], [firstRowData]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: TwoRowSpreadSheetHeader.headerRowContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: firstRowData
  }, (item, index) => /*#__PURE__*/react.createElement(HeaderSegment, {
    gamepadIndex: index,
    headerSegmentData: item
  }))), /*#__PURE__*/react.createElement("div", {
    className: TwoRowSpreadSheetHeader.headerRowContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: secondRowData
  }, (item, index) => /*#__PURE__*/react.createElement(HeaderSegment, {
    gamepadIndex: index,
    gamepadIndexOffset: firstRowCount,
    headerSegmentData: item
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TwoRowSpreadSheetHeader/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerTag/PlayerTag.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerTag = ({"playerTagContainer":"Mn3WO","playerTagContent":"k_1IM","gamerTag":"Nyd9S"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerTag/PlayerTag.tsx







function PlayerTag_PlayerTag({
  gamerIcon,
  gamerTag,
  onlineStatus
}) {
  const statusFacet = (0,react_facet_src.useFacetWrap)(onlineStatus);
  const gamerIconFacet = (0,react_facet_src.useFacetWrap)(gamerIcon);
  const neutralColors = hooks_useSemanticColors('neutral');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(PlayerTag.playerTagContainer, neutralColors.background.base, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: PlayerTag.playerTagContent
  }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    src: gamerIconFacet,
    status: statusFacet,
    variant: 'small'
  }), /*#__PURE__*/react.createElement("div", {
    className: PlayerTag.gamerTag
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    align: "left"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, gamerTag)))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerTag/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Lane/Lane.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const Lane = ({"laneSegmentContainer":"LnPiE","laneSegmentBorder":"om40F","focus":"XDSKv","laneContainer":"mz7FL","laneBlock":"L6Bqq","laneBlockInner":"yVc05","laneBlockBorder":"pxZ8Y"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Lane/Lane.tsx









function LaneSegment({
  gamepadIndex,
  laneSegmentData: maybeLaneSegmentData
}) {
  const laneSegmentData = (0,react_facet_src.useFacetWrap)(maybeLaneSegmentData !== null && maybeLaneSegmentData !== void 0 ? maybeLaneSegmentData : {
    darkenLevel: 0,
    narrationText: ''
  });
  const neutral80Colors = hooks_useSemanticColors('neutral80');
  const neutralColors = hooks_useSemanticColors('neutral');
  const laneSegmentStylesFacet = (0,react_facet_src.useFacetMap)(segmentData => classnames_default()(segmentData.darkenLevel === 0 ? neutralColors.background.base : segmentData.darkenLevel === 2 ? neutral80Colors.shadow.base : neutral80Colors.background.base, Lane.laneSegmentBorder, neutralColors.border.base), [neutralColors, neutral80Colors], [laneSegmentData]);
  const narration = (0,react_facet_src.useFacetMap)(segmentData => segmentData.narrationText, [], [laneSegmentData]);
  return /*#__PURE__*/react.createElement("div", {
    className: Lane.laneSegmentContainer
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: laneSegmentStylesFacet
  }), useNarrationEnabled() ? /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    classNameFocused: classnames_default()(Lane.focus, neutralColors.outline.base),
    gamepadIndex: gamepadIndex,
    inputLegend: false,
    narrationText: narration,
    onClick: () => {}
  }, /*#__PURE__*/react.createElement(Focus_Focus, null)) : null);
}

const DATA_VISUAL_ROLES = ['dataViz01', 'dataViz02', 'dataViz03', 'dataViz04', 'dataViz05', 'dataViz06', 'dataViz07'];

function LaneBlock({
  unitWidth,
  color,
  blockData
}) {
  const blockColor = hooks_useSemanticColors(DATA_VISUAL_ROLES[color % DATA_VISUAL_ROLES.length]);
  const neutralColors = hooks_useSemanticColors('neutral');
  return /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(Lane.laneBlock, blockColor.background.base),
    style: {
      left: (0,react_facet_src.useFacetMap)(data => `${data.start * unitWidth * 100}%`, [unitWidth], [blockData]),
      width: (0,react_facet_src.useFacetMap)(data => `${data.size * unitWidth * 100}%`, [unitWidth], [blockData])
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: Lane.laneBlockInner
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(Lane.laneBlockBorder, neutralColors.border.base)
  })));
}

function Lane_Lane({
  isDarker = false,
  numberOfSegments,
  maximumBlockCount,
  highlightedSegment = -1,
  blackenedSegmentBefore = -1,
  blackenedSegmentAfter = -1,
  gamepadIndex,
  blocks,
  blockColor,
  narrationText = (0,react_facet_src.createStaticFacet)([])
}) {
  const unitWidth = 1 / maximumBlockCount;
  const highlightedSegmentFacet = (0,react_facet_src.useFacetWrap)(highlightedSegment);
  const blackenedSegmentBeforeFacet = (0,react_facet_src.useFacetWrap)(blackenedSegmentBefore);
  const blackenedSegmentAfterFacet = (0,react_facet_src.useFacetWrap)(blackenedSegmentAfter);
  const lanes = (0,react_facet_src.useFacetMap)((highlighted, blackenedBefore, blackenedAfter, narration) => {
    const array = [];

    for (let i = 0; i < numberOfSegments; i++) {
      array.push({
        darkenLevel: i === highlighted ? 0 : i < blackenedBefore && blackenedBefore !== -1 || i > blackenedAfter && blackenedAfter !== -1 || isDarker ? 2 : 1,
        narrationText: i < narration.length ? narration[i] : ''
      });
    }

    return array;
  }, [numberOfSegments, isDarker], [highlightedSegmentFacet, blackenedSegmentBeforeFacet, blackenedSegmentAfterFacet, narrationText]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: Lane.laneContainer
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: lanes
  }, (item, index) => /*#__PURE__*/react.createElement(LaneSegment, {
    laneSegmentData: item,
    gamepadIndex: gamepadIndex + index
  })), /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: blocks
  }, item => /*#__PURE__*/react.createElement(LaneBlock, {
    blockData: item,
    unitWidth: unitWidth,
    color: blockColor
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Lane/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/TimelineTab.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TimelineTab = ({"emptyStateArt":"CtYr9","emptyStateArtBig":"fLYRQ","fullWidth":"ULZBU","fullHeight":"tx_2T","flexRow":"YayMK","leftSideNarrow":"UGT5g","leftSideWide":"bh4Vj","rightSideNarrow":"VbtmA","rightSideWide":"jUU1G","considerScrollbarWide":"q0DXQ","considerScrollbarNarrow":"oH5v_","withoutScrollbar":"x7BwQ","topBorder":"dcgPW","rightBorder":"c137S","bottomBorder":"Ga8Si","leftBorder":"Qpo28","justifyRightHorizontal":"yr9Y0","widePaginationWidth":"b9bXX","widePaginationContainer":"nJCuE","justifyCenterVertical":"C0AEe"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/hooks/PlayerTimelineHooks.ts



const MONTHS = ['.month00', '.month01', '.month02', '.month03', '.month04', '.month05', '.month06', '.month07', '.month08', '.month09', '.month10', '.month11'];
const MONTHS_SHORT = ['.monthShort00', '.monthShort01', '.monthShort02', '.monthShort03', '.monthShort04', '.monthShort05', '.monthShort06', '.monthShort07', '.monthShort08', '.monthShort09', '.monthShort10', '.monthShort11'];
const DAYS = ['.day0', '.day1', '.day2', '.day3', '.day4', '.day5', '.day6'];
const DAYS_SHORT = ['.dayShort0', '.dayShort1', '.dayShort2', '.dayShort3', '.dayShort4', '.dayShort5', '.dayShort6'];
const TOTAL_DAYS = 28;
const TOTAL_BLOCK_IN_ONE_SEGMENT = 1440;
const DAY_TO_MS = 86400000;
const IS_TEST_ENVIRONMENT = "production" === 'test'; // wrapper for getting the current date. need to have a fixed date in test environment for consistent snapshots

function getCurrentDate() {
  if (IS_TEST_ENVIRONMENT) {
    return new Date(TEST_DATE);
  } else {
    const currentDate = new Date();
    currentDate.setHours(13); // set it to 1PM because date functions behave weirdly around 23:00 to 00:00

    return currentDate;
  }
} // in non test environment we want to have the time frame of the player timeline starts and ends at the beginning and the end of a local day instead of a UTC day
// this function returns the local timezone offset on the date of getCurrentDate() in test environment and 0 otherwise
// useful to avoid having IS_TEST_ENVIRONMENT check existing all over the place to gate between using Date.<set/get>UTC and Date.<set/get> functions
// basically we're going to use Date.<set/get> functions but add the local timezone offset to mimic Date.<set/get>UTC functions

function getTimeZoneOffset() {
  return IS_TEST_ENVIRONMENT ? new Date(TEST_DATE).getTimezoneOffset() * 60 * 1000 : 0;
}
/**
 * Hook to group sessions by player xuid
 */

const useGroupSessionsByPlayerXuid = sessions => {
  return (0,react_facet_src.useFacetMap)(sessions => {
    const copy = [];

    for (let i = 0; i < sessions.sessions.length; i++) {
      copy.push(sessions.sessions[i]);
    }

    return copy.sort((a, b) => {
      if (a.userXuid === b.userXuid) {
        return a.login - b.login;
      } else {
        return a.userXuid.localeCompare(b.userXuid);
      }
    });
  }, [], [sessions]);
};
/**
 * Hook to get sorted list of player tags to be shown in the timeline
 */

const useGetTimelinePlayerTagList = (sessions, realmData, players) => {
  return (0,react_facet_src.useFacetMap)((realmData, players, sessions) => {
    const array = [];

    for (let i = 0; i < players.players.length; i++) {
      array.push({
        xuid: players.players[i].xuid,
        gamerTag: players.players[i].gamerTag,
        lastSeenTime: players.players[i].lastSeenTime
      });
    }

    const clientPlayer = find_find(players.players, player => player.xuid === realmData.userXuid);
    const clientXuid = clientPlayer != null ? clientPlayer.xuid : '';
    array.sort((a, b) => {
      if (a.xuid === b.xuid) {
        return 0;
      } else if (a.xuid === clientXuid) {
        return -1;
      } else if (b.xuid === clientXuid) {
        return 1;
      } else {
        const sessionEntryA = find_find(sessions.sessions, session => session.userXuid === a.xuid);
        const sessionEntryB = find_find(sessions.sessions, session => session.userXuid === b.xuid);

        if (sessionEntryA != null && sessionEntryB != null) {
          if (a.lastSeenTime === b.lastSeenTime) {
            return a.gamerTag.localeCompare(b.gamerTag);
          } else {
            return b.lastSeenTime - a.lastSeenTime;
          }
        } else if (sessionEntryA == null && sessionEntryB == null) {
          return a.gamerTag.localeCompare(b.gamerTag);
        } else if (sessionEntryA != null) {
          return -1;
        } else {
          return 1;
        }
      }
    });
    return array.map(a => a.gamerTag);
  }, [], [realmData, players, sessions]);
};
/**
 * Hook to generate the month and year header of the player timeline
 */

const useCreateMonthYearTimelineHeader = (currentPage, totalPages, numberOfSegments, date, t) => {
  return (0,react_facet_src.useFacetMap)(currentPage => {
    const array = [];
    let previousMonth = -1;

    for (let i = 0; i < numberOfSegments; i++) {
      const offset = numberOfSegments * (totalPages - currentPage) + (numberOfSegments - 1 - i);
      const dateAfterOffset = new Date(date.getTime() + getTimeZoneOffset() - offset * DAY_TO_MS);
      const month = dateAfterOffset.getMonth();
      const year = dateAfterOffset.getFullYear().toString();

      if (month !== previousMonth) {
        array.push({
          text1: t(MONTHS_SHORT[month]),
          text2: year,
          narrationText: t('.monthYear', [t(MONTHS[month]), year]),
          darkenLevel: 1,
          size: 1 / numberOfSegments
        });
      } else {
        array[array.length - 1].text1 = t(MONTHS[month]);
        array[array.length - 1].size = (array[array.length - 1].size * numberOfSegments + 1) / numberOfSegments;
      }

      previousMonth = month;
    }

    return array;
  }, [numberOfSegments, totalPages, date, t], [currentPage]);
};
/**
 * Hook to generate the day and date header of the player timeline
 */

const useCreateDayDateTimelineHeader = (currentPage, totalPages, numberOfSegments, date, t) => {
  return (0,react_facet_src.useFacetMap)(currentPage => {
    const array = [];

    for (let i = 0; i < numberOfSegments; i++) {
      const offset = numberOfSegments * (totalPages - currentPage) + (numberOfSegments - 1 - i);
      const dateAfterOffset = new Date(date.getTime() + getTimeZoneOffset() - offset * DAY_TO_MS);
      const day = dateAfterOffset.getDay();
      const theDate = dateAfterOffset.getDate();
      array.push({
        text1: t(DAYS_SHORT[day]),
        text2: ('0' + theDate).slice(-2),
        narrationText: t('.dayAndDate', [t(DAYS[day]), theDate.toString()]),
        darkenLevel: offset === 0 ? 0 : offset < TOTAL_DAYS ? 1 : 2,
        size: 1 / numberOfSegments
      });
    }

    return array;
  }, [numberOfSegments, totalPages, date, t], [currentPage]);
};
const HOUR_TO_MS = 3600000;
/**
 * calculate whether there's daylight savings switch numberOfSegments days after startTime
 * and return at which hour it happens
 */

function getDayLightSavingsOffset(startTime, numberOfSegments) {
  let dayLightSavingsOffset = 0;
  let dayLightSavingsSegment = -1;
  let dayLightSavingsHour = 0;

  for (let i = 0; i < numberOfSegments; i++) {
    const theDate = new Date(startTime.getTime() + DAY_TO_MS * (i - 0.5));
    const theDateAfterThat = new Date(startTime.getTime() + DAY_TO_MS * (i + 0.5));
    dayLightSavingsOffset = theDateAfterThat.getTimezoneOffset() - theDate.getTimezoneOffset();

    if (dayLightSavingsOffset !== 0) {
      dayLightSavingsSegment = i;

      for (let j = 0; j < 24; j++) {
        const theHour = new Date(startTime.getTime() + DAY_TO_MS * i + HOUR_TO_MS * j);
        const theHourAfterThat = new Date(theHour.getTime() + HOUR_TO_MS);
        const deltaHours = theHourAfterThat.getHours() - theHour.getHours();

        if (theHour.getHours() === theHourAfterThat.getHours() || deltaHours > 1 || deltaHours === -23 && theHourAfterThat.getHours() === 1 || deltaHours === -22 && theHourAfterThat.getHours() === 0) {
          dayLightSavingsHour = j + 1;
          break;
        }
      }

      break;
    }
  }

  return {
    dayLightSavingsOffset: dayLightSavingsOffset,
    dayLightSavingsSegment: dayLightSavingsSegment,
    dayLightSavingsHour: dayLightSavingsHour
  };
}
/**
 * Hook to generate play data of the player timeline
 */


const useCreatePlayData = (currentPage, sessions, players, totalPages, numberOfSegments, date, t) => {
  return (0,react_facet_src.useFacetMap)((sessions, page, players) => {
    const array = [];
    const timeZoneOffset = getTimeZoneOffset() / 60 / 1000;
    const timeZoneOffsetSign = timeZoneOffset < 0 ? -1 : 1;
    const timeZoneOffsetHour = Math.floor(Math.abs(timeZoneOffset) / 60) * timeZoneOffsetSign;
    const timeZoneOffsetMinute = Math.floor(Math.abs(timeZoneOffset) % 60) * timeZoneOffsetSign;
    const endOffset = numberOfSegments * (totalPages - page);
    const endTime = new Date(date.getTime() - endOffset * DAY_TO_MS);
    endTime.setHours(0 - timeZoneOffsetHour, 0 - timeZoneOffsetMinute, 0, 0);
    endTime.setTime(endTime.getTime() + DAY_TO_MS - 1);
    const startOffset = numberOfSegments * (totalPages - page + 1) - 1;
    const startOffsetCapped = Math.min(TOTAL_DAYS - 1, startOffset);
    const startTime = new Date(date.getTime() - startOffsetCapped * DAY_TO_MS);
    startTime.setHours(0 - timeZoneOffsetHour, 0 - timeZoneOffsetMinute, 0, 0);
    const dayLightsSavingsOffset = getDayLightSavingsOffset(startTime, numberOfSegments);
    const drawStartTime = new Date(date.getTime() - startOffset * DAY_TO_MS);
    drawStartTime.setHours(0 - timeZoneOffsetHour, 0 - timeZoneOffsetMinute, 0, 0);
    let previousXuid = '';

    for (let i = 0; i < sessions.length; i++) {
      const xuid = sessions[i].userXuid;
      const startDate = new Date();
      startDate.setTime(sessions[i].login * 1000);
      const endDate = new Date();
      endDate.setTime(sessions[i].logout * 1000);
      const newBlock = {
        start: 0,
        size: 0
      };

      if (startDate.getTime() <= endTime.getTime() && startDate.getTime() >= startTime.getTime() || endDate.getTime() <= endTime.getTime() && endDate.getTime() >= startTime.getTime()) {
        const blockStartDate = new Date(Math.max(startDate.getTime(), startTime.getTime())).getTime();
        const blockEndDate = new Date(Math.min(endDate.getTime(), endTime.getTime())).getTime();
        const dayLightOffset = dayLightsSavingsOffset.dayLightSavingsOffset;
        let blockStart = (blockStartDate - drawStartTime.getTime()) / 1000 / 60;
        let blockSize = (blockEndDate - blockStartDate) / 1000 / 60;
        const daylightSavingsStartDate = new Date(startTime.getTime() + dayLightsSavingsOffset.dayLightSavingsSegment * DAY_TO_MS + dayLightsSavingsOffset.dayLightSavingsHour * HOUR_TO_MS);

        if (dayLightOffset > 0) {
          if (blockStartDate > daylightSavingsStartDate.getTime()) {
            blockStart = (blockStartDate - drawStartTime.getTime() - Math.min(blockStartDate - drawStartTime.getTime(), HOUR_TO_MS)) / 1000 / 60;
          }

          if (blockStartDate <= daylightSavingsStartDate.getTime() && blockEndDate > daylightSavingsStartDate.getTime()) {
            blockSize = (blockEndDate - blockStartDate - Math.min(blockEndDate - daylightSavingsStartDate.getTime(), HOUR_TO_MS)) / 1000 / 60;
          }
        } else if (dayLightOffset < 0) {
          if (blockStartDate >= daylightSavingsStartDate.getTime()) {
            blockStart = (blockStartDate - drawStartTime.getTime() + HOUR_TO_MS) / 1000 / 60;
          }

          if (blockStartDate < daylightSavingsStartDate.getTime() && blockEndDate >= daylightSavingsStartDate.getTime()) {
            blockSize = blockEndDate - blockStartDate + Math.min(endTime.getTime() - endDate.getTime(), HOUR_TO_MS);
          }
        }

        newBlock.start = blockStart;
        newBlock.size = blockSize;
      }

      if (xuid !== previousXuid) {
        var _find;

        const author = (_find = find_find(players.players, player => player.xuid === xuid)) !== null && _find !== void 0 ? _find : unknownRealmPlayer;
        const blocks = [];

        if (newBlock.size !== 0) {
          blocks.push(newBlock);
        }

        array.push({
          gamerTag: author.gamerTag,
          gamerIcon: author.gamerIcon,
          gamerStatus: author.isOnline === true && author.hasOptedIn === true,
          narrationText: [''],
          blocks: blocks
        });
      } else if (newBlock.size !== 0) {
        array[array.length - 1].blocks.push(newBlock);
      }

      previousXuid = xuid;
    }

    for (let i = 0; i < players.players.length; i++) {
      const gamerTag = players.players[i].gamerTag;
      let alreadyIncluded = false;

      for (let j = 0; j < array.length; j++) {
        if (array[j].gamerTag === gamerTag) {
          alreadyIncluded = true;
          break;
        }
      }

      if (!alreadyIncluded) {
        array.push({
          gamerTag: gamerTag,
          gamerIcon: players.players[i].gamerIcon,
          gamerStatus: players.players[i].isOnline === true && players.players[i].hasOptedIn === true,
          narrationText: [''],
          blocks: []
        });
      }
    }

    for (let i = 0; i < array.length; i++) {
      const narrationText = [];

      for (let j = 0; j < numberOfSegments; j++) {
        const segmentStart = j * TOTAL_BLOCK_IN_ONE_SEGMENT;
        const segmentEnd = (j + 1) * TOTAL_BLOCK_IN_ONE_SEGMENT - 1;
        const playSession = [];

        for (let k = 0; k < array[i].blocks.length; k++) {
          const sessionStart = array[i].blocks[k].start;
          const sessionDuration = array[i].blocks[k].size;
          const sessionEnd = sessionStart + sessionDuration;

          if (sessionStart >= segmentStart && sessionStart < segmentEnd || sessionEnd > segmentStart && sessionEnd <= segmentEnd) {
            const startTimeRaw = Math.max(sessionStart, segmentStart) - segmentStart;
            const startTimeMinute = Math.floor(startTimeRaw % 60);
            const startTimeHour = Math.floor(startTimeRaw / 60);
            const endTimeRaw = Math.min(sessionEnd, segmentEnd) - segmentStart;
            const endTimeMinute = Math.floor(endTimeRaw % 60);
            const endTimeHour = Math.floor(endTimeRaw / 60);
            playSession.push(t('.fromTo', [t('.timeFormat', [startTimeHour.toString(), startTimeMinute.toString()]), t('.timeFormat', [endTimeHour.toString(), endTimeMinute.toString()])]));
          }
        }

        const segmentOffset = numberOfSegments * (totalPages - page) + numberOfSegments - j - 1;
        const segmentDay = new Date();
        segmentDay.setDate(date.getDate() - segmentOffset);
        const dayOfMonthYear = t('.onDayOfMonthYear', [t(DAYS[segmentDay.getDay()]), segmentDay.getDate().toString(), t('.monthYear', [t(MONTHS[segmentDay.getMonth()]), segmentDay.getFullYear().toString()])]);

        if (playSession.length === 0) {
          narrationText.push(t('.didNotPlay', [array[i].gamerTag, dayOfMonthYear]));
        } else {
          let sessionsString = '';

          for (let k = 0; k < playSession.length; k++) {
            if (k === 0) {
              sessionsString = playSession[k];
            } else {
              sessionsString = t('.and', [sessionsString, playSession[k]]);
            }
          }

          narrationText.push(t('.played', [array[i].gamerTag, sessionsString, dayOfMonthYear]));
        }
      }

      array[i].narrationText = narrationText;
    }

    return array;
  }, [numberOfSegments, totalPages, date, t], [sessions, currentPage, players]);
};

/**
 * Hook to sort play data using the order defined in playerTagList
 */
const useSortPlayData = (playData, playerTagList) => {
  return (0,react_facet_src.useFacetMap)((playData, playerTagList) => {
    return playData.sort((a, b) => playerTagList.indexOf(a.gamerTag) - playerTagList.indexOf(b.gamerTag));
  }, [], [playData, playerTagList]);
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/TimelineTab.tsx


















function PlayerTimelineLane({
  gamepadIndex,
  isDarker,
  numberOfSegments,
  maximumBlockCount,
  highlightedSegment,
  blackenedSegmentBefore,
  blockColor,
  playerData
}) {
  const isWindowNarrow = useIsWindowNarrow();
  const neutralColors = hooks_useSemanticColors('neutral');
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.fullWidth, TimelineTab.flexRow)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [TimelineTab.leftSideNarrow]: isWindowNarrow
    }, {
      [TimelineTab.leftSideWide]: !isWindowNarrow
    }, TimelineTab.leftBorder, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(PlayerTag_PlayerTag, {
    gamerIcon: (0,react_facet_src.useFacetMap)(data => data.gamerIcon, [], [playerData]),
    gamerTag: (0,react_facet_src.useFacetMap)(data => data.gamerTag, [], [playerData]),
    onlineStatus: (0,react_facet_src.useFacetMap)(data => data.gamerStatus === true ? 'online' : 'offline', [], [playerData])
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [TimelineTab.rightSideNarrow]: isWindowNarrow
    }, {
      [TimelineTab.rightSideWide]: !isWindowNarrow
    }, TimelineTab.rightBorder, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(Lane_Lane, {
    isDarker: isDarker,
    blockColor: blockColor,
    numberOfSegments: numberOfSegments,
    maximumBlockCount: maximumBlockCount,
    highlightedSegment: highlightedSegment,
    blackenedSegmentBefore: blackenedSegmentBefore,
    gamepadIndex: gamepadIndex,
    blocks: (0,react_facet_src.useFacetMap)(data => data.blocks, [], [playerData]),
    narrationText: (0,react_facet_src.useFacetMap)(data => data.narrationText, [], [playerData])
  })));
}

const TimelineTab_TOTAL_DAYS = 28;
const NARROW_SEGMENT_COUNT = 5;
const WIDE_SEGMENT_COUNT = 7;

function PlayerTimeline() {
  const isWindowNarrow = useIsWindowNarrow();
  const numberOfSegments = isWindowNarrow ? NARROW_SEGMENT_COUNT : WIDE_SEGMENT_COUNT;
  const maximumBlockCount = numberOfSegments * TOTAL_BLOCK_IN_ONE_SEGMENT;
  const totalPages = Math.ceil(TimelineTab_TOTAL_DAYS / numberOfSegments);
  const [currentPage, setCurrentPage] = (0,react_facet_src.useFacetState)(totalPages);
  const date = getCurrentDate();
  const {
    t
  } = localization_useLocalization('Timeline');
  const firstRowHeader = useCreateMonthYearTimelineHeader(currentPage, totalPages, numberOfSegments, date, t);
  const secondRowHeader = useCreateDayDateTimelineHeader(currentPage, totalPages, numberOfSegments, date, t);
  const sessionsRaw = (0,react_facet_src.useSharedFacet)(sessionsFacet);
  const sessions = useGroupSessionsByPlayerXuid(sessionsRaw);
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const playerDataUnsorted = useCreatePlayData(currentPage, sessions, playersFacet, totalPages, numberOfSegments, date, t);
  const realmFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const playerTagList = useGetTimelinePlayerTagList(sessionsRaw, realmFacet, playersFacet);
  const playerData = useSortPlayData(playerDataUnsorted, playerTagList);
  const highlightedSegment = (0,react_facet_src.useFacetMap)(page => totalPages === page ? numberOfSegments - 1 : -1, [totalPages, numberOfSegments], [currentPage]);
  const blackenedSegmentBefore = (0,react_facet_src.useFacetMap)(page => page === 1 ? numberOfSegments * totalPages - TimelineTab_TOTAL_DAYS : -1, [totalPages, numberOfSegments], [currentPage]);
  const neutralColors = hooks_useSemanticColors('neutral');
  const [renderData, setRenderData] = (0,react_facet_src.useFacetState)([]);
  (0,react_facet_src.useFacetEffect)(playerData => {
    setRenderData(playerData);
  }, [setRenderData], [playerData]);
  const firstPlayerData = (0,react_facet_src.useFacetMap)(data => data[0], [], [renderData]);
  const wideAndPlayerDataExists = (0,react_facet_src.useFacetMap)(data => data.length !== 0 && !isWindowNarrow, [isWindowNarrow], [renderData]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, !isWindowNarrow && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.fullWidth, TimelineTab.widePaginationContainer)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.widePaginationWidth, TimelineTab.justifyRightHorizontal)
  }, /*#__PURE__*/react.createElement(Pagination_Pagination, {
    totalPages: totalPages,
    currentPage: currentPage,
    onChange: setCurrentPage,
    hideIndices: true
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.fullWidth, TimelineTab.flexRow)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [TimelineTab.leftSideNarrow]: isWindowNarrow
    }, {
      [TimelineTab.leftSideWide]: !isWindowNarrow
    }, TimelineTab.rightBorder, TimelineTab.bottomBorder, neutralColors.border.base, TimelineTab.justifyCenterVertical)
  }, isWindowNarrow && /*#__PURE__*/react.createElement(Pagination_Pagination, {
    totalPages: totalPages,
    currentPage: currentPage,
    onChange: setCurrentPage,
    hideIndices: true
  })), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [TimelineTab.rightSideNarrow]: isWindowNarrow
    }, {
      [TimelineTab.rightSideWide]: !isWindowNarrow
    }, TimelineTab.topBorder, TimelineTab.rightBorder, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(TwoRowSpreadSheetHeader_TwoRowSpreadSheetHeader, {
    firstRowData: firstRowHeader,
    secondRowData: secondRowHeader
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: wideAndPlayerDataExists
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(PlayerTimelineLane, {
    gamepadIndex: 0,
    isDarker: false,
    numberOfSegments: numberOfSegments,
    maximumBlockCount: maximumBlockCount,
    highlightedSegment: highlightedSegment,
    blackenedSegmentBefore: blackenedSegmentBefore,
    blockColor: 0,
    playerData: firstPlayerData
  }))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.fullWidth, TimelineTab.fullHeight, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()({
      [TimelineTab.considerScrollbarNarrow]: isWindowNarrow
    }, {
      [TimelineTab.considerScrollbarWide]: !isWindowNarrow
    })
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    floating: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TimelineTab.withoutScrollbar, TimelineTab.bottomBorder, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: (0,react_facet_src.useFacetMap)(data => data.slice(isWindowNarrow ? 0 : 1), [isWindowNarrow], [renderData])
  }, (item, index) => /*#__PURE__*/react.createElement(PlayerTimelineLane, {
    gamepadIndex: index,
    isDarker: index % 2 === (isWindowNarrow ? 1 : 0),
    numberOfSegments: numberOfSegments,
    maximumBlockCount: maximumBlockCount,
    highlightedSegment: highlightedSegment,
    blackenedSegmentBefore: blackenedSegmentBefore,
    blockColor: index + (isWindowNarrow ? 0 : 1),
    playerData: item
  })))))));
}

function TimelineTab_TimelineTab() {
  const {
    t
  } = localization_useLocalization('RealmsStories');
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const settingsFacet = (0,react_facet_src.useSharedFacet)(realmStoriesSettingsFacet);
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  const timelineOffMessageVisible = (0,react_facet_src.useFacetMap)((settings, noInternet) => !settings.realmTimelineStatus && !noInternet, [], [settingsFacet, noInternetMessageVisible]);
  const errorMessageVisible = (0,react_facet_src.useFacetMap)((noInternet, timelineOff) => noInternet || timelineOff, [], [noInternetMessageVisible, timelineOffMessageVisible]);
  const narrowImage = useImageBreakpoint({
    wide: 10,
    narrow: 8,
    width: 260
  });
  return /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 10,
    narrowSize: 8,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 10,
    narrow: 8
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: timelineOffMessageVisible
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    autofocus: true,
    title: t('.messages.timelineOff.title'),
    text: t('.messages.timelineOff.body'),
    imgSrc: generic_empty_namespaceObject,
    imgClass: narrowImage ? TimelineTab.emptyStateArt : TimelineTab.emptyStateArtBig
  }))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 3,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 12,
    narrowSize: 8,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(PlayerTimeline, null)))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/Tabs/index.tsx



;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/hooks/useInitializeRealmFacets.tsx



/**
 * A hook that will be called when realms stories is first entered.
 * Its purpose is to pass the realmId to the init() method on the realms action facet and call it.
 * @param: realmId, taken from the realm ID route parameter.
 */

function useInitializeRealmFacets(realmId) {
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const initializeFacet = (0,react_facet_src.useFacetCallback)(actions => realmId => actions.init(realmId), [], [actionsFacet]);
  (0,react.useEffect)(() => {
    initializeFacet(realmId);
  }, [initializeFacet, realmId]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/RealmsStoriesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsStoriesRoute = ({"tabsContainer":"lLbmU"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/RealmsStoriesRoute.tsx
















function RealmsStoriesRoute_RealmsStoriesRoute() {
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const dataFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const routerAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('RealmsStories');
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const tabBarNamespaceAlias = 'realms-stories';
  const setFocusedId = src_useSetFocusedId_useSetFocusedId();
  const headerText = (0,react_facet_src.useFacetMap)(data => `${t('.header', [data.name])}`, [t], [dataFacet]);
  const screenNarration = (0,react_facet_src.useFacetMap)(headerText => `${t('.screen', [headerText])}`, [t], [headerText]);
  const onLeave = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.reset();
    routerAPI.goBack();
  }, [routerAPI], [actionsFacet]); //TODO: Replace this with logic to handle the number of unread stories
  // hint: unreadStories === 1 ? t('.oneUnreadStoryHint') : t('.unreadStoryHint', [unreadStories.toString()]),

  const realmsStoriesTabs = [{
    label: t('.storyFeed'),
    value: RealmsStoriesTabs.Feed,
    hint: t('.oneUnreadStoryHint')
  }, {
    label: t('.timeline'),
    value: RealmsStoriesTabs.Timeline
  }, {
    label: t('.members'),
    value: RealmsStoriesTabs.Members
  }];
  useInitializeRealmFacets(params.realmId);
  const postsFacet = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const onChangeTabCallback = (0,react_facet_src.useFacetCallback)(facet => newValue => {
    setRealmStoriesPostsAsViewed(facet.stories);
    routerAPI.replace(`/realms-stories/${newValue}/${params.realmId}`);
    setFocusedId(TabBar_TabBar_TabBar.getFocusAlias(tabBarNamespaceAlias, newValue));
  }, [params.realmId, routerAPI, setFocusedId], [postsFacet]);
  const navigateToSettings = (0,react_facet_src.useFacetCallback)(facet => () => {
    setRealmStoriesPostsAsViewed(facet.stories);
    routerAPI.push(`/realms-stories-settings/${params.realmId}`);
  }, [params.realmId, routerAPI], [postsFacet]);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, {
    role: "primary"
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: onLeave,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, headerText),
    narrationText: screenNarration,
    right: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.MenuButton, {
      onClick: navigateToSettings,
      type: 'filter',
      gamepadIndex: 1,
      narrationText: t('.narration.settings')
    }),
    gamepadAlias: "realms-stories-route",
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsStoriesRoute.tabsContainer
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(TabBar_TabBar_TabBar, {
    gamepadAliasNamespace: tabBarNamespaceAlias,
    gamepadIndex: 0,
    tabs: realmsStoriesTabs,
    value: params.tab ? params.tab : RealmsStoriesTabs.Feed,
    enableGamepadShortcuts: true,
    onChange: onChangeTabCallback,
    narrationTitle: t('.narration.title')
  })))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: StoryFeedTab_StoryFeedTab,
    tab: RealmsStoriesTabs.Feed
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: TimelineTab_TimelineTab,
    tab: RealmsStoriesTabs.Timeline
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    component: MemberTab,
    tab: RealmsStoriesTabs.Members
  }), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesRoute/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/hooks/useRedirectOnPostSuccess.tsx



/**
 * A hook that will be called when a new story is successfully posted.
 * Its purpose is to reset persistent data properties, clear the post story status, and go back to story feed
 * after a new story has been post.
 */

function useRedirectOnPostSuccess() {
  const actions = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const persistentData = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const storiesFacet = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const routerAPI = hooks_useRouterAPI();
  const postStoryStatus = (0,react_facet_src.useFacetMap)(facet => facet.postStoryStatus, [], [storiesFacet]);
  const clearPostStoryStatus = (0,react_facet_src.useFacetCallback)(actions => () => actions.clearPostStoryStatus(), [], [actions]);
  const clearPersistentData = (0,react_facet_src.useFacetCallback)(persistentData => () => {
    persistentData.postInProgressBody = '';
    persistentData.storyScreenshotSelectionFilePath = '';
  }, [], [persistentData]);
  (0,react_facet_src.useFacetEffect)(status => {
    if (status === PostStatus.Success) {
      clearPostStoryStatus();
      clearPersistentData();
      routerAPI.goBack();
    }
  }, [clearPostStoryStatus, clearPersistentData, routerAPI], [postStoryStatus]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/Modals/PostingStoryProgressModal.tsx






function PostingStoryProgressModal_noop() {}
/**
 * The PostingStoryProgressModal component represents a modal that becomes visible during the
 * posting of a new realms story.
 */


const PostingStoryProgressModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('RealmsNewStoryRoute.modals');
  const isNarrationEnabled = useNarrationEnabled();
  const FOCUS_ALIAS_CONTENT = 'posting-story-progress-content-focus';
  const FOCUS_ALIAS_CLOSE = 'posting-story-progress-close-focus'; // We only want the close button to exist as an invisible button
  // to move focus to _if_ narration is disabled. If narration is enabled,
  // then we just put focus on the content and narrate that.

  const onClose = isNarrationEnabled ? undefined : PostingStoryProgressModal_noop;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: isNarrationEnabled ? FOCUS_ALIAS_CONTENT : FOCUS_ALIAS_CLOSE
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    closeButtonGamepadAlias: FOCUS_ALIAS_CLOSE,
    hideCloseButton: true,
    onClose: onClose
  }, t('.postingStoryTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    gamepadAlias: FOCUS_ALIAS_CONTENT
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Spinner, null)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/Modals/PostingStoryErrorModal.tsx






const PostingStoryErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('RealmsNewStoryRoute.modals');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-postingStoryErrorModal';
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const onClose = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.clearPostStoryStatus();
  }, [], [actionsFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.errorModalTitle')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.errorModalBody'),
    gamepadIndex: 0
  }, t('.errorModalBody'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.close'),
    variant: "secondary",
    onClick: onClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/Modals/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/images/add-image-dark-icon.png
const add_image_dark_icon_namespaceObject = __webpack_require__.p + "assets/add-image-dark-icon-7fb8f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/RealmsNewStoryRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsNewStoryRoute = ({"buttonRowContainer":"juocW","border":"A6Wiz","iconContainer":"QTomy"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/RealmsNewStoryRoute.tsx






















function RealmsNewStoryRoute_RealmsNewStoryRoute() {
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const persistentFacet = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const realmFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const storyFacet = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const screenshotFacet = (0,react_facet_src.useSharedFacet)(localScreenshotsFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const routerAPI = hooks_useRouterAPI();
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const {
    t
  } = useLocalization_useLocalization('RealmsNewStoryRoute');
  const postAuthor = (0,react_facet_src.useFacetMap)((facet, {
    userXuid
  }) => {
    var _find;

    return (_find = find_find(facet.players, player => player.xuid === userXuid)) !== null && _find !== void 0 ? _find : unknownRealmPlayer;
  }, [], [playersFacet, realmFacet]);
  const authorGamerIcon = (0,react_facet_src.useFacetMap)(player => player.gamerIcon, [], [postAuthor]);
  const isPostEmpty = (0,react_facet_src.useFacetMap)(persistentData => !persistentData.postInProgressBody.length && !persistentData.storyScreenshotSelectionFilePath.length, [], [persistentFacet]);
  const storyHasImage = (0,react_facet_src.useFacetMap)(persistentData => persistentData.storyScreenshotSelectionFilePath.length > 0, [], [persistentFacet]);
  const postStatus = (0,react_facet_src.useFacetMap)(facet => facet.postStoryStatus, [], [storyFacet]);
  const isPostingStory = (0,react_facet_src.useFacetMap)(status => status === PostStatus.InProgress || status === PostStatus.Uploading, [], [postStatus]);
  const showPostErrorModal = (0,react_facet_src.useFacetMap)(status => status === PostStatus.InputInvalid || status === PostStatus.InternalError || status === PostStatus.PostingFailed || status === PostStatus.UploadFailed, [], [postStatus]);
  const showRateLimitError = (0,react_facet_src.useFacetMap)(status => status === PostStatus.RateLimit, [], [postStatus]);
  const onCloseError = (0,react_facet_src.useFacetCallback)(actions => () => {
    actions.clearPostStoryStatus();
  }, [], [actionsFacet]);
  const selectedImage = (0,react_facet_src.useFacetMap)((facet, {
    storyScreenshotSelectionFilePath
  }) => {
    if (!storyScreenshotSelectionFilePath.length) return '';
    const screenshot = find_find(facet.localScreenshots, screenshot => screenshot.filePath === storyScreenshotSelectionFilePath);
    return screenshot != null ? screenshot.image : '';
  }, [], [screenshotFacet, persistentFacet]);
  const onLeave = (0,react_facet_src.useFacetCallback)(persistentData => () => {
    persistentData.postInProgressBody = '';
    persistentData.storyScreenshotSelectionFilePath = '';
    routerAPI.goBack();
  }, [routerAPI], [persistentFacet]);
  const onRemoveImage = (0,react_facet_src.useFacetCallback)(persistentData => () => {
    persistentData.storyScreenshotSelectionFilePath = '';
  }, [], [persistentFacet]);
  const postBodyValue = (0,react_facet_src.useFacetMap)(facet => facet.postInProgressBody, [], [persistentFacet]);
  const onBodyTextChange = (0,react_facet_src.useFacetCallback)(facet => newValue => {
    facet.postInProgressBody = newValue;
  }, [], [persistentFacet]);
  const postStory = (0,react_facet_src.useFacetCallback)((facet, status) => () => {
    if (status === PostStatus.Idle) {
      facet.postStory();
    }
  }, [], [actionsFacet, postStatus]);
  const postSuffixNarration = (0,react_facet_src.useFacetMap)(isPostEmpty => `${isPostEmpty ? t('.disabled') : ''} . ${t('.postStoryHint')}`, [t], [isPostEmpty]);
  const postInputFieldNarration = (0,react_facet_src.useFacetMap)(value => `${t('.textBoxPlaceholder')} . ${t('.inputField')} . ${value.length > 0 ? value : t('.inputFieldHint')}`, [t], [postBodyValue]);
  useRedirectOnPostSuccess();

  const goToImageSelect = () => routerAPI.push('/realms-new-story/image-select');

  const neutralColors = hooks_useSemanticColors('neutral');
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, {
    role: "primary"
  }, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: onLeave,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.addStory')),
    gamepadAlias: "realms-new-story-route"
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isPostingStory
  }, /*#__PURE__*/react.createElement(PostingStoryProgressModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPostErrorModal
  }, /*#__PURE__*/react.createElement(PostingStoryErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitError
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onCloseError
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 12,
    narrow: 8
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 1,
    narrowSize: 1
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.iconContainer
  }, /*#__PURE__*/react.createElement(PlayerAvatar_PlayerAvatar_PlayerAvatar, {
    src: authorGamerIcon,
    variant: "large"
  }))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 10,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.border
  }, /*#__PURE__*/react.createElement(Form, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, t('.selectScreenshot')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: storyHasImage,
    condition: false
  }, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    gamepadIndex: 0,
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    onClick: goToImageSelect,
    inputLegend: t('.addScreenshot'),
    imgSrc: add_image_dark_icon_namespaceObject,
    narrationPrefix: t('.addScreenshot')
  }, t('.addScreenshot')))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: storyHasImage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmsNewStoryRoute.border, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: selectedImage,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    gamepadIndex: 1,
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.buttonRowContainer
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.changeScreenshotImage'),
    onClick: goToImageSelect,
    narrationPrefix: t('.changeScreenshotImage'),
    horizontal: true
  }, t('.change')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.removeScreenshotImage'),
    onClick: onRemoveImage,
    narrationPrefix: t('.removeScreenshotImage'),
    horizontal: true
  }, t('.remove')))))))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    gamepadIndex: 2,
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement(BaseTextField_BaseTextField, {
    gamepadIndex: 0,
    maxLength: 350,
    rows: 3,
    placeholder: t('.textBoxPlaceholder'),
    value: postBodyValue,
    onChange: onBodyTextChange,
    narrationText: postInputFieldNarration,
    disabled: isPostingStory
  })))), /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(GamepadRow_GamepadRow, {
    shouldSkipLandmarkInVisual: true
  }, /*#__PURE__*/react.createElement("div", {
    className: RealmsNewStoryRoute.buttonRowContainer
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 3,
    inputLegend: t('.cancel'),
    onClick: onLeave,
    horizontal: true,
    narrationPrefix: t('.cancel')
  }, t('.cancel')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 4,
    inputLegend: t('.postStory'),
    variant: "primary",
    onClick: postStory,
    disabled: (0,react_facet_src.useFacetMap)((isPostEmpty, isPosting) => isPosting || isPostEmpty, [], [isPostEmpty, isPostingStory]),
    horizontal: true,
    narrationPrefix: t('.postStory'),
    narrationSuffix: postSuffixNarration
  }, t('.post')))))))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })
  }))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 2,
    wideSize: 1,
    narrowSize: 1
  })))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryImageSelectRoute/RealmsNewStoryImageSelectRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsNewStoryImageSelectRoute = ({"noScreenshotsImage":"Ntpma"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryImageSelectRoute/images/no-screenshots.png
const no_screenshots_namespaceObject = __webpack_require__.p + "assets/no-screenshots-0bef2.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryImageSelectRoute/RealmsNewStoryImageSelectRoute.tsx













function RealmsNewStoryImageSelectRoute_RealmsNewStoryImageSelectRoute() {
  const screenshotsFacet = (0,react_facet_src.useSharedFacet)(localScreenshotsFacet);
  const persistentFacet = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const routerAPI = hooks_useRouterAPI();
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const {
    t
  } = useLocalization_useLocalization('RealmsNewStoryImageSelectRoute');
  const localScreenshots = (0,react_facet_src.useFacetMap)(facet => facet.localScreenshots, [], [screenshotsFacet]);
  const totalScreenshots = (0,react_facet_src.useFacetMap)(screenshots => screenshots.length, [], [localScreenshots]);
  const imageSelectNarration = `${t('.selectAScreenshot')} . ${t('.group')}`;
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: routerAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.selectScreenshot')),
    gamepadAlias: "realms-new-story-image-select"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 12,
    narrow: 8
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: imageSelectNarration
  }, /*#__PURE__*/react.createElement(GridList_GridList, {
    autofocus: true,
    gamepadIndex: 0,
    columns: breakpoint === 'narrow' ? 2 : 3,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    }),
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 1 : 3
    }),
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    renderItem: ({
      itemFacet,
      index,
      columnIndex,
      rowIndex
    }) => /*#__PURE__*/react.createElement(ScreenshotContainer, {
      screenshot: itemFacet,
      persistentFacet: persistentFacet,
      index: index,
      autofocus: columnIndex === 0 && rowIndex === 0,
      total: totalScreenshots
    }),
    data: localScreenshots,
    emptyMessage: /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
      gamepadIndex: 1,
      title: t('.noScreenshotsMessageTitle'),
      text: t('.noScreenshotsMessageBody'),
      imgSrc: no_screenshots_namespaceObject,
      imgClass: RealmsNewStoryImageSelectRoute.noScreenshotsImage
    }),
    footer: /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    }))
  }))))))));
}

function ScreenshotContainer({
  screenshot,
  persistentFacet,
  autofocus,
  index,
  total
}) {
  const routerAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('RealmsNewStoryImageSelectRoute');
  const image = (0,react_facet_src.useFacetMap)(screenshot => screenshot.image, [], [screenshot]);
  const lastModifiedTime = (0,react_facet_src.useFacetMap)(screenshot => screenshot.printableModifiedTime, [], [screenshot]);
  const isSelected = (0,react_facet_src.useFacetMap)((screenshot, facet) => screenshot.filePath === facet.storyScreenshotSelectionFilePath, [], [screenshot, persistentFacet]);
  const onScreenshotClick = (0,react_facet_src.useFacetCallback)((screenshot, persistentData, isSelected) => () => {
    persistentData.storyScreenshotSelectionFilePath = isSelected ? '' : screenshot.filePath;
    routerAPI.goBack();
  }, [routerAPI], [screenshot, persistentFacet, isSelected]);
  const selectionText = (0,react_facet_src.useFacetMap)(isSelected => isSelected ? t('.isSelected') : t('.notSelected'), [t], [isSelected]);
  const imageEnumerationText = (0,react_facet_src.useFacetMap)(total => t('.screenshotEnumeration', [(index + 1).toString(), total.toString()]), [t, index], [total]);
  const suffixNarrationText = (0,react_facet_src.useFacetMap)((selectionText, lastModifiedTime, imageEnumerationText) => `${selectionText} . ${imageEnumerationText} . ${t('.screenshotTaken', [lastModifiedTime])}`, [t], [selectionText, lastModifiedTime, imageEnumerationText]);
  return /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: index,
    onClick: onScreenshotClick,
    inputLegend: t('.selectImage'),
    autofocus: autofocus,
    narrationSuffix: suffixNarrationText
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: t('.screenshot')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, lastModifiedTime))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsNewStoryImageSelectRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/TemplateCommon.tsx





function getMessageImage(message, imageID) {
  for (let i = 0; i < message.images.length; i++) {
    const image = message.images[i];
    if (image == null || image.id != imageID) continue;
    if (image.isLoaded) return image;
    return null;
  }

  return null;
}
function getMessageImageUrl(message, imageID) {
  const image = getMessageImage(message, imageID);
  if (image && image.url.length > 0) return image.url;
  return null;
}
function getMessageButton(message, buttonID) {
  for (let i = 0; i < message.buttons.length; i++) {
    const button = message.buttons[i];
    if (button != null && button.id == buttonID) return button;
  }

  return null;
}
function getButtonText(message, buttonID, fallback = '') {
  const button = getMessageButton(message, buttonID);
  if (button != null && button.text.length > 0) return button.text;
  return fallback;
}
function TemplateCommon_ErrorModal({
  errorMessage,
  messageID
}) {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  let title = String(t('.errorTitle'));
  const bodyText = String(errorMessage);

  if (messageID != null) {
    title += ' ID: ' + messageID;
  }

  const continueClick = function () {
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: title + bodyText
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, bodyText))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: () => continueClick()
  }, t('.continue')))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageThumbnailCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ImageThumbnailCTA = ({"headerDiv":"mbdeF","image1Div":"q5uyU","image2Div":"hkTtP","imageFill":"CZukv","rightDiv":"Fhcnq","buttonDiv":"kiYsW","boarderStyle":"U_nrH"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageThumbnailCTA.tsx










const CONTINUE_BUTTON_ID = 'Dismiss';
const UNLOCK_BUTTON_ID = 'CallToAction';
const LARGE_IMAGE_ID = 'Primary';
const SMALL_IMAGE_ID = 'Secondary'; //check if all non-default message properties are present

function hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'ImageThumbnailCTA' && announcement.images.length >= 2 && getMessageButton(announcement, UNLOCK_BUTTON_ID) != null) return true;
  return false;
}

function joinClasses(head, tail) {
  return head + ' ' + tail;
}

function ImageThumbnailCTA_ImageThumbnailCTA({
  announcement
}) {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportClick = (0,react_facet_src.useFacetCallback)(report => (messageID, button) => {
    report(messageID, button.id);
    button.reportClick();
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportClick)]);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  const title = message.header;
  const bodyText = message.body;

  if (bodyText == null || title == null || !hasRequiredProperties(message)) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorInvalidTemplate')
    });
  }

  const continueButtonText = getButtonText(message, CONTINUE_BUTTON_ID, t('.continue'));
  const unlockButton = getMessageButton(message, UNLOCK_BUTTON_ID);
  const unlockButtonText = getButtonText(message, UNLOCK_BUTTON_ID, t('.unlock'));
  const image1 = getMessageImageUrl(message, LARGE_IMAGE_ID);
  const image2 = getMessageImageUrl(message, SMALL_IMAGE_ID);

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  const fillWidth = {
    width: '100%'
  };
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.headerDiv
  }, /*#__PURE__*/react.createElement("div", {
    className: joinClasses(ImageThumbnailCTA.image1Div, ImageThumbnailCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image1}`,
    className: ImageThumbnailCTA.imageFill
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.rightDiv
  }, /*#__PURE__*/react.createElement("div", {
    className: joinClasses(ImageThumbnailCTA.image2Div, ImageThumbnailCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image2}`,
    className: ImageThumbnailCTA.imageFill
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("div", {
    className: ImageThumbnailCTA.buttonDiv
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    inputLegend: t('.confirmInputLegend'),
    variant: "primary",
    onClick: () => {
      if (unlockButton != null) {
        reportClick(message.id, unlockButton);
        reportDismiss(message.id);
      }
    }
  }, unlockButtonText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    style: fillWidth
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left",
    whiteSpace: "preWrap"
  }, bodyText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal
  }, continueButtonText)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageText.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ImageText = ({"mainImage":"NQe8O","textBox":"L5DW3","imageFill":"WuFak","boarderStyle":"f9XJI"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/ImageText.tsx









const ImageText_CONTINUE_BUTTON_ID = 'Dismiss';
const MAIN_IMAGE_ID = 'Primary'; //check if all non-default message properties are present

function ImageText_hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'ImageText' && announcement.images.length >= 1) return true;
  return false;
}

let imgWidth;

function calculateWidth() {
  const rem = parseFloat(window.getComputedStyle(document.documentElement).fontSize);
  const vh = window.innerHeight / 100;
  const imgHeight = 16;
  const imgMaxHeight = 26.8;
  imgWidth = imgMaxHeight * vh < 16 * rem ? 'calc(' + imgMaxHeight.toString() + 'vh * 16 / 9)' : 'calc(' + imgHeight.toString() + 'rem * 16 / 9)';
}

function ImageText_ImageText({
  announcement
}) {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  const title = message.header;
  const bodyText = message.body;

  if (bodyText == null || title == null || !ImageText_hasRequiredProperties(message)) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorInvalidTemplate')
    });
  }

  const image = getMessageImageUrl(message, MAIN_IMAGE_ID);
  const continueButtonText = getButtonText(message, ImageText_CONTINUE_BUTTON_ID, t('.continue'));

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  calculateWidth();
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageText.mainImage
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image}`,
    className: ImageText.imageFill + ' ' + ImageText.boarderStyle,
    width: imgWidth
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    className: ImageText.textBox
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left",
    whiteSpace: "preWrap"
  }, bodyText)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal
  }, continueButtonText)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/HeroImageCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const HeroImageCTA = ({"outerDiv":"oQouW","imageContainer":"ncO_r","textBox":"FDtOo","imageFill":"zahMv","boarderStyle":"CL2fS"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates/HeroImageCTA.tsx










const HeroImageCTA_CONTINUE_BUTTON_ID = 'Dismiss';
const HeroImageCTA_UNLOCK_BUTTON_ID = 'CallToAction';
const HeroImageCTA_MAIN_IMAGE_ID = 'Primary'; //check if all non-default message properties are present

function HeroImageCTA_hasRequiredProperties(announcement) {
  if (announcement.surface === 'LoginAnnouncement' && announcement.template === 'HeroImageCTA' && announcement.images.length >= 1) return true;
  return false;
}

function HeroImageCTA_joinClasses(head, tail) {
  return head + ' ' + tail;
}

function HeroImageCTA_HeroImageCTA({
  announcement
}) {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const message = (0,react_facet_src.useFacetUnwrap)(announcement);
  const reportClick = (0,react_facet_src.useFacetCallback)(report => (messageID, button) => {
    report(messageID, button.id);
    button.reportClick();
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportClick)]);
  const reportDismiss = (0,react_facet_src.useFacetCallback)(reportDismiss => messageID => {
    reportDismiss(messageID);
  }, [], [(0,react_facet_src.useSharedFacet)(applyReportDismiss)]);

  if (message === react_facet_src.NO_VALUE || message == null) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorNoMessage')
    });
  }

  const title = message.header;
  const bodyText = message.body;

  if (bodyText == null || title == null || !HeroImageCTA_hasRequiredProperties(message)) {
    return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
      errorMessage: t('.errorInvalidTemplate')
    });
  }

  const continueButtonText = getButtonText(message, HeroImageCTA_CONTINUE_BUTTON_ID, t('.continue'));
  const unlockButton = getMessageButton(message, HeroImageCTA_UNLOCK_BUTTON_ID);
  const unlockButtonText = getButtonText(message, HeroImageCTA_UNLOCK_BUTTON_ID, t('.unlock'));
  const image = getMessageImageUrl(message, HeroImageCTA_MAIN_IMAGE_ID);

  const dismissModal = () => {
    reportDismiss(message.id);
    historyAPI.goBack();
  };

  function includeUnlock(id) {
    return /*#__PURE__*/react.createElement(Button_Button_Button, {
      gamepadIndex: 2,
      inputLegend: t('.confirmInputLegend'),
      variant: "primary",
      onClick: () => {
        if (unlockButton != null) {
          reportClick(id, unlockButton);
          reportDismiss(id);
        }
      },
      horizontal: true
    }, unlockButtonText);
  }

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: dismissModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    focusableIfScrollable: true
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA.outerDiv
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA_joinClasses(HeroImageCTA.imageContainer, HeroImageCTA.boarderStyle)
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: `${image}`,
    className: HeroImageCTA.imageFill
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: bodyText
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroImageCTA.textBox
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    verticalAlign: "center",
    align: "left",
    role: "inherit",
    whiteSpace: "preWrap"
  }, bodyText))))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.confirmInputLegend'),
    variant: "secondary",
    onClick: dismissModal,
    horizontal: true
  }, continueButtonText), unlockButton != null && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), unlockButton != null && includeUnlock(message.id)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/Templates.tsx




;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/AnnouncementModalRoute.tsx







function DynamicTemplate({
  template: templateWrapped,
  message: messageWrapped
}) {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const template = (0,react_facet_src.useFacetUnwrap)(templateWrapped);
  const message = (0,react_facet_src.useFacetUnwrap)(messageWrapped);
  if (template == react_facet_src.NO_VALUE || message == react_facet_src.NO_VALUE) return null;

  switch (template) {
    case 'ImageText':
      return /*#__PURE__*/react.createElement(ImageText_ImageText, {
        announcement: message
      });

    case 'ImageThumbnailCTA':
      return /*#__PURE__*/react.createElement(ImageThumbnailCTA_ImageThumbnailCTA, {
        announcement: message
      });

    case 'HeroImageCTA':
      return /*#__PURE__*/react.createElement(HeroImageCTA_HeroImageCTA, {
        announcement: message
      });

    default:
      return /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
        errorMessage: t('.errorUnsupportedTemplate')
      });
  }
}

function AnnouncementModalRoute() {
  const {
    t
  } = useLocalization_useLocalization('AnnouncementModalRoute');
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const data = (0,react_facet_src.useSharedFacet)(messageDetailSelector(params.id));
  const message = (0,react_facet_src.useFacetMap)(facet => facet.message, [], [data]);
  const isLoadedWithMessage = (0,react_facet_src.useFacetMap)((data, message) => data.isLoaded && message != null, [], [data, message]);
  const messageIsMissing = (0,react_facet_src.useFacetMap)((data, message) => data.isLoaded && message == null, [], [data, message]);
  const template = (0,react_facet_src.useFacetMap)(facet => facet === null || facet === void 0 ? void 0 : facet.template, [], [message]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoadedWithMessage
  }, /*#__PURE__*/react.createElement(DynamicTemplate, {
    template: template // We validate message exists in isLoadedWithMessage
    ,
    message: message
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: messageIsMissing
  }, /*#__PURE__*/react.createElement(TemplateCommon_ErrorModal, {
    errorMessage: t('.errorNoMessage')
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AnnouncementModalRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/engine/src/playerBannedFacet.ts

const PLAYER_BANNED_FACET = 'vanilla.playerBanned';
const playerBannedFacet = (0,react_facet_src.sharedFacet)(PLAYER_BANNED_FACET);
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayerBannedModalRoute/PlayerBannedModalRoute.tsx







function getBanTimeRemainingBody(timeRemaining, isPermanent, isHours, t) {
  if (isPermanent) {
    return t('.body.forever');
  } else if (timeRemaining == null || timeRemaining == '0') {
    return '';
  } else if (timeRemaining == '1') {
    return isHours ? t('.body.hour') : t('.body.day');
  } else {
    return isHours ? t('.body.hours', [timeRemaining]) : t('.body.days', [timeRemaining]);
  }
}

const PlayerBannedModalRoute = () => {
  var _params$get;

  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('PlayerBannedModalRoute');
  const openBannedInfoPage = (0,react_facet_src.useFacetCallback)(facet => () => facet.openBannedInfoPage(), [], [(0,react_facet_src.useSharedFacet)(playerBannedFacet)]);
  const params = useRouteQueryUnwrapped();
  const banReason = t('.' + ((_params$get = params.get('banReason')) !== null && _params$get !== void 0 ? _params$get : 'unknownReportArea'));
  const timeRemaining = params.get('timeRemaining');
  const isHours = params.get('isHours') == '1';
  const isPermanent = params.get('isPermanent') == '1';
  const banType = isPermanent ? t('.permanent') : t('.temporary');
  const bannedBody = t('.body', [banType, banReason]);
  const closeButtonText = t('.close');
  const bannedBody2 = t('.body2', [closeButtonText, banType]);
  const modalTitle = t('.title', [banType]);
  const banTimeRemainingBody = getBanTimeRemainingBody(timeRemaining, isPermanent, isHours, t);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: () => historyAPI.goBack()
  }, modalTitle), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${bannedBody}. ${bannedBody2} . ${banTimeRemainingBody}`,
    spaceBetweenParagraphs: 4,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bannedBody), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, bannedBody2), banTimeRemainingBody != '' && /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, banTimeRemainingBody))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: closeButtonText,
    variant: "primary",
    delayedClick: true,
    onClick: openBannedInfoPage
  }, closeButtonText)));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayerBannedModalRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesOptInModals/RealmsStoryOptInModal.tsx






const RealmsStoryOptInModal = registerModal(({
  onOptInCompleted
}) => {
  const DEFAULT_FOCUS_ALIAS = 'Open-Realms-Stories-Button';
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.OptInModal');
  const closeModal = useHideModal();
  const onOpenStories = (0,react.useCallback)(() => {
    closeModal();
    onOptInCompleted();
  }, [onOptInCompleted, closeModal]);
  const title = t('.title');
  const message = t('.message');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: s('.select'),
    variant: "primary",
    onClick: onOpenStories
  }, t('.openStoriesButton')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesOptInModals/RealmsStoryOptOutModal.tsx






function RealmsStoryOptOutModal({
  onOptOutCompleted,
  children
}) {
  const DEFAULT_FOCUS_ALIAS = 'Opt-Out-Button';
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.OptOutModal');
  const closeModal = useHideModal();
  const handleOptOut = (0,react.useCallback)(() => {
    closeModal();
    onOptOutCompleted();
  }, [closeModal, onOptOutCompleted]);
  const title = t('.title');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, children), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    autofocus: true,
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: s('.select'),
    variant: "destructive",
    onClick: handleOptOut
  }, t('.confirm')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: s('.select'),
    gamepadIndex: 1,
    variant: "secondary",
    onClick: closeModal
  }, t('.cancel'))));
}

const RealmsStoryMemberOptOutModal = registerModal(({
  onOptOutCompleted
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.OptOutModal');
  const message = t('.realmMember.message');
  return /*#__PURE__*/react.createElement(RealmsStoryOptOutModal, {
    onOptOutCompleted: onOptOutCompleted
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message
  }, message));
});
const RealmsStoryOwnerOptOutModal = registerModal(({
  onOptOutCompleted
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.OptOutModal');
  const messageP1 = t('.realmOwner.message.para.1');
  const messageP2 = t('.realmOwner.message.para.2');
  return /*#__PURE__*/react.createElement(RealmsStoryOptOutModal, {
    onOptOutCompleted: onOptOutCompleted
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    narrationText: [messageP1, messageP2].join(' . '),
    spaceBetweenParagraphs: 5
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP1), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP2)));
});
const RealmsStorySettingsMemberOptOutModal = registerModal(({
  onOptOutCompleted
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.settings.OptOutModal');
  const messageP1 = t('.realmMember.message');
  const messageP2 = t('.message');
  return /*#__PURE__*/react.createElement(RealmsStoryOptOutModal, {
    onOptOutCompleted: onOptOutCompleted
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    narrationText: [messageP1, messageP2].join(' . '),
    spaceBetweenParagraphs: 5
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP1), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP2)));
});
const RealmsStorySettingsOwnerOptOutModal = registerModal(({
  onOptOutCompleted
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.settings.OptOutModal');
  const messageP1 = t('.realmOwner.message');
  const messageP2 = t('.message');
  return /*#__PURE__*/react.createElement(RealmsStoryOptOutModal, {
    onOptOutCompleted: onOptOutCompleted
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    narrationText: [messageP1, messageP2].join(' . '),
    spaceBetweenParagraphs: 5
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP1), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP2)));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesOptInModals/RealmsStoryOwnerOptInNoticeModal.tsx




const RealmsStoryOwnerOptInNoticeModal = registerModal(({
  onNoticeClosed
}) => {
  const DEFAULT_FOCUS_ALIAS = 'Got-It-Realms-Stories-Button';
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.OptInNoticeModal');
  const closeModal = useHideModal();
  const handleNoticeClose = (0,react.useCallback)(() => {
    closeModal();
    onNoticeClosed();
  }, [closeModal, onNoticeClosed]);
  const title = t('.title');
  const messageP1 = t('.message.p1');
  const messageP2 = t('.message.p2');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    narrationText: [messageP1, messageP2].join(' . '),
    spaceBetweenParagraphs: 5
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP1), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, messageP2))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    autofocus: true,
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: s('.select'),
    variant: "secondary",
    onClick: handleNoticeClose
  }, t('.gotItButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesOptInModals/RealmsStoryShareLinkModal.tsx







const RealmsStoryShareLinkModal = registerModal(({
  playNow,
  openStories
}) => {
  const DEFAULT_FOCUS_ALIAS = 'Play-Realms-Button';
  const {
    t: s
  } = useLocalization_useLocalization('RealmsStories');
  const {
    t: t
  } = useLocalization_useLocalization('RealmsStories.ShareLink');
  const title = t('.title');
  const message = t('.message');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: message
  }, message)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    gamepadIndex: 0,
    inputLegend: s('.select'),
    variant: "primary",
    onClick: playNow
  }, t('.playNow')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: s('.select'),
    gamepadIndex: 1,
    variant: "secondary",
    onClick: openStories
  }, t('.openStories')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoriesOptInModals/index.ts







;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesSettingsRoute/hooks/useInitialiseRealm.ts




function useInitialiseRealm() {
  const firstFetchDone = (0,react.useRef)(false);
  const paramsFacet = hooks_useRouteParams();
  const realmIdFacet = (0,react_facet_src.useFacetMap)(params => params.realmId, [], [paramsFacet]);
  (0,react_facet_src.useFacetEffect)((actions, realmId) => {
    if (!firstFetchDone.current) {
      actions.clearSettingsStatus();
      actions.init(realmId);
      actions.fetchSettings(realmId);
      firstFetchDone.current = true;
    }
  }, [firstFetchDone], [(0,react_facet_src.useSharedFacet)(realmActionsFacet), realmIdFacet]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesSettingsRoute/hooks/useExitRealmsStoriesOnOptOutComplete.ts



function useExitRealmsStoriesOnOptOutComplete() {
  const routerAPI = hooks_useRouterAPI();
  const isRouteActive = hooks_useRouteIsActive();
  (0,react_facet_src.useFacetEffect)((actions, settings, isRouteActive) => {
    if (!isRouteActive) {
      return;
    } // Only used when opting Out is successful


    if (settings.currentPostState === postStatus.Success && settings.currentFetchState === fetchStatus.Success) {
      actions.clearSettingsStatus(); // The Double back here is intentional.
      // When opting out of realms stories we also want to back out from the stories page,
      // which will always be the previous page

      routerAPI.goBack();
      routerAPI.goBack();
    }
  }, [routerAPI], [(0,react_facet_src.useSharedFacet)(realmActionsFacet), (0,react_facet_src.useSharedFacet)(realmStoriesSettingsFacet), isRouteActive]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesSettingsRoute/RealmStoriesSettingsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmStoriesSettingsRoute = ({"spinner":"mm198","containerBorder":"r8kuw"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesSettingsRoute/RealmsStoriesSettingsRoute.tsx

















function RealmsStoriesSettingsRoute() {
  useInitialiseRealm();
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.settings');
  const isRouteActive = hooks_useRouteIsActive();
  const routerAPI = hooks_useRouterAPI();
  const settingsFacet = (0,react_facet_src.useSharedFacet)(realmStoriesSettingsFacet);
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const isOwnerFacet = (0,react_facet_src.useFacetMap)(realmDataFacet => realmDataFacet.userXuid === realmDataFacet.ownerXuid, [], [(0,react_facet_src.useSharedFacet)(realmDataFacet)]);
  const realmName = (0,react_facet_src.useFacetMap)(realmData => {
    return t('.header', [realmData.name]);
  }, [t], [(0,react_facet_src.useSharedFacet)(realmDataFacet)]);
  const screenHeaderNarration = (0,react_facet_src.useFacetMap)(realmData => {
    return t('.screenheader', [realmData.name]);
  }, [t], [(0,react_facet_src.useSharedFacet)(realmDataFacet)]);
  const optOutDescription = (0,react_facet_src.useFacetMap)(isOwner => isOwner ? t('.optOut.realmOwner.description') : t('.optOut.realmMember.description'), [t], [isOwnerFacet]);
  const personalSettingsHeader = (0,react_facet_src.useFacetMap)(isOwner => isOwner ? t('.personalSettings.header') : t('.personalSettings.member.header'), [t], [isOwnerFacet]); // Loading and Error modals

  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  const unknownErrorVisible = (0,react_facet_src.useFacetMap)((settings, noInternet) => (settings.currentFetchState === fetchStatus.InternalError || settings.currentFetchState === fetchStatus.FetchFailed || settings.currentFetchState === fetchStatus.RateLimit) && !noInternet, [], [settingsFacet, noInternetMessageVisible]);
  const errorMessageVisible = (0,react_facet_src.useFacetMap)((noInternet, unknownError) => noInternet || unknownError, [], [noInternetMessageVisible, unknownErrorVisible]);
  const showFailedError = (0,react_facet_src.useFacetMap)((settings, isRouteActive) => isRouteActive && (settings.currentPostState == postStatus.InternalError || settings.currentPostState == postStatus.InputInvalid || settings.currentPostState == postStatus.UploadFailed || settings.currentPostState == postStatus.PostingFailed), [], [settingsFacet, isRouteActive]);
  const showRateLimitError = (0,react_facet_src.useFacetMap)((isRouteActive, settings) => isRouteActive && settings.currentPostState == postStatus.RateLimit, [], [isRouteActive, settingsFacet]);
  const showPostSettingsLoading = (0,react_facet_src.useFacetMap)((settings, isRouteActive, isShowingFailedError, isShowingRateLimitError) => {
    return isRouteActive && settings.currentPostState == postStatus.InProgress && !isShowingFailedError && !isShowingRateLimitError;
  }, [], [settingsFacet, isRouteActive, showFailedError, showRateLimitError]);
  const showFetchSettingsLoading = (0,react_facet_src.useFacetMap)((settings, errorMessageVisible) => settings.currentFetchState != fetchStatus.Success && !errorMessageVisible, [], [settingsFacet, errorMessageVisible]);
  const showSettings = (0,react_facet_src.useFacetMap)((settingsLoading, errorMessageVisible) => !settingsLoading && !errorMessageVisible, [], [showFetchSettingsLoading, errorMessageVisible]); // Opting out and Exit

  const params = hooks_useRouteParams();
  const tryOptOut = (0,react_facet_src.useFacetCallback)((actions, isOwner, params) => () => {
    actions.setPlayerOptInStatus(optInState.OptedOut);

    if (isOwner) {
      actions.setRealmsOptInStatus(optInState.OptedOut);
    }

    actions.postSettings(params.realmId);
  }, [], [actionsFacet, isOwnerFacet, params]);
  const showOptOutMembersModal = RealmsStorySettingsMemberOptOutModal.useShowModal();
  const showOptOutOwnerModal = RealmsStorySettingsOwnerOptOutModal.useShowModal();
  const onOptOutButtonClick = (0,react_facet_src.useFacetCallback)(isOwner => () => isOwner ? showOptOutOwnerModal({
    onOptOutCompleted: tryOptOut
  }) : showOptOutMembersModal({
    onOptOutCompleted: tryOptOut
  }), [showOptOutOwnerModal, showOptOutMembersModal, tryOptOut], [isOwnerFacet]);
  const onExitButtonClick = (0,react_facet_src.useFacetCallback)((actions, params) => () => {
    actions.postSettingsOnExit(params.realmId);
    routerAPI.goBack();
  }, [routerAPI], [actionsFacet, params]);
  useExitRealmsStoriesOnOptOutComplete(); // Settings

  const onStoryNotifSwitchClick = (0,react_facet_src.useFacetCallback)((actions, settings) => () => {
    actions.setRealmNotificationStatus(!settings.realmNotificationsStatus);
  }, [], [actionsFacet, settingsFacet]);
  const onStoryEventsSwitchClick = (0,react_facet_src.useFacetCallback)((actions, settings) => () => {
    actions.setRealmEventsStatus(!settings.realmEventsStatus);
  }, [], [actionsFacet, settingsFacet]);
  const onStoryCoordinatesSwitchClick = (0,react_facet_src.useFacetCallback)((actions, settings) => () => {
    actions.setRealmCoordinatesStatus(!settings.realmCoordinatesStatus);
  }, [], [actionsFacet, settingsFacet]);
  const onStoryTimelineSwitchClick = (0,react_facet_src.useFacetCallback)((actions, settings) => () => {
    actions.setRealmTimelineStatus(!settings.realmTimelineStatus);
  }, [], [actionsFacet, settingsFacet]);
  const retryFailedFetch = (0,react_facet_src.useFacetCallback)((actions, params) => () => {
    actions.fetchSettings(params.realmId);
  }, [], [actionsFacet, params]);
  const personalSettingsNarration = [t('.personalSettings.member.header'), t('.personalSettings.description')].join(' . ');
  const realmSettingsNarration = [t('.realmWideSettings.member.header'), t('.realmWideSettings.description')].join(' . ');
  const semanticColors = hooks_useSemanticColors('inherit');
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: onExitButtonClick
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header3"
    }, realmName),
    gamepadAlias: "realms-stories-settings",
    narrationText: screenHeaderNarration
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: errorMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 12,
    narrow: 8
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: unknownErrorVisible
  }, /*#__PURE__*/react.createElement(StoriesUnknownErrorMessage_StoriesUnknownErrorMessage, {
    wide: 12,
    narrow: 8,
    onClick: retryFailedFetch,
    pageName: realmName
  })))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFailedError
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: onExitButtonClick
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitError
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onExitButtonClick
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPostSettingsLoading
  }, /*#__PURE__*/react.createElement(RealmsStoryContactingRealmsLoadingModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFetchSettingsLoading
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoriesSettingsRoute.spinner, semanticColors.overlay.base)
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSettings
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    floating: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmStoriesSettingsRoute.containerBorder, semanticColors.border.base)
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: personalSettingsNarration
  }, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: personalSettingsHeader,
    description: t('.personalSettings.description')
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.personalSettings.storyNotifSwitch.title'),
    description: t('.personalSettings.storyNotifSwitch.description'),
    value: (0,react_facet_src.useFacetMap)(settings => settings.realmNotificationsStatus, [], [settingsFacet]),
    onChange: onStoryNotifSwitchClick,
    gamepad: {
      index: 1
    }
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isOwnerFacet
  }, /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: realmSettingsNarration
  }, /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.realmWideSettings.header'),
    description: t('.realmWideSettings.description')
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.realmWideSettings.realmEvents.title'),
    description: t('.realmWideSettings.realmEvents.description'),
    value: (0,react_facet_src.useFacetMap)(settings => settings.realmEventsStatus, [], [settingsFacet]),
    onChange: onStoryEventsSwitchClick,
    gamepad: {
      index: 2
    }
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.realmWideSettings.storyCoordinates.title'),
    description: t('.realmWideSettings.storyCoordinates.description'),
    value: (0,react_facet_src.useFacetMap)(settings => settings.realmCoordinatesStatus, [], [settingsFacet]),
    onChange: onStoryCoordinatesSwitchClick,
    gamepad: {
      index: 3
    }
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    title: t('.realmWideSettings.playerTimeline.title'),
    description: t('.realmWideSettings.playerTimeline.description'),
    value: (0,react_facet_src.useFacetMap)(settings => settings.realmTimelineStatus, [], [settingsFacet]),
    onChange: onStoryTimelineSwitchClick,
    gamepad: {
      index: 4
    }
  }))), /*#__PURE__*/react.createElement(PanelButton_PanelButton_PanelButton, {
    gamepadIndex: 5,
    title: t('.optOut.title'),
    description: optOutDescription,
    buttons: /*#__PURE__*/react.createElement(Button_Button_Button, {
      inputLegend: t('.inputLegend.select'),
      horizontal: true,
      onClick: onOptOutButtonClick,
      narrationSuffix: optOutDescription
    }, t('.optOut.title'))
  }))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null)))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesSettingsRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/AreaInput.tsx





function AreaInput({
  reportArea,
  onConfirm,
  onChangeReportArea,
  isSubmitDisabled
}) {
  const {
    t
  } = useLocalization_useLocalization('ReportPlayerRoute');
  const reportableAreas = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.reportAreaOptions, [playerReportFacet]);
  const options = (0,react_facet_src.useFacetMap)(areas => areas.map(a => ({
    label: t('.' + a.label),
    value: a.value
  })), [t], [(0,react_facet_src.useSharedFacet)(reportableAreas)]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    scrollable: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.whereReportDescription')
  }, t('.whereReportDescription')), /*#__PURE__*/react.createElement(Dropdown, {
    label: "",
    placeholder: t('.whereReport'),
    description: "",
    options: options,
    gamepadIndex: 1,
    onChange: onChangeReportArea,
    value: reportArea
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.next'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm,
    disabled: isSubmitDisabled
  }, t('.next'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReasonInputAndSubmission.tsx






function ReasonInputAndSubmission({
  gamertag,
  reportReason,
  onClickSendReport,
  onChangeReportReason,
  onChangeReportMessage,
  isSubmitDisabled
}) {
  const {
    t
  } = useLocalization_useLocalization('ReportPlayerRoute');
  const reportableReasons = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.reportReasonOptions, [playerReportFacet]);
  const options = (0,react_facet_src.useFacetMap)(reasons => reasons.map(reason => ({
    label: t('.' + reason.label),
    value: reason.value
  })), [t], [(0,react_facet_src.useSharedFacet)(reportableReasons)]); // If only one reason is available for the dropdown, select that reason and disable the dropdown

  const isOnlyOneReportReasonAvailable = (0,react_facet_src.useFacetMap)(availableOptions => availableOptions.length == 1, [], [options]);
  const reason = (0,react_facet_src.useFacetMap)((reportReason, options) => options.length > 1 ? reportReason : options[0].value, [], [reportReason, options]);
  (0,react_facet_src.useFacetEffect)((isOnlyOneReportReasonAvailable, options) => {
    if (isOnlyOneReportReasonAvailable) {
      onChangeReportReason(options[0].value);
    }
  }, [onChangeReportReason], [isOnlyOneReportReasonAvailable, options]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Dropdown, {
    label: "",
    placeholder: t('.whyReport', [gamertag]),
    description: "",
    options: options,
    gamepadIndex: 0,
    onChange: onChangeReportReason,
    value: reason,
    disabled: isOnlyOneReportReasonAvailable
  }), /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField, {
    gamepadIndex: 1,
    rows: 8,
    label: "",
    description: t('.optionalText'),
    value: "",
    onChange: onChangeReportMessage,
    maxLength: 500
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    autofocus: true,
    inputLegend: t('.report'),
    variant: "primary",
    delayedClick: true,
    onClick: onClickSendReport,
    disabled: isSubmitDisabled
  }, t('.report'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ChatSelection.tsx





const MAX_SELECTED_CHAT_MESSAGES = 4;

function MessageCheckbox({
  index,
  gamepad,
  data,
  onChange,
  checkingDisabled
}) {
  const [isCheckboxEnabled, setIsCheckboxEnabled] = (0,react_facet_src.useFacetState)(false);
  const changeHandler = (0,react_facet_src.useFacetCallback)(checkingDisabled => value => {
    if (value && checkingDisabled) {
      return;
    }

    onChange(index, value);
    setIsCheckboxEnabled(value);
  }, [onChange, index, setIsCheckboxEnabled], [checkingDisabled]);
  return /*#__PURE__*/react.createElement(Checkbox_Checkbox, {
    title: (0,react_facet_src.useFacetMap)(data => data.message, [], [data]),
    description: (0,react_facet_src.useFacetMap)(data => data.author, [], [data]),
    gamepad: gamepad,
    value: isCheckboxEnabled,
    onChange: changeHandler,
    disabled: (0,react_facet_src.useFacetMap)(data => !data.isAuthorBeingReported, [], [data])
  });
}

const useOnChangeChatMessageCheckbox = (selectedMessagesFacet, setSelectedMessagesFacet) => {
  return (0,react_facet_src.useFacetCallback)(facet => (index, value) => {
    setSelectedMessagesFacet(() => {
      const updated = [...facet];

      if (value) {
        if (updated.length < MAX_SELECTED_CHAT_MESSAGES) {
          updated.push(index);
        }
      } else {
        const idx = updated.findIndex(value => value == index);

        if (idx > -1) {
          updated.splice(idx, 1);
        }
      }

      return updated;
    });
  }, [setSelectedMessagesFacet], [selectedMessagesFacet]);
};
function ChatSelection({
  chatMessages,
  selectedMessages,
  onConfirm,
  setSelectedMessagesFacet
}) {
  const {
    t
  } = useLocalization_useLocalization('ReportPlayerRoute');
  const dataFacet = (0,react_facet_src.useFacetWrap)(chatMessages);
  const selectedMessagesFacet = (0,react_facet_src.useFacetWrap)(selectedMessages);
  const onChange = useOnChangeChatMessageCheckbox(selectedMessagesFacet, setSelectedMessagesFacet);
  const isSelectedChatMessagesFull = (0,react_facet_src.useFacetMap)(selectedChatMessages => selectedChatMessages.length >= MAX_SELECTED_CHAT_MESSAGES, [], [selectedMessagesFacet]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isSelectedChatMessagesFull
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.chatSelectionLimitReached')
  }, t('.chatSelectionLimitReached'))), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 1,
    darkTheme: true
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: dataFacet
  }, (chatMessage, index) => /*#__PURE__*/react.createElement(MessageCheckbox, {
    index: index,
    gamepad: {
      index: index
    },
    data: chatMessage,
    onChange: onChange,
    checkingDisabled: isSelectedChatMessagesFull
  })))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 2,
    autofocus: true,
    inputLegend: t('.confirmSelection'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm
  }, t('.confirmSelection'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReportConfirmation.tsx



function ReportConfirmation({
  onConfirm
}) {
  const {
    t
  } = useLocalization_useLocalization('ReportPlayerRoute');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, {
    scrollable: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.reportConfirmation')
  }, t('.reportConfirmation'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: t('.next'),
    variant: "primary",
    delayedClick: true,
    onClick: onConfirm
  }, t('.next'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/ReportPlayerRoute.tsx










var ReportPlayerModalState;

(function (ReportPlayerModalState) {
  ReportPlayerModalState[ReportPlayerModalState["ReportAreaInput"] = 0] = "ReportAreaInput";
  ReportPlayerModalState[ReportPlayerModalState["ChatSelection"] = 1] = "ChatSelection";
  ReportPlayerModalState[ReportPlayerModalState["ReportReasonInputAndSubmission"] = 2] = "ReportReasonInputAndSubmission";
  ReportPlayerModalState[ReportPlayerModalState["WaitingForReportResponse"] = 3] = "WaitingForReportResponse";
  ReportPlayerModalState[ReportPlayerModalState["ReportComplete"] = 4] = "ReportComplete";
})(ReportPlayerModalState || (ReportPlayerModalState = {}));

const ReportPlayerRoute = () => {
  var _params$get, _params$get2, _params$get3;

  const {
    t
  } = useLocalization_useLocalization('ReportPlayerRoute');
  const historyAPI = RouterEngineProvider_useRouteHistory(); // Query parameters

  const params = useRouteQueryUnwrapped();
  const gamertag = (_params$get = params.get('gamertag')) !== null && _params$get !== void 0 ? _params$get : t('.unknownGamertag');
  const xuid = (_params$get2 = params.get('xuid')) !== null && _params$get2 !== void 0 ? _params$get2 : '0';
  const uuid = (_params$get3 = params.get('uuid')) !== null && _params$get3 !== void 0 ? _params$get3 : '0'; // State

  const [reportStateFacet, setReportStateFacet] = (0,react_facet_src.useFacetState)(ReportPlayerModalState.ReportAreaInput);
  const [reportAreaFacet, setReportAreaFacet] = (0,react_facet_src.useFacetState)(-1);
  const [reportReasonFacet, setReportReasonFacet] = (0,react_facet_src.useFacetState)(-1);
  const [reportMessageFacet, setReportMessageFacet] = (0,react_facet_src.useFacetState)('');
  const selectedMessages = [];
  const [selectedMessagesFacet, setSelectedMessagesFacet] = (0,react_facet_src.useFacetState)(selectedMessages);
  const reportableChatMessagesFacet = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.reportableChatMessages, [playerReportFacet]);
  const isChatSelectionAvailableFacet = (0,react_facet_src.sharedSelector)(reportFacet => reportFacet.isChatAvailable(), [playerReportFacet]);
  const isReportAreaInputVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportAreaInput, [], [reportStateFacet]);
  const isReportAreaInvalidFacet = (0,react_facet_src.useFacetMap)(reportArea => reportArea == -1, [], [reportAreaFacet]);
  const isReportReasonInputVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportReasonInputAndSubmission, [], [reportStateFacet]);
  const isReportReasonInvalidFacet = (0,react_facet_src.useFacetMap)(reportReason => reportReason == -1, [], [reportReasonFacet]);
  const isChatSelectionVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ChatSelection, [], [reportStateFacet]);
  const isReportConfirmationVisibleFacet = (0,react_facet_src.useFacetMap)(reportState => reportState === ReportPlayerModalState.ReportComplete, [], [reportStateFacet]);
  const playerReport = (0,react_facet_src.useSharedFacet)(playerReportFacet); // Callbacks

  const reportPlayer = (0,react_facet_src.useFacetCallback)((facet, reportReason, reportMessage, selectedChatMessages) => () => {
    facet.reportReason = reportReason;
    facet.reportMessage = reportMessage;
    facet.selectedChatMessages = selectedChatMessages;
    facet.xuid = xuid;
    facet.uuid = uuid;
    facet.reportPlayer();
  }, [xuid, uuid], [playerReport, reportReasonFacet, reportMessageFacet, selectedMessagesFacet]);
  const onConfirmReportArea = (0,react_facet_src.useFacetCallback)((facet, isChatSelectionAvailable, reportArea) => () => {
    facet.reportArea = reportArea;
    facet.decideReportReasonOptions();

    if (isChatSelectionAvailable && reportArea == 0) {
      setReportStateFacet(ReportPlayerModalState.ChatSelection);
    } else {
      setReportStateFacet(ReportPlayerModalState.ReportReasonInputAndSubmission);
    }
  }, [setReportStateFacet], [playerReport, (0,react_facet_src.useSharedFacet)(isChatSelectionAvailableFacet), reportAreaFacet]);

  const onConfirmChatSelection = () => {
    setReportStateFacet(ReportPlayerModalState.ReportReasonInputAndSubmission);
  };

  const onClose = () => {
    historyAPI.goBack();
  };

  const sendReportAndGoToConfirmation = () => {
    reportPlayer();
    setReportStateFacet(ReportPlayerModalState.ReportComplete);
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title', [gamertag])), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportAreaInputVisibleFacet
  }, /*#__PURE__*/react.createElement(AreaInput, {
    reportArea: reportAreaFacet,
    onChangeReportArea: setReportAreaFacet,
    onConfirm: onConfirmReportArea,
    isSubmitDisabled: isReportAreaInvalidFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isChatSelectionVisibleFacet
  }, /*#__PURE__*/react.createElement(ChatSelection, {
    chatMessages: (0,react_facet_src.useSharedFacet)(reportableChatMessagesFacet),
    selectedMessages: selectedMessagesFacet,
    onConfirm: onConfirmChatSelection,
    setSelectedMessagesFacet: setSelectedMessagesFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportReasonInputVisibleFacet
  }, /*#__PURE__*/react.createElement(ReasonInputAndSubmission, {
    gamertag: gamertag,
    reportReason: reportReasonFacet,
    onChangeReportReason: setReportReasonFacet,
    onClickSendReport: sendReportAndGoToConfirmation,
    onChangeReportMessage: setReportMessageFacet,
    isSubmitDisabled: isReportReasonInvalidFacet
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isReportConfirmationVisibleFacet
  }, /*#__PURE__*/react.createElement(ReportConfirmation, {
    onConfirm: onClose
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ReportPlayerRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/SignInAchievementsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInAchievementsRoute = ({"mainImage":"Ux__y"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/images/Sign-in_Prompts_Achievements.png
const Sign_in_Prompts_Achievements_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Achievements-f878d.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/images/Sign-in_Prompts_Achievements Animated.gif
const Sign_in_Prompts_Achievements_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Achievements Animated-06cb0.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/SignInAchievementsRoute.tsx














function SignInAchievementsRoute_SignInAchievementsRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInAchievementsRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableAchievementsAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableAchievementsAnimatedFlag, [disableAchievementsAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Achievements_Animated_namespaceObject : Sign_in_Prompts_Achievements_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInAchievements',
      button: 'SignIn'
    });
    historyAPI.replace('/achievements');
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInAchievements',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInAchievements',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInAchievementsButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInAchievementsRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInAchievementsButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAchievementsRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/SignInAddFriendRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInAddFriendRoute = ({"mainImage":"MedW5"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/images/Sign-in_Prompts_Friends.png
const Sign_in_Prompts_Friends_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Friends-24f5f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/images/Sign-in_Prompts_Friends Animated.gif
const Sign_in_Prompts_Friends_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Friends Animated-0c355.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/SignInAddFriendRoute.tsx















function SignInAddFriendRoute_SignInAddFriendRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInAddFriendRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInfo = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableFriendsAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableFriendsAnimatedFlag, [disableFriendsAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Friends_Animated_namespaceObject : Sign_in_Prompts_Friends_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]); //return the correct version of the list based on platform

  const signInList = (0,react_facet_src.useFacetMap)(device => {
    if (device.platform == Platform.PS4 || device.platform == Platform.PS5 || device.platform == Platform.NX_HANDHELD || device.platform == Platform.NX_TV) {
      return [t('.signInList1NXPS'), t('.signInList3')];
    } else {
      //all platforms other than PS and Switch should use this
      return [t('.signInList1'), t('.signInList2'), t('.signInList3')];
    }
  }, [t], [deviceInfo]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInAddFriend',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInAddFriend',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInAddFriend',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInAddFriendButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInAddFriendRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInAddFriendButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInAddFriendRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/SignInPlayOnServerRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInPlayOnServerRoute = ({"mainImage":"nKl10"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/images/Sign-in_Prompts_Servers.png
const Sign_in_Prompts_Servers_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Servers-327ad.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/images/Sign-in_Prompts_Servers Animated.gif
const Sign_in_Prompts_Servers_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Servers Animated-ab246.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/SignInPlayOnServerRoute.tsx














function SignInPlayOnServerRoute_SignInPlayOnServerRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInPlayOnServerRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableServerAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableServerAnimatedFlag, [disableServerAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Servers_Animated_namespaceObject : Sign_in_Prompts_Servers_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInPlayOnServer',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInPlayOnServer',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInPlayOnServer',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInPlayOnServerButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInPlayOnServerRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInPlayOnServerButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInPlayOnServerRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/SignInSavePurchasesRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInSavePurchasesRoute = ({"mainImage":"WNtel"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/images/Sign-in_Prompts_Save_Purchases.png
const Sign_in_Prompts_Save_Purchases_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases-c428e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/images/Sign-in_Prompts_Save_Purchases Animated.gif
const Sign_in_Prompts_Save_Purchases_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases Animated-cfb0b.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/SignInSavePurchasesRoute.tsx














function SignInSavePurchasesRoute_SignInSavePurchasesRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInSavePurchasesRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1'), t('.signInList2'), t('.signInList3')]);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disablePurchasesAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disablePurchasesAnimatedFlag, [disablePurchasesAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Save_Purchases_Animated_namespaceObject : Sign_in_Prompts_Save_Purchases_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInSavePurchases',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.SAVE_ENTITLEMENTS);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInSavePurchases',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInSavePurchases',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInSavePurchasesButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInSavePurchasesRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 2,
    narrationText: t('.createAccountPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.createAccountPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInSavePurchasesButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInSavePurchasesRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInDressingRoomRoute/SignInDressingRoomRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInDressingRoomRoute = ({"mainImage":"vw9Nj"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInDressingRoomRoute/images/Sign-in_Prompts_Launch.png
const Sign_in_Prompts_Launch_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch-be303.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInDressingRoomRoute/images/Sign-in_Prompts_Launch Animated.gif
const Sign_in_Prompts_Launch_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch Animated-d5ba8.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInDressingRoomRoute/SignInDressingRoomRoute.tsx














function SignInDressingRoomRoute_SignInDressingRoomRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInDressingRoomRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableSignInAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableSignInAnimatedFlag, [disableSignInAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? Sign_in_Prompts_Launch_Animated_namespaceObject : Sign_in_Prompts_Launch_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInDressingRoom',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInDressingRoom',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInDressingRoom',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'dressingRoomSignInButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInDressingRoomRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'dressingRoomSignInButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInDressingRoomRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInMarketplaceRoute/SignInMarketplaceRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInMarketplaceRoute = ({"mainImage":"QnWeO"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInMarketplaceRoute/images/Sign-in_Prompts_Save_Purchases.png
const SignInMarketplaceRoute_images_Sign_in_Prompts_Save_Purchases_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases-c428e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInMarketplaceRoute/images/Sign-in_Prompts_Save_Purchases Animated.gif
const SignInMarketplaceRoute_images_Sign_in_Prompts_Save_Purchases_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Save_Purchases Animated-cfb0b.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInMarketplaceRoute/SignInMarketplaceRoute.tsx














function SignInMarketplaceRoute_SignInMarketplaceRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInMarketplaceRoute');
  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const signInList = (0,react_facet_src.useFacetWrap)([t('.signInList1')]);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disablePurchasesAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disablePurchasesAnimatedFlag, [disablePurchasesAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? SignInMarketplaceRoute_images_Sign_in_Prompts_Save_Purchases_Animated_namespaceObject : SignInMarketplaceRoute_images_Sign_in_Prompts_Save_Purchases_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]);
  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInMarketplace',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.SAVE_ENTITLEMENTS);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInMarketplace',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInMarketplace',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInMarketplaceButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInMarketplaceRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInMarketplaceButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInMarketplaceRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInWorldsFriendsServersRoute/SignInWorldsFriendsServersRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignInWorldsFriendsServersRoute = ({"mainImage":"HJLaJ"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInWorldsFriendsServersRoute/images/Sign-in_Prompts_Launch.png
const SignInWorldsFriendsServersRoute_images_Sign_in_Prompts_Launch_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch-be303.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInWorldsFriendsServersRoute/images/Sign-in_Prompts_Launch Animated.gif
const SignInWorldsFriendsServersRoute_images_Sign_in_Prompts_Launch_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch Animated-d5ba8.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInWorldsFriendsServersRoute/SignInWorldsFriendsServersRoute.tsx















function SignInWorldsFriendsServersRoute_SignInWorldsFriendsServersRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('SignInWorldsFriendsServersRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInfo = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableSignInAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableSignInAnimatedFlag, [disableSignInAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? SignInWorldsFriendsServersRoute_images_Sign_in_Prompts_Launch_Animated_namespaceObject : SignInWorldsFriendsServersRoute_images_Sign_in_Prompts_Launch_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]); //return the correct version of the list based on platform

  const signInList = (0,react_facet_src.useFacetMap)(device => {
    if (consoles_isPlaystationPlatform(device.platform)) {
      return [t('.signInList4'), t('.signInList2PS'), t('.signInList3PS')];
    } else {
      //all platforms other than PS should use this
      return [t('.signInList1'), t('.signInList2'), t('.signInList3'), t('.signInList4')];
    }
  }, [t], [deviceInfo]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'SignInWorldsFriendsServers',
      button: 'SignIn'
    });
    historyAPI.replace('/play');
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'SignInWorldsFriendsServers',
      button: 'MaybeLater'
    });
    historyAPI.replace('/play');
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'SignInWorldsFriendsServers',
      button: 'Close'
    });
    historyAPI.replace('/play');
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'signInWorldsFriendsServersButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: SignInWorldsFriendsServersRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 2,
    narrationText: t('.createAccountPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.createAccountPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'signInWorldsFriendsServersButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/SignInWorldsFriendsServersRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/FirstTimeSignInRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const FirstTimeSignInRoute = ({"mainImage":"ulzxH"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/images/Sign-in_Prompts_Launch.png
const FirstTimeSignInRoute_images_Sign_in_Prompts_Launch_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch-be303.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/images/Sign-in_Prompts_Launch Animated.gif
const FirstTimeSignInRoute_images_Sign_in_Prompts_Launch_Animated_namespaceObject = __webpack_require__.p + "assets/Sign-in_Prompts_Launch Animated-d5ba8.gif";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/FirstTimeSignInRoute.tsx















function FirstTimeSignInRoute_FirstTimeSignInRoute() {
  const historyAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('FirstTimeSignInRoute'); //set up all facets

  const userAccount = (0,react_facet_src.useSharedFacet)(userAccountFacet);
  const deviceInfo = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const animation = (0,react_facet_src.useSharedFacet)(animationFacet);
  const buttonTelemetry = useButtonTelemetry(); //decide whether to show the animated version of the art

  const disableSignInAnimatedFlag = useFeatureFlag(DISABLE_ANIMATED_SIGN_IN_SCREENS);
  const isScreenAnimationEnabled = useScreenAnimationEnabled(); //to display the animated version, the user must have animation enabled and the feature flag must be active

  const isAnimationEnabled = (0,react_facet_src.useFacetMap)(isScreenAnimationEnabled => isScreenAnimationEnabled && !disableSignInAnimatedFlag, [disableSignInAnimatedFlag], [isScreenAnimationEnabled]); //set the image based on the above

  const MainImage = (0,react_facet_src.useFacetMap)(isAnimationEnabled => isAnimationEnabled ? FirstTimeSignInRoute_images_Sign_in_Prompts_Launch_Animated_namespaceObject : FirstTimeSignInRoute_images_Sign_in_Prompts_Launch_namespaceObject, [], [isAnimationEnabled]); //Temporary workaround for Bug 1004251, once we can flip origins for gifs on
  //the back end side this should be removed

  const shouldFlipOrigin = (0,react_facet_src.useFacetMap)((animation, isAnimationEnabled) => animation.shouldFlipOrigin && isAnimationEnabled, [], [animation, isAnimationEnabled]); //return the correct version of the list based on platform

  const signInList = (0,react_facet_src.useFacetMap)(device => {
    if (consoles_isPlaystationPlatform(device.platform)) {
      return [t('.signInList4'), t('.signInList2PS'), t('.signInList3PS')];
    } else {
      //all platforms other than PS should use this
      return [t('.signInList1'), t('.signInList2'), t('.signInList3'), t('.signInList4')];
    }
  }, [t], [deviceInfo]); //call the sign in screen when the button is pressed

  const signIn = (0,react_facet_src.useFacetCallback)(user => () => {
    buttonTelemetry({
      screen: 'FirstTimeSignIn',
      button: 'SignIn'
    });
    historyAPI.goBack();
    user.showMicrosoftAccountLogInScreen(PostSignInAction.DO_NOTHING);
  }, [historyAPI, buttonTelemetry], [userAccount]);

  const laterAction = () => {
    buttonTelemetry({
      screen: 'FirstTimeSignIn',
      button: 'MaybeLater'
    });
    historyAPI.goBack();
  };

  const closeAction = () => {
    buttonTelemetry({
      screen: 'FirstTimeSignIn',
      button: 'Close'
    });
    historyAPI.goBack();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: 'firstTimeSignInButton'
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeAction
  }, t('.signInHeader')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: MainImage,
    className: FirstTimeSignInRoute.mainImage,
    imageRendering: 'pixelated',
    shouldFlipOrigin: shouldFlipOrigin
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.signInPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.signInPrompt'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.List, {
    items: signInList,
    gamepadIndex: 1
  }), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 2,
    narrationText: t('.createAccountPrompt')
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "left"
  }, t('.createAccountPrompt')))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.laterButton'),
    variant: "secondary",
    onClick: laterAction,
    horizontal: true
  }, t('.laterButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: 'firstTimeSignInButton',
    autofocus: true,
    inputLegend: t('.signInButton'),
    variant: "primary",
    onClick: signIn,
    horizontal: true
  }, t('.signInButton'))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/FirstTimeSignInRoute/index.ts

;// CONCATENATED MODULE: ./packages/ui/src/Modal/ErrorModal.tsx





/**
 * This is a generic error modal that be passed as the errorComponent in the root <Application />
 */
function ErrorModal_ErrorModal({
  errorMessage,
  onDismiss
}) {
  const {
    t
  } = useLocalization_useLocalization('ErrorModal');
  const title = t('.title');
  const goBack = t('.goBack');
  const goingBack = t('.goingBack');
  const content = errorMessage != null && errorMessage !== '' ? errorMessage : goingBack;
  const narration = `${title} . ${content}`;
  const showButtons = content !== goingBack;
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: narration
  }, content)), showButtons && /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "primary",
    onClick: onDismiss,
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: goBack
  }, goBack)));
}
;// CONCATENATED MODULE: ./packages/ui/src/RouteSlideTransition/RouteSlideTransition.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RouteSlideTransition = ({"base":"C84xm","exited":"_rSgg","entered":"JDSRH","left":"kEh2T","entering":"DSGNH","slide-left-in":"EMBuQ","exiting":"uv_vE","slide-left-out":"h0rGc","right":"k0msz","slide-right-in":"DFwIo","slide-right-out":"NE3Mc"});
;// CONCATENATED MODULE: ./packages/ui/src/RouteSlideTransition/RouteSlideTransition.tsx












function RouteSlideTransition_RouteSlideTransition({
  visible,
  unmountOnExit,
  alwaysMounted,
  contentComponent,
  inverse
}) {
  const ref = (0,react.useRef)(null);
  const Content = (0,react.useMemo)(() => react.memo(contentComponent), [contentComponent]);
  const recalculateSizes = useOnComponentResizeForceRecalculate();
  const isScreenAnimationEnabled = useScreenAnimationEnabled();
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isScreenAnimationEnabled
  }, /*#__PURE__*/react.createElement(TransitionPrimitive, {
    alwaysMounted: alwaysMounted,
    visible: visible,
    inverse: inverse,
    appear: true,
    unmountOnExit: unmountOnExit,
    timeout: 400
  }, (status, inverse) => {
    const paused = status !== 'entered';
    recalculateSizes();
    return /*#__PURE__*/react.createElement(OverrideRouteIsActive, {
      value: status === 'entered' || status === 'entering'
    }, /*#__PURE__*/react.createElement(FocusGroup, {
      disabled: !visible
    }, /*#__PURE__*/react.createElement("div", {
      ref: ref,
      className: classnames_default()(RouteSlideTransition.base, {
        [RouteSlideTransition.left]: !inverse,
        [RouteSlideTransition.right]: inverse,
        [RouteSlideTransition.entered]: status === 'entered',
        [RouteSlideTransition.entering]: status === 'entering',
        [RouteSlideTransition.exiting]: status === 'exiting',
        [RouteSlideTransition.exited]: status === 'exited'
      })
    }, /*#__PURE__*/react.createElement(deferred_mount_dist.PauseMountProvider, {
      paused: paused
    }, /*#__PURE__*/react.createElement(RenderTrackingDelay, {
      type: "contentful",
      renderingCompleted: status === 'entered'
    }), /*#__PURE__*/react.createElement(Content, null)))));
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isScreenAnimationEnabled,
    condition: false
  }, /*#__PURE__*/react.createElement(RouteInstantTransition_RouteInstantTransition, {
    contentComponent: contentComponent,
    visible: visible,
    unmountOnExit: unmountOnExit
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_crosshair.webm
const video_crosshair_namespaceObject = __webpack_require__.p + "assets/video_crosshair-c6f01.webm";
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_touch.webm
const video_touch_namespaceObject = __webpack_require__.p + "assets/video_touch-181aa.webm";
;// CONCATENATED MODULE: ./games/vanilla/main/src/videos/video_classic.webm
const video_classic_namespaceObject = __webpack_require__.p + "assets/video_classic-164db.webm";
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioBox = ({"wrapper":"C9Ox8","wrapperDisabled":"chklf","RadioBox":"UYLxr","innerBox":"mNihg","innerBoxTileLeft":"Rugdi","innerBoxTileRight":"TG2vJ","RadioBoxCheckedDisabled":"OGJXs","label":"aS_mB","labelInner":"T4t4A"});
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioBox.tsx









function RadioBox_RadioBox({
  onClick,
  gamepad,
  checked,
  label,
  description,
  disabled,
  extraSpeechProps: {
    index,
    groupSize
  } = {
    index: 1,
    groupSize: 1
  },
  onFocusChanged,
  omitDescription = false,
  readDescription = false,
  checkedRole = 'primary',
  uncheckedRole = 'neutral50',
  textRole = 'neutral',
  soundEffectPressed
}) {
  const {
    t
  } = useLocalization_useLocalization('RadioBox');
  const checkedFacet = (0,dist.useFacetWrap)(checked);
  const semanticColorsChecked = hooks_useSemanticColors(checkedRole);
  const semanticColorsUnchecked = hooks_useSemanticColors(uncheckedRole);
  const semanticSounds = useSemanticSounds('inherit');
  const narrationText = (0,dist.useFacetMap)(checked => [...(label != null ? [label] : []), checked ? t('.selected') : '', checked && readDescription && description != null ? description + '. ' : '', disabled ? t('.disabled') : '', t('.count', [`${index + 1}`, `${groupSize}`])].join(' . '), [readDescription, description, label, index, groupSize, disabled, t], [checkedFacet]);
  const box = (0,dist.useFacetMap)(checked => {
    var _semanticColorsChecke, _semanticColorsChecke2, _semanticColorsUnchec, _semanticColorsUnchec2;

    return classnames_default()(RadioBox.RadioBox, {
      [(_semanticColorsChecke = semanticColorsChecked.background.interactive) !== null && _semanticColorsChecke !== void 0 ? _semanticColorsChecke : '']: checked,
      [(_semanticColorsChecke2 = semanticColorsChecked.border.interactive) !== null && _semanticColorsChecke2 !== void 0 ? _semanticColorsChecke2 : '']: checked,
      [(_semanticColorsUnchec = semanticColorsUnchecked.background.interactive) !== null && _semanticColorsUnchec !== void 0 ? _semanticColorsUnchec : '']: !checked,
      [(_semanticColorsUnchec2 = semanticColorsUnchecked.border.interactive) !== null && _semanticColorsUnchec2 !== void 0 ? _semanticColorsUnchec2 : '']: !checked
    });
  }, [semanticColorsChecked, semanticColorsUnchecked], [checkedFacet]);
  return /*#__PURE__*/react.createElement(InteractivePrimitive_InteractivePrimitive, {
    className: RadioBox.wrapper,
    classNameFocused: classnames_default()(RadioBox.focused, focusClass),
    classNameDisabled: RadioBox.wrapperDisabled,
    narrationText: narrationText,
    onClick: onClick,
    onFocusChanged: onFocusChanged,
    inputLegend: false,
    disabled: disabled,
    gamepadIndex: gamepad.index,
    soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: box
  }, /*#__PURE__*/react.createElement(Focus_Focus, null), /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), /*#__PURE__*/react.createElement(dist.Mount, {
    when: checkedFacet
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBox
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBoxTileLeft
  }), /*#__PURE__*/react.createElement("div", {
    className: RadioBox.innerBoxTileRight
  })))), Boolean(label) && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RadioBox.label)
  }, Boolean(!omitDescription) && Boolean(description) && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: textRole // Setting text to sub role dimmer when disabled is not ideal, but is needed in order to retro fit the semantic tokens
    ,
    variant: disabled ? 'dimmer' : undefined
  }, label), Boolean(!omitDescription) && Boolean(description) && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    role: textRole,
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement("div", {
    className: RadioBox.labelInner
  }, description)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }))));
}
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioGroup.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RadioGroup = ({"wrapper":"d41i7","header":"dTZYj"});
;// CONCATENATED MODULE: ./packages/ui/src/RadioGroup/RadioGroup.tsx
function RadioGroup_extends() { RadioGroup_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return RadioGroup_extends.apply(this, arguments); }









let RadioGroup_id = 0;

const RadioGroup_noop = () => {};

function RadioGroup_RadioGroup({
  gamepad,
  options,
  title,
  onChange = RadioGroup_noop,
  value: selectedValue,
  disabled = false,
  disabledValues,
  onFocusChanged,
  checkedRole,
  uncheckedRole,
  wrapperRole = 'neutral',
  soundEffectPressed
}) {
  const wrappingRef = (0,react.useRef)(null);
  const semanticColors = hooks_useSemanticColors(wrapperRole);
  const semanticSounds = useSemanticSounds(wrapperRole);
  const index = options.findIndex(option => {
    return option.value === selectedValue;
  });

  if (index === -1) {
    console.warn('The provided default value does not match any of the provided options. This means that no option is selected, which is a broken state for RadioGroup.');
  }

  const focusAlias = (0,react.useRef)(`MCT-${RadioGroup_id++}`);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: wrapperRole
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, RadioGroup_extends({
    index: 0
  }, gamepad, {
    defaultFocusedChildBehavior: 'remember',
    disabled: disabled,
    defaultFocusedChildAlias: focusAlias.current,
    scrollRef: wrappingRef
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RadioGroup.wrapper, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular",
    thin: true,
    left: false,
    right: false,
    bottom: false
  }), title != null && title != '' && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: RadioGroup.header
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    role: wrapperRole // Setting text to sub role dimmer when disabled is not ideal, but is needed in order to retro fit the semantic tokens
    ,
    variant: disabled ? 'dimmer' : undefined
  }, title))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), options.map((option, index) => {
    return /*#__PURE__*/react.createElement(RadioBox_RadioBox, {
      disabled: disabled || disabledValues && disabledValues.indexOf(option.value) > -1 ? true : false,
      key: index,
      label: option.label,
      description: option.description,
      omitDescription: option.omitDescription,
      readDescription: option.readDescription,
      gamepad: {
        index: index
      },
      checked: option.value === selectedValue,
      onClick: () => {
        if (selectedValue !== option.value) onChange(option.value);
      },
      extraSpeechProps: {
        index,
        groupSize: options.length
      },
      onFocusChanged: onFocusChanged,
      checkedRole: checkedRole,
      uncheckedRole: uncheckedRole,
      textRole: wrapperRole,
      soundEffectPressed: soundEffectPressed !== null && soundEffectPressed !== void 0 ? soundEffectPressed : semanticSounds.toggle
    });
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelection.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const TouchControlSelection = ({"borderedContainer":"vzhv1","information":"c_o_5","spinnerContainer":"hmYnU","loadingImageSpinnerOuter":"SmsRy","loadingImageSpinnerInner":"RBMB_"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelection.tsx















function TouchControlSelection_TouchControlSelection({
  startWorld
}) {
  const VIDEO_ASPECT_RATIO = 0.48;
  const [videoContainerHeight, setVideoContainerHeight] = (0,react_facet_src.useFacetState)('0px');
  const videoContainerRef = (0,react.useRef)(null);
  const history = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('TouchControlSelectionRoute');
  const options = (0,react_facet_src.useSharedFacet)(optionsFacet);
  const [selected, setSelected] = (0,react.useState)(TouchControlSchemeEnum.CLASSIC);
  const createNewWorldFacetLocal = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const goBack = (0,react_facet_src.useFacetCallback)(world => () => {
    world.inWorldCreation = false;
    history.goBack();
  }, [history], [createNewWorldFacetLocal]);
  const onSelectControlScheme = (0,react_facet_src.useFacetCallback)(options => () => {
    options.touchControlScheme = selected;
    options.showTouchControlSelectionScreen = false;
    startWorld();
  }, [selected, startWorld], [options]);
  const semanticColors = hooks_useSemanticColors('neutral80');
  const touchId = 'touch';
  const classicId = 'classic';
  const crosshairId = 'crosshair';
  const videoRefTouch = (0,react.useRef)(null);
  const videoRefClassic = (0,react.useRef)(null);
  const videoRefCrosshair = (0,react.useRef)(null);
  const videoRefs = (0,react.useMemo)(() => [videoRefTouch, videoRefCrosshair, videoRefClassic], []);
  const playVideoWithString = (0,react_facet_src.useFacetCallback)(options => stringId => {
    let id = TouchControlSchemeEnum.TOUCH;

    if (stringId == classicId) {
      id = TouchControlSchemeEnum.CLASSIC;
    } else if (stringId == crosshairId) {
      id = TouchControlSchemeEnum.CROSSHAIR;
    }

    if (options.playVideoInTouchControlSelectionScreen) {
      for (let i = TouchControlSchemeEnum.TOUCH; i <= TouchControlSchemeEnum.CLASSIC; ++i) {
        const videoRef = videoRefs[i].current;

        if (i == id) {
          if (videoRef != null) {
            videoRef.currentTime = 0;
            videoRef.play();
          }
        } else {
          videoRef === null || videoRef === void 0 ? void 0 : videoRef.pause();
        }
      }
    }

    setSelected(id);
  }, [videoRefs], [options]);
  (0,react_facet_src.useFacetEffect)(options => {
    switch (options.touchControlScheme) {
      case TouchControlSchemeEnum.CLASSIC:
        {
          playVideoWithString(classicId);
          break;
        }

      case TouchControlSchemeEnum.TOUCH:
        {
          playVideoWithString(touchId);
          break;
        }

      case TouchControlSchemeEnum.CROSSHAIR:
        {
          playVideoWithString(crosshairId);
          break;
        }

      default:
    }
  }, [playVideoWithString], [options]);
  const resize = (0,react.useCallback)(() => {
    if (videoContainerRef.current) {
      const {
        width
      } = videoContainerRef.current.getBoundingClientRect();

      if (width > 0) {
        setVideoContainerHeight(width * VIDEO_ASPECT_RATIO + 'px');
      } else {
        requestAnimationFrame(resize);
      }
    }
  }, [setVideoContainerHeight]);
  (0,react.useEffect)(() => {
    resize();
    window.addEventListener('resize', resize);
    return () => window.removeEventListener('resize', resize);
  }, [resize]);

  function videoWidth(id) {
    return selected == id ? '100%' : '0px';
  }

  function videoHeight(id) {
    return selected == id ? '100%' : '0px';
  }

  const introNarration = [t('.header') + '. ', t('.title') + '. ', (selected == TouchControlSchemeEnum.CLASSIC ? t('.classicLabel') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchLabel') : t('.crosshairLabel')) + '. ', t('.selected') + '. ', selected == TouchControlSchemeEnum.CLASSIC ? t('.classicInfo') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchInfo') : t('.crosshairInfo')].join(' . ');
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(Narration, {
    text: introNarration
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.header')),
    gamepadAlias: "touch-control-selection"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.borderedContainer
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: videoContainerRef,
    style: {
      height: videoContainerHeight
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(TouchControlSelection.spinnerContainer, semanticColors.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.loadingImageSpinnerOuter
  }, /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.loadingImageSpinnerInner
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null)))), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.CLASSIC],
    style: {
      width: videoWidth(TouchControlSchemeEnum.CLASSIC),
      height: videoHeight(TouchControlSchemeEnum.CLASSIC),
      position: 'absolute'
    },
    src: video_classic_namespaceObject,
    loop: true
  }), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.CROSSHAIR],
    style: {
      width: videoWidth(TouchControlSchemeEnum.CROSSHAIR),
      height: videoHeight(TouchControlSchemeEnum.CROSSHAIR),
      position: 'absolute'
    },
    src: video_crosshair_namespaceObject,
    loop: true
  }), /*#__PURE__*/react.createElement("video", {
    ref: videoRefs[TouchControlSchemeEnum.TOUCH],
    style: {
      width: videoWidth(TouchControlSchemeEnum.TOUCH),
      height: videoHeight(TouchControlSchemeEnum.TOUCH),
      position: 'absolute'
    },
    src: video_touch_namespaceObject,
    loop: true
  })), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.information
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, selected == TouchControlSchemeEnum.CLASSIC ? t('.classicInfo') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchInfo') : t('.crosshairInfo')))))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 4,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement("div", {
    className: TouchControlSelection.borderedContainer
  }, /*#__PURE__*/react.createElement(RadioGroup_RadioGroup, {
    title: t('.title'),
    gamepad: {
      index: 0
    },
    options: [{
      label: t('.touchLabel'),
      value: touchId,
      description: t('.touchInfo'),
      omitDescription: true,
      readDescription: true
    }, {
      label: t('.classicLabel'),
      value: classicId,
      description: t('.classicInfo'),
      omitDescription: true,
      readDescription: true
    }, {
      label: t('.crosshairLabel'),
      value: crosshairId,
      description: t('.crosshairInfo'),
      omitDescription: true,
      readDescription: true
    }],
    onChange: test => playVideoWithString(test),
    value: selected == TouchControlSchemeEnum.CLASSIC ? classicId : selected == TouchControlSchemeEnum.TOUCH ? touchId : crosshairId
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: "hero",
    gamepadIndex: 1,
    onClick: onSelectControlScheme,
    inputLegend: t('.select'),
    autofocus: true,
    narrationSuffix: selected == TouchControlSchemeEnum.CLASSIC ? t('.classicLabel') : selected == TouchControlSchemeEnum.TOUCH ? t('.touchLabel') : t('.crosshairLabel')
  }, t('.select'))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/TouchControlSelectionRoute.tsx




 // this is the original implementation of /touch-control-selection that relies
// on a hack for world startup

function TouchControlSelectionRoute() {
  const history = hooks_useRouterAPI();
  const startWorld = (0,react_facet_src.useFacetCallback)((world, telemetry) => () => {
    if (world.inWorldCreation) {
      world.inWorldCreation = false;
      telemetry.fireEventButtonPressed('Create_World_Button_OreUI', {});
      world.createWorld_v2();
    } else {
      // this relies on the previous screen (edit world screen or play screen)
      // to check flags in its screen controller to handle the world startup
      history.goBack();
    }
  }, [history], [(0,react_facet_src.useSharedFacet)(createNewWorldFacet), (0,react_facet_src.useSharedFacet)(telemetryFacet)]);
  return /*#__PURE__*/react.createElement(TouchControlSelection_TouchControlSelection, {
    startWorld: startWorld
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/WorldStartupTouchControlSelectionRoute.tsx




 // this a second version of /touch-control-selection that will start the world
// via the WorldStartupFacet when the player presses the "select" button

function WorldStartupTouchControlSelectionRoute() {
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const startWorld = (0,react_facet_src.useFacetCallback)(worldStartup => () => {
    worldStartup.startLocalWorld_v2(decodeURIComponent(params.id));
  }, [params], [(0,react_facet_src.useSharedFacet)(worldStartupFacet)]);
  return /*#__PURE__*/react.createElement(TouchControlSelection_TouchControlSelection, {
    startWorld: startWorld
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/TouchControlSelectionRoute/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/components/TabWrapper/TabTypes.tsx
const createNewWorldTabValues = ['general', 'resource-packs', 'cheats', 'experimental', 'multiplayer', 'advanced', 'behavior-packs', 'debug'];
const EditWorldTabValues = (/* unused pure expression or super */ null && (['general', 'advanced', 'multiplayer', 'cheats', 'resource-packs', 'behavior-packs', 'experiments']));
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/JoinRealmErrorModal/JoinRealmsErrorModal.tsx






const JoinRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'join-realms-error-modal-back';
const JoinRealmsErrorModal = registerModal(() => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld.playOnRealmsErrorModal');
  const networkJoinerSharedFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const joinResult = (0,react_facet_src.useFacetMap)(networkJoinerSharedFacet => networkJoinerSharedFacet.joinRealmResult, [], [networkJoinerSharedFacet]);
  const onClose = (0,react_facet_src.useFacetCallback)(networkJoinerFacet => () => networkJoinerFacet.clearJoinRealmState(), [], [networkJoinerSharedFacet]);
  const text = (0,react_facet_src.useFacetMap)(errorCode => {
    switch (errorCode) {
      case JoinRealmWorldResult.UnassignedDevVersion:
        return {
          title: t(`.unassignedDevVersion.title`),
          message: t(`.unassignedDevVersion.message`),
          message2: t(`.unassignedDevVersion.message2`)
        };

      case JoinRealmWorldResult.MemberOfTooManyRealms:
        return {
          title: t(`.memberOfTooManyRealms.title`),
          message: t(`.memberOfTooManyRealms.message`),
          message2: ''
        };

      case JoinRealmWorldResult.CannotConnectToRealm:
        return {
          title: t(`.cannotConnectToRealm.title`),
          message: t(`.cannotConnectToRealm.message`),
          message2: ''
        };

      case JoinRealmWorldResult.UnknownError:
      case JoinRealmWorldResult.UnexpectedError:
      default:
        return {
          title: t(`.unknown.title`),
          message: t(`.unknown.message`),
          message2: ''
        };
    }
  }, [t], [joinResult]);
  const title = (0,react_facet_src.useFacetMap)(text => text.title, [], [text]);
  const message = (0,react_facet_src.useFacetMap)(text => text.message, [], [text]);
  const message2 = (0,react_facet_src.useFacetMap)(text => text.message2, [], [text]);
  const isTwoParagraphs = (0,react_facet_src.useFacetMap)(text => text.message2 != '', [], [text]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: onClose,
    defaultFocusAlias: JoinRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, title), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isTwoParagraphs,
    condition: false
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: message,
    gamepadIndex: 0,
    center: true
  }, message)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isTwoParagraphs,
    condition: true
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    narrationText: `${message}. ${message2}`,
    spaceBetweenParagraphs: 5,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, message), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong",
    align: "center"
  }, message2)))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: JoinRealmsErrorModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.closeButton'),
    variant: "secondary",
    onClick: onClose
  }, t('.closeButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/EditWorldModals.tsx








const EditWorldModals = () => {
  const worldOperationSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const worldStartupSharedFacet = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const networkWorldJoinerSharedFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const showExportErrorModal = (0,react_facet_src.useFacetMap)(facet => [null, ExportWorldResult.Ok].indexOf(facet.exportWorldResult) === -1, [], [worldOperationSharedFacet]);
  const isShowingFileSelector = (0,react_facet_src.useFacetMap)(facet => facet.exportWorldStatus === ExportWorldStatus.SelectingFileDestination, [], [worldOperationSharedFacet]);
  const isClearingPlayerData = (0,react_facet_src.useFacetMap)(facet => {
    return facet.clearPlayerDataStatus === FacetTaskProgress.RUNNING;
  }, [], [worldOperationSharedFacet]);
  const isClearPlayerDataError = (0,react_facet_src.useFacetMap)(facet => facet.startClearPlayerDataError != null, [], [worldOperationSharedFacet]);
  const showExportingWorldModal = (0,react_facet_src.useFacetMap)(facet => {
    return facet.exportWorldStatus === ExportWorldStatus.Exporting;
  }, [], [worldOperationSharedFacet]);
  const showUnexpectedLaunchErrorModal = (0,react_facet_src.useFacetMap)(worldStartup => {
    const result = worldStartup.startLocalWorldResult;
    return result != null && result != StartLocalWorldResult.Ok && result != StartLocalWorldResult.MissingDlcDependencies;
  }, [], [worldStartupSharedFacet]);
  const showSavingModal = (0,react_facet_src.useFacetMap)(facet => facet.saveLocalWorldProgress === FacetTaskProgress.RUNNING, [], [worldEditorSharedFacet]);
  const showEditWorldErrorModal = (0,react_facet_src.useFacetMap)((worldEditorFacet, worldOperationFacet) => worldOperationFacet.duplicateWorldError != null || worldEditorFacet.saveLocalWorldError != null, [], [worldEditorSharedFacet, worldOperationSharedFacet]);
  const showDownloadPackErrorModal = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadError != null, [], [worldPackagesSharedFacet]);
  const showDuplicatingModal = (0,react_facet_src.useFacetMap)(facet => {
    return facet.duplicateWorldProgress === FacetTaskProgress.RUNNING;
  }, [], [worldOperationSharedFacet]); // Download missing packs.

  const showDownloadPackAndStartWorldModal = (0,react_facet_src.useFacetMap)(worldStartup => worldStartup.startLocalWorldResult == StartLocalWorldResult.MissingDlcDependencies, [], [worldStartupSharedFacet]); // Download pack progress.

  const showDownloadPackProgressModal = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadProgress != FacetTaskProgress.IDLE, [], [worldPackagesSharedFacet]);
  const packDownloadName = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadName, [], [worldPackagesSharedFacet]);
  const packDownloadPercentage = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadPercentage, [], [worldPackagesSharedFacet]);
  const isImportingPack = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadStatus === PackDownloadStatus.Importing, [], [worldPackagesSharedFacet]);
  const onDownloadPackCancel = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.cancelPackDownload();
  }, [], [worldPackagesSharedFacet]);
  const showJoinRealmErrorModal = (0,react_facet_src.useFacetMap)(networkWorldJoinerSharedFacet => networkWorldJoinerSharedFacet.joinRealmResult != null && networkWorldJoinerSharedFacet.joinRealmResult !== JoinRealmWorldResult.Ok, [], [networkWorldJoinerSharedFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackProgressModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadProgressModal.Component, {
    title: packDownloadName,
    percentage: packDownloadPercentage,
    isImportingPack: isImportingPack,
    onCancel: onDownloadPackCancel
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackAndStartWorldModal
  }, /*#__PURE__*/react.createElement(UnexpectedLaunchErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showUnexpectedLaunchErrorModal
  }, /*#__PURE__*/react.createElement(UnexpectedLaunchErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDownloadPackErrorModal
  }, /*#__PURE__*/react.createElement(ResourcePacksDownloadErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showSavingModal
  }, /*#__PURE__*/react.createElement(SavingWorldModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showEditWorldErrorModal
  }, /*#__PURE__*/react.createElement(EditWorldErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDuplicatingModal
  }, /*#__PURE__*/react.createElement(DuplicatingWorldModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showExportingWorldModal
  }, /*#__PURE__*/react.createElement(ExportingWorldModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showExportErrorModal
  }, /*#__PURE__*/react.createElement(ExportErrorModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingFileSelector
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Overlay, null, /*#__PURE__*/react.createElement(react.Fragment, null))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isClearingPlayerData
  }, /*#__PURE__*/react.createElement(ClearingPlayerDataModal, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isClearPlayerDataError
  }, /*#__PURE__*/react.createElement(ClearPlayerDataErrorModal, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showJoinRealmErrorModal
  }, /*#__PURE__*/react.createElement(JoinRealmsErrorModal.Component, null)));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/modals/SaveChangesModal/SaveChangesModal.tsx





const SAVE_CHANGES_BUTTON = 'save-changes-modal-continue';
const SaveChangesModal = registerModal(({
  saveChanges,
  closeModal,
  discardChanges
}) => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld.saveChangesModal');
  const onSaveChanges = (0,react.useCallback)(() => {
    closeModal();
    saveChanges();
  }, [saveChanges, closeModal]);
  const onDiscardChanges = (0,react.useCallback)(() => {
    discardChanges();
    closeModal();
  }, [discardChanges, closeModal]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    onOverlayClick: closeModal,
    defaultFocusAlias: SAVE_CHANGES_BUTTON
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: closeModal
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: SAVE_CHANGES_BUTTON,
    variant: "primary",
    inputLegend: t('.saveInputLegend'),
    onClick: onSaveChanges
  }, t('.save')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: t('.discardInputLegend'),
    onClick: onDiscardChanges
  }, t('.discard'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/EditWorldRoute.tsx
















const EditWorldRoute = () => {
  const worldId = useWorldID();
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const loadWorld = (0,react_facet_src.useFacetCallback)((facet, worldId) => () => {
    if (worldId != null) facet.loadWorld(worldId);
  }, [], [worldEditorSharedFacet, worldId]);
  const loadWorldPacks = (0,react_facet_src.useFacetCallback)((facet, worldId) => () => {
    if (worldId != null) facet.loadPacksData(worldId);
  }, [], [worldPackagesSharedFacet, worldId]);
  const worldIsLoaded = (0,react_facet_src.useFacetMap)((ewFacet, packsFacet) => ewFacet.worldIsInitialized && packsFacet.isInitialized, [], [worldEditorSharedFacet, worldPackagesSharedFacet]);
  /**
   * This will be executed on the first render and check worldId. If the worldId is null,
   * it will save it
   *
   * Dependencies:
   * We will close the world to clear the data and will reset the state
   * of the "saveLocalWorld" method
   *
   * Sanity return: -
   */

  (0,react.useEffect)(() => {
    loadWorld();
    loadWorldPacks();
  }, [loadWorld, loadWorldPacks]);
  useUploadRealmCompleted();
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: worldIsLoaded
  }, /*#__PURE__*/react.createElement(EditWorldRouteSettings, null));
};

const EditWorldRouteSettings = () => {
  const {
    t
  } = useLocalization_useLocalization('EditWorld');
  const saveNotification = t('.notificationToasts.saved');
  const deleteNotification = t('.notificationToasts.deleted');
  const duplicateNotification = t('.notificationToasts.duplicated');
  const packActivatedNotification = t('.notificationToasts.packActivated');
  const packDeactivatedNotification = t('.notificationToasts.packDeactivated');
  /*
  	We will use this state to instantly disable the back button after being pressed as
  	in some cases if the user clicks twice or more quite quickly, we could be trying to save/close
  	a world that has been already closed. It will be enabled again when the world was saved or if
  	there were some errors in the saving. This can happen because backend is not so quick to
  	change the status to "saving" between the first and second click
  */

  const [backButtonDisabled, setBackButtonDisabled] = useToggleBackButton();
  const worldId = useWorldID();
  const localWorldList = (0,react_facet_src.useSharedFacet)(localWorldListFacet);
  const localWorldDataFound = (0,react_facet_src.useFacetMap)((localWorldList, worldId) => localWorldList.localWorlds.find(world => world.allContentOwned && world.id === worldId), [], [localWorldList, worldId]);
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const worldEditorSharedFacet = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const realmWorldUploaderSharedFacet = (0,react_facet_src.useSharedFacet)(realmWorldUploaderFacet);
  const telemetrySharedFacet = (0,react_facet_src.useSharedFacet)(telemetryFacet);
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  const worldOperationsSharedFacet = (0,react_facet_src.useSharedFacet)(worldOperationsFacet);
  const worldPackagesSharedFacet = (0,react_facet_src.useSharedFacet)(worldPackagesFacet);
  const networkWorldJoinerSharedFacet = (0,react_facet_src.useSharedFacet)(networkWorldJoinerFacet);
  const {
    advancedData,
    cheatsData,
    generalData,
    experimentsData,
    multiplayerData
  } = useEditWorldData();
  const worldSummary = useEditWorldSummaryData();
  const saveChangesModalGoBack = SaveChangesModal.useModal();
  const saveChangesModalPlay = SaveChangesModal.useModal();
  const worldPacks = (0,react_facet_src.useFacetMap)(facet => facet.worldPacksData, [], [worldPackagesSharedFacet]);
  const isUsingTemplate = (0,react_facet_src.useFacetMap)(facet => facet.worldData.isUsingTemplate, [], [worldEditorSharedFacet]);
  const isLockedTemplate = (0,react_facet_src.useFacetMap)(facet => {
    var _facet$worldData;

    return (_facet$worldData = facet.worldData) === null || _facet$worldData === void 0 ? void 0 : _facet$worldData.lockedTemplate;
  }, [], [worldEditorSharedFacet]);
  const cleanup = (0,react_facet_src.useFacetCallback)((worldEditorFacet, worldId) => () => {
    if (worldId != null) {
      worldEditorFacet.closeWorld(worldId);
    }
  }, [], [worldEditorSharedFacet, worldId]);
  /**
   * This will clean up the world data just before leaving the screen
   * so next loads of data work properly
   *
   * Dependencies:
   * @cleanup : the function that does the clean up
   *
   * Sanity return: the clean up function call
   */

  (0,react.useEffect)(() => () => {
    cleanup();
  }, [cleanup]);
  const startWorldCallback = useStartLocalWorldWithPrerequisites(localWorldDataFound);
  const saveLocalWorldProgress = (0,react_facet_src.useFacetMap)(facet => facet.saveLocalWorldProgress, [], [worldEditorSharedFacet]);
  const duplicateWorldProgress = (0,react_facet_src.useFacetMap)(facet => facet.duplicateWorldProgress, [], [worldOperationsSharedFacet]);
  const isAchievementsDisabled = (0,react_facet_src.useFacetMap)(facet => facet.isAchievementsEditDisabled, [], [worldEditorSharedFacet]); // Achievements disabled messages.

  const betaFeaturesEnabled = (0,react_facet_src.useFacetMap)(facet => facet.worldData.betaFeatures.some(feature => feature.isEnabled), [], [worldEditorSharedFacet]);
  const behaviorPacksEnabled = (0,react_facet_src.useFacetMap)(facet => facet.behaviorPacks.active.length > 0, [], [worldPacks]);
  const achievementsDisabledMessages = useAchievementsDisabledMessages({
    generalData,
    advancedData,
    cheatsData,
    multiplayerData,
    betaFeaturesEnabled,
    behaviorPacksEnabled
  }); // Download pack modal.

  const formatBytes = useFormatBytes();
  const availableSize = (0,react_facet_src.useFacetMap)(({
    storageUsed,
    storageSize
  }) => formatBytes(Math.max(0, storageSize - storageUsed)), [formatBytes], [deviceInformationSharedFacet]); // Pack actions.

  const showResourcePacksErrorModal = ResourcePacksErrorModal.useShowModal();
  const showResourcePacksDependencyWarningModal = ResourcePacksDependencyWarningModal.useShowModal();
  const showResourcePacksDownloadAndActivateModal = ResourcePacksDownloadAndActivateModal.useShowModal();
  const showBehaviorPacksConfirmationModal = BehaviorPacksConfirmationModal.useShowModal();
  const onActivatePackContinue = (0,react_facet_src.useFacetCallback)((facet, worldId, notificationFacet) => () => {
    if (worldId != null) {
      const result = facet.continuePackActivation(worldId);

      if (result != null) {
        showResourcePacksErrorModal({
          errorCode: result
        });
      } else {
        notificationFacet.queueSnackbar(packActivatedNotification);
      }
    }
  }, [showResourcePacksErrorModal, packActivatedNotification], [worldPackagesSharedFacet, worldId, notificationsSharedFacet]);
  const onDeactivatePackContinue = (0,react_facet_src.useFacetCallback)((facet, worldId, notificationFacet) => () => {
    if (worldId != null) {
      const result = facet.continuePackDeactivation(worldId);

      if (result != null) {
        showResourcePacksErrorModal({
          errorCode: result
        });
      } else {
        notificationFacet.queueSnackbar(packDeactivatedNotification);
      }
    }
  }, [showResourcePacksErrorModal, packDeactivatedNotification], [worldPackagesSharedFacet, worldId, notificationsSharedFacet]);
  const packDownloadProgress = (0,react_facet_src.useFacetMap)(facet => facet.packDownloadProgress, [], [worldPackagesSharedFacet]);
  const onDownloadAndActivatePack = useFacetCoroutine((facet, worldId) => function* (packId) {
    if (worldId != null) {
      // Download.
      facet.downloadPacks(worldId, [packId]);
      yield packDownloadProgress;

      switch (facet.packDownloadProgress) {
        case FacetTaskProgress.DONE:
          // Reset download flags.
          facet.cancelPackDownload(); // Activate.

          onActivatePackContinue();
          break;

        case FacetTaskProgress.CANCELLED:
          // Reset download flags.
          facet.cancelPackDownload();
          break;
      }
    }
  }, [packDownloadProgress, onActivatePackContinue], [worldPackagesSharedFacet, worldId]);
  const getPackSizeProgress = (0,react_facet_src.useFacetMap)(facet => facet.lastConsultedPackSizesProgress, [], [worldPackagesSharedFacet]);
  const onGetPackSize = useFacetCoroutine((facet, worldId) => function* (packId, packName) {
    if (worldId != null) {
      // Get Pack Size.
      facet.getPackSizes([packId], worldId);
      yield getPackSizeProgress;
      let packSize = '';

      if (facet.lastConsultedPackSizesError == null) {
        packSize = facet.lastConsultedPackSizes; // Reset flags.

        facet.getPackSizesReset();
      } // Show modal.


      showResourcePacksDownloadAndActivateModal({
        packId: packId,
        packName: packName,
        packSize: packSize,
        availableSize: availableSize,
        onAccept: onDownloadAndActivatePack
      });
    }
  }, [getPackSizeProgress, showResourcePacksDownloadAndActivateModal, availableSize, onDownloadAndActivatePack], [worldPackagesSharedFacet, worldId]);
  const onActivatePack = (0,react_facet_src.useFacetCallback)((facet, worldId, notificationFacet) => (packId, packType, packName) => {
    if (worldId != null) {
      const result = facet.activatePack(worldId, packId, packType, false);

      if (result === PackActionError.NeedToDownloadPack) {
        onGetPackSize(packId, packName);
      } else if (result === PackActionError.PackDependencyWarning) {
        showResourcePacksDependencyWarningModal({
          onAccept: onActivatePackContinue
        });
      } else if (result === PackActionError.PackDataWarning) {
        showBehaviorPacksConfirmationModal({
          packId: packId,
          type: 'activate',
          packType: packType,
          onAccept: onActivatePackContinue
        });
      } else if (result != null) {
        showResourcePacksErrorModal({
          errorCode: result
        });
      } else {
        notificationFacet.queueSnackbar(packActivatedNotification);
      }
    }
  }, [onGetPackSize, showResourcePacksDependencyWarningModal, onActivatePackContinue, showBehaviorPacksConfirmationModal, showResourcePacksErrorModal, packActivatedNotification], [worldPackagesSharedFacet, worldId, notificationsSharedFacet]);
  const onDeactivatePack = (0,react_facet_src.useFacetCallback)((facet, worldId, notificationFacet) => (packId, packType) => {
    if (worldId != null) {
      const result = facet.deactivatePack(worldId, packId, packType, false);

      if (result === PackActionError.PackDataWarning) {
        showBehaviorPacksConfirmationModal({
          packId: packId,
          type: 'deactivate',
          packType: packType,
          onAccept: onDeactivatePackContinue
        });
      } else if (result != null) {
        showResourcePacksErrorModal({
          errorCode: result
        });
      } else {
        notificationFacet.queueSnackbar(packDeactivatedNotification);
      }
    }
  }, [showBehaviorPacksConfirmationModal, onDeactivatePackContinue, showResourcePacksErrorModal, packDeactivatedNotification], [worldPackagesSharedFacet, worldId, notificationsSharedFacet]);
  const onChangePackPriority = (0,react_facet_src.useFacetCallback)((facet, worldId, notificationFacet) => (packId, packType, fromIndex, toIndex) => {
    if (worldId != null) {
      facet.changePackPriority(worldId, packId, packType, fromIndex, toIndex);
      notificationFacet.queueSnackbar(saveNotification);
    }
  }, [saveNotification], [worldPackagesSharedFacet, worldId, notificationsSharedFacet]);
  const onClickPackSettings = (0,react_facet_src.useFacetCallback)(() => packId => {
    historyAPI.push(`/pack-settings/${packId}`);
  }, [historyAPI], []);
  const onUnlockTemplateSettings = (0,react_facet_src.useFacetCallback)((facet, isLockedTemplate) => () => {
    if (isLockedTemplate) {
      facet.worldData.lockedTemplate = false;
    }
  }, [], [worldEditorSharedFacet, isLockedTemplate]);
  const worldPreviewImagePath = (0,react_facet_src.useFacetMap)(facet => facet.worldSummary.worldIconPath != null && facet.worldSummary.worldIconPath.length > 0 ? facet.worldSummary.worldIconPath : world_preview_default_namespaceObject, [], [worldEditorSharedFacet]);
  const onOptOut = (0,react_facet_src.useFacetCallback)((facet, worldId) => () => {
    if (worldId != null) {
      facet.closeWorld(worldId);
    }
  }, [], [worldEditorSharedFacet, worldId]);
  const onSaveWorld = useFacetCoroutine((worldEditorSharedFacet, notificationsFacet, worldId) => function* () {
    if (worldId != null) {
      setBackButtonDisabled(true); // Save world.

      worldEditorSharedFacet.startSaveLocalWorld(worldId);
      yield saveLocalWorldProgress;

      if (!worldEditorSharedFacet.saveLocalWorldError) {
        worldEditorSharedFacet.clearSaveLocalWorld(); // Notification.

        notificationsFacet.queueSnackbar(saveNotification); // Close world.

        historyAPI.goBack();
      }
    }
  }, [setBackButtonDisabled, saveLocalWorldProgress, saveNotification, historyAPI], [worldEditorSharedFacet, notificationsSharedFacet, worldId]);
  const backButtonCallback = (0,react_facet_src.useFacetCallback)(facet => () => {
    if (facet.worldHasBeenModified) {
      saveChangesModalGoBack.show();
    } else {
      historyAPI.goBack();
    }
  }, [historyAPI, saveChangesModalGoBack], [worldEditorSharedFacet]);
  const playWorld = useFacetCoroutine((worldEditorSharedFacet, worldId) => function* () {
    if (worldId != null) {
      // Save world.
      worldEditorSharedFacet.startSaveLocalWorld(worldId);
      yield saveLocalWorldProgress;

      if (!worldEditorSharedFacet.saveLocalWorldError) {
        worldEditorSharedFacet.clearSaveLocalWorld(); // Play world.

        startWorldCallback();
      }
    }
  }, [saveLocalWorldProgress, startWorldCallback], [worldEditorSharedFacet, worldId]);
  const onPlayWorld = (0,react_facet_src.useFacetCallback)(worldEditorSharedFacet => () => {
    if (worldEditorSharedFacet.worldHasBeenModified) {
      saveChangesModalPlay.show();
    } else {
      playWorld();
    }
  }, [playWorld, saveChangesModalPlay], [worldEditorSharedFacet]);
  const onDiscardAndPlay = (0,react_facet_src.useFacetCallback)((worldEditorSharedFacet, worldId) => () => {
    if (worldId != null) {
      // Reset local changes
      worldEditorSharedFacet.reloadWorld(worldId); // Play world.

      startWorldCallback();
    }
  }, [startWorldCallback], [worldEditorSharedFacet, worldId]);
  const onDuplicateWorld = useFacetCoroutine((worldEditorSharedFacet, notificationsFacet, worldOperationsFacet, worldId) => function* () {
    if (worldId != null) {
      // Save world.
      worldEditorSharedFacet.startSaveLocalWorld(worldId);
      yield saveLocalWorldProgress;

      if (!worldEditorSharedFacet.saveLocalWorldError) {
        worldEditorSharedFacet.clearSaveLocalWorld(); // Duplicate world.

        worldOperationsFacet.startDuplicateWorld(worldId);
        yield duplicateWorldProgress;

        if (!worldOperationsFacet.duplicateWorldError) {
          worldOperationsFacet.clearDuplicateWorld(); // Notification.

          notificationsFacet.queueSnackbar(duplicateNotification); // Close world.

          historyAPI.goBack();
        }
      }
    }
  }, [saveLocalWorldProgress, duplicateWorldProgress, duplicateNotification, historyAPI], [worldEditorSharedFacet, notificationsSharedFacet, worldOperationsSharedFacet, worldId]);
  const onDeleteWorld = (0,react_facet_src.useFacetCallback)((worldOperationsFacet, notificationsSharedFacet, worldId) => () => {
    if (worldId != null) {
      // Delete world.
      worldOperationsFacet.deleteWorld(worldId); // Notification.

      notificationsSharedFacet.queueSnackbar(deleteNotification); // Go Back

      historyAPI.goBack();
    }
  }, [deleteNotification, historyAPI], [worldOperationsSharedFacet, notificationsSharedFacet, worldId]);
  const onExportWorld = useFacetCoroutine((worldEditorSharedFacet, worldOperationsFacet, worldId) => function* () {
    if (worldId != null) {
      // Save world.
      worldEditorSharedFacet.startSaveLocalWorld(worldId);
      yield saveLocalWorldProgress;

      if (!worldEditorSharedFacet.saveLocalWorldError) {
        worldEditorSharedFacet.clearSaveLocalWorld(); // Export world.

        worldOperationsFacet.exportWorld(worldId);
      }
    }
  }, [saveLocalWorldProgress], [worldEditorSharedFacet, worldOperationsSharedFacet, worldId]);
  const onExportTemplate = useFacetCoroutine((worldEditorSharedFacet, worldOperationsFacet, worldId) => function* () {
    if (worldId != null) {
      // Save world.
      worldEditorSharedFacet.startSaveLocalWorld(worldId);
      yield saveLocalWorldProgress;

      if (!worldEditorSharedFacet.saveLocalWorldError) {
        worldEditorSharedFacet.clearSaveLocalWorld(); // Export world as template.

        worldOperationsFacet.exportWorldAsTemplate(worldId);
      }
    }
  }, [saveLocalWorldProgress], [worldEditorSharedFacet, worldOperationsSharedFacet, worldId]);
  const uploadRealmWorldProgress = (0,react_facet_src.useFacetMap)(realmWorldUploaderSharedFacet => realmWorldUploaderSharedFacet.uploadRealmWorldTaskStatus, [], [realmWorldUploaderSharedFacet]);
  const realmsActionCallback = useFacetCoroutine((realmWorldUploaderFacet, worldId, networkWorldJoinerFacet, telemetryFacet) => function* () {
    if (worldId != null) {
      telemetryFacet.fireEventButtonPressed('Upload_Realm_OreUI', {});
      realmWorldUploaderFacet.uploadWorldToRealm(worldId);
      yield uploadRealmWorldProgress;
      const realmId = realmWorldUploaderFacet.uploadedRealmWorld;
      realmWorldUploaderFacet.clearUploadRealmWorldState();
      networkWorldJoinerFacet.joinRealmWorld(realmId.toString());
    }
  }, [uploadRealmWorldProgress], [realmWorldUploaderSharedFacet, worldId, networkWorldJoinerSharedFacet, telemetrySharedFacet]);
  useNotifyAfterExported();
  useNotifyAfterPlayerDataCleared();
  const isEditorWorld = (0,react_facet_src.useFacetMap)(worldEditorFacet => {
    return worldEditorFacet.isEditorWorld;
  }, [], [worldEditorSharedFacet]);
  return /*#__PURE__*/react.createElement(WorldModeContext.Provider, {
    value: "edit"
  }, /*#__PURE__*/react.createElement(WorldSettingsWrapper, {
    advancedData: advancedData,
    cheatsData: cheatsData,
    experimentsData: experimentsData,
    generalData: generalData,
    multiplayerData: multiplayerData,
    worldPacks: worldPacks,
    worldPreviewImage: worldPreviewImagePath,
    isUsingTemplate: isUsingTemplate,
    isLockedTemplate: isLockedTemplate,
    worldSummary: worldSummary,
    isEditorWorld: isEditorWorld,
    isAchievementsDisabled: isAchievementsDisabled,
    achievementsDisabledMessages: achievementsDisabledMessages,
    renderPage: (0,react_facet_src.useFacetWrap)(true),
    onActivatePack: onActivatePack,
    onDeactivatePack: onDeactivatePack,
    onChangePackPriority: onChangePackPriority,
    onClickPackSettings: onClickPackSettings,
    onUnlockTemplateSettings: onUnlockTemplateSettings,
    backButtonCallback: backButtonCallback,
    mainActionCallback: onPlayWorld,
    realmsActionCallback: realmsActionCallback,
    backButtonDisabled: backButtonDisabled,
    onDuplicateWorld: onDuplicateWorld,
    onDeleteWorld: onDeleteWorld,
    onExportWorld: onExportWorld,
    onExportTemplate: onExportTemplate,
    onOptOut: onOptOut,
    isSeedChangeLocked: (0,react_facet_src.useFacetWrap)(false)
  }), /*#__PURE__*/react.createElement(EditWorldModals, null), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: saveChangesModalGoBack.isVisible
  }, /*#__PURE__*/react.createElement(SaveChangesModal.Component, {
    saveChanges: onSaveWorld,
    closeModal: saveChangesModalGoBack.hide,
    discardChanges: historyAPI.goBack
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: saveChangesModalPlay.isVisible
  }, /*#__PURE__*/react.createElement(SaveChangesModal.Component, {
    saveChanges: playWorld,
    closeModal: saveChangesModalPlay.hide,
    discardChanges: onDiscardAndPlay
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/EditWorldRoute/index.ts


;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/images/emptyRealmSlotBig.png
const emptyRealmSlotBig_namespaceObject = __webpack_require__.p + "assets/emptyRealmSlotBig-174b3.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/images/emptyRealmSlotSmall.png
const emptyRealmSlotSmall_namespaceObject = __webpack_require__.p + "assets/emptyRealmSlotSmall-fe677.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/WorldSettings/images/celebration_world_icon.jpg
const celebration_world_icon_namespaceObject = __webpack_require__.p + "assets/celebration_world_icon-917c8.jpg";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewReplaceWorldModal/RealmsPreviewReplaceWorldModal.tsx





const RealmsPreviewReplaceWorldModal_CLOSE_BUTTON_GAMEPAD_ALIAS = 'realm-preview-replace-preview-realm-close';
const RealmsPreviewReplaceWorldModal = registerModal(({
  onConfirm,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('RealmsPreviews.ReplaceWorld');
  const messageText = t('.message');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: RealmsPreviewReplaceWorldModal_CLOSE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: messageText,
    gamepadIndex: 0
  }, messageText)), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.select'),
    variant: "primary",
    onClick: onConfirm
  }, t('.confirm')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    gamepadAlias: RealmsPreviewReplaceWorldModal_CLOSE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.select'),
    variant: "secondary",
    onClick: onClose
  }, t('.cancel'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsPreviewReplaceWorldModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/images/RealmsGenericEmptyMessageArt.png
const RealmsGenericEmptyMessageArt_namespaceObject = __webpack_require__.p + "assets/RealmsGenericEmptyMessageArt-45ab1.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseSlotRoute/ChooseSlotRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ChooseSlotRoute = ({"worldImageWrapper":"xKrMY","border":"WsmeP","spinner":"aziqd"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseSlotRoute/ChooseSlotRoute.tsx





















function RealmSlotGridListItem({
  world,
  index,
  onItemClick
}) {
  const {
    t
  } = useLocalization_useLocalization('ChooseSlotRoute');
  const slotName = (0,react_facet_src.useFacetMap)(world => world.worldName, [], [world]);
  const worldImage = (0,react_facet_src.useFacetMap)(world => world.id === -1 ? emptyRealmSlotBig_namespaceObject : world.slotImage.length > 0 ? celebration_world_icon_namespaceObject : world_preview_default_namespaceObject, // BBITODO: this formula works for now, but we'll probably have some sort of isCelebrationMap in the future (ADO: 1025234)
  [], [world]);
  const hint = (0,react_facet_src.useFacetMap)(world => world.id === -1 ? t('.emptySlotHint') : t('.slotHint'), [t], [world]);
  const buttonNarrationSuffix = (0,react_facet_src.useFacetMap)(hint => t('.slotEnumeration', [(index + 1).toString(), hint.toString()]), [t, index], [hint]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: index,
    inputLegend: t('.select'),
    onClick: onItemClick,
    narrationSuffix: buttonNarrationSuffix
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: worldImage,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: slotName
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    verticalAlign: "center"
  }, slotName))));
}

function RealmSlotsGrid({
  onItemClick
}) {
  return /*#__PURE__*/react.createElement(GridList_GridList, {
    gamepadIndex: 0,
    data: (0,react_facet_src.useFacetMap)(facet => {
      return facet.realmSlots;
    }, [], [(0,react_facet_src.useSharedFacet)(realmSlotsFacet)]),
    columns: 3,
    itemSeparatorHorizontal: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(RealmSlotGridListItem, {
      world: itemFacet,
      index: index,
      onItemClick: () => onItemClick(index)
    })
  });
}

function RealmSlotListItem({
  world,
  index,
  onItemClick
}) {
  const {
    t
  } = useLocalization_useLocalization('ChooseSlotRoute');
  const slotName = (0,react_facet_src.useFacetMap)(world => world.worldName, [], [world]);
  const worldImage = (0,react_facet_src.useFacetMap)(world => world.id === -1 ? emptyRealmSlotSmall_namespaceObject : world.slotImage.length > 0 ? celebration_world_icon_namespaceObject : world_preview_default_namespaceObject, // BBITODO: this formula works for now, but we'll probably have some sort of isCelebrationMap in the future (ADO: 1025234)
  [], [world]);
  const semanticColors = hooks_useSemanticColors('neutral80');
  const buttonNarration = (0,react_facet_src.useFacetMap)((world, slotName) => t('.slotButtonNarration', [slotName.toString(), (index + 1).toString(), world.id === -1 ? t('.emptySlotHint') : t('.slotHint')]), [t, index], [world, slotName]);
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: index,
    tall: true
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: t('.select'),
    narrationText: buttonNarration,
    onClick: onItemClick
  }, /*#__PURE__*/react.createElement("div", {
    className: ChooseSlotRoute.worldImageWrapper
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: worldImage,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"],
    className: classnames_default()(semanticColors.border.base, ChooseSlotRoute.border)
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, slotName))));
}

function RealmSlotsSectionList({
  onItemClick
}) {
  return /*#__PURE__*/react.createElement(FlatList_FlatList, {
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    gamepadIndex: 0,
    data: (0,react_facet_src.useFacetMap)(facet => facet.realmSlots, [], [(0,react_facet_src.useSharedFacet)(realmSlotsFacet)]),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(RealmSlotListItem, {
      world: itemFacet,
      index: index,
      onItemClick: () => onItemClick(index)
    })
  });
}

function ChooseSlotRoute_ChooseSlotRoute() {
  const history = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('ChooseSlotRoute');
  const isNarrow = useIsWindowNarrow(70);
  const realmSlotsFacetLocal = (0,react_facet_src.useSharedFacet)(realmSlotsFacet);
  const isLoading = (0,react_facet_src.useFacetMap)(facet => facet.isLoading, [], [realmSlotsFacetLocal]);
  const header = (0,react_facet_src.useFacetMap)(facet => t('.chooseSlotHeader', [facet.selectedRealmName]), [t], [realmSlotsFacetLocal]);
  const realmSlotClick = (0,react_facet_src.useFacetCallback)(realmSlots => selectedIndex => {
    realmSlots.selectSlot(selectedIndex);
  }, [], [realmSlotsFacetLocal]);
  const paramsFacet = hooks_useRouteParams();
  const realmId = (0,react_facet_src.useFacetMap)(facet => facet.id, [], [paramsFacet]);
  const createNewWorldFacetLocal = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const initialLoadDone = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)((cnw, realmSlots, id) => {
    if (!initialLoadDone.current) {
      console.log('Initial loading of realm details');
      initialLoadDone.current = true;
      realmSlots.getSelectedRealmDetails(id);
    }

    if (realmSlots.isSlotSelected) {
      console.log('Slot selected detected, proceeding with world creation...');
      realmSlots.reset();
      cnw.createWorldOnPreviewRealm(id);
    }
  }, [initialLoadDone, history], [createNewWorldFacetLocal, realmSlotsFacetLocal, realmId]);
  const isShowingConfirmationModal = (0,react_facet_src.useFacetMap)(facet => facet.isShowingConfirmationModal, [], [realmSlotsFacetLocal]);
  const confirmClick = (0,react_facet_src.useFacetCallback)(realmSlots => () => {
    realmSlots.confirm();
  }, [], [realmSlotsFacetLocal]);
  const cancelClick = (0,react_facet_src.useFacetCallback)(realmSlots => () => {
    realmSlots.reset();
  }, [], [realmSlotsFacetLocal]);
  const didFailToActivateSlot = (0,react_facet_src.useFacetMap)(facet => facet.didFailToActivateSlot, [], [realmSlotsFacetLocal]);
  const didFailToQuerySelectedRealmDetails = (0,react_facet_src.useFacetMap)(facet => facet.didFailToQuerySelectedRealmDetails, [], [realmSlotsFacetLocal]);
  const failToActivateSlotOkClick = (0,react_facet_src.useFacetCallback)(realmSlots => () => {
    realmSlots.reset();
  }, [], [realmSlotsFacetLocal]);
  const semanticColors = hooks_useSemanticColors('inherit');
  const hint = t('.backHint');
  const screenNarration = (0,react_facet_src.useFacetMap)(header => t('.screen', [header]), [t], [header]);
  const tryAgain = (0,react_facet_src.useFacetCallback)((realmSlots, id) => () => {
    if (realmSlots.didFailToQuerySelectedRealmDetails) {
      realmSlots.getSelectedRealmDetails(id);
    }
  }, [], [realmSlotsFacetLocal, realmId]);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ChooseSlotRoute.spinner, semanticColors.overlay.base)
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Narration, {
    text: screenNarration
  }), /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: history.goBack,
      hint: hint
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, header),
    gamepadAlias: "choose-slote-route"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: didFailToQuerySelectedRealmDetails,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), isNarrow && /*#__PURE__*/react.createElement(RealmSlotsSectionList, {
    onItemClick: realmSlotClick
  }), !isNarrow && /*#__PURE__*/react.createElement(RealmSlotsGrid, {
    onItemClick: realmSlotClick
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: didFailToQuerySelectedRealmDetails
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: t('.noSlotsErrorTitle'),
    text: t('.noSlotsErrorMessage'),
    imgSrc: RealmsGenericEmptyMessageArt_namespaceObject,
    buttons: [{
      text: t('.noSlotsErrorButton'),
      inputLegend: t('.select'),
      onClick: tryAgain
    }]
  })))))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingConfirmationModal
  }, /*#__PURE__*/react.createElement(RealmsPreviewReplaceWorldModal.Component, {
    onConfirm: confirmClick,
    onClose: cancelClick
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: didFailToActivateSlot
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: failToActivateSlotOkClick
  })))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseSlotRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/images/trash.png
const trash_namespaceObject = __webpack_require__.p + "assets/trash-4fd68.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/images/arrowForwardWhite.png
const arrowForwardWhite_namespaceObject = __webpack_require__.p + "assets/arrowForwardWhite-9acff.png";
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/IconArrowForwardWhite.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconArrowForwardWhite = ({"iconArrowForwardWhite":"VBVxi"});
;// CONCATENATED MODULE: ./packages/ui-icons/src/IconArrowForwardWhite/IconArrowForwardWhite.tsx
function IconArrowForwardWhite_extends() { IconArrowForwardWhite_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return IconArrowForwardWhite_extends.apply(this, arguments); }

function IconArrowForwardWhite_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = IconArrowForwardWhite_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function IconArrowForwardWhite_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }






const IconArrowForwardWhite_IconArrowForwardWhite = (_ref) => {
  let {
    className
  } = _ref,
      props = IconArrowForwardWhite_objectWithoutProperties(_ref, ["className"]);

  const classNames = useCombinedClassNames(IconArrowForwardWhite.iconArrowForwardWhite, className);
  return /*#__PURE__*/react.createElement(Image_Image_Image, IconArrowForwardWhite_extends({}, props, {
    className: classNames,
    src: arrowForwardWhite_namespaceObject,
    imageRendering: "pixelated"
  }));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/InboxListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxListItem = ({"iconTrashCan":"gRR2U"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/TelemetryUtil.tsx

const messageTelemetryDetails = item => {
  return {
    messageId: item.id,
    messageType: categoryDataToStringValue(item.announcementType),
    messageRead: item.read.toString()
  };
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/DeleteInboxMessageModal/DeleteInboxMessageModal.tsx









const DELETE_INBOX_MESSAGE_CONFIRM = 'delete-inbox-message-confirm';
const DeleteInboxMessageModal = registerModal(function DeleteInboxMessage({
  item
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxRoute.deleteConfirmation');
  const hideModal = useHideModal();
  const buttonTelemetry = useButtonTelemetry();
  const deleteNotification = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.deleteNotification(item.instanceId);
    buttonTelemetry({
      button: 'MessageAction_Delete',
      screen: 'Inbox',
      details: messageTelemetryDetails(item)
    });
  }, [item, buttonTelemetry], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet)]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Overlay, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DELETE_INBOX_MESSAGE_CONFIRM
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.dialogText')
  }, t('.dialogText'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: 'destructive',
    gamepadIndex: 0,
    gamepadAlias: DELETE_INBOX_MESSAGE_CONFIRM,
    inputLegend: t('.deleteConfirm'),
    autofocus: true,
    onClick: () => {
      deleteNotification();
      hideModal();
    }
  }, t('.deleteConfirm')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    onClick: hideModal
  }, t('.cancel')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InviteExpiredModal/InviteExpiredModal.tsx






const INVITE_EXPIRED_OK = 'invite-expired-modal-ok';
const InviteExpiredModal = registerModal(({
  item,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('Realms.InviteExpiredModals');
  const hideModal = useHideModal();
  const handleClose = (0,react_facet_src.useFacetCallback)((inboxFacet, item) => () => {
    inboxFacet.setInvitationStatus(item.instanceId, InvitationStatus.EXPIRED);
    inboxFacet.setNotificationRead(item.instanceId);
    onClose();
    hideModal();
  }, [hideModal, onClose], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet), item]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: INVITE_EXPIRED_OK
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.message')
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: INVITE_EXPIRED_OK,
    gamepadIndex: 0,
    inputLegend: t('.ok'),
    variant: "secondary",
    onClick: handleClose
  }, t('.ok'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/InboxListItem.tsx

















function StatusTag({
  invite,
  daysLeft
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxRoute');
  const role = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    switch (invite.invStatus) {
      case InvitationStatus.ACCEPTED:
        return 'primaryTint';

      case InvitationStatus.REJECTED:
        return 'neutral100';

      case InvitationStatus.EXPIRED:
        return 'noticeTint';

      case InvitationStatus.NONE:
        if (daysLeft != null && (invite.announcementType == InboxMessageType.NEWS || invite.announcementType == InboxMessageType.REALMS)) {
          if (daysLeft <= 0) {
            return 'noticeTint';
          } else {
            return 'informativeTint';
          }
        }

      default:
        return 'noticeTint';
    }
  }, [], [invite, daysLeft]);
  const label = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    switch (invite.invStatus) {
      case InvitationStatus.ACCEPTED:
        return t('.accepted');

      case InvitationStatus.REJECTED:
        return t('.rejected');

      case InvitationStatus.EXPIRED:
        return t('.expired');

      default:
        if (daysLeft != null && (invite.announcementType == InboxMessageType.NEWS || invite.announcementType == InboxMessageType.REALMS)) {
          if (daysLeft <= 0) {
            return t('.expired');
          } else {
            return t('.endsSoon', [`${daysLeft}`]);
          }
        }

        return '';
    }
  }, [t], [invite, daysLeft]);
  const shouldRenderTag = (0,react_facet_src.useFacetMap)((invite, daysLeft) => {
    return invite.invStatus != InvitationStatus.NONE || daysLeft != null;
  }, [], [invite, daysLeft]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRenderTag
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: role
  }, label));
}
function InboxListItem_InboxListItem({
  item,
  gamepadIndex
}) {
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: gamepadIndex,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/react.createElement(InboxListItemAction, {
    item: item,
    gamepadIndex: 0
  }), /*#__PURE__*/react.createElement(InboxAdditionalActions, {
    item: item,
    gamepadIndex: 1
  }));
}

const InboxListItemAction = ({
  item
}) => {
  const routerAPI = hooks_useRouterAPI();
  const {
    t
  } = useLocalization_useLocalization('InboxListItem');
  const {
    t: narration
  } = useLocalization_useLocalization('InboxListItem.narration');
  const daysLeft = (0,react_facet_src.useFacetMap)(item => {
    return item.inviteDaysLeft;
  }, [], [item]);
  const buttonTelemetry = useButtonTelemetry();
  const handleClick = (0,react_facet_src.useFacetCallback)((item, inboxFacet) => () => {
    buttonTelemetry({
      button: 'MessageAction_View',
      screen: 'Inbox',
      details: messageTelemetryDetails(item)
    });

    if (!item.read && item.announcementType != InboxMessageType.INVITES) {
      inboxFacet.setNotificationRead(item.instanceId);
    }

    routerAPI.push(`/message/${item.instanceId}/`);
  }, [routerAPI, buttonTelemetry], [item, (0,react_facet_src.useSharedFacet)(inboxSharedFacet)]);
  const title = (0,react_facet_src.useFacetMap)(item => item.title, [], [item]);
  const status = (0,react_facet_src.useFacetMap)(item => item.read, [], [item]);
  const postedBy = (0,react_facet_src.useFacetMap)(item => item.sender, [], [item]);
  const categoryName = (0,react_facet_src.useFacetMap)(item => item.announcementType, [], [item]);
  const contextNarration = (0,react_facet_src.useFacetMap)((categoryName, title, status, postedBy) => [categoryName, title, status === false ? narration('.unreadPost') : narration('.readPost'), postedBy !== '' ? narration('.postedBy', [postedBy]) : '', categoryName !== InboxMessageType.INVITES ? narration('.buttonSiblings', ['1', '2']) : narration('.buttonSiblings', ['1', '3'])] // Filter out any empty strings
  .filter(x => x != null && x !== '').join(' . '), [narration], [categoryName, title, status, postedBy]);
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: t('.view'),
    narrationText: contextNarration,
    onClick: handleClick,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus === InvitationStatus.NONE && item.invType != InvitationType.NONE || !item.read && item.announcementType != InboxMessageType.INVITES, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(Badge_Badge, null)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.title, [], [item]))), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.sender, [], [item])))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.announcementType != InboxMessageType.INVITES, [], [item])
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, (0,react_facet_src.useFacetMap)(item => item.dateString, [], [item])))), /*#__PURE__*/react.createElement(StatusTag, {
    invite: item,
    daysLeft: daysLeft
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }));
};

const InboxAdditionalActions = ({
  item
}) => {
  const {
    t
  } = useLocalization_useLocalization('InboxListItem');
  const {
    t: narration
  } = useLocalization_useLocalization('InboxListItem.narration');
  const semanticColors = hooks_useSemanticColors('inherit');
  const showDeleteMessageModal = DeleteInboxMessageModal.useShowModal();
  const buttonTelemetry = useButtonTelemetry();
  const friendsTab = '/play/friends';
  const routerAPI = hooks_useRouterAPI();
  const inboxFacet = (0,react_facet_src.useSharedFacet)(inboxSharedFacet);
  const [isAcceptButtonClicked, setIsAcceptButtonClicked] = (0,react_facet_src.useFacetState)(false);
  const handleAccepted = (0,react_facet_src.useFacetCallback)((item, inboxFacet, isAcceptButtonClicked) => () => {
    if (!isAcceptButtonClicked) {
      inboxFacet.setInvitationStatus(item.instanceId, InvitationStatus.ACCEPTED);
      setIsAcceptButtonClicked(true);

      if (!item.read) {
        inboxFacet.setNotificationRead(item.instanceId);
      }

      console.log('Inbox Accepted Clicked');
      buttonTelemetry({
        button: 'MessageAction_AcceptInvite',
        screen: 'Inbox',
        details: messageTelemetryDetails(item)
      });
    }
  }, [buttonTelemetry, setIsAcceptButtonClicked], [item, inboxFacet, isAcceptButtonClicked]);
  const handleRejected = (0,react_facet_src.useFacetCallback)((item, inboxFacet) => () => {
    inboxFacet.setInvitationStatus(item.instanceId, InvitationStatus.REJECTED);

    if (!item.read) {
      inboxFacet.setNotificationRead(item.instanceId);
    }

    console.log('Inbox Rejected Clicked');
    buttonTelemetry({
      button: 'MessageAction_RejectInvite',
      screen: 'Inbox',
      details: messageTelemetryDetails(item)
    });
  }, [buttonTelemetry], [item, inboxFacet]);
  const handleRealms = (0,react_facet_src.useFacetCallback)(item => () => {
    routerAPI.push(friendsTab);
    buttonTelemetry({
      button: 'MessageAction_Realms',
      screen: 'Inbox',
      details: messageTelemetryDetails(item)
    });
  }, [routerAPI, buttonTelemetry], [item]);
  const handleDelete = (0,react_facet_src.useFacetCallback)(item => () => {
    showDeleteMessageModal({
      item: item
    });
  }, [showDeleteMessageModal], [item]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus == InvitationStatus.NONE && item.invType != InvitationType.NONE, [], [item])
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 0,
    narrationText: [narration('.accept'), narration('.buttonSiblings', ['2', '3'])].join(' . '),
    inputLegend: t('.accept'),
    onClick: handleAccepted
  }, /*#__PURE__*/react.createElement(IconCheckWhite_IconCheckWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.accept'))), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 3,
    narrationText: [narration('.reject'), narration('.buttonSiblings', ['3', '3'])].join(' . '),
    inputLegend: t('.reject'),
    onClick: handleRejected
  }, /*#__PURE__*/react.createElement(IconCrossWhite_IconCrossWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.reject'))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus == InvitationStatus.JOIN && item.invType == InvitationType.REALMS || item.invStatus == InvitationStatus.ACCEPTED && item.invType == InvitationType.REALMS, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 1,
    inputLegend: t('.realms'),
    narrationText: [narration('.realm'), narration('.buttonSiblings', ['2', '3'])].join(' . '),
    onClick: handleRealms
  }, /*#__PURE__*/react.createElement(IconArrowForwardWhite_IconArrowForwardWhite, null), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.realms')))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => item.invStatus != InvitationStatus.NONE || item.invType == InvitationType.NONE, [], [item])
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.AdditionalAction, {
    gamepadIndex: 3,
    narrationText: [narration('.delete'), narration('.buttonSiblings', ['2', '2'])].join(' . '),
    inputLegend: t('.delete'),
    onClick: handleDelete
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: trash_namespaceObject,
    className: classnames_default()(InboxListItem.iconTrashCan, semanticColors.icon)
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionTiny"
  }, t('.delete')))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((item, isAcceptButtonClicked) => isAcceptButtonClicked && item.invStatus === InvitationStatus.EXPIRED, [], [item, isAcceptButtonClicked])
  }, /*#__PURE__*/react.createElement(InviteExpiredModal.Component, {
    item: item,
    onClose: () => setIsAcceptButtonClicked(false)
  })));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxListItem/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoNews.png
const NoNews_namespaceObject = __webpack_require__.p + "assets/NoNews-191af.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoRealmsInvites.png
const NoRealmsInvites_namespaceObject = __webpack_require__.p + "assets/NoRealmsInvites-3af80.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/NoRealmsNews.png
const NoRealmsNews_namespaceObject = __webpack_require__.p + "assets/NoRealmsNews-ed604.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/images/GenericError.png
const InboxSectionList_images_GenericError_namespaceObject = __webpack_require__.p + "assets/GenericError-2a9c9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/InboxSectionList.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxSectionList = ({"emptyStateArt":"_7QZv"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/InboxSectionList.tsx















function InboxSectionList_InboxSectionList({
  data,
  value
}) {
  const hasData = (0,react_facet_src.useFacetMap)(data => data != null && (data.history.length > 0 || data.recent.length > 0), [], [data]);
  const {
    t
  } = useLocalization_useLocalization('InboxSectionList');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasData
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SectionList_SectionList, {
    gamepadIndex: 0,
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    data: (0,react_facet_src.useFacetMap)(data => [{
      role: 'neutral',
      title: t('.recent'),
      data: data.recent
    }, {
      role: 'neutral',
      title: t('.history'),
      data: data.history
    }], [t], [data]),
    renderSectionHeader: (title, role) => /*#__PURE__*/react.createElement(ListHeader_ListHeader_ListHeader, {
      role: role,
      label: title
    }),
    sectionSeparator: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => {
      return /*#__PURE__*/react.createElement(InboxListItem_InboxListItem, {
        item: itemFacet,
        gamepadIndex: index
      });
    },
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    })
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasData,
    condition: false
  }, /*#__PURE__*/react.createElement(InboxSectionList_EmptyState, {
    value: value,
    realmsSubscriber: (0,react_facet_src.useFacetMap)(inbox => {
      return inbox.realmsSubscriber;
    }, [], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet)])
  })));
}

function getVariantValues(values, t) {
  switch (values) {
    case InboxMessageType.NEWS:
      return {
        title: t('.emptyMessageTitle'),
        text: t('.emptyMessageText'),
        imgSrc: NoNews_namespaceObject
      };

    case InboxMessageType.INVITES:
      return {
        title: t('.emptyInvitesTitle'),
        text: t('.emptyInvitesText'),
        imgSrc: NoRealmsInvites_namespaceObject
      };

    case InboxMessageType.REALMS:
      return {
        title: t('.emptyRealmSubTitle'),
        text: t('.emptyRealmSubText'),
        imgSrc: NoRealmsNews_namespaceObject
      };

    default:
      return {
        title: t('.errorTitle'),
        text: t('.errorText'),
        imgSrc: InboxSectionList_images_GenericError_namespaceObject
      };
  }
}

function InboxSectionList_EmptyState({
  value,
  realmsSubscriber
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxRoute');
  const data = getVariantValues(value, t);
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const mountRealmsUpsell = (0,react_facet_src.useFacetMap)(realmsSubscriber => {
    return value == InboxMessageType.REALMS && !realmsSubscriber;
  }, [value], [realmsSubscriber]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: mountRealmsUpsell,
    condition: true
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadIndex: 0,
    title: t('.emptyRealmNoSubTitle'),
    text: t('.emptyRealmNoSubText'),
    imgSrc: NoRealmsNews_namespaceObject,
    imgClass: InboxSectionList.emptyStateArt,
    buttons: [{
      text: t('.learn'),
      inputLegend: t('.select'),
      onClick: () => historyAPI.push('/realms-plus-pdp?tab=default'),
      variant: 'primary'
    }]
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: mountRealmsUpsell,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    autofocus: true,
    gamepadIndex: 0,
    title: data.title,
    text: data.text,
    imgSrc: data.imgSrc,
    imgClass: InboxSectionList.emptyStateArt
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSectionList/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/News.png
const News_namespaceObject = __webpack_require__.p + "assets/News-1cc93.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/Invites.png
const Invites_namespaceObject = __webpack_require__.p + "assets/Invites-8a83b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/images/Realms.png
const Realms_namespaceObject = __webpack_require__.p + "assets/Realms-93444.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxSideMenu/InboxSideMenu.tsx













function getCategories(t, inboxCount, inboxSettings) {
  return [{
    displayName: t('.news'),
    imageUrl: News_namespaceObject,
    imageId: 'newsIcon',
    contentType: InboxMessageType.NEWS,
    value: 'news',
    count: inboxCount.unreadNewsCount,
    shouldShowBadge: inboxSettings.showNewsBadges,
    telemetryButtonName: 'Inbox_News_Button'
  }, {
    displayName: t('.invites'),
    imageUrl: Invites_namespaceObject,
    imageId: 'invitesIcon',
    contentType: InboxMessageType.INVITES,
    value: 'invites',
    count: inboxCount.unreadInvitesCount,
    shouldShowBadge: inboxSettings.showInvitesBadges,
    telemetryButtonName: 'Inbox_Invites_Button'
  }, {
    displayName: t('.realms'),
    imageUrl: Realms_namespaceObject,
    imageId: 'realmsIcon',
    contentType: InboxMessageType.REALMS,
    value: 'realms',
    count: inboxCount.unreadRealmsCount,
    shouldShowBadge: inboxSettings.showRealmsBadges,
    telemetryButtonName: 'Inbox_Realms_Button'
  }];
}

function InboxSideMenu() {
  /** This is just boilerplate code for when to show a loading state */
  const {
    t
  } = useLocalization_useLocalization('InboxRoute');
  const categories = (0,react_facet_src.useFacetMap)((inboxCount, inboxSettings) => {
    return getCategories(t, {
      unreadNewsCount: inboxCount.unreadNewsCount,
      unreadInvitesCount: inboxCount.unreadInvitesCount,
      unreadRealmsCount: inboxCount.unreadRealmsCount
    }, {
      showNewsBadges: inboxSettings.showNewsBadges,
      showInvitesBadges: inboxSettings.showInvitesBadges,
      showRealmsBadges: inboxSettings.showRealmsBadges
    });
  }, [t], [(0,react_facet_src.useSharedFacet)(categorizedMessagesSelector), (0,react_facet_src.useSharedFacet)(inboxSettingsSelector)]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    loading: (0,deferred_mount_dist.useIsDeferring)(),
    autofocus: true
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemList, {
    items: (0,react_facet_src.useFacetWrap)(categories),
    initialGamepadIndex: 0,
    renderItem: InboxSideMenu_SideMenuItem
  }));
}
function InboxSideMenu_SideMenuItem({
  item,
  gamepadIndex
}) {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('InboxRoute');
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const menuItemText = (0,react_facet_src.useFacetMap)(item => item.displayName, [], [item]);
  const telemetryButton = useButtonTelemetry();
  const prefix = 'inbox';
  const selected = (0,react_facet_src.useFacetMap)(item => {
    return params.tab === item.value;
  }, [params], [item]);
  return /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ListItem, {
    narrationText: menuItemText,
    onSelect: (0,react_facet_src.useFacetCallback)(item => () => {
      if (item.value === params.tab) return;
      telemetryButton({
        button: item.telemetryButtonName,
        screen: 'Inbox'
      });
      historyAPI.replace(`/${prefix}/${item.value}`);
    }, [params, historyAPI, telemetryButton], [item]),
    value: (0,react_facet_src.useFacetMap)(item => item.value, [], [item]),
    selected: selected,
    gamepadIndex: gamepadIndex,
    inputLegend: t('.select')
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemCell, null, /*#__PURE__*/react.createElement(IllustrativeMenuIcon_IllustrativeMenuIcon, {
    iconSrc: (0,react_facet_src.useFacetMap)(item => item.imageUrl, [], [item]),
    selected: selected
  })), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemMain, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, menuItemText)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)(item => {
      return item.count > 0 && item.shouldShowBadge;
    }, [], [item])
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.ItemCell, {
    margin: 'start'
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: 'destructiveTint'
  }, (0,react_facet_src.useFacetMap)(item => {
    return `${item.count}`;
  }, [], [item]))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxRoute/InboxRoute.tsx










function InboxRoute() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('InboxRoute');
  const categorizedMessages = (0,react_facet_src.useSharedFacet)(categorizedMessagesSelector);
  const newsData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    var _categorizedMessages$;

    return (_categorizedMessages$ = categorizedMessages.newsData) !== null && _categorizedMessages$ !== void 0 ? _categorizedMessages$ : [];
  }, [], [categorizedMessages]);
  const inviteData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    var _categorizedMessages$2;

    return (_categorizedMessages$2 = categorizedMessages.invitesData) !== null && _categorizedMessages$2 !== void 0 ? _categorizedMessages$2 : [];
  }, [], [categorizedMessages]);
  const realmsData = (0,react_facet_src.useFacetMap)(categorizedMessages => {
    var _categorizedMessages$3;

    return (_categorizedMessages$3 = categorizedMessages.realmsData) !== null && _categorizedMessages$3 !== void 0 ? _categorizedMessages$3 : [];
  }, [], [categorizedMessages]);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: historyAPI.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.header')),
    right: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.MenuButton, {
      type: "filter",
      gamepadIndex: 2,
      onClick: () => {
        historyAPI.push('/inbox-settings');
      },
      narrationText: t('.settingsButton')
    }),
    gamepadAlias: "inbox-route"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    narrowBreakpointWidth: 102
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(InboxSideMenu, null)), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 7,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: categoryDataToStringValue(InboxMessageType.NEWS),
    component: () => /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
      data: newsData,
      value: InboxMessageType.NEWS
    })
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: categoryDataToStringValue(InboxMessageType.INVITES),
    component: () => /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
      data: inviteData,
      value: InboxMessageType.INVITES
    })
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: categoryDataToStringValue(InboxMessageType.REALMS),
    component: () => /*#__PURE__*/react.createElement(InboxSectionList_InboxSectionList, {
      data: realmsData,
      value: InboxMessageType.REALMS
    })
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseRealmRoute/ChooseRealmRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ChooseRealmRoute = ({"spinner":"_8UNVp","addPreviewRealmButtonTablet":"TyJek","addPreviewRealmButtonDesktop":"z8rvJ","addPreviewRealmButtonNarrow":"opGGY"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseRealmRoute/ChooseRealmRoute.tsx





















function RealmListItem({
  realm,
  index,
  maxIndex,
  asSubscription,
  onItemClick
}) {
  const {
    t
  } = useLocalization_useLocalization('ChooseRealmRoute');
  const numberOfPlayers = (0,react_facet_src.useFacetMap)(realm => t('.players', [realm.maxPlayers.toString()]), [t], [realm]);
  const gameMode = (0,react_facet_src.useFacetMap)(facet => {
    if (facet.gameMode === GameMode.CREATIVE) return t('.creative');
    if (facet.gameMode === GameMode.SURVIVAL) return t('.survival');
    return t('.adventure');
  }, [t], [realm]);
  const realmPrimaryName = (0,react_facet_src.useFacetMap)(realm => asSubscription ? t('.realmSubscription', [(index + 1).toString()]) : realm.slotName, [t, index, asSubscription], [realm]);
  const realmLinkName = (0,react_facet_src.useFacetMap)(realm => asSubscription ? t('.pairedWith', [realm.realmName]) : realm.realmName, [t, asSubscription], [realm]);
  const realmNarration = (0,react_facet_src.useFacetMap)((maxIndex, numberOfPlayers, gameMode, realmPrimaryName, realmLinkName) => {
    return [realmPrimaryName, t('.realmChoiceNumber', [(index + 1).toString(), maxIndex.toString()]), realmLinkName, asSubscription ? t('.typeOfSubscription', [numberOfPlayers]) : t('.typeOfWorld', [gameMode])].join(' . ');
  }, [t, index, asSubscription], [maxIndex, numberOfPlayers, gameMode, realmPrimaryName, realmLinkName]);
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: index,
    tall: true
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: t('.select'),
    narrationText: realmNarration,
    onClick: onItemClick
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, realmPrimaryName)), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "dimmer"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, realmLinkName)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), asSubscription && /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: 'primaryTint'
  }, numberOfPlayers)), !asSubscription && /*#__PURE__*/react.createElement(Tag_Tag_Tag, {
    role: 'neutral100'
  }, gameMode))));
}

function PreviewRealmList() {
  const {
    t
  } = useLocalization_useLocalization('ChooseRealmRoute');
  const realmList = (0,react_facet_src.useSharedFacet)(realmListFacet);
  const createNewWorldFacetLocal = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const data = (0,react_facet_src.useSharedFacet)(activeRealmsSelector);
  const realmItemClick = (0,react_facet_src.useFacetCallback)((cnw, realms) => selectedIndex => {
    if (cnw.inWorldCreation) {
      cnw.selectRealmToCreateOn(realms[selectedIndex].id);
    }
  }, [], [createNewWorldFacetLocal, data]);
  const history = RouterEngineProvider_useRouteHistory();
  const activateNewPreviewRealmClick = (0,react.useCallback)(() => {
    history.replace('/realms-choose-realm/realm-subscriptions');
  }, [history]);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const buildSettingsFacetLocal = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  return /*#__PURE__*/react.createElement(FlatList_FlatList, {
    gamepadIndex: 0,
    gamepadAlias: "wrapper",
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    data: data,
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => RealmListItem({
      realm: itemFacet,
      index: index,
      maxIndex: listLengthFacet,
      asSubscription: false,
      onItemClick: () => realmItemClick(index)
    }),
    footer: /*#__PURE__*/react.createElement(react_facet_src.Mount, {
      when: (0,react_facet_src.useFacetMap)((facet, realms) => facet.unpairedParentRealms.length > 0 && realms.length != 0, [], [realmList, data])
    }, /*#__PURE__*/react.createElement(deferred_mount_dist.DeferredMount, null, /*#__PURE__*/react.createElement("div", {
      className: classnames_default()({
        [ChooseRealmRoute.addPreviewRealmButtonTablet]: breakpoint === 'tablet'
      }, {
        [ChooseRealmRoute.addPreviewRealmButtonDesktop]: breakpoint === 'desktop'
      }, {
        [ChooseRealmRoute.addPreviewRealmButtonNarrow]: breakpoint === 'narrow'
      })
    }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }), /*#__PURE__*/react.createElement(Button_Button_Button, {
      gamepadIndex: (0,react_facet_src.useFacetMap)(facet => facet.unpairedParentRealms.length, [], [realmList]),
      inputLegend: t('.select'),
      variant: "secondary",
      onClick: activateNewPreviewRealmClick
    }, (0,react_facet_src.useFacetMap)(buildSettings => {
      return buildSettings.isBetaBuild ? t('.addNewBetaRealm') : t('.addNewPreviewRealm');
    }, [t], [buildSettingsFacetLocal])), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    }))))
  });
}

function RealmSubscriptionList({
  onItemClick
}) {
  const createPreviewRealmFacetLocal = (0,react_facet_src.useSharedFacet)(createPreviewRealmFacet);
  const data = (0,react_facet_src.useSharedFacet)(activeUnpairedParentRealmsSelector);
  const subscriptionItemClick = (0,react_facet_src.useFacetCallback)((createPreviewRealm, realms) => selectedIndex => {
    onItemClick();
    createPreviewRealm.createPreviewRealmFromSubscriptionId(realms[selectedIndex].id);
  }, [onItemClick], [createPreviewRealmFacetLocal, data]);
  return /*#__PURE__*/react.createElement(FlatList_FlatList, {
    gamepadIndex: 0,
    header: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }),
    data: data,
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => RealmListItem({
      realm: itemFacet,
      index: index,
      maxIndex: listLengthFacet,
      asSubscription: true,
      onItemClick: () => subscriptionItemClick(index)
    })
  });
}

function ChooseRealmRoute_ChooseRealmRoute() {
  const history = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('ChooseRealmRoute');
  const buildSettingsFacetLocal = (0,react_facet_src.useSharedFacet)(buildSettingsFacet);
  const realmListFacetLocal = (0,react_facet_src.useSharedFacet)(realmListFacet);
  const createPreviewRealmFacetLocal = (0,react_facet_src.useSharedFacet)(createPreviewRealmFacet);
  const createNewWorldFacetLocal = (0,react_facet_src.useSharedFacet)(createNewWorldFacet);
  const [isLoadingJoiningRealm, setIsLoadingJoiningRealm] = (0,react_facet_src.useFacetState)(false);
  const isLoading = (0,react_facet_src.useFacetMap)((facet, createPreviewRealm, joiningRealm) => facet.isLoading || createPreviewRealm.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.RUNNING || joiningRealm, [], [realmListFacetLocal, createPreviewRealmFacetLocal, isLoadingJoiningRealm]);
  const paramsFacet = hooks_useRouteParams();
  const isSubscriptionPage = (0,react_facet_src.useFacetMap)(facet => facet.tab === 'realm-subscriptions', [], [paramsFacet]);
  const header = (0,react_facet_src.useFacetMap)((isSubscription, buildSettings) => {
    if (isSubscription) {
      return t('.chooseARealmSubscription');
    } else {
      return buildSettings.isBetaBuild ? t('.chooseABetaRealm') : t('.chooseAPreviewRealm');
    }
  }, [t], [isSubscriptionPage, buildSettingsFacetLocal]);
  const activeUnpairedParentRealms = (0,react_facet_src.useSharedFacet)(activeUnpairedParentRealmsSelector);
  const backClick = (0,react_facet_src.useFacetCallback)((isSubscription, realmList, cnw) => () => {
    if (isSubscription) {
      if (realmList.length === 0 || !cnw.inWorldCreation) {
        history.goBack();
      } else {
        history.replace('/realms-choose-realm/preview-realms');
      }
    } else {
      history.goBack();
    }
  }, [history], [isSubscriptionPage, activeUnpairedParentRealms, createNewWorldFacetLocal]);
  const isRouteActive = hooks_useRouteIsActive();
  (0,react_facet_src.useFacetEffect)((createPreviewRealm, cnw, routeActive, isJoiningRealm) => {
    // make sure screen state is reset when we leave this screen
    if (!routeActive && isJoiningRealm) {
      setIsLoadingJoiningRealm(false);
    }

    if (createPreviewRealm.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.DONE) {
      console.log('Successfully created preview realm detected, continue with create new world...');
      createPreviewRealm.reset();

      if (cnw.inWorldCreation) {
        setIsLoadingJoiningRealm(true);
        cnw.createWorldOnPreviewRealm(createPreviewRealm.getCreatedPreviewRealmId());
      }
    }
  }, [history, setIsLoadingJoiningRealm], [createPreviewRealmFacetLocal, createNewWorldFacetLocal, isRouteActive, isLoadingJoiningRealm]);
  const isShowingErrorModal = (0,react_facet_src.useFacetMap)(facet => facet.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.FAILED, [], [createPreviewRealmFacetLocal]);
  const errorOkClick = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.reset();
  }, [], [createPreviewRealmFacetLocal]);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const hint = t('.backButtonHint');
  const semanticColors = hooks_useSemanticColors('inherit');
  const screenNarration = (0,react_facet_src.useFacetMap)(header => t('.screen', [header]), [t], [header]);
  const activeRealms = (0,react_facet_src.useSharedFacet)(activeRealmsSelector);
  const shouldShowPreviewRealmsEmptyState = (0,react_facet_src.useFacetMap)((isSubscriptionPage, realmList) => !isSubscriptionPage && realmList.length === 0, [], [isSubscriptionPage, activeRealms]);
  const shouldShowRealmSubscriptionsEmptyState = (0,react_facet_src.useFacetMap)((isSubscriptionPage, realmList) => isSubscriptionPage && realmList.length === 0, [], [isSubscriptionPage, activeUnpairedParentRealms]);
  const shouldShowEitherEmptyState = (0,react_facet_src.useFacetMap)((isEmptyPreviewRealms, isEmptyRealmSubscriptions) => isEmptyPreviewRealms || isEmptyRealmSubscriptions, [], [shouldShowPreviewRealmsEmptyState, shouldShowRealmSubscriptionsEmptyState]);
  const tryAgain = (0,react_facet_src.useFacetCallback)(realms => () => {
    realms.forceFetchRealmList();
  }, [], [realmListFacetLocal]);
  const emptyStateTitle = (0,react_facet_src.useFacetMap)((isRealmSubscriptionsEmpty, buildSettings) => {
    if (isRealmSubscriptionsEmpty) {
      return t('.emptyState.noSubscriptionErrorTitle');
    } else {
      return buildSettings.isBetaBuild ? t('.emptyState.noRealmsErrorTitle.beta') : t('.emptyState.noRealmsErrorTitle.preview');
    }
  }, [t], [shouldShowRealmSubscriptionsEmptyState, buildSettingsFacetLocal]);
  const [isShowingConfirmationModal, setIsShowingConfirmationModal] = (0,react_facet_src.useFacetState)(false);
  return /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(Narration, {
    text: screenNarration
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(ChooseRealmRoute.spinner, semanticColors.overlay.base)
  }, /*#__PURE__*/react.createElement(Spinner_Spinner, null))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    left: /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout.BackButton, {
      onClick: backClick,
      hint: hint
    }),
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, header),
    gamepadAlias: "choose-realm-route",
    delegateByAlias: "wrapper"
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldShowEitherEmptyState,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: breakpoint === 'tablet' ? 1 : breakpoint === 'desktop' ? 2 : 12,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: breakpoint === 'tablet' ? 10 : breakpoint === 'desktop' ? 8 : 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "realm-subscriptions",
    component: (0,react.useCallback)(() => /*#__PURE__*/react.createElement(RealmSubscriptionList, {
      onItemClick: () => setIsShowingConfirmationModal(true)
    }), [setIsShowingConfirmationModal])
  }), /*#__PURE__*/react.createElement(TabWrapper_TabWrapper, {
    tab: "preview-realms",
    component: PreviewRealmList
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldShowEitherEmptyState
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 2,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 8,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(EmptyStateMessage_EmptyStateMessage, {
    gamepadIndex: 0,
    title: emptyStateTitle,
    text: t('.emptyState.message'),
    imgSrc: RealmsGenericEmptyMessageArt_namespaceObject,
    buttons: [{
      text: t('.emptyState.tryAgain'),
      inputLegend: t('.select'),
      onClick: tryAgain
    }]
  }))))))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    })
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingConfirmationModal
  }, /*#__PURE__*/react.createElement(RealmsPreviewCreateModal.Component, {
    onConfirm: (0,react_facet_src.useFacetCallback)((createPreviewRealm, cnw) => () => {
      createPreviewRealm.activateNewPreviewRealm(cnw.inWorldCreation);
      setIsShowingConfirmationModal(false);
    }, [setIsShowingConfirmationModal], [createPreviewRealmFacetLocal, createNewWorldFacetLocal]),
    onClose: (0,react_facet_src.useFacetCallback)(createPreviewRealm => () => {
      createPreviewRealm.reset();
      setIsShowingConfirmationModal(false);
    }, [setIsShowingConfirmationModal], [createPreviewRealmFacetLocal])
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingErrorModal
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: errorOkClick
  }))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ChooseRealmRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/GuidedCreateWorldRoute/GuidedCreateWorldRoute.tsx




function GuidedCreateWorldRoute() {
  const {
    t
  } = useLocalization('GuidedCreateWorldRoute');
  const historyAPI = useRouteHistory();
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(GlassPane, null, /*#__PURE__*/React.createElement(NavigationBarLayout, {
    left: /*#__PURE__*/React.createElement(NavigationBarLayout.BackButton, {
      onClick: () => historyAPI.goBack()
    }),
    center: /*#__PURE__*/React.createElement(Typography, {
      type: "header5A"
    }, t('.title')),
    gamepadAlias: "guided-create-world-route"
  }, /*#__PURE__*/React.createElement(React.Fragment, null))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxSettingsRoute/DeleteReadMessagesModal/DeleteReadMessagesModal.tsx








const DELETE_READ_INBOX_MESSAGE_CONFIRM = 'delete-read-inbox-message-confirm';
const DeleteReadMessagesModal = registerModal(function DeleteReadMessagesModal() {
  const {
    t
  } = useLocalization_useLocalization('InboxSettingsRoute.deleteReadConfirmation');
  const hideModal = useHideModal();
  const buttonTelemetry = useButtonTelemetry();
  const deleteReadNotifications = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.deleteAllRead();
    buttonTelemetry({
      button: 'DeleteAllRead',
      screen: 'Inbox'
    });
    hideModal();
  }, [hideModal, buttonTelemetry], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet)]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal.Overlay, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DELETE_READ_INBOX_MESSAGE_CONFIRM
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: hideModal
  }, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.dialogText')
  }, t('.dialogText'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    variant: 'destructive',
    gamepadIndex: 0,
    gamepadAlias: DELETE_READ_INBOX_MESSAGE_CONFIRM,
    inputLegend: t('.deleteConfirm'),
    autofocus: true,
    onClick: deleteReadNotifications
  }, t('.deleteConfirm')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.cancel'),
    onClick: hideModal
  }, t('.cancel')))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxSettingsRoute/InboxSettingsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxSettingsRoute = ({"border":"kVqwq"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxSettingsRoute/InboxSettingsRoute.tsx













function InboxSettingsRoute_InboxSettingsRoute() {
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const inboxFacet = (0,react_facet_src.useSharedFacet)(inboxSharedFacet);
  const buttonTelemetry = useButtonTelemetry();
  const role = 'neutral80';
  const semanticColors = hooks_useSemanticColors(role);
  const showDeleteReadMessagesModal = DeleteReadMessagesModal.useShowModal();
  const showOnlyFriendInvites = (0,react_facet_src.useFacetMap)(inboxSettings => inboxSettings.settings.showOnlyFriendInvites, [], [inboxFacet]);
  const showInvitesBadges = (0,react_facet_src.useFacetMap)(inboxSettings => inboxSettings.settings.showInvitesBadges, [], [inboxFacet]);
  const showRealmsBadges = (0,react_facet_src.useFacetMap)(inboxSettings => inboxSettings.settings.showRealmsBadges, [], [inboxFacet]);
  const showNewsBadges = (0,react_facet_src.useFacetMap)(inboxSettings => inboxSettings.settings.showNewsBadges, [], [inboxFacet]);
  const updateFriendsbadges = (0,react_facet_src.useFacetCallback)(inboxSettings => newValue => {
    inboxSettings.settings.showOnlyFriendInvites = newValue;
    inboxSettings.saveSettings();
    inboxSettings.reloadInvites();
  }, [], [inboxFacet]);
  const updateNewsbadges = (0,react_facet_src.useFacetCallback)(inboxSettings => newValue => {
    inboxSettings.settings.showNewsBadges = newValue;
    inboxSettings.saveSettings();
  }, [], [inboxFacet]);
  const updateInvitesbadges = (0,react_facet_src.useFacetCallback)(inboxSettings => newValue => {
    inboxSettings.settings.showInvitesBadges = newValue;
    inboxSettings.saveSettings();
  }, [], [inboxFacet]);
  const updateRealmsbadges = (0,react_facet_src.useFacetCallback)(inboxSettings => newValue => {
    inboxSettings.settings.showRealmsBadges = newValue;
    inboxSettings.saveSettings();
  }, [], [inboxFacet]);
  const {
    t
  } = useLocalization_useLocalization('InboxSettingsRoute');
  const onExit = (0,react_facet_src.useFacetCallback)(inboxSettings => () => {
    inboxSettings.saveSettings();
    historyAPI.goBack();
  }, [historyAPI], [inboxFacet]);
  return /*#__PURE__*/react.createElement(SemanticRole_SemanticRoleProvider, {
    role: role
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: onExit,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.title')),
    gamepadAlias: "inbox-settings-route",
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    })
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, breakpoint === 'desktop' && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 10,
    narrowSize: 6
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement("fast-div", {
    className: classnames_default()(semanticColors.border.base, semanticColors.background.base, InboxSettingsRoute.border)
  }, /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    gamepad: {
      index: 2
    },
    title: t('.onlyShowFriends'),
    value: showOnlyFriendInvites,
    onChange: updateFriendsbadges
  }), /*#__PURE__*/react.createElement(SectionHeader_SectionHeader, {
    title: t('.categories'),
    description: t('.categoriesDescription')
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    gamepad: {
      index: 4
    },
    title: t('.showNews'),
    value: showNewsBadges,
    onChange: updateNewsbadges
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    gamepad: {
      index: 5
    },
    title: t('.showInvites'),
    value: showInvitesBadges,
    onChange: updateInvitesbadges
  }), /*#__PURE__*/react.createElement(Switch_Switch_Switch, {
    gamepad: {
      index: 6
    },
    title: t('.showRealms'),
    value: showRealmsBadges,
    onChange: updateRealmsbadges
  }), /*#__PURE__*/react.createElement(Panel_Panel_Panel, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 7,
    onClick: (0,react_facet_src.useFacetCallback)(facet => () => {
      facet.markAllRead();
      buttonTelemetry({
        button: 'MarkAllRead',
        screen: 'Inbox'
      });
    }, [buttonTelemetry], [inboxFacet]),
    inputLegend: t('.markAllRead'),
    variant: "secondary"
  }, t('.markAllRead')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 8,
    onClick: showDeleteReadMessagesModal,
    inputLegend: t('.deleteAllRead'),
    variant: "destructive"
  }, t('.deleteAllRead')))))))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxSettingsRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxMessageImageText/images/image.png
const image_namespaceObject = __webpack_require__.p + "assets/image-f8369.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxMessageImageText/InboxMessageImageText.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxMessageImageText = ({"textContent":"G5UDG","textContentDesktop":"XAK_R"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxMessageImageText/InboxMessageImageText.tsx












function InboxMessageImageText_InboxMessageImageText({
  message
}) {
  const [below102, above102] = useCustomBreakpoint([102]);
  const color = hooks_useSemanticColors();
  const role = 'neutral';
  const textContentClasses = classnames_default()(InboxMessageImageText.textContent, color[role].background.base, {
    [`${color[role].border.base}`]: color[role].border.base != null && above102,
    [InboxMessageImageText.textContentDesktop]: above102
  });
  return /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: below102,
    narrowBreakpointWidth: 102
  }, above102 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(ImageTextSideMenu, {
    message: message,
    below102: below102
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 7,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(ImageTextContent, {
    contentClasses: textContentClasses,
    message: message
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  })));
}

function ImageTextSideMenu({
  message,
  below102
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const title = (0,react_facet_src.useFacetMap)(message => message.title, [], [message]);
  const sender = (0,react_facet_src.useFacetMap)(message => t('.from', [message.sender]), [t], [message]);
  const date = (0,react_facet_src.useFacetMap)(message => message.dateString, [], [message]);
  const isLoaded = (0,react_facet_src.useFacetMap)(message => message.images[0].isLoaded, [], [message]);
  const narration = (0,react_facet_src.useFacetMap)((message, sender) => [message.title, sender, message.dateString].join(' . '), [], [message, sender]);
  const image = (0,react_facet_src.useFacetMap)(message => {
    if (message.images[0].url != '') {
      return message.images[0].url;
    }

    return image_namespaceObject;
  }, [], [message]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    autofocus: true,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoaded
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "stronger"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, sender), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, date))));
}

function ImageTextContent({
  contentClasses,
  message
}) {
  const content = (0,react_facet_src.useFacetMap)(message => message.content, [], [message]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: content
  }, /*#__PURE__*/react.createElement("div", {
    className: contentClasses
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    whiteSpace: "preWrap",
    children: content
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxInviteDetails/images/realms.png
const realms_namespaceObject = __webpack_require__.p + "assets/realms-94faf.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxInviteDetails/InboxInviteDetails.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxInviteDetails = ({"textContent":"eaMoq","textContentDesktop":"x0pQt"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxInviteDetails/InboxInviteDetails.tsx
















var ButtonClicked;

(function (ButtonClicked) {
  ButtonClicked[ButtonClicked["Accept"] = 0] = "Accept";
  ButtonClicked[ButtonClicked["Reject"] = 1] = "Reject";
  ButtonClicked[ButtonClicked["Realms"] = 2] = "Realms";
  ButtonClicked[ButtonClicked["Back"] = 3] = "Back";
})(ButtonClicked || (ButtonClicked = {}));

function InboxInviteDetails_InboxInviteDetails({
  message
}) {
  const [below102, above102] = useCustomBreakpoint([102]);
  const color = hooks_useSemanticColors();
  const role = 'neutral';
  const textContentClasses = classnames_default()(InboxInviteDetails.textContent, color[role].background.base, {
    [`${color[role].border.base}`]: color[role].border.base != null && above102,
    [InboxInviteDetails.textContentDesktop]: above102
  });
  const routerAPI = hooks_useRouterAPI(); // the following is a workaround for a known issue AB#1090204 and should be removed

  const loadedRef = (0,react.useRef)(false);
  (0,react_facet_src.useFacetEffect)(message => {
    if (loadedRef.current && message.invStatus == InvitationStatus.REJECTED) {
      loadedRef.current = false;
      routerAPI.goBack();
    }
  }, [routerAPI, loadedRef], [message]); // also see below

  const friendsTab = '/play/friends';
  const [isAcceptButtonClicked, setIsAcceptButtonClicked] = (0,react_facet_src.useFacetState)(false);
  const handleButtonClick = (0,react_facet_src.useFacetCallback)((message, inboxFacet, isAcceptButtonClicked) => button => {
    switch (button) {
      case ButtonClicked.Accept:
        if (!isAcceptButtonClicked) {
          inboxFacet.setInvitationStatus(message.instanceId, InvitationStatus.ACCEPTED);
          setIsAcceptButtonClicked(true);

          if (!message.read) {
            inboxFacet.setNotificationRead(message.instanceId);
          }
        }

        break;

      case ButtonClicked.Reject:
        inboxFacet.setInvitationStatus(message.instanceId, InvitationStatus.REJECTED);

        if (!message.read) {
          inboxFacet.setNotificationRead(message.instanceId);
        }

        loadedRef.current = true;
        break;

      case ButtonClicked.Realms:
        routerAPI.push(friendsTab);
        break;

      case ButtonClicked.Back:
        routerAPI.goBack();
        break;
    }
  }, [routerAPI, setIsAcceptButtonClicked], [message, (0,react_facet_src.useSharedFacet)(inboxSharedFacet), isAcceptButtonClicked]);
  return /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: below102,
    narrowBreakpointWidth: 102
  }, above102 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(InviteSideMenu, {
    message: message,
    handleButtonClick: handleButtonClick,
    below102: below102
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 7,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(InviteContent, {
    contentClasses: textContentClasses,
    message: message
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((message, isAcceptButtonClicked) => isAcceptButtonClicked && message.invStatus === InvitationStatus.EXPIRED, [], [message, isAcceptButtonClicked])
  }, /*#__PURE__*/react.createElement(InviteExpiredModal.Component, {
    item: message,
    onClose: () => setIsAcceptButtonClicked(false)
  })));
}

function InviteSideMenu({
  message,
  handleButtonClick,
  below102
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const sender = (0,react_facet_src.useFacetMap)(message => t('.from', [message.sender]), [t], [message]);
  const date = (0,react_facet_src.useFacetMap)(message => message.dateString, [], [message]);
  const notAccepted = (0,react_facet_src.useFacetMap)(message => message.invStatus === InvitationStatus.NONE, [], [message]);
  const accepted = (0,react_facet_src.useFacetMap)(message => message.invStatus === InvitationStatus.ACCEPTED, [], [message]);
  const joined = (0,react_facet_src.useFacetMap)(message => message.invStatus === InvitationStatus.JOIN, [], [message]);
  const narration = (0,react_facet_src.useFacetMap)((sender, date) => [t('.realmInvite'), sender, date].join(' . '), [t], [sender, date]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: narration
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    autofocus: true,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: (0,react_facet_src.useFacetWrap)(realms_namespaceObject),
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "stronger"
  }, t('.realmInvite')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, sender), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, date)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: notAccepted
  }, /*#__PURE__*/react.createElement(NotAcceptedSideItems, {
    handleButtonClick: handleButtonClick
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: accepted
  }, /*#__PURE__*/react.createElement(AcceptedSideItems, {
    handleButtonClick: handleButtonClick
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: joined
  }, /*#__PURE__*/react.createElement(AcceptedSideItems, {
    handleButtonClick: handleButtonClick
  }))));
}

function InviteContent({
  contentClasses,
  message
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const inviteMessage = (0,react_facet_src.useFacetMap)(message => t('.invitationNote0', [message.sender]), [t], [message]);
  const rejectedMessage = (0,react_facet_src.useFacetMap)(message => t('.invitationRejectedMessage', [message.sender]), [t], [message]);
  const showRejectedText = (0,react_facet_src.useFacetMap)(message => message.invStatus == InvitationStatus.REJECTED, [], [message]);
  const rejectedMessageDetails = t('.invitationRejectedMessageDetails');
  const messageList = (0,react.useMemo)(() => [t('.invitationNote1'), t('.invitationNote2'), t('.invitationNote3'), t('.invitationNote4')], [t]);
  const notRejectedNarration = (0,react_facet_src.useFacetMap)(inviteMessage => [inviteMessage, messageList.join(' . ')].join(' . '), [messageList], [inviteMessage]);
  const rejectedNarration = (0,react_facet_src.useFacetMap)(rejectedMessage => [rejectedMessage, rejectedMessageDetails].join(' '), [rejectedMessageDetails], [rejectedMessage]);
  return /*#__PURE__*/react.createElement(NarrationContext_NarrationContext, {
    text: (0,react_facet_src.useFacetMap)((reject, rNarration, nrNarration) => reject ? rNarration : nrNarration, [], [showRejectedText, rejectedNarration, notRejectedNarration])
  }, /*#__PURE__*/react.createElement("div", {
    className: contentClasses
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRejectedText,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    children: inviteMessage,
    type: 'paragraphs'
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography.List, {
    items: messageList
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRejectedText
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    children: rejectedMessage,
    type: 'paragraphs'
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    children: rejectedMessageDetails,
    type: 'paragraphs'
  }))))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  })));
}

function NotAcceptedSideItems({
  handleButtonClick
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const {
    t: narration
  } = useLocalization_useLocalization('InboxMessageDetailsRoute.narration');
  const acceptButtonText = t('.accept');
  const rejectButtonText = t('.reject');
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    narrationSuffix: narration('.buttonSiblings', ['1', '2']),
    gamepadIndex: 1,
    inputLegend: acceptButtonText,
    isElevated: true,
    variant: "primary",
    onClick: () => handleButtonClick(ButtonClicked.Accept)
  }, acceptButtonText)), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    narrationSuffix: narration('.buttonSiblings', ['2', '2']),
    gamepadIndex: 1,
    inputLegend: rejectButtonText,
    onClick: () => handleButtonClick(ButtonClicked.Reject),
    isElevated: true,
    variant: "secondary"
  }, rejectButtonText)));
}

function AcceptedSideItems({
  handleButtonClick
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const {
    t: narration
  } = useLocalization_useLocalization('InboxMessageDetailsRoute.narration');
  const goButtonText = t('.realms');
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    narrationSuffix: narration('.buttonSiblings', ['1', '1']),
    gamepadIndex: 2,
    inputLegend: goButtonText,
    onClick: () => handleButtonClick(ButtonClicked.Realms),
    isElevated: true,
    variant: "primary"
  }, goButtonText)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxImageThumbnailCTA/InboxImageThumbnailCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxImageThumbnailCTA = ({"textContent":"vnzf4","textContentDesktop":"ZLVHh","scrollBox":"yxgnA","image1Div":"r1xtb"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxImageThumbnailCTA/images/image.png
const InboxImageThumbnailCTA_images_image_namespaceObject = __webpack_require__.p + "assets/image-f8369.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxImageThumbnailCTA/InboxImageThumbnailCTA.tsx













const InboxImageThumbnailCTA_LARGE_IMAGE_ID = 'Primary';
const InboxImageThumbnailCTA_SMALL_IMAGE_ID = 'Secondary';
function InboxImageThumbnailCTA_InboxImageThumbnailCTA({
  message
}) {
  const [below102, above102] = useCustomBreakpoint([102]);
  const color = hooks_useSemanticColors();
  const role = 'neutral';
  const textContentClasses = classnames_default()(InboxImageThumbnailCTA.textContent, color[role].background.base, {
    [`${color[role].border.base}`]: color[role].border.base != null && above102,
    [InboxImageThumbnailCTA.textContentDesktop]: above102
  });
  return /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: below102,
    narrowBreakpointWidth: 102
  }, above102 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(ImageThumbnailSideMenu, {
    message: message,
    below102: below102
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 7,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(ImageThumbnailContent, {
    contentClasses: textContentClasses,
    message: message
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  })));
}

function ImageThumbnailSideMenu({
  message,
  below102
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const title = (0,react_facet_src.useFacetMap)(message => message.title, [], [message]);
  const sender = (0,react_facet_src.useFacetMap)(message => t('.from', [message.sender]), [t], [message]);
  const date = (0,react_facet_src.useFacetMap)(message => message.dateString, [], [message]);
  const isImgLoaded = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$1$isL, _message$images$;

    return (_message$images$1$isL = (_message$images$ = message.images[1]) === null || _message$images$ === void 0 ? void 0 : _message$images$.isLoaded) !== null && _message$images$1$isL !== void 0 ? _message$images$1$isL : false;
  }, [], [message]);
  const button = (0,react_facet_src.useFacetMap)(message => message.buttons[0], [], [message]);
  const buttonText = (0,react_facet_src.useFacetMap)(button => {
    var _button$text;

    return (_button$text = button === null || button === void 0 ? void 0 : button.text) !== null && _button$text !== void 0 ? _button$text : '';
  }, [], [button]);
  const image = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$2, _message$images$1$url, _message$images$4;

    const id = (_message$images$2 = message.images[1]) === null || _message$images$2 === void 0 ? void 0 : _message$images$2.id;

    if (id && id != InboxImageThumbnailCTA_SMALL_IMAGE_ID) {
      var _message$images$3;

      console.error('Expected ', InboxImageThumbnailCTA_SMALL_IMAGE_ID, ' for message.images[1].id, got: ', (_message$images$3 = message.images[1]) === null || _message$images$3 === void 0 ? void 0 : _message$images$3.id);
    }

    return (_message$images$1$url = (_message$images$4 = message.images[1]) === null || _message$images$4 === void 0 ? void 0 : _message$images$4.url) !== null && _message$images$1$url !== void 0 ? _message$images$1$url : InboxImageThumbnailCTA_images_image_namespaceObject;
  }, [], [message]);
  const handleButtonClick = (0,react_facet_src.useFacetCallback)(button => () => button.reportClick(), [], [button]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    autofocus: true,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isImgLoaded
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "stronger"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, sender), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, date)), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: buttonText,
    gamepadIndex: 1,
    variant: "primary",
    onClick: handleButtonClick
  }, buttonText)));
}

function ImageThumbnailContent({
  contentClasses,
  message
}) {
  const content = (0,react_facet_src.useFacetMap)(message => message.content, [], [message]);
  const isLoaded = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$0$isL, _message$images$5;

    return (_message$images$0$isL = (_message$images$5 = message.images[0]) === null || _message$images$5 === void 0 ? void 0 : _message$images$5.isLoaded) !== null && _message$images$0$isL !== void 0 ? _message$images$0$isL : false;
  }, [], [message]);
  const image = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$6, _message$images$0$url, _message$images$7;

    const id = (_message$images$6 = message.images[0]) === null || _message$images$6 === void 0 ? void 0 : _message$images$6.id;

    if (id && id != InboxImageThumbnailCTA_LARGE_IMAGE_ID) {
      console.error('Expected ', InboxImageThumbnailCTA_LARGE_IMAGE_ID, ' for message.images[0].id, got: ', id);
    }

    return (_message$images$0$url = (_message$images$7 = message.images[0]) === null || _message$images$7 === void 0 ? void 0 : _message$images$7.url) !== null && _message$images$0$url !== void 0 ? _message$images$0$url : InboxImageThumbnailCTA_images_image_namespaceObject;
  }, [], [message]);
  return /*#__PURE__*/react.createElement("div", {
    className: contentClasses
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", {
    className: InboxImageThumbnailCTA.scrollBox
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoaded
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: InboxImageThumbnailCTA.image1Div
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 5
  }))), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    whiteSpace: "preWrap",
    children: content
  }), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 5
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxHeroImageCTA/images/image.png
const InboxHeroImageCTA_images_image_namespaceObject = __webpack_require__.p + "assets/image-f8369.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxHeroImageCTA/InboxHeroImageCTA.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const InboxHeroImageCTA = ({"textContent":"e33ud","textContentDesktop":"Din57"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/InboxHeroImageCTA/InboxHeroImageCTA.tsx











function InboxHeroImageCTA_InboxHeroImageCTA({
  message
}) {
  const [below102, above102] = useCustomBreakpoint([102]);
  const color = hooks_useSemanticColors();
  const role = 'neutral';
  const textContentClasses = classnames_default()(InboxHeroImageCTA.textContent, color[role].background.base, {
    [`${color[role].border.base}`]: color[role].border.base != null && above102,
    [InboxHeroImageCTA.textContentDesktop]: above102
  });
  const messageButton = (0,react_facet_src.useFacetMap)(message => {
    if (message.buttons.length != 0) {
      return message.buttons[0];
    } else {
      return null;
    }
  }, [], [message]);
  const handleButtonClick = (0,react_facet_src.useFacetCallback)(messageButton => () => {
    if (messageButton != null) {
      messageButton.reportClick();
    }
  }, [], [messageButton]);
  return /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    noGutters: below102,
    narrowBreakpointWidth: 102
  }, above102 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement(HeroImageCTASideMenu, {
    message: message,
    below102: below102,
    onClick: handleButtonClick
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: 7,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement(HeroImageCTAContent, {
    contentClasses: textContentClasses,
    message: message
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 1,
    narrowSize: 0
  })));
}

function HeroImageCTASideMenu({
  message,
  below102,
  onClick
}) {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const title = (0,react_facet_src.useFacetMap)(message => message.title, [], [message]);
  const sender = (0,react_facet_src.useFacetMap)(message => t('.from', [message.sender]), [t], [message]);
  const date = (0,react_facet_src.useFacetMap)(message => message.dateString, [], [message]);
  const isLoaded = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$0$isL, _message$images$;

    return (_message$images$0$isL = (_message$images$ = message.images[0]) === null || _message$images$ === void 0 ? void 0 : _message$images$.isLoaded) !== null && _message$images$0$isL !== void 0 ? _message$images$0$isL : false;
  }, [], [message]);
  const image = (0,react_facet_src.useFacetMap)(message => {
    var _message$images$0$url, _message$images$2;

    return (_message$images$0$url = (_message$images$2 = message.images[0]) === null || _message$images$2 === void 0 ? void 0 : _message$images$2.url) !== null && _message$images$0$url !== void 0 ? _message$images$0$url : InboxHeroImageCTA_images_image_namespaceObject;
  }, [], [message]);
  const button = (0,react_facet_src.useFacetMap)(message => message.buttons[0], [], [message]);
  const buttonText = (0,react_facet_src.useFacetMap)(button => {
    var _button$text;

    return (_button$text = button === null || button === void 0 ? void 0 : button.text) !== null && _button$text !== void 0 ? _button$text : '';
  }, [], [button]);
  const hasButton = (0,react_facet_src.useFacetMap)(message => {
    return message.buttons.length != 0;
  }, [], [message]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 1,
    autofocus: true,
    fullHeight: below102
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoaded
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"]
  }))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    variant: "stronger"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, sender), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, date)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasButton
  }, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    inputLegend: buttonText,
    gamepadIndex: 1,
    onClick: onClick,
    variant: "primary"
  }, buttonText))));
}

function HeroImageCTAContent({
  contentClasses,
  message
}) {
  const content = (0,react_facet_src.useFacetMap)(message => message.content, [], [message]);
  return /*#__PURE__*/react.createElement("div", {
    className: contentClasses
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "paragraphs",
    whiteSpace: "preWrap",
    children: content
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/InboxMessageDetailsRoute/InboxMessageDetailsRoute.tsx













function InboxMessageDetailsRoute() {
  const {
    t
  } = useLocalization_useLocalization('InboxMessageDetailsRoute');
  const routeHistory = RouterEngineProvider_useRouteHistory();
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const messageId = params.messageId;
  const visible = hooks_useRouteIsActive();
  const message = (0,react_facet_src.useFacetMap)((inboxFacet, visible) => {
    if (visible) {
      for (let i = 0; i < inboxFacet.inboxMessages.length; i++) {
        if (inboxFacet.inboxMessages[i].instanceId == messageId) {
          return inboxFacet.inboxMessages[i];
        }
      } // If we can't find the message, go back to the previous page


      console.error('Failed to locate message with id: ', messageId);
    }

    return defaultMessage;
  }, [messageId], [(0,react_facet_src.useSharedFacet)(inboxSharedFacet), visible]);
  const isImageText = (0,react_facet_src.useFacetMap)(message => message.template == InboxTemplate.IMAGETEXT, [], [message]);
  const isHeroImageCTA = (0,react_facet_src.useFacetMap)(message => message.template == InboxTemplate.HEROIMAGECTA, [], [message]);
  const isInvite = (0,react_facet_src.useFacetMap)(message => message.announcementType == InboxMessageType.INVITES, [], [message]);
  const isImgThumbnailCTA = (0,react_facet_src.useFacetMap)(message => message.template == InboxTemplate.IMAGETNAILCTA, [], [message]);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: visible
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(NavigationBarLayout_NavigationBarLayout_NavigationBarLayout, {
    onBackButton: routeHistory.goBack,
    center: /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "header5A"
    }, t('.details')),
    gamepadAlias: "inbox-message-details-route",
    footer: /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
      extraSpace: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
        size: 1
      })
    })
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isImageText
  }, /*#__PURE__*/react.createElement(InboxMessageImageText_InboxMessageImageText, {
    message: message
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isImgThumbnailCTA
  }, /*#__PURE__*/react.createElement(InboxImageThumbnailCTA_InboxImageThumbnailCTA, {
    message: message
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isInvite
  }, /*#__PURE__*/react.createElement(InboxInviteDetails_InboxInviteDetails, {
    message: message
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isHeroImageCTA
  }, /*#__PURE__*/react.createElement(InboxHeroImageCTA_InboxHeroImageCTA, {
    message: message
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreatePreviewRealmWithOnlyOneSubscriptionRoute/CreatePreviewRealmWithOnlyOneSubscriptionRoute.tsx









function CreatePreviewRealmWithOnlyOneSubscriptionRoute() {
  const history = RouterEngineProvider_useRouteHistory();
  const createPreviewRealmFacetLocal = (0,react_facet_src.useSharedFacet)(createPreviewRealmFacet);
  const realmListFacetLocal = (0,react_facet_src.useSharedFacet)(realmListFacet);
  const hasAutoProgressedCreatePreviewRealm = (0,react.useRef)(false);
  const [isShowingConfirmationModal, setIsShowingConfirmationModal] = (0,react_facet_src.useFacetState)(false);
  const activeUnpairedParentRealms = (0,react_facet_src.useSharedFacet)(activeUnpairedParentRealmsSelector);
  (0,react_facet_src.useFacetEffect)((createPreviewRealm, realmList, activeUnpairedParentRealmList) => {
    if (realmList.isLoading) {
      return;
    }

    if (!hasAutoProgressedCreatePreviewRealm.current && activeUnpairedParentRealmList.length > 0) {
      setIsShowingConfirmationModal(true);
      createPreviewRealm.createPreviewRealmFromSubscriptionId(activeUnpairedParentRealmList[0].id);
      hasAutoProgressedCreatePreviewRealm.current = true;
    }
  }, [hasAutoProgressedCreatePreviewRealm, setIsShowingConfirmationModal], [createPreviewRealmFacetLocal, realmListFacetLocal, activeUnpairedParentRealms]);
  const isLoading = (0,react_facet_src.useFacetMap)((realmList, cpr) => cpr.createPreviewRealmFromSubscriptionProgress !== FacetTaskProgress.RUNNING && realmList.isLoading, [], [realmListFacetLocal, createPreviewRealmFacetLocal]);
  const isCreatePreviewRealmBusy = (0,react_facet_src.useFacetMap)(facet => facet.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.RUNNING && facet.createPreviewRealmFromSubscriptionResult === CreatePreviewRealmFromSubscriptionResult.CreatingPreviewRealm, [], [createPreviewRealmFacetLocal]);
  const isRetrievingCreatedPreviewRealm = (0,react_facet_src.useFacetMap)(facet => facet.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.RUNNING && facet.createPreviewRealmFromSubscriptionResult === CreatePreviewRealmFromSubscriptionResult.RetrievingCreatedPreviewRealm, [], [createPreviewRealmFacetLocal]);
  const isShowingErrorModal = (0,react_facet_src.useFacetMap)(facet => facet.createPreviewRealmFromSubscriptionProgress === FacetTaskProgress.FAILED, [], [createPreviewRealmFacetLocal]);
  const resetCreatePreviewRealmFacetOnClose = (0,react_facet_src.useFacetCallback)(facet => () => {
    setIsShowingConfirmationModal(false);
    facet.reset();
    history.goBack();
  }, [history, setIsShowingConfirmationModal], [createPreviewRealmFacetLocal]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading
  }, /*#__PURE__*/react.createElement(RealmsFetchingSubscriptionInformationModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isLoading,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingConfirmationModal
  }, /*#__PURE__*/react.createElement(RealmsPreviewCreateModal.Component, {
    onConfirm: (0,react_facet_src.useFacetCallback)(createPreviewRealm => () => {
      setIsShowingConfirmationModal(false);
      createPreviewRealm.activateNewPreviewRealm(false);
    }, [setIsShowingConfirmationModal], [createPreviewRealmFacetLocal]),
    onClose: resetCreatePreviewRealmFacetOnClose
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isCreatePreviewRealmBusy
  }, /*#__PURE__*/react.createElement(RealmsCreatingRealmModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isRetrievingCreatedPreviewRealm
  }, /*#__PURE__*/react.createElement(RealmsFetchingRealmInformationModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: isShowingErrorModal
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: resetCreatePreviewRealmFacetOnClose
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CreatePreviewRealmWithOnlyOneSubscriptionRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/ExternalServerForm.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ExternalServerForm = ({"externalServerButtons":"b_Dcf"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/hooks/useServerId.ts


function useServerId_useServerId() {
  const paramsFacet = useRouteParams();
  return useFacetMap(paramsFacet => paramsFacet.id, [], [paramsFacet]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/modals/ExternalServerErrorModal/ExternalServerErrorModal.tsx





const ExternalServerErrorModal_ExternalServerErrorModal = registerModal(({
  externalServerWorldError,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.addServerError');
  const DEFAULT_FOCUS_ALIAS = 'pop-up-modal-AddServerErrorModal';
  const closeModal = useHideModal();
  const modalText = getModalText(externalServerWorldError);

  const handleOnClose = () => {
    closeModal();
    onClose();
  };

  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: DEFAULT_FOCUS_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: handleOnClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t(modalText),
    gamepadIndex: 0,
    center: true
  }, t(modalText))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: DEFAULT_FOCUS_ALIAS,
    inputLegend: t('.closeButton'),
    onClick: handleOnClose
  }, t('.closeButton'))));
});

function getModalText(externalServerWorldError) {
  switch (externalServerWorldError) {
    case ExternalServerWorldOperationError.NameIsEmpty:
      return '.nameError';

    case ExternalServerWorldOperationError.AddressIsEmpty:
      return '.addressError';

    case ExternalServerWorldOperationError.InvalidPortNumber:
      return '.portError';

    case ExternalServerWorldOperationError.IdNotFound:
    case ExternalServerWorldOperationError.UnknownError:
    default:
      return '.genericError';
  }
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/modals/ConfirmDeletionModal/ConfirmDeletionModal.tsx





const ConfirmDeletionModal_GO_BACK_BUTTON_GAMEPAD_ALIAS = 'go-back-server-modal';
const ConfirmDeletionModal_ConfirmDeletionModal = registerModal(({
  onDeleteServer,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.confirmDeletion');
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: ConfirmDeletionModal_GO_BACK_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: ConfirmDeletionModal_GO_BACK_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.goBackButton'),
    variant: "secondary",
    onClick: onClose
  }, t('.goBackButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.deleteButtonInputLegend'),
    variant: "destructive",
    onClick: () => {
      onDeleteServer();
      onClose();
    }
  }, t('.deleteButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/modals/UnsavedChangesModal/UnsavedChangesModal.tsx






const SAVE_BUTTON_GAMEPAD_ALIAS = 'save-button-unsaved-changes-server-modal';
const UnsavedChangesModal_UnsavedChangesModal = registerModal(({
  onSaveChanges,
  onDiscardChanges,
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('PlayScreen.serverTab.unsavedChanges');
  const onDiscardChangesClick = (0,react_facet_src.useFacetCallback)(() => () => {
    onClose();
    onDiscardChanges();
  }, [onDiscardChanges, onClose], []);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: SAVE_BUTTON_GAMEPAD_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    narrationText: t('.message'),
    gamepadIndex: 0,
    center: true
  }, t('.message'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, null, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    gamepadAlias: SAVE_BUTTON_GAMEPAD_ALIAS,
    inputLegend: t('.discardChangesButtonInputLegend'),
    variant: "secondary",
    onClick: onDiscardChangesClick
  }, t('.discardChangesButton')), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 1
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 1,
    inputLegend: t('.saveChangesButtonInputLegend'),
    variant: "primary",
    onClick: () => {
      onSaveChanges();
      onClose();
    }
  }, t('.saveChangesButton'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/modals/index.ts



;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/ExternalServerForm.tsx
















const DEFAULT_PORT = 19132;
const MAX_PORT = 65535;
/**
 * This component is used in both add a new server
 * and editing an existing server. This is determined if
 * we receive an ID in the route params
 */

const ExternalServerForm_ExternalServerForm = () => {
  const thirdPartyWorldListSharedFacet = useSharedFacet(thirdPartyWorldListFacet);
  const networkWorldDetailsFacet = useSharedFacet(networkWorldDetailsSharedFacet);
  const externalServerWorldListSharedFacet = useSharedFacet(externalServerWorldListFacet);
  const notificationsSharedFacet = useSharedFacet(notificationsFacet);
  const [isErrorModalOpen, setIsErrorModalOpen] = useFacetState(false);
  const [isConfirmationModalOpen, setIsConfirmationModalOpen] = useFacetState(false);
  const [isUnsavedChangesModalOpen, setIsUnsavedChangesModalOpen] = useFacetState(false);
  const [operationError, setOperationError] = useState(undefined);
  const [formHasChanges, setFormHasChanges] = useFacetState(false);
  const historyAPI = useRouterAPI();
  const serverId = useServerId();
  const isEditing = useFacetMap(serverID => serverID != null, [], [serverId]);
  const defaultServerId = useFacetMap(thirdPartyWorldListSharedFacet => thirdPartyWorldListSharedFacet.thirdPartyWorlds[0].id, [], [thirdPartyWorldListSharedFacet]);
  const isNarrow = useWindowBreakpoint() === 'narrow';
  const {
    t
  } = useLocalization('PlayScreen.serverTab.serverForm');
  const [isServerDeleted, setIsServerDeleted] = useFacetState(false);
  const [nameField, setNameField] = useFacetState('');
  const editServerName = useFacetMap(facet => facet.networkDetails.name, [], [networkWorldDetailsFacet]);
  const editServerPort = useFacetMap(value => value.networkDetails.port.toString(), [], [networkWorldDetailsFacet]);
  const [portField, setPortField] = useFacetState(DEFAULT_PORT.toString());
  const editServerAddress = useFacetMap(value => value.networkDetails.address, [], [networkWorldDetailsFacet]);
  const [addressField, setAddressField] = useFacetState('');
  const onNameChange = useFacetCallback(() => newValue => {
    setNameField(newValue);
    setFormHasChanges(true);
  }, [setNameField, setFormHasChanges], []);
  const onAddressChange = useFacetCallback(() => newValue => {
    setAddressField(newValue);
    setFormHasChanges(true);
  }, [setAddressField, setFormHasChanges], []);
  const onPortChange = useFacetCallback(() => newValue => {
    setPortField(newValue);
    setFormHasChanges(true);
  }, [setPortField, setFormHasChanges], []);
  const handleOperationError = useFacetCallback(isModalOpen => operationError => {
    if (isModalOpen) {
      return;
    }

    setIsErrorModalOpen(true);
    setOperationError(operationError);
  }, [setIsErrorModalOpen], [isErrorModalOpen]);
  const queueSnackbar = useFacetCallback(notificationSharedFacet => message => {
    notificationSharedFacet.queueSnackbar(message);
  }, [], [notificationsSharedFacet]);
  const addServerCallback = useFacetCallback((externalServerFacet, name, address, port) => () => {
    const addResult = externalServerFacet.addExternalServerWorld(name, address, parseInt(port));
    setFormHasChanges(true);

    if (addResult != null) {
      handleOperationError(addResult);
    } else {
      queueSnackbar(t('.serverAddedNotification'));
      historyAPI.goBack();
    }
  }, [setFormHasChanges, queueSnackbar, t, handleOperationError, historyAPI], [externalServerWorldListSharedFacet, nameField, addressField, portField]);
  const addAndPlayCallback = useCallback(() => {
    addServerCallback();
  }, [addServerCallback]);
  const selectDefaultServer = useFacetCallback((networkWorldDetailsFacet, defaultServerId) => () => {
    networkWorldDetailsFacet.loadNetworkWorldDetails(defaultServerId, NetworkWorldType.thirdParty);
  }, [], [networkWorldDetailsFacet, defaultServerId]);
  const deleteServerCallback = useFacetCallback((externalServerWorldListSharedFacet, serverId) => () => {
    if (serverId != null) {
      const deleteResult = externalServerWorldListSharedFacet.removeExternalServerWorld(parseInt(serverId));

      if (deleteResult) {
        handleOperationError(deleteResult);
      } else {
        selectDefaultServer();
        setIsServerDeleted(true);
        queueSnackbar(t('.serverDeletedNotification'));
        historyAPI.goBack();
      }
    }
  }, [handleOperationError, queueSnackbar, t, selectDefaultServer, setIsServerDeleted, historyAPI], [externalServerWorldListSharedFacet, serverId]);
  const OnDelete = useCallback(() => {
    setIsConfirmationModalOpen(true);
  }, [setIsConfirmationModalOpen]);
  const editServerCallback = useFacetCallback((externalServerFacet, id, name, address, port) => () => {
    if (id != null) {
      const editResult = externalServerFacet.editExternalServerWorld(parseInt(id), name, address, parseInt(port));

      if (editResult) {
        handleOperationError(editResult);
      } else {
        queueSnackbar(t('.serverEditedNotification'));
        historyAPI.goBack();
      }
    }
  }, [handleOperationError, queueSnackbar, t, historyAPI], [externalServerWorldListSharedFacet, serverId, nameField, addressField, portField]);
  const onGoBack = useFacetCallback(formHasChanges => () => {
    if (formHasChanges) {
      setIsUnsavedChangesModalOpen(true);
    } else {
      historyAPI.goBack();
    }
  }, [historyAPI, setIsUnsavedChangesModalOpen], [formHasChanges]);
  /**
   * This gets the first time the values in the facet and assign it to local values
   */

  useFacetEffect((name, address, port, isEditing) => {
    if (isEditing) {
      setNameField(name);
      setAddressField(address);
      setPortField(port);
    }
  }, [setNameField, setAddressField, setPortField], [editServerName, editServerAddress, editServerPort, isEditing]);
  return /*#__PURE__*/React.createElement(Mount, {
    when: isServerDeleted,
    condition: false
  }, /*#__PURE__*/React.createElement(GlassPane, null, /*#__PURE__*/React.createElement(Mount, {
    when: isEditing,
    condition: true
  }, /*#__PURE__*/React.createElement(NarrationContext, {
    text: t('.editServerNarration')
  }, /*#__PURE__*/React.createElement(NavigationBarLayout, {
    onBackButton: onGoBack,
    center: /*#__PURE__*/React.createElement(Typography, {
      type: "header5A"
    }, t('.editServerTitle')),
    footer: isNarrow ? /*#__PURE__*/React.createElement(ExternalServerForm_Buttons, {
      gamepadIndex: 0,
      isEditing: true,
      primaryCallback: editServerCallback,
      secondaryCallback: OnDelete
    }) : null,
    gamepadAlias: "external-server-form-creating"
  }, /*#__PURE__*/React.createElement(ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement(Grid, null, /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: -1,
    wideSize: 1,
    narrowSize: 1,
    disabled: true
  }), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 10,
    narrowSize: 6
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(VanillaTextField, {
    gamepadIndex: 0,
    label: t('.serverNameLabel'),
    value: nameField,
    onChange: onNameChange,
    placeholder: t('.serverNamePlaceholder')
  }), /*#__PURE__*/React.createElement(ServerAddressField, {
    gamepadIndex: 1,
    address: addressField,
    setAddress: onAddressChange
  }), /*#__PURE__*/React.createElement(ServerPortField, {
    gamepadIndex: 2,
    port: portField,
    setPort: onPortChange
  }), !isNarrow ? /*#__PURE__*/React.createElement(ExternalServerForm_Buttons, {
    gamepadIndex: 3,
    isEditing: true,
    primaryCallback: editServerCallback,
    secondaryCallback: OnDelete
  }) : null), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 1,
    wideSize: 1,
    narrowSize: 1,
    disabled: true
  }))))))), /*#__PURE__*/React.createElement(Mount, {
    when: isEditing,
    condition: false
  }, /*#__PURE__*/React.createElement(NarrationContext, {
    text: t('.newServerNarration')
  }, /*#__PURE__*/React.createElement(NavigationBarLayout, {
    onBackButton: historyAPI.goBack,
    center: /*#__PURE__*/React.createElement(Typography, {
      type: "header5A"
    }, t('.newServerTitle')),
    footer: isNarrow ? /*#__PURE__*/React.createElement(ExternalServerForm_Buttons, {
      gamepadIndex: 0,
      primaryCallback: addAndPlayCallback,
      secondaryCallback: addServerCallback,
      isEditing: false
    }) : null,
    gamepadAlias: "external-server-form-editing"
  }, /*#__PURE__*/React.createElement(ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement(Grid, null, /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: -1,
    wideSize: 1,
    narrowSize: 1
  }), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 10,
    narrowSize: 6
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(VanillaTextField, {
    gamepadIndex: 0,
    label: t('.serverNameLabel'),
    value: nameField,
    onChange: setNameField,
    placeholder: t('.serverNamePlaceholder')
  }), /*#__PURE__*/React.createElement(ServerAddressField, {
    gamepadIndex: 1,
    address: addressField,
    setAddress: setAddressField
  }), /*#__PURE__*/React.createElement(ServerPortField, {
    gamepadIndex: 2,
    port: portField,
    setPort: setPortField
  }), !isNarrow ? /*#__PURE__*/React.createElement(ExternalServerForm_Buttons, {
    gamepadIndex: 3,
    primaryCallback: addAndPlayCallback,
    secondaryCallback: addServerCallback,
    isEditing: false
  }) : null), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 1,
    wideSize: 1,
    narrowSize: 1
  }))))))), /*#__PURE__*/React.createElement(Mount, {
    when: isErrorModalOpen
  }, /*#__PURE__*/React.createElement(ExternalServerErrorModal.Component, {
    externalServerWorldError: operationError,
    onClose: () => setIsErrorModalOpen(false)
  })), /*#__PURE__*/React.createElement(Mount, {
    when: isConfirmationModalOpen
  }, /*#__PURE__*/React.createElement(ConfirmDeletionModal.Component, {
    onDeleteServer: deleteServerCallback,
    onClose: () => setIsConfirmationModalOpen(false)
  })), /*#__PURE__*/React.createElement(Mount, {
    when: isUnsavedChangesModalOpen
  }, /*#__PURE__*/React.createElement(UnsavedChangesModal.Component, {
    onSaveChanges: editServerCallback,
    onDiscardChanges: () => historyAPI.goBack(),
    onClose: () => setIsUnsavedChangesModalOpen(false)
  }))));
};

function ExternalServerForm_Buttons({
  isEditing,
  primaryCallback,
  secondaryCallback,
  gamepadIndex
}) {
  const semanticClassNamesButton = useSemanticColors('neutral');
  const {
    t
  } = useLocalization('PlayScreen.serverTab.serverForm');
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: classnames(styles.externalServerButtons, semanticClassNamesButton.background.base)
  }, /*#__PURE__*/React.createElement(RowLegacy, {
    options: {
      index: gamepadIndex
    }
  }, /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 0,
    horizontal: true,
    inputLegend: isEditing ? t('.deleteServerButton') : t('.addServerButton'),
    onClick: secondaryCallback,
    variant: isEditing ? 'destructive' : 'secondary',
    Icon: isEditing ? IconDelete : undefined
  }, isEditing ? t('.deleteServerButton') : t('.addServerButton')), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 1,
    horizontal: true,
    inputLegend: isEditing ? t('.saveChangesButton') : t('.addAndPlayButton'),
    onClick: primaryCallback,
    variant: "primary",
    Icon: isEditing ? IconSave : undefined
  }, isEditing ? t('.saveChangesButton') : t('.addAndPlayButton')))), /*#__PURE__*/React.createElement(InputLegend.Space, null));
}

function ServerAddressField({
  address,
  setAddress,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('PlayScreen.serverTab.serverForm');
  return /*#__PURE__*/React.createElement(VanillaTextField, {
    gamepadIndex: gamepadIndex,
    label: t('.serverAddressLabel'),
    onChange: setAddress,
    placeholder: t('.serverAddressPlaceholder'),
    value: address
  });
}

function ServerPortField({
  port,
  setPort,
  gamepadIndex
}) {
  const {
    t
  } = useLocalization('PlayScreen.serverTab.serverForm');
  const {
    narrateText
  } = useNarrateText({
    interruptible: false
  });
  const portBlurHandler = useCallback(
  /**
   * Handler for sanitizing the input to only
   * allow digits and the max port should be 65535
   */
  (port, setPort) => {
    const numbersReg = /^[0-9]*$/g;
    const isOnlyDigits = port.match(numbersReg);
    const isEmpty = port.length === 0;

    if (isEmpty || !isOnlyDigits) {
      narrateText(t('.serverPortInvalidValue', [DEFAULT_PORT.toString()]));
      setPort(DEFAULT_PORT.toString());
      return TextField.ValidationResult.INVALID;
    } else if (parseInt(port) > MAX_PORT) {
      narrateText(t('.serverPortNotWithinRange', [MAX_PORT.toString()]));
      setPort(MAX_PORT.toString());
      return TextField.ValidationResult.INVALID;
    }

    return TextField.ValidationResult.VALID;
  }, [narrateText, t]);
  return /*#__PURE__*/React.createElement(VanillaTextField, {
    gamepadIndex: gamepadIndex,
    label: t('.serverPortLabel'),
    onBlur: portBlurHandler,
    onChange: setPort,
    value: port,
    isNumber: true
  });
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ExternalServerRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/QuickWorldCreationRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const QuickWorldCreationRoute = ({"cardImage":"_PMoJ","modeCardImage":"NHHNk","listImage":"yIenp"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/survival.png
const survival_namespaceObject = __webpack_require__.p + "assets/survival-6af61.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/creative.png
const creative_namespaceObject = __webpack_require__.p + "assets/creative-63872.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/easy.png
const easy_namespaceObject = __webpack_require__.p + "assets/easy-e04ab.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/normal.png
const normal_namespaceObject = __webpack_require__.p + "assets/normal-5fc05.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/hard.png
const hard_namespaceObject = __webpack_require__.p + "assets/hard-92508.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/images/peaceful.png
const peaceful_namespaceObject = __webpack_require__.p + "assets/peaceful-a5b58.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/QuickWorldCreationRoute/QuickWorldCreationRoute.tsx




















const MODE_SURVIVAL_CARD_ALIAS = 'quick-world-creation-route-mode/survival';
const DIFFICULTY_EASY_CARD_ALIAS = 'quick-world-creation-route-difficulty/easy';

function ModeRoute() {
  const {
    t
  } = useLocalization_useLocalization('QuickWorldCreationRoute.Mode');
  const routerAPI = hooks_useRouterAPI();
  const handleClickCreative = useQuickCreateWorldWithPrerequisites(GameMode.CREATIVE, DifficultyEnum.NORMAL);
  return /*#__PURE__*/react.createElement(VanillaScreenLayout_VanillaScreenLayout, {
    title: t('.title'),
    screenAnalyticsId: "QuickWorldCreationMode",
    gamepadAlias: "quick-world-creation-route-mode",
    delegateByAlias: MODE_SURVIVAL_CARD_ALIAS
  }, () => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(QuickWorldCreationErrorModal, null), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    delegateFocusByAlias: DIFFICULTY_EASY_CARD_ALIAS
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    maxWidth: 96,
    centerContentVertically: true,
    nonFullScreen: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 5,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ModeCard, {
    gamepadAlias: MODE_SURVIVAL_CARD_ALIAS,
    title: t('.survivalTitle'),
    description: t('.survivalDescription'),
    inputLegend: t('.survivalInputLegend'),
    image: survival_namespaceObject,
    onClick: () => routerAPI.push('/quick-create-new-world/survival/difficulty'),
    groupIndex: 1,
    groupSize: 2
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 5,
    narrowSize: 4
  }, /*#__PURE__*/react.createElement(ModeCard, {
    title: t('.creativeTitle'),
    description: t('.creativeDescription'),
    inputLegend: t('.creativeInputLegend'),
    image: creative_namespaceObject,
    onClick: handleClickCreative,
    groupIndex: 2,
    groupSize: 2
  })))))));
}

function DifficultyRoute() {
  const {
    t
  } = useLocalization_useLocalization('QuickWorldCreationRoute.Difficulty'); // Breakpoint is at 48rem, so we consider anything below 48.1 narrow
  // TODO: revisit this hook definition, maybe it should accept 48 as the correct value

  const isNarrow = useIsWindowNarrow(48.1);
  const cards = /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    centerContentVertically: true,
    nonFullScreen: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement(DifficultyCard, {
    title: t('.peacefulTitle'),
    description: t('.peacefulDescription'),
    inputLegend: t('.createInputLegend'),
    image: peaceful_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.PEACEFUL),
    groupIndex: 1,
    groupSize: 4
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement(DifficultyCard, {
    gamepadAlias: DIFFICULTY_EASY_CARD_ALIAS,
    title: t('.easyTitle'),
    description: t('.easyDescription'),
    inputLegend: t('.createInputLegend'),
    image: easy_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.EASY),
    groupIndex: 2,
    groupSize: 4
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement(DifficultyCard, {
    title: t('.normalTitle'),
    description: t('.normalDescription'),
    inputLegend: t('.createInputLegend'),
    image: normal_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.NORMAL),
    groupIndex: 3,
    groupSize: 4
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 3,
    narrowSize: 2
  }, /*#__PURE__*/react.createElement(DifficultyCard, {
    title: t('.hardTitle'),
    description: t('.hardDescription'),
    inputLegend: t('.createInputLegend'),
    image: hard_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.HARD),
    groupIndex: 4,
    groupSize: 4
  }))));
  const list = /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    centerContentVertically: true,
    nonFullScreen: true
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(DifficultyListItem, {
    title: t('.peacefulTitle'),
    description: t('.peacefulDescription'),
    inputLegend: t('.createInputLegend'),
    image: peaceful_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.PEACEFUL),
    groupIndex: 1,
    groupSize: 4
  }), /*#__PURE__*/react.createElement(DifficultyListItem, {
    gamepadAlias: DIFFICULTY_EASY_CARD_ALIAS,
    title: t('.easyTitle'),
    description: t('.easyDescription'),
    inputLegend: t('.createInputLegend'),
    image: easy_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.EASY),
    groupIndex: 2,
    groupSize: 4
  }), /*#__PURE__*/react.createElement(DifficultyListItem, {
    title: t('.normalTitle'),
    description: t('.normalDescription'),
    inputLegend: t('.createInputLegend'),
    image: normal_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.NORMAL),
    groupIndex: 3,
    groupSize: 4
  }), /*#__PURE__*/react.createElement(DifficultyListItem, {
    title: t('.hardTitle'),
    description: t('.hardDescription'),
    inputLegend: t('.createInputLegend'),
    image: hard_namespaceObject,
    onClick: useQuickCreateWorldWithPrerequisites(GameMode.SURVIVAL, DifficultyEnum.HARD),
    groupIndex: 4,
    groupSize: 4
  }))));
  return /*#__PURE__*/react.createElement(VanillaScreenLayout_VanillaScreenLayout, {
    title: t('.title'),
    screenAnalyticsId: "QuickWorldCreationMode",
    gamepadAlias: "quick-world-creation-route-difficulty",
    delegateByAlias: DIFFICULTY_EASY_CARD_ALIAS
  }, () => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(RenderTrackingEvent_RenderTrackingEvent, {
    type: "meaningful",
    renderingCompleted: true
  }), /*#__PURE__*/react.createElement(QuickWorldCreationErrorModal, null), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: 0,
    delegateFocusByAlias: DIFFICULTY_EASY_CARD_ALIAS
  }, isNarrow ? list : cards)));
}

function QuickWorldCreationRoute_TouchControlSelectionRoute() {
  const {
    mode,
    difficulty
  } = RouterEngineProvider_useRouteParamsUnwrapped();
  const createAndStartWorld = useQuickCreateWorld(parseInt(mode, 10), parseInt(difficulty, 10));
  return /*#__PURE__*/react.createElement(TouchControlSelection_TouchControlSelection, {
    startWorld: createAndStartWorld
  });
}

const QuickWorldCreationErrorModal = () => {
  const worldEditor = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  return /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: (0,react_facet_src.useFacetMap)((worldEditor, worldStartup) => worldEditor.saveLocalWorldError != null || worldStartup.startLocalWorldResult === StartLocalWorldResult.WorldNotInLevelList || worldStartup.startLocalWorldResult === StartLocalWorldResult.GameServerStarterNotReady, [], [worldEditor, worldStartup])
  }, /*#__PURE__*/react.createElement(EditWorldErrorModal.Component, null));
};
/**
 * Hook that returns a callback that creates a world and starts with a given mode and difficulty
 */


const useQuickCreateWorld = (mode, difficulty) => {
  const worldEditor = (0,react_facet_src.useSharedFacet)(worldEditorFacet);
  const worldStartup = (0,react_facet_src.useSharedFacet)(worldStartupFacet);
  const saveLocalWorldProgress = (0,react_facet_src.useFacetMap)(worldEditor => worldEditor.saveLocalWorldProgress, [], [worldEditor]);
  return useFacetCoroutine((worldEditor, worldStartup) => function* () {
    if (worldEditor.saveLocalWorldProgress !== FacetTaskProgress.IDLE) return;
    worldEditor.addWorld();
    worldEditor.worldData.general.gameMode = mode;
    worldEditor.worldData.general.difficulty = difficulty;
    worldEditor.startSaveLocalWorld(worldEditor.currentWorldId);
    yield saveLocalWorldProgress;
    worldStartup.startLocalWorld_v2(worldEditor.currentWorldId);
  }, [mode, difficulty, saveLocalWorldProgress], [worldEditor, worldStartup]);
};

const useQuickCreateWorldWithPrerequisites = (mode, difficulty) => {
  const routerAPI = hooks_useRouterAPI();
  const shouldShowControlSelection = useShouldShowTouchControlScreen();
  const createAndStart = useQuickCreateWorld(mode, difficulty);
  return (0,react_facet_src.useFacetCallback)(shouldShowControlSelection => () => {
    if (shouldShowControlSelection) {
      routerAPI.push(`/quick-create-new-world/${mode}/${difficulty}/touch-control-selection`);
    } else {
      createAndStart();
    }
  }, [routerAPI, mode, difficulty, createAndStart], [shouldShowControlSelection]);
};

const ModeCard = ({
  image,
  title,
  description,
  inputLegend,
  gamepadAlias,
  onClick,
  groupIndex,
  groupSize
}) => {
  const [imageRef, paddingTop] = useImageAspectRatio(16.2);
  const {
    t
  } = useLocalization_useLocalization('Common.narration');
  const countText = t('.position', [`${groupIndex}`, `${groupSize}`]);
  const narrationText = [title, t('.roles.button'), countText, description].join(' . ');
  return /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: 0,
    inputLegend: inputLegend,
    gamepadAlias: gamepadAlias,
    onClick: onClick,
    narrateCardRole: false
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: imageRef,
    className: QuickWorldCreationRoute.modeCardImage,
    style: {
      backgroundImage: getImagePixelatedUrl(image),
      paddingTop
    }
  }), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    verticalAlign: "center"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, description)));
};

const DifficultyCard = ({
  image,
  title,
  inputLegend,
  description,
  gamepadAlias,
  onClick,
  groupIndex,
  groupSize
}) => {
  const [imageRef, paddingTop] = useImageAspectRatio(14);
  const {
    t
  } = useLocalization_useLocalization('Common.narration');
  const countText = t('.position', [`${groupIndex}`, `${groupSize}`]);
  const narrationText = [title, t('.roles.button'), countText, description].join(' . ');
  return /*#__PURE__*/react.createElement(Card_Card, {
    gamepadIndex: 0,
    inputLegend: inputLegend,
    gamepadAlias: gamepadAlias,
    onClick: onClick,
    narrateCardRole: false
  }, /*#__PURE__*/react.createElement("fast-div", {
    ref: imageRef,
    className: QuickWorldCreationRoute.cardImage,
    style: {
      backgroundImage: getImagePixelatedUrl(image),
      paddingTop
    }
  }), /*#__PURE__*/react.createElement(Card_Card.Information, {
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body",
    verticalAlign: "center"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, description)));
};

const DifficultyListItem = ({
  image,
  title,
  description,
  inputLegend,
  gamepadAlias,
  onClick,
  groupIndex,
  groupSize
}) => {
  const {
    t
  } = useLocalization_useLocalization('Common.narration');
  const countText = t('.position', [`${groupIndex}`, `${groupSize}`]);
  const narrationText = [title, t('.roles.button'), countText, description].join(' . ');
  return /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    gamepadIndex: 0,
    tall: true
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: inputLegend,
    narrationText: narrationText,
    gamepadAlias: gamepadAlias,
    onClick: onClick
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Cell, null, /*#__PURE__*/react.createElement("div", {
    className: QuickWorldCreationRoute.listImage,
    style: {
      backgroundImage: getImagePixelatedUrl(image)
    }
  })), /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, title), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, description))));
};

const useImageAspectRatio = minimumHeightInRems => {
  const imageRef = (0,react.useRef)(null);
  const [paddingTop, setPaddingTop] = (0,react_facet_src.useFacetState)('0px');
  const minimumHeightInPixels = useSizeInPixelsFacet(minimumHeightInRems);
  const onComponentResize = (0,react_facet_src.useFacetCallback)(minimumHeightInPixels => ({
    width
  }) => {
    /**
     * Keeps aspect-ratio, unless image is too small, then we prioritize keeping the content visible
     * Implemented in JavaScript as Gameface does not support the `max` function in CSS.
     *
     * padding-top: max(56.25%, 10.8rem);
     */
    setPaddingTop(`${Math.max(width * 0.5625, minimumHeightInPixels)}px`);
  }, [setPaddingTop], [minimumHeightInPixels]);
  useOnComponentResize_useOnComponentResize(imageRef, onComponentResize);
  return [imageRef, paddingTop];
};

const QuickWorldCreationRoute_QuickWorldCreationRoute = {
  Mode: ModeRoute,
  Difficulty: DifficultyRoute,
  TouchControlSelection: QuickWorldCreationRoute_TouchControlSelectionRoute
};
/**
 * Gameface currently does not support "imageRendering: pixelated" for backgroundImage.
 * As a workaround, we temporarily use custom supported query-strings to make sure images are rendered sharply.
 *
 * TODO: move all custom image code from this file to the official Image component
 */

const getImagePixelatedUrl = src => {
  const isGameface = "gameface" === 'gameface';
  return `url(${src}${isGameface ? '?filtering=point' : ''})`;
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PrivacyAndOnlineSafetyModal/images/externalLink.png
const externalLink_namespaceObject = __webpack_require__.p + "assets/externalLink-0e493.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PrivacyAndOnlineSafetyModal/images/privacy_safety_help_qr.png
const privacy_safety_help_qr_namespaceObject = __webpack_require__.p + "assets/privacy_safety_help_qr-0e514.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PrivacyAndOnlineSafetyModal/PrivacyAndOnlineSafetyModal.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PrivacyAndOnlineSafetyModal = ({"row":"IveWW","indentedText":"ufbEn","column":"L115_","image":"HC86T","imageContainer":"zo5W7"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PrivacyAndOnlineSafetyModal/PrivacyAndOnlineSafetyModal.tsx













const webLink = 'https://aka.ms/RealmsSafety';

function RenderPrivacySettingsInstructionsModal({
  addExtraSpace,
  onClose,
  children
}) {
  const {
    t
  } = useLocalization_useLocalization('PrivacyAndOnlineSafetyModal');
  const privacyAndOnlineSafetySharedFacet = (0,react_facet_src.useSharedFacet)(privacyAndOnlineSafetyFacet);
  const TRY_AGAIN_BUTTON_ALIAS = 'privacy-and-online-safety-try-again-button';
  const openRealmsSafetyPage = (0,react_facet_src.useFacetCallback)(webBrowser => () => {
    webBrowser.openLink(WebBrowserLink.RealmsSafetyPage);
  }, [], [(0,react_facet_src.useSharedFacet)(webBrowserFacet)]);
  const browserAvailable = (0,react_facet_src.useFacetMap)(({
    platform
  }) => isBrowserSupportedPlatform(platform), [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const tryAgainHandler = (0,react_facet_src.useFacetCallback)(facet => () => {
    facet.checkClubAndMultiplayerPermissions();
  }, [], [privacyAndOnlineSafetySharedFacet]);
  const addExtraSpaceFacet = (0,react_facet_src.useFacetWrap)(addExtraSpace);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, {
    defaultFocusAlias: TRY_AGAIN_BUTTON_ALIAS
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, {
    onClose: onClose
  }, t('.header')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.row
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: browserAvailable,
    condition: false
  }, /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.imageContainer
  }, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: privacy_safety_help_qr_namespaceObject,
    className: PrivacyAndOnlineSafetyModal.image
  }))), /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.column
  }, children, /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.indentedText
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: browserAvailable
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, /*#__PURE__*/react.createElement(Link_Link, {
    onClick: openRealmsSafetyPage,
    gamepadIndex: 1,
    withUnderlinePolyfill: true
  }, webLink))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: browserAvailable,
    condition: false
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: addExtraSpaceFacet
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  })), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, webLink))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }))))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    horizontal: true
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadAlias: TRY_AGAIN_BUTTON_ALIAS,
    gamepadIndex: 0,
    inputLegend: t('.tryAgain'),
    horizontal: true,
    onClick: tryAgainHandler
  }, t('.tryAgain')), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: browserAvailable
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Button_Button_Button, {
    onClick: openRealmsSafetyPage,
    imgSrc: externalLink_namespaceObject,
    inputLegend: t('.buttonAction'),
    variant: "primary",
    horizontal: true,
    narrationSuffix: t('.linkButtonHint'),
    gamepadIndex: 1
  }, t('.externalLinkText'))))));
}

const PrivacyMissingMultiplayerPermissionModal = registerModal(({
  closeCallback
}) => {
  const {
    t
  } = useLocalization_useLocalization('PrivacyAndOnlineSafetyModal');
  const browserAvailable = (0,react_facet_src.useFacetMap)(({
    platform
  }) => isBrowserSupportedPlatform(platform), [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const narrationText = (0,react_facet_src.useFacetMap)(browserAvailable => {
    const hint = browserAvailable ? null : t('.qrCodeHint');
    return [t('.fromOnlineSafety'), t('.toAccessRealms'), t('.multiplayerPermissionMessage'), hint].join(' . ');
  }, [t], [browserAvailable]);
  return /*#__PURE__*/react.createElement(RenderPrivacySettingsInstructionsModal, {
    onClose: closeCallback
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    spaceBetweenParagraphs: 0,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.fromOnlineSafety')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.toAccessRealms')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.multiplayerPermissionMessage'))));
});
const PrivacyMissingClubPermissionModal = registerModal(({
  closeCallback
}) => {
  const {
    t
  } = useLocalization_useLocalization('PrivacyAndOnlineSafetyModal');
  const browserAvailable = (0,react_facet_src.useFacetMap)(({
    platform
  }) => isBrowserSupportedPlatform(platform), [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const narrationText = (0,react_facet_src.useFacetMap)(browserAvailable => {
    const hint = browserAvailable ? null : t('.qrCodeHint');
    return [t('.fromOnlineSafety'), t('.toAccessRealmsStories'), t('.clubPermissionMessage'), hint].join(' . ');
  }, [t], [browserAvailable]);
  return /*#__PURE__*/react.createElement(RenderPrivacySettingsInstructionsModal, {
    onClose: closeCallback
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    spaceBetweenParagraphs: 0,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.fromOnlineSafety')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.toAccessRealmsStories')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.clubPermissionMessage'))));
});
const PrivacyMissingBothPermissionsModal = registerModal(({
  closeCallback
}) => {
  const {
    t
  } = useLocalization_useLocalization('PrivacyAndOnlineSafetyModal');
  const browserAvailable = (0,react_facet_src.useFacetMap)(({
    platform
  }) => isBrowserSupportedPlatform(platform), [], [(0,react_facet_src.useSharedFacet)(deviceInformationFacet)]);
  const narrationText = (0,react_facet_src.useFacetMap)(browserAvailable => {
    const hint = browserAvailable ? null : t('.qrCodeHint');
    return [t('.fromOnlineSafety'), t('.toAccessRealmsNumbered'), t('.multiplayerPermissionMessage'), t('.toAccessRealmsStoriesNumbered'), t('.clubPermissionMessage'), hint].join(' . ');
  }, [t], [browserAvailable]);
  return /*#__PURE__*/react.createElement(RenderPrivacySettingsInstructionsModal, {
    addExtraSpace: true,
    onClose: closeCallback
  }, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Paragraphs, {
    gamepadIndex: 0,
    spaceBetweenParagraphs: 0,
    narrationText: narrationText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.fromOnlineSafety')), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.toAccessRealmsNumbered')), /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.indentedText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.multiplayerPermissionMessage'))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.toAccessRealmsStoriesNumbered')), /*#__PURE__*/react.createElement("div", {
    className: PrivacyAndOnlineSafetyModal.indentedText
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, t('.clubPermissionMessage')))));
});
function PrivacyAndOnlineSafetyModal_PrivacyAndOnlineSafetyModal({
  closeCallback
}) {
  const privacyAndOnlineSafetySharedFacet = (0,react_facet_src.useSharedFacet)(privacyAndOnlineSafetyFacet);
  const multiplayerPermissionNotAllowed = (0,react_facet_src.useFacetMap)(facet => !facet.isCheckingCompleted || !facet.getMultiplayerCheckResult && facet.getClubCheckResult, [], [privacyAndOnlineSafetySharedFacet]);
  const clubPermissionNotAllowed = (0,react_facet_src.useFacetMap)(facet => !facet.isCheckingCompleted || !facet.getClubCheckResult && facet.getMultiplayerCheckResult, [], [privacyAndOnlineSafetySharedFacet]);
  const clubAndMultiplayerPermissionNotAllowed = (0,react_facet_src.useFacetMap)(facet => !facet.isCheckingCompleted || !facet.getClubCheckResult && !facet.getMultiplayerCheckResult, [], [privacyAndOnlineSafetySharedFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: clubAndMultiplayerPermissionNotAllowed
  }, /*#__PURE__*/react.createElement(PrivacyMissingBothPermissionsModal.Component, {
    closeCallback: closeCallback
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: clubPermissionNotAllowed
  }, /*#__PURE__*/react.createElement(PrivacyMissingClubPermissionModal.Component, {
    closeCallback: closeCallback
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: multiplayerPermissionNotAllowed
  }, /*#__PURE__*/react.createElement(PrivacyMissingMultiplayerPermissionModal.Component, {
    closeCallback: closeCallback
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PrivacyAndOnlineSafetyModal/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoryEntry/RealmsStoryEntryRoute.tsx








var EntryRouteState;

(function (EntryRouteState) {
  EntryRouteState[EntryRouteState["Enter"] = 0] = "Enter";
  EntryRouteState[EntryRouteState["Initializing"] = 1] = "Initializing";
  EntryRouteState[EntryRouteState["FetchSettings"] = 2] = "FetchSettings";
  EntryRouteState[EntryRouteState["DataReady"] = 3] = "DataReady";
})(EntryRouteState || (EntryRouteState = {}));

function RealmsStoryEntryRoute() {
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const historyAPI = hooks_useRouterAPI();
  const isRouteActive = hooks_useRouteIsActive();
  const settingsFacet = (0,react_facet_src.useSharedFacet)(realmStoriesSettingsFacet);
  const dataFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const [entryRouteState, setEntryRouteState] = (0,react_facet_src.useFacetState)(EntryRouteState.Enter);
  const showInitErrorModal = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, realmsDataFacet) => isRouteActive && entryRouteState == EntryRouteState.Initializing && !realmsDataFacet.isFetchingRealmWorld && !realmsDataFacet.isRealmWorldValid, [], [entryRouteState, isRouteActive, dataFacet]);
  const showFetchErrorModal = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, settingsFacet) => isRouteActive && entryRouteState == EntryRouteState.FetchSettings && (settingsFacet.currentFetchState == fetchStatus.FetchFailed || settingsFacet.currentFetchState == fetchStatus.InternalError), [], [entryRouteState, isRouteActive, settingsFacet]);
  const showRateLimitErrorModal = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, settingsFacet) => isRouteActive && entryRouteState == EntryRouteState.FetchSettings && settingsFacet.currentFetchState == fetchStatus.RateLimit, [], [entryRouteState, isRouteActive, settingsFacet]);
  const showLoading = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, showInitError, showFetchError) => isRouteActive && entryRouteState != EntryRouteState.DataReady && !showInitError && !showFetchError, [], [entryRouteState, isRouteActive, showInitErrorModal, showFetchErrorModal]);
  const showNoticeModal = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, settingsFacet) => isRouteActive && entryRouteState == EntryRouteState.DataReady && settingsFacet.playerOptIn == optInState.OptedIn && settingsFacet.realmOptIn != optInState.OptedIn, [], [entryRouteState, isRouteActive, settingsFacet]);
  const showPermissionsModal = (0,react_facet_src.useFacetMap)((entryRouteState, isRouteActive, settingsFacet, permissionFacet) => isRouteActive && entryRouteState == EntryRouteState.DataReady && settingsFacet.playerOptIn == optInState.OptedIn && settingsFacet.realmOptIn == optInState.OptedIn && permissionFacet.isCheckingCompleted && (!permissionFacet.getClubCheckResult || !permissionFacet.getMultiplayerCheckResult), [], [entryRouteState, isRouteActive, settingsFacet, (0,react_facet_src.useSharedFacet)(privacyAndOnlineSafetyFacet)]);
  const onClose = (0,react.useCallback)(() => {
    historyAPI.goBack();
  }, [historyAPI]);
  (0,react_facet_src.useFacetEffect)((entryRouteState, isRouteActive, actionsFacet, dataFacet, settingsFacet, showNoticeModal, showPermissionsModal) => {
    if (!isRouteActive) {
      return;
    }

    switch (entryRouteState) {
      case EntryRouteState.Enter:
        {
          actionsFacet.reset();
          actionsFacet.init(params.realmId);
          setEntryRouteState(EntryRouteState.Initializing);
        }
        break;

      case EntryRouteState.Initializing:
        {
          if (!dataFacet.isFetchingRealmWorld && dataFacet.isRealmWorldValid) {
            actionsFacet.fetchSettings(params.realmId);
            setEntryRouteState(EntryRouteState.FetchSettings);
          }
        }
        break;

      case EntryRouteState.FetchSettings:
        {
          if (settingsFacet.currentFetchState == fetchStatus.Success) {
            setEntryRouteState(EntryRouteState.DataReady);
          }
        }
        break;

      case EntryRouteState.DataReady:
        {
          if (settingsFacet.playerOptIn == optInState.OptedIn) {
            // Player has opted in and we are not showing either the owner opted out modal or permissions modal we are clear to navigate to the stories home page
            if (!showNoticeModal && !showPermissionsModal) {
              historyAPI.replace(`/realms-stories/${params.tab}/${params.realmId}`);
            }
          } else {
            historyAPI.replace(`/realms-story-opt-in/${params.realmId}`);
          }
        }
        break;
    }
  }, [params, setEntryRouteState, historyAPI], [entryRouteState, isRouteActive, (0,react_facet_src.useSharedFacet)(realmActionsFacet), dataFacet, settingsFacet, showNoticeModal, showPermissionsModal]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showLoading
  }, /*#__PURE__*/react.createElement(RealmsStoryContactingRealmsLoadingModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showInitErrorModal
  }, /*#__PURE__*/react.createElement(RealmsSomethingWentWrongErrorModal.Component, {
    onClickClose: onClose
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFetchErrorModal
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: onClose
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitErrorModal
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onClose
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNoticeModal
  }, /*#__PURE__*/react.createElement(RealmsStoryOwnerOptInNoticeModal.Component, {
    onNoticeClosed: onClose
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showPermissionsModal
  }, /*#__PURE__*/react.createElement(PrivacyAndOnlineSafetyModal_PrivacyAndOnlineSafetyModal, {
    closeCallback: onClose
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/RealmsStoryEntry/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesCommentsRoute/RealmsStoriesCommentsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsStoriesCommentsRoute = ({"bordered":"YwLqB"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SideStoryPostContainer/SideStoryPostContainer.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SideStoryPostContainer = ({"image":"LDTnm"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SideStoryPostContainer/SideStoryPostContainer.tsx









function SideStoryPostContainer_SideStoryPostContainer({
  sender,
  timestamp,
  image = (0,react_facet_src.createStaticFacet)(''),
  content
}) {
  const neutralColors = hooks_useSemanticColors('neutral');
  const hasImage = (0,react_facet_src.useFacetMap)(image => image !== '', [], [image]);
  const {
    t
  } = useLocalization_useLocalization('SideStoryPostContainer');
  const narrationSuffix = (0,react_facet_src.useFacetMap)((sender, timestamp, content) => [t('.hint', [sender]), timestamp, content].join(' . '), [t], [sender, timestamp, content]);
  return /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu, {
    gamepadIndex: 0,
    narrationPrefix: t('.name'),
    narrationRole: t('.role'),
    narrationSuffix: narrationSuffix
  }, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: hasImage
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Image_Image_Image, {
    src: image,
    aspectRatio: Image_Image_Image.AspectRatio["16:9"],
    className: classnames_default()(SideStoryPostContainer.image, neutralColors.border.base)
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }))), /*#__PURE__*/react.createElement(SideMenu_SideMenu_SideMenu.Item, null, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort"
  }, sender), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, timestamp), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 2
  }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "captionLong"
  }, content)));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/SideStoryPostContainer/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesCommentsRoute/RealmsStoriesCommentsRoute.tsx






















function StoryCommentContent({
  storyComment,
  index
}) {
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const commentBody = (0,react_facet_src.useFacetMap)(facet => facet.body, [], [storyComment]);
  const commentTimePosted = (0,react_facet_src.useFacetMap)(facet => facet.timePosted, [], [storyComment]);
  const hasViewed = (0,react_facet_src.useFacetWrap)(true);
  const author = (0,react_facet_src.useFacetMap)((comment, players) => {
    const player = find_find(players.players, player => player.xuid === comment.authorXuid);
    return player != null && (player === null || player === void 0 ? void 0 : player.fetchProfileStatus) === FetchStatus.Success ? player : unknownRealmPlayer;
  }, [], [storyComment, playersFacet]);
  return /*#__PURE__*/react.createElement(RealmStoryFeedContent, {
    body: commentBody,
    timePosted: commentTimePosted,
    author: author,
    gamepadIndex: index,
    hasViewed: hasViewed
  });
}

function RealmStoryComment({
  storyComment,
  index
}) {
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.feedPost');
  const realmFacet = (0,react_facet_src.useSharedFacet)(realmDataFacet);
  const totalLikes = (0,react_facet_src.useFacetMap)(facet => facet.totalLikes === 1 ? t('.totalLike', [facet.totalLikes.toString()]) : t('.totalLikes', [facet.totalLikes.toString()]), [t], [storyComment]);
  const hasLiked = (0,react_facet_src.useFacetMap)(facet => facet.hasLiked, [], [storyComment]);
  const hideLikes = (0,react_facet_src.useFacetMap)(facet => facet.totalLikes === 0, [], [storyComment]);
  const likedCommentNarration = (0,react_facet_src.useFacetMap)(facet => {
    return `${t('.like')} . ${t('.commentButtonEnumeration', ['1'])} . ${t('.likeStoryComment', [facet])}`;
  }, [t], [totalLikes]);
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const toggleCommentLike = (0,react_facet_src.useFacetCallback)((comment, actions) => () => {
    if (comment.toggleLikeStatus !== PostStatus.InProgress) {
      // This should be handled in the backend to reduce UI side devs' needing to have full understanding of the backend implementation (ADO: 1112254)
      actions.toggleLike(comment.id, comment.parentId);
    }
  }, [], [storyComment, actionsFacet]);
  const realmsCommentOptionsModal = RealmsStoriesOptionsModal.useModal();
  const isAuthor = (0,react_facet_src.useFacetMap)((comment, realmData) => comment.authorXuid === realmData.userXuid, [], [storyComment, realmFacet]);
  const isRealmOwner = (0,react_facet_src.useFacetMap)(realmData => realmData.ownerXuid === realmData.userXuid, [], [realmFacet]); //Delete comment

  const confirmDeleteModal = ConfirmDeleteStoryModal.useModal();
  const onCloseDeleteModal = (0,react.useCallback)(() => {
    confirmDeleteModal.hide();
    realmsCommentOptionsModal.hide();
  }, [confirmDeleteModal, realmsCommentOptionsModal]);
  const onDeleteConfirm = (0,react_facet_src.useFacetCallback)((comment, actions) => () => {
    actions.delete(comment.id, comment.parentId);
    onCloseDeleteModal();
  }, [onCloseDeleteModal], [storyComment, actionsFacet]);
  const showDeleteError = (0,react_facet_src.useFacetMap)(comment => comment.deleteStatus == PostStatus.InputInvalid || comment.deleteStatus == PostStatus.InternalError || comment.deleteStatus == PostStatus.UploadFailed || comment.deleteStatus == PostStatus.PostingFailed, [], [storyComment]);
  const onCloseDeleteFailed = (0,react_facet_src.useFacetCallback)((comment, actions) => () => actions.clearDeleteStatus(comment.id), [], [storyComment, actionsFacet]); //Report Story to Realm Owner

  const confirmNotifyModal = ConfirmNotifyStoryModal.useModal();
  const onCloseNotifyModal = (0,react.useCallback)(() => {
    confirmNotifyModal.hide();
    realmsCommentOptionsModal.hide();
  }, [confirmNotifyModal, realmsCommentOptionsModal]);
  const onNotifyConfirm = (0,react_facet_src.useFacetCallback)((comment, actions) => () => {
    actions.reportToClubOwner(comment.id, comment.parentId);
    onCloseNotifyModal();
  }, [onCloseNotifyModal], [storyComment, actionsFacet]);
  const showNotifyError = (0,react_facet_src.useFacetMap)(comment => comment.reportToClubOwnerStatus == PostStatus.InputInvalid || comment.reportToClubOwnerStatus == PostStatus.InternalError || comment.reportToClubOwnerStatus == PostStatus.UploadFailed || comment.reportToClubOwnerStatus == PostStatus.PostingFailed, [], [storyComment]);
  const onCloseNotifyFailed = (0,react_facet_src.useFacetCallback)((comment, actions) => () => actions.clearReportToClubOwnerStatus(comment.id), [], [storyComment, actionsFacet]); //Report to Xbox Enforcers Option

  const confirmReportModal = ConfirmReportStoryModal.useModal();
  const onCloseReportModal = (0,react.useCallback)(() => {
    confirmReportModal.hide();
    realmsCommentOptionsModal.hide();
  }, [confirmReportModal, realmsCommentOptionsModal]);
  const onReportConfirm = (0,react_facet_src.useFacetCallback)((comment, actions) => () => {
    actions.reportToXbox(comment.id, comment.parentId);
    onCloseReportModal();
  }, [onCloseReportModal], [storyComment, actionsFacet]);
  const showReportError = (0,react_facet_src.useFacetMap)(comment => comment.reportToXboxStatus == PostStatus.InputInvalid || comment.reportToXboxStatus == PostStatus.InternalError || comment.reportToXboxStatus == PostStatus.UploadFailed || comment.reportToXboxStatus == PostStatus.PostingFailed, [], [storyComment]);
  const onCloseReportFailed = (0,react_facet_src.useFacetCallback)((comment, actions) => () => {
    actions.clearReportToXboxStatus(comment.id);
  }, [], [storyComment, actionsFacet]);
  const notificationsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationsFacet_notificationsFacet);
  (0,react_facet_src.useFacetEffect)((comment, notification, actions) => {
    if (comment.reportToClubOwnerStatus === PostStatus.Success) {
      notification.queueSnackbar(t('.options.notify.toast'));
      actions.clearReportToClubOwnerStatus(comment.id);
    } else if (comment.reportToXboxStatus === PostStatus.Success) {
      notification.queueSnackbar(t('.options.report.toast'));
      actions.clearReportToXboxStatus(comment.id);
    }
  }, [t], [storyComment, notificationsSharedFacet, actionsFacet]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(RealmStoryFeed_RealmStoryFeed, {
    content: /*#__PURE__*/react.createElement(StoryCommentContent, {
      storyComment: storyComment,
      index: index
    }),
    index: index,
    totalLikes: totalLikes,
    hasLiked: hasLiked,
    hideLikes: hideLikes,
    likedNarration: likedCommentNarration,
    toggleLikeCallback: toggleCommentLike,
    openOptionsCallback: realmsCommentOptionsModal.show
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: realmsCommentOptionsModal.isVisible
  }, /*#__PURE__*/react.createElement(RealmsStoriesOptionsModal.Component, {
    isAuthor: isAuthor,
    isRealmOwner: isRealmOwner,
    isCommentOptions: true,
    onClose: realmsCommentOptionsModal.hide,
    onDelete: confirmDeleteModal.show,
    onNotify: confirmNotifyModal.show,
    onReport: confirmReportModal.show
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmDeleteModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmDeleteStoryModal.Component, {
    onConfirm: onDeleteConfirm,
    onCancel: onCloseDeleteModal,
    isCommentOptions: true
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showDeleteError
  }, /*#__PURE__*/react.createElement(DeleteStoryFailedModals.Component, {
    onClose: onCloseDeleteFailed,
    isCommentOptions: true
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmNotifyModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmNotifyStoryModal.Component, {
    onConfirm: onNotifyConfirm,
    onCancel: onCloseNotifyModal,
    isCommentOptions: true
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showNotifyError
  }, /*#__PURE__*/react.createElement(NotifyStoryFailedModals.Component, {
    onClose: onCloseNotifyFailed
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: confirmReportModal.isVisible
  }, /*#__PURE__*/react.createElement(ConfirmReportStoryModal.Component, {
    onConfirm: onReportConfirm,
    onCancel: onCloseReportModal,
    isCommentOptions: true
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showReportError
  }, /*#__PURE__*/react.createElement(ReportStoryFailedModals.Component, {
    onClose: onCloseReportFailed
  })));
}
function RealmsStoriesCommentsRoute_RealmsStoriesCommentsRoute() {
  const history = RouterEngineProvider_useRouteHistory();
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.CommentsScreen');
  const isRouteActive = hooks_useRouteIsActive();
  const params = hooks_useRouteParams();
  const storyId = (0,react_facet_src.useFacetMap)(facet => facet.id, [], [params]);
  const realmStories = (0,react_facet_src.useSharedFacet)(realmStoriesPostsFacet);
  const realmStoriesComments = (0,react_facet_src.useSharedFacet)(storyCommentsFacet);
  const persistentFacet = (0,react_facet_src.useSharedFacet)(realmPersistentDataFacet);
  const deviceInformationSharedFacet = (0,react_facet_src.useSharedFacet)(deviceInformationFacet);
  const realmStory = (0,react_facet_src.useFacetMap)((stories, id) => find_find(stories.stories, story => story.id === decodeURIComponent(id)), [], [realmStories, storyId]);
  const isStoriesLoading = (0,react_facet_src.useFacetMap)(facet => facet.storiesStatus === FetchStatus.InProgress, [], [realmStories]);
  const content = (0,react_facet_src.useFacetMap)(story => story ? story.body : '', [], [realmStory]);
  const playersFacet = (0,react_facet_src.useSharedFacet)(realmPlayersFacet);
  const sender = (0,react_facet_src.useFacetMap)((story, players) => {
    var _find;

    const author = story ? (_find = find_find(players.players, player => player.xuid === story.authorXuid)) !== null && _find !== void 0 ? _find : unknownRealmPlayer : unknownRealmPlayer;
    return author.gamerTag;
  }, [], [realmStory, playersFacet]);
  const date = (0,react_facet_src.useFacetMap)(story => story ? story.timePosted : '', [], [realmStory]);
  const image = (0,react_facet_src.useFacetMap)(story => story ? story.image : '', [], [realmStory]);
  const loadedRealmStoryComments = (0,react_facet_src.useFacetMap)((comments, id) => comments.comments.filter(comment => comment.parentId === decodeURIComponent(id)), [], [realmStoriesComments, storyId]);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint();
  const comment = (0,react_facet_src.useFacetMap)(facet => facet.postInProgressBody, [], [persistentFacet]);
  const setComment = (0,react_facet_src.useFacetCallback)(facet => newValue => {
    facet.postInProgressBody = newValue;
  }, [], [persistentFacet]);
  const actionsFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const [initialFetchComments, setInitialFetchComments] = (0,react_facet_src.useFacetState)(false);
  (0,react_facet_src.useFacetEffect)((actions, id, isLoading, initialFetch) => {
    if (initialFetch) {
      return;
    }

    if (!isLoading) {
      setInitialFetchComments(true);
      actions.fetchStoryComments(decodeURIComponent(id));
    }
  }, [setInitialFetchComments], [actionsFacet, storyId, isStoriesLoading, initialFetchComments]);
  const onPostComment = (0,react_facet_src.useFacetCallback)((actions, newComment, persistentData) => () => {
    persistentData.postInProgressBody = newComment;
    actions.postComment();
  }, [], [actionsFacet, comment, persistentFacet]);
  const onLeave = (0,react_facet_src.useFacetCallback)(persistentData => () => {
    persistentData.postInProgressBody = '';
    history.goBack();
  }, [history], [persistentFacet]);
  (0,react_facet_src.useFacetEffect)((comments, actionsFacet) => {
    if (comments.postCommentStatus === PostStatus.Success) {
      setComment('');
      actionsFacet.clearPostCommentStatus();
    }
  }, [setComment], [realmStoriesComments, actionsFacet]);
  const showFailedError = (0,react_facet_src.useFacetMap)((isRouteActive, comments) => isRouteActive && (comments.postCommentStatus == PostStatus.InputInvalid || comments.postCommentStatus == PostStatus.InternalError || comments.postCommentStatus == PostStatus.UploadFailed || comments.postCommentStatus == PostStatus.PostingFailed), [], [isRouteActive, realmStoriesComments]);
  const showRateLimitError = (0,react_facet_src.useFacetMap)((isRouteActive, comments) => isRouteActive && comments.postCommentStatus == PostStatus.RateLimit, [], [isRouteActive, realmStoriesComments]);
  const onErrorClosing = (0,react_facet_src.useFacetCallback)(actionsFacet => () => {
    actionsFacet.clearPostCommentStatus();
  }, [], [actionsFacet]);
  const isPostButtonDisabled = (0,react_facet_src.useFacetMap)((facet, commentsFacet) => facet === '' || commentsFacet.postCommentStatus === PostStatus.InProgress || commentsFacet.postCommentStatus === PostStatus.Uploading, [], [comment, realmStoriesComments]);
  const isPostButtonDisabledUnwrap = (0,react_facet_src.useFacetUnwrap)(isPostButtonDisabled);
  const neutralColors = hooks_useSemanticColors('neutral');
  const noInternetMessageVisible = (0,react_facet_src.useFacetMap)(deviceInformation => !deviceInformation.isOnline, [], [deviceInformationSharedFacet]);
  return /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(GlassPane_GlassPane_GlassPane, null, /*#__PURE__*/react.createElement(VanillaScreenLayout_VanillaScreenLayout, {
    onBack: onLeave,
    title: t('.header'),
    gamepadAlias: "realms-stories-comments-route",
    screenAnalyticsId: "StoriesComments"
  }, () => /*#__PURE__*/react.createElement(Grid_Grid_Grid, null, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: 4
  }), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 12,
    narrowSize: 8
  }, /*#__PURE__*/react.createElement(StoriesNoInternetMessage_StoriesNoInternetMessage, {
    wide: 12,
    narrow: 8
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 0 : 1
  }))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: noInternetMessageVisible,
    condition: false
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 0
  }, /*#__PURE__*/react.createElement(SideStoryPostContainer_SideStoryPostContainer, {
    content: content,
    sender: sender,
    timestamp: date,
    image: image
  })), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    wideSize: 8,
    narrowSize: 8,
    gamepadIndex: 1
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(RealmsStoriesCommentsRoute.bordered, neutralColors.border.base)
  }, /*#__PURE__*/react.createElement(VanillaTextField_VanillaTextField.WithButton, {
    buttonInputLegend: t('.select'),
    buttonText: t('.post'),
    buttonOnClick: onPostComment,
    gamepadIndex: 0,
    placeholder: t('.writeYourComment'),
    label: ''
    /* Clubs limits comment length to 350 characters */
    ,
    maxLength: 350,
    value: comment,
    onChange: setComment,
    buttonDisabled: isPostButtonDisabled,
    buttonVariant: isPostButtonDisabledUnwrap === false ? 'primary' : 'secondary'
  })), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
    size: breakpoint === 'narrow' ? 2 : 4
  }), /*#__PURE__*/react.createElement(GridList_GridList, {
    loading: isStoriesLoading // this should be based on fetching comments instead of stories loading, but we currently are not exposing fetch comments status. keeping this outside of this PR as it requires both frontend + backend changes (ADO: 1112270)
    ,
    firstRowSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 1
    }),
    data: loadedRealmStoryComments,
    gamepadIndex: 1,
    columns: 1,
    itemSeparatorVertical: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: breakpoint === 'narrow' ? 2 : 4
    }),
    renderItem: ({
      itemFacet,
      index
    }) => /*#__PURE__*/react.createElement(RealmStoryComment, {
      storyComment: itemFacet,
      index: index
    }),
    footer: /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 4
    })
  })))))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFailedError
  }, /*#__PURE__*/react.createElement(RealmsPostingCommentFailedErrorModal.Component, {
    onClickClose: onErrorClosing
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitError
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onErrorClosing
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoriesCommentsRoute/index.ts

;// CONCATENATED MODULE: ./packages/ui-internal/src/ResponsivePixelArt/ResponsivePixelArt.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ResponsivePixelArt = ({"container":"alnnk"});
;// CONCATENATED MODULE: ./packages/ui-internal/src/ResponsivePixelArt/ResponsivePixelArt.tsx
function ResponsivePixelArt_extends() { ResponsivePixelArt_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ResponsivePixelArt_extends.apply(this, arguments); }

function ResponsivePixelArt_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ResponsivePixelArt_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function ResponsivePixelArt_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





function ResponsivePixelArt_ResponsivePixelArt(_ref) {
  let {
    minWidth,
    minHeight,
    className: classNameProp,
    style
  } = _ref,
      props = ResponsivePixelArt_objectWithoutProperties(_ref, ["minWidth", "minHeight", "className", "style"]);

  const containerRef = (0,react.useRef)(null);
  const [imageScale, setImageScale] = (0,react_facet_src.useFacetState)(1);
  const className = (0,react_facet_src.useFacetMap)(cn => [ResponsivePixelArt.container, cn].filter(Boolean).join(' '), [], [(0,react_facet_src.useFacetWrap)(classNameProp)]);
  useOnComponentResize_useOnComponentResize(containerRef, ({
    width
  }) => {
    const nextImageScale = Math.max(1, Math.floor(width / minWidth));

    if (typeof nextImageScale === 'number' && nextImageScale > 0) {
      // Sets the image width to the highest multiple of minWidth that fits within width
      setImageScale(nextImageScale);
    }
  });
  const width = (0,react_facet_src.useFacetMap)(scale => `${minWidth * scale}px`, [minWidth], [imageScale]);
  const height = (0,react_facet_src.useFacetMap)(scale => `${minHeight * scale}px`, [minHeight], [imageScale]);
  return /*#__PURE__*/react.createElement("fast-div", {
    ref: containerRef,
    className: className,
    style: style
  }, /*#__PURE__*/react.createElement("fast-img", ResponsivePixelArt_extends({}, props, {
    style: {
      imageRendering: 'pixelated',
      width,
      height
    }
  })));
}
;// CONCATENATED MODULE: ./packages/ui/src/HeroMessage/HeroMessage.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const HeroMessage = ({"outerContainer":"ql95r","container":"YqX3E","titleImageContainer":"uJ4VV","titleImageBody":"iZMwc","border":"O1z7a","buttons":"YZFU6","content":"DURQC","contentInner":"rUQta","padded":"Bp0Op","floatingButtons":"sbwOK","floatingButtonsInner":"N9mIh"});
;// CONCATENATED MODULE: ./packages/ui/src/HeroMessage/HeroMessage.tsx
function HeroMessage_extends() { HeroMessage_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return HeroMessage_extends.apply(this, arguments); }

function HeroMessage_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = HeroMessage_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function HeroMessage_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }














const renderButtons = (buttons, horizontal) => {
  return buttons.map((_ref, i, arr) => {
    let {
      children
    } = _ref,
        props = HeroMessage_objectWithoutProperties(_ref, ["children"]);

    return /*#__PURE__*/react.createElement(react.Fragment, {
      key: i
    }, /*#__PURE__*/react.createElement(Button_Button_Button, HeroMessage_extends({
      gamepadIndex: horizontal ? arr.length - i : i
    }, props, {
      horizontal: horizontal
    }), children), i !== arr.length - 1 && /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }));
  });
};

const HeroMessage_HeroMessage = ({
  title,
  sectionRole = 'neutral80',
  buttonsRole = 'neutral',
  leftContent,
  rightContent,
  buttons,
  delegateFocusByAlias,
  onGoBack
}) => {
  const safeZone = useSafeZone();
  const semanticClassNamesSection = hooks_useSemanticColors(sectionRole);
  const semanticClassNamesButton = hooks_useSemanticColors(buttonsRole);
  const breakpoint = useWindowBreakpoint_useWindowBreakpoint(93);
  const isNarrow = breakpoint === 'narrow';
  const ref = (0,react.useRef)(null);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Landmark, {
    containerRef: ref,
    delegateFocusByAlias: delegateFocusByAlias
  }, /*#__PURE__*/react.createElement("div", {
    ref: ref,
    className: HeroMessage.outerContainer,
    style: {
      marginLeft: safeZone.left + 'px',
      marginRight: safeZone.right + 'px',
      marginTop: safeZone.top + 'px',
      marginBottom: isNarrow ? 0 : safeZone.bottom + 'px'
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroMessage.container
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid, {
    narrowBreakpointWidth: 53
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Row, {
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 1,
    wideSize: isNarrow ? 6 : 7,
    narrowSize: 3
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(HeroMessage.border, HeroMessage.titleImageContainer, semanticClassNamesSection.background.base, semanticClassNamesSection.border.base)
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: isNarrow ? 'header5A' : 'header3',
    align: 'center'
  }, title), /*#__PURE__*/react.createElement("fast-div", {
    className: HeroMessage.titleImageBody
  }, leftContent))), /*#__PURE__*/react.createElement(Grid_Grid_Grid.Column, {
    gamepadIndex: 2,
    wideSize: isNarrow ? 6 : 5,
    narrowSize: 5
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(HeroMessage.content, semanticClassNamesSection.background.base)
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(HeroMessage.contentInner, HeroMessage.border, semanticClassNamesSection.border.base)
  }, rightContent), !isNarrow && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(HeroMessage.buttons, HeroMessage.border, semanticClassNamesButton.background.base, semanticClassNamesButton.border.base)
  }, /*#__PURE__*/react.createElement(ColumnLegacy, {
    options: {
      index: 1
    }
  }, renderButtons(buttons, false))))))))), isNarrow && /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(HeroMessage.floatingButtons, semanticClassNamesButton.background.base)
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "bevel",
    left: false,
    right: false
  }), /*#__PURE__*/react.createElement("div", {
    className: HeroMessage.floatingButtonsInner,
    style: {
      paddingLeft: safeZone.left + 'px',
      paddingRight: safeZone.right + 'px',
      paddingBottom: safeZone.bottom + 'px'
    }
  }, /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: 1000
    }
  }, renderButtons(buttons, true))), /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, {
    addSafeZone: false
  }))), !isNarrow && /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend.Space, null), onGoBack && /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    onClick: onGoBack,
    options: {
      button: types_ButtonType.B,
      inputLegend: TitleBar_TitleBar.Buttons.Back.useLocalization().t('.inputLegend')
    }
  }));
};

const HeroMessage_Content = ({
  children
}) => {
  return /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: -1
  }, /*#__PURE__*/react.createElement("div", {
    className: HeroMessage.padded
  }, children));
};

HeroMessage_HeroMessage.Content = HeroMessage_Content;
;// CONCATENATED MODULE: ./packages/ui/src/SlidingNavigationPane/SlidingNavigationPane.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const SlidingNavigationPane = ({"multiStepContainer":"UXt21","multiSteps":"ldUqd","isSubPage":"xEVVZ","multiStep":"An2ie","multiStepMenuInner":"pJAxl","content":"YLp7y","multiStepList":"NgvAh","multiStepListItem":"sQPyh","header":"n4pdL","headerWithButton":"pIxpo","hidden":"u9qaf","headerShadow":"t8vJH","backButton":"haDng","spacer":"eQcQq"});
;// CONCATENATED MODULE: ./packages/ui/src/SlidingNavigationPane/SlidingNavigationPane.tsx












const TRANSITION_DURATION = 400;
const SlidingNavigationPaneContext = (0,react.createContext)({
  steps: (0,react_facet_src.createFacet)({
    initialValue: []
  }),
  isMenu: (0,react_facet_src.createFacet)({
    initialValue: true
  }),
  activeStep: (0,react_facet_src.createFacet)({
    initialValue: null
  }),
  onBackClick: () => {},
  onNavigationClick: () => {},
  registerStep: () => {}
});

const useMultiStepItem = () => {
  return (0,react.useContext)(SlidingNavigationPaneContext);
};

const SlidingNavigationPane_SlidingNavigationPane = ({
  children,
  title,
  activePane,
  onNavigationClick,
  onBackClick,
  role = 'neutral80',
  headerRole = 'neutral'
}) => {
  const [steps, setSteps] = (0,react_facet_src.useFacetState)([]);
  const activePaneFacet = (0,react_facet_src.useFacetWrap)(activePane);
  const isMenu = (0,react_facet_src.useFacetMap)(activePane => activePane == '', [], [activePaneFacet]);
  const semanticClassNames = hooks_useSemanticColors(role);
  const multiStepsClassNames = (0,react_facet_src.useFacetMap)(isMenu => classnames_default()(SlidingNavigationPane.multiSteps, {
    [SlidingNavigationPane.isSubPage]: isMenu === false
  }), [], [isMenu]);
  const registerStep = (0,react.useCallback)(title => {
    setSteps(prev => {
      if (prev === react_facet_src.NO_VALUE || prev.includes(title)) return prev;
      return [...prev, title];
    });
  }, [setSteps]);
  const ctxValue = (0,react.useMemo)(() => ({
    activeStep: activePaneFacet,
    steps,
    isMenu,
    headerRole,
    onNavigationClick,
    onBackClick,
    registerStep
  }), [activePaneFacet, isMenu, headerRole, onNavigationClick, onBackClick, registerStep, steps]);
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SlidingNavigationPane.multiStepContainer, semanticClassNames.background.base)
  }, /*#__PURE__*/react.createElement("fast-div", {
    className: multiStepsClassNames
  }, /*#__PURE__*/react.createElement(SlidingNavigationPaneContext.Provider, {
    value: ctxValue
  }, /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.multiStep
  }, /*#__PURE__*/react.createElement(SlidingNavigationPane_Header, null, title), /*#__PURE__*/react.createElement(SlidingNavigationPaneMenu, null)), /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.multiStep
  }, children))));
};

const SlidingNavigationPaneMenu = () => {
  const {
    t
  } = useLocalization_useLocalization('Modal');
  const {
    steps,
    isMenu,
    onNavigationClick
  } = useMultiStepItem();
  const isMenuUnwrapped = (0,react_facet_src.useFacetUnwrap)(isMenu);
  const handleClick = (0,react.useCallback)(title => {
    const titleUnwrapped = title.get();

    if (titleUnwrapped !== react_facet_src.NO_VALUE) {
      onNavigationClick(titleUnwrapped);
    }
  }, [onNavigationClick]);
  return /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.multiStepMenuInner
  }, /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: -1,
    floating: true
  }, /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.multiStepList
  }, /*#__PURE__*/react.createElement(GamepadColumn_GamepadColumn, {
    disabled: isMenuUnwrapped === false,
    shouldSkipLandmarkInVisual: true,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(react_facet_src.Map, {
    array: steps
  }, (title, i) => /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem, {
    small: true,
    gamepadIndex: i,
    key: i
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Action, {
    inputLegend: t('.select'),
    narrationText: title,
    onClick: () => handleClick(title)
  }, /*#__PURE__*/react.createElement(ListItem_ListItem_ListItem.Main, null, /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.multiStepListItem
  }, /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, title), /*#__PURE__*/react.createElement(IconArrowForwardWhite_IconArrowForwardWhite, null))))))))));
};

const Pane = ({
  children,
  title
}) => {
  const {
    activeStep,
    onBackClick,
    registerStep
  } = useMultiStepItem();
  const [shouldRender, setShouldRender] = (0,react_facet_src.useFacetState)(false);
  const wasActiveItem = (0,react.useRef)(false);
  (0,react.useEffect)(() => {
    registerStep(title);
  }, [registerStep, title]);
  /*
  	This effect is used to delay the unmounting of the pane when the user navigates away from it.
  	Without it the pane would unmount before the animation is done, causing an unwanted visual effect.
  */

  (0,react_facet_src.useFacetEffect)(activeItem => {
    let timeout;
    const isActiveItem = (activeItem === null || activeItem === void 0 ? void 0 : activeItem.toLowerCase()) === title.toLowerCase();
    const isUnMounting = wasActiveItem.current === true && isActiveItem === false;

    if (isUnMounting) {
      timeout = setTimeout(() => setShouldRender(false), TRANSITION_DURATION);
    } else {
      setShouldRender(isActiveItem);
    }

    wasActiveItem.current = isActiveItem;
    return () => {
      clearTimeout(timeout);
    };
  }, [setShouldRender, title], [activeStep]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: shouldRender
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: {
      button: types_ButtonType.B,
      inputLegend: TitleBar_TitleBar.Buttons.Back.useLocalization().t('.inputLegend')
    },
    onClick: onBackClick
  }), /*#__PURE__*/react.createElement(SlidingNavigationPane_Header, {
    onBack: onBackClick
  }, title), /*#__PURE__*/react.createElement(ScrollView_ScrollView_ScrollView, {
    gamepadIndex: -1,
    floating: true
  }, /*#__PURE__*/react.createElement("div", {
    className: SlidingNavigationPane.content
  }, children)))));
};

const SlidingNavigationPane_Header = ({
  children,
  onBack,
  role = 'inherit'
}) => {
  const {
    t
  } = useLocalization_useLocalization('Modal');
  const backInputLegendLoc = t('.backInputLegend');
  const semanticClassNames = hooks_useSemanticColors(role);
  const shortcutOptions = (0,react_facet_src.useFacetMap)(() => ({
    button: types_ButtonType.B,
    inputLegend: backInputLegendLoc,
    disabled: false
  }), [backInputLegendLoc], []);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SlidingNavigationPane.header, semanticClassNames.background.base, semanticClassNames.text.base, {
      [SlidingNavigationPane.headerWithButton]: onBack != null
    })
  }, /*#__PURE__*/react.createElement(Reflection_Reflection, {
    effect: "specular"
  }), onBack != null && /*#__PURE__*/react.createElement(GlobalShortcut_GlobalShortcut, {
    options: shortcutOptions,
    onClick: onBack
  }), /*#__PURE__*/react.createElement(Row_RowLegacy, {
    options: {
      index: -2
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SlidingNavigationPane.backButton, {
      [SlidingNavigationPane.hidden]: onBack == null
    })
  }, onBack && /*#__PURE__*/react.createElement(NavigationButton_NavigationButton, {
    role: role,
    inputLegend: backInputLegendLoc,
    narrationText: t('.backNarration'),
    onClick: onBack,
    gamepadIndex: 0
  }, /*#__PURE__*/react.createElement(IconArrowBackWhite_IconArrowBackWhite, null))), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
    type: "body"
  }, /*#__PURE__*/react.createElement(EllipsisPrimitive_EllipsisPrimitive_EllipsisPrimitive, null, children)), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SlidingNavigationPane.spacer, {
      [SlidingNavigationPane.hidden]: onBack == null
    })
  }))), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(SlidingNavigationPane.headerShadow, semanticClassNames.shadow.base)
  }));
};
SlidingNavigationPane_SlidingNavigationPane.Pane = Pane;
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/RealmsStoryOptInRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const RealmsStoryOptInRoute = ({"row":"JIgih","rightSideArt":"kWAt3"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/Images/RealmsStoryOptIn.png
const RealmsStoryOptIn_namespaceObject = __webpack_require__.p + "assets/RealmsStoryOptIn-f47af.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/Images/promo-small-social.png
const promo_small_social_namespaceObject = __webpack_require__.p + "assets/promo-small-social-09075.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/Images/promo-small-members.png
const promo_small_members_namespaceObject = __webpack_require__.p + "assets/promo-small-members-9a075.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/Images/promo-small-time.png
const promo_small_time_namespaceObject = __webpack_require__.p + "assets/promo-small-time-4e542.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsStoryOptInRoute/RealmsStoryOptInRoute.tsx


















function RealmsStoryOptInRoute_RealmsStoryOptInRoute() {
  const params = RouterEngineProvider_useRouteParamsUnwrapped();
  const {
    t
  } = useLocalization_useLocalization('RealmsStories.OptInScreen');
  const [heroTitle, setHeroTitle] = (0,react_facet_src.useFacetState)('');
  const [checkPermissions, setCheckPermissions] = (0,react_facet_src.useFacetState)(false);
  const historyAPI = RouterEngineProvider_useRouteHistory();
  const isRouteActive = hooks_useRouteIsActive();
  const realmActionsSharedFacet = (0,react_facet_src.useSharedFacet)(realmActionsFacet);
  const realmStoriesSettingsSharedFacet = (0,react_facet_src.useSharedFacet)(realmStoriesSettingsFacet);
  const clubAndMultiplayerPermissionAllowedFacet = (0,react_facet_src.useFacetMap)(facet => facet.isCheckingCompleted && facet.getClubCheckResult && facet.getMultiplayerCheckResult, [], [(0,react_facet_src.useSharedFacet)(privacyAndOnlineSafetyFacet)]);
  const isRealmOwnerFacet = (0,react_facet_src.useFacetMap)(realmDataFacet => realmDataFacet.userXuid === realmDataFacet.ownerXuid, [], [(0,react_facet_src.useSharedFacet)(realmDataFacet)]);
  const isRealmOwnerOptedInFacet = (0,react_facet_src.useFacetMap)(facet => facet.realmOptIn === optInState.OptedIn, [], [realmStoriesSettingsSharedFacet]);
  const currentSettingsPostStateFacet = (0,react_facet_src.useFacetMap)(facet => facet.currentPostState, [], [realmStoriesSettingsSharedFacet]);
  const showOptOutMembersModal = RealmsStoryMemberOptOutModal.useShowModal();
  const showOptOutOwnerModal = RealmsStoryOwnerOptOutModal.useShowModal();
  const showOptInNoAccessModal = RealmsStoryOwnerOptInNoticeModal.useShowModal();
  const showLoading = (0,react_facet_src.useFacetMap)((isRouteActive, currentSettingsPostState) => isRouteActive && (currentSettingsPostState == postStatus.InProgress || currentSettingsPostState == postStatus.Uploading), [], [isRouteActive, currentSettingsPostStateFacet]);
  const showFailedError = (0,react_facet_src.useFacetMap)((isRouteActive, currentSettingsPostState) => isRouteActive && (currentSettingsPostState == postStatus.InputInvalid || currentSettingsPostState == postStatus.InternalError || currentSettingsPostState == postStatus.UploadFailed || currentSettingsPostState == postStatus.PostingFailed), [], [isRouteActive, currentSettingsPostStateFacet]);
  const showRateLimitError = (0,react_facet_src.useFacetMap)((isRouteActive, currentSettingsPostState) => isRouteActive && currentSettingsPostState == postStatus.RateLimit, [], [isRouteActive, currentSettingsPostStateFacet]);
  const onOptInHandler = (0,react_facet_src.useFacetCallback)((realmActionsFacet, isOwner) => () => {
    realmActionsFacet.setPlayerOptInStatus(optInState.OptedIn);

    if (isOwner) {
      realmActionsFacet.setRealmsOptInStatus(optInState.OptedIn);
    }

    realmActionsFacet.postSettings(params.realmId);
  }, [params.realmId], [realmActionsSharedFacet, isRealmOwnerFacet]);
  const onOptOutHandler = (0,react_facet_src.useFacetCallback)((realmActionsFacet, isOwner) => () => {
    if (isOwner) {
      showOptOutOwnerModal({
        onOptOutCompleted: () => {
          realmActionsFacet.setPlayerOptInStatus(optInState.OptedOut);
          realmActionsFacet.setRealmsOptInStatus(optInState.OptedOut);
          realmActionsFacet.postSettingsOnExit(params.realmId);
          historyAPI.goBack();
        }
      });
    } else {
      showOptOutMembersModal({
        onOptOutCompleted: () => {
          realmActionsFacet.setPlayerOptInStatus(optInState.OptedOut);
          realmActionsFacet.postSettingsOnExit(params.realmId);
          historyAPI.goBack();
        }
      });
    }
  }, [showOptOutOwnerModal, params.realmId, historyAPI, showOptOutMembersModal], [realmActionsSharedFacet, isRealmOwnerFacet]);
  const onPostingSuccess = (0,react_facet_src.useFacetCallback)((isOwner, isOwnerOptedIn, settingsFacet) => () => {
    if (settingsFacet.playerOptIn == optInState.OptedIn) {
      // Current User not realms owner and realms owner has not opted in
      if (!isOwner && !isOwnerOptedIn) {
        // Show optInNotice Modal
        showOptInNoAccessModal({
          onNoticeClosed: () => {
            historyAPI.goBack();
          }
        });
      } else {
        setCheckPermissions(true);
      }
    }
  }, [historyAPI, setCheckPermissions, showOptInNoAccessModal], [isRealmOwnerFacet, isRealmOwnerOptedInFacet, realmStoriesSettingsSharedFacet]);
  const onErrorClosing = (0,react_facet_src.useFacetCallback)(actionsFacet => () => {
    actionsFacet.clearSettingsStatus();
    historyAPI.goBack();
  }, [historyAPI], [realmActionsSharedFacet]);
  (0,react_facet_src.useFacetEffect)((isRouteActive, currentSettingsPostState, actionsFacet) => {
    if (!isRouteActive) {
      return;
    }

    if (currentSettingsPostState == postStatus.Success) {
      actionsFacet.clearSettingsStatus();
      onPostingSuccess();
    }
  }, [onPostingSuccess], [isRouteActive, currentSettingsPostStateFacet, realmActionsSharedFacet]);
  const onGoBack = (0,react_facet_src.useFacetCallback)(title => () => {
    if (title === '') {
      historyAPI.goBack();
    }
  }, [historyAPI], [heroTitle]);
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(SemanticTokensProvider_SemanticTokensProvider, {
    collection: realmsCollection
  }, /*#__PURE__*/react.createElement(HeroMessage_HeroMessage, {
    delegateFocusByAlias: "realms-primary-button",
    onGoBack: onGoBack,
    buttons: [{
      variant: 'primary',
      inputLegend: 'Select',
      onClick: onOptInHandler,
      children: t('.optInButton'),
      gamepadAlias: 'realms-primary-button'
    }, {
      variant: 'secondary',
      inputLegend: 'Select',
      onClick: onOptOutHandler,
      children: t('.maybeLaterButton')
    }],
    title: t('.title'),
    leftContent: /*#__PURE__*/react.createElement(ResponsivePixelArt_ResponsivePixelArt, {
      src: RealmsStoryOptIn_namespaceObject,
      minWidth: 128,
      minHeight: 72
    }),
    rightContent: /*#__PURE__*/react.createElement(SlidingNavigationPane_SlidingNavigationPane, {
      title: t('.learnMore.title'),
      activePane: heroTitle,
      onNavigationClick: title => setHeroTitle(title),
      onBackClick: () => setHeroTitle('')
    }, /*#__PURE__*/react.createElement(SlidingNavigationPane_SlidingNavigationPane.Pane, {
      title: t('.learnMore.social.title')
    }, /*#__PURE__*/react.createElement("div", {
      className: RealmsStoryOptInRoute.row
    }, /*#__PURE__*/react.createElement(ResponsivePixelArt_ResponsivePixelArt, {
      src: promo_small_social_namespaceObject,
      minWidth: 72,
      minHeight: 72,
      className: RealmsStoryOptInRoute.rightSideArt
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.social.body.1'))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.social.body.2'))), /*#__PURE__*/react.createElement(SlidingNavigationPane_SlidingNavigationPane.Pane, {
      title: t('.learnMore.members.title')
    }, /*#__PURE__*/react.createElement("div", {
      className: RealmsStoryOptInRoute.row
    }, /*#__PURE__*/react.createElement(ResponsivePixelArt_ResponsivePixelArt, {
      src: promo_small_members_namespaceObject,
      minWidth: 72,
      minHeight: 72,
      className: RealmsStoryOptInRoute.rightSideArt
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.members.body.1'))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.members.body.2'))), /*#__PURE__*/react.createElement(SlidingNavigationPane_SlidingNavigationPane.Pane, {
      title: t('.learnMore.history.title')
    }, /*#__PURE__*/react.createElement("div", {
      className: RealmsStoryOptInRoute.row
    }, /*#__PURE__*/react.createElement(ResponsivePixelArt_ResponsivePixelArt, {
      src: promo_small_time_namespaceObject,
      minWidth: 72,
      minHeight: 72,
      className: RealmsStoryOptInRoute.rightSideArt
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.history.body.1'))), /*#__PURE__*/react.createElement(Spacing_Spacing_Spacing, {
      size: 2
    }), /*#__PURE__*/react.createElement(Typography_Typography_Typography, {
      type: "captionLong"
    }, t('.learnMore.history.body.2'))))
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: checkPermissions
  }, /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: clubAndMultiplayerPermissionAllowedFacet,
    condition: false
  }, /*#__PURE__*/react.createElement(PrivacyAndOnlineSafetyModal_PrivacyAndOnlineSafetyModal, {
    closeCallback: () => {
      setCheckPermissions(false);
    }
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: clubAndMultiplayerPermissionAllowedFacet,
    condition: true
  }, /*#__PURE__*/react.createElement(RealmsStoryOptInModal.Component, {
    onOptInCompleted: () => {
      setCheckPermissions(false);
      historyAPI.replace(`/realms-stories/feed/${params.realmId}`);
    }
  })))), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showLoading
  }, /*#__PURE__*/react.createElement(RealmsStoryContactingRealmsLoadingModal.Component, null)), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showFailedError
  }, /*#__PURE__*/react.createElement(RealmsCannotContactRealmsErrorModal.Component, {
    onClickClose: onErrorClosing
  })), /*#__PURE__*/react.createElement(react_facet_src.Mount, {
    when: showRateLimitError
  }, /*#__PURE__*/react.createElement(RealmsRateLimitErrorModal.Component, {
    onClickClose: onErrorClosing
  })));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSideMenu/images/qr_placeholder.png
const qr_placeholder_namespaceObject = __webpack_require__.p + "assets/qr_placeholder-83885.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSideMenu/AddFriendSideMenu.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddFriendSideMenu_AddFriendSideMenu = ({"desktopSideMenu":"qCwOF"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/hooks/useLoadPlayerProfileFacet.ts



/**
 * A hook to load the player profile facet for the current player
 */

function useLoadPlayerProfileFacet_useLoadCurrentPlayerProfileFacet() {
  const playerFacet = useSharedFacet(playerProfileFacet);
  const initializeFacet = useFacetCallback(player => () => {
    player.loadForCurrentPlayer();
  }, [], [playerFacet]);
  useEffect(() => {
    initializeFacet();
  }, [initializeFacet]);
}
/**
 * A hook to load the player profile facet for the given player id
 */

function useLoadPlayerProfileFacet_useLoadPlayerProfileFacet(playerId) {
  const playerFacet = useSharedFacet(playerProfileFacet);
  const initializeFacet = useFacetCallback(player => playerId => {
    player.loadForPlayer(playerId);
  }, [], [playerFacet]);
  useEffect(() => {
    initializeFacet(playerId);
  }, [initializeFacet, playerId]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSideMenu/AddFriendSideMenu.tsx











function AddFriendSideMenu_AddFriendSideMenu_AddFriendSideMenu() {
  const {
    t
  } = useLocalization('AddFriendSideMenu');
  const {
    t: narration
  } = useLocalization('WorldCard.narration');
  useLoadCurrentPlayerProfileFacet();
  const playerFacet = useSharedFacet(playerProfileFacet);
  const clipboard = useSharedFacet(clipboardFacet);
  const copyGamertag = useFacetCallback((player, clipboard) => () => {
    if (player.loaded) {
      clipboard.copyToClipboard(player.data.gamerTag);
    }
  }, [], [playerFacet, clipboard]);
  const breakpoint = useWindowBreakpoint();
  return /*#__PURE__*/React.createElement(ScrollView, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement("div", {
    className: `${breakpoint === 'desktop' ? styles.desktopSideMenu : ''}`
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 3
  }), /*#__PURE__*/React.createElement(SideMenu, {
    gamepadIndex: 1,
    autofocus: true
  }, /*#__PURE__*/React.createElement(SideMenu.Item, null, /*#__PURE__*/React.createElement(SideMenu.ItemMain, null, /*#__PURE__*/React.createElement(Image, {
    src: qrPlaceholder
  }))), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.loaded, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(SideMenu.Item, null, /*#__PURE__*/React.createElement(Typography, {
    type: "header5B",
    align: "center"
  }, /*#__PURE__*/React.createElement(EllipsisPrimitive, null, useFacetMap(player => player.data.gamerTag, [], [playerFacet]))), /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmer",
    align: "center"
  }, /*#__PURE__*/React.createElement(EllipsisPrimitive, null, useFacetMap(player => player.data.realName, [], [playerFacet]))))), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }), /*#__PURE__*/React.createElement(SideMenu.Item, null, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.shareButton'),
    variant: "hero",
    linebreak: true,
    gamepadIndex: 0,
    narrationSuffix: [narration('.buttonSiblings', ['1', '2']), t('.shareButtonHint')].join(' . ')
  }, t('.shareButton'))), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }), /*#__PURE__*/React.createElement(SideMenu.Item, null, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.copyGamertagButton'),
    narrationSuffix: [narration('.buttonSiblings', ['2', '2']), t('.copyGamertagButton')].join(' . '),
    variant: "secondary",
    linebreak: true,
    gamepadIndex: 0,
    onClick: copyGamertag
  }, t('.copyGamertagButton'))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSearchByGamertag/images/qr-code-icon.png
const qr_code_icon_namespaceObject = __webpack_require__.p + "assets/qr-code-icon-cdeea.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSearchByGamertag/AddFriendSearchByGamertag.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddFriendSearchByGamertag_AddFriendSearchByGamertag = ({"searchOptionsContainer":"XTqtC","searchByQRContainer":"i3br0","searchBorder":"bydU_"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSearchByGamertag/AddFriendSearchByGamertag.tsx









function AddFriendSearchByGamertag_AddFriendSearchByGamertag_AddFriendSearchByGamertag() {
  const {
    t
  } = useLocalization('AddFriendSearchByGamertag');
  const {
    t: narration
  } = useLocalization('AddFriendSearchByGamertag.narration');
  const [searchValue, setSearchValue] = useFacetState('');
  const neutralColors = useSemanticColors('neutral');
  const textFieldNarration = useFacetMap(searchValue => searchValue ? [narration('.searchBar'), searchValue, narration('.searchGamertagHint')].join(' . ') : [narration('.searchBar'), narration('.searchGamertagHint')].join(' . '), [narration], [searchValue]);
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Spacing, {
    size: 3
  }), /*#__PURE__*/React.createElement(Panel, {
    className: classNames(styles.searchBorder, neutralColors.border.base, neutralColors.background.base)
  }, /*#__PURE__*/React.createElement(PanelLabel, {
    disabled: true
  }, t('.searchGamertagDescription')), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.searchOptionsContainer
  }, /*#__PURE__*/React.createElement(BaseTextField, {
    narrationText: textFieldNarration,
    placeholderIcon: PlaceholderIcon.MagnifyingGlass,
    placeholder: t('.searchGamertag'),
    gamepadIndex: 0,
    value: searchValue,
    onChange: setSearchValue
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 3
  }), /*#__PURE__*/React.createElement(NavigationBarLayout.Divider, null), /*#__PURE__*/React.createElement(Spacing, {
    size: 3
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.searchByQRContainer
  }, /*#__PURE__*/React.createElement(Button, {
    variant: "secondary",
    imgSrc: QRCode,
    inputLegend: t('.search'),
    narrationPrefix: narration('.searchByQR')
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendSearchByGamertag/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/Accordion/index.tsx

;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/AddFriendAccordion.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddFriendAccordion_AddFriendAccordion = ({"playerButtonTextWrap":"kbJmt","addPlayerIcon":"PYapd","accordionButtons":"IsVhy","accordionButtonContainer":"C15if"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/images/placeholder-gamertag-image.png
const placeholder_gamertag_image_namespaceObject = __webpack_require__.p + "assets/placeholder-gamertag-image-0ac2b.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/images/add-player-icon.png
const add_player_icon_namespaceObject = __webpack_require__.p + "assets/add-player-icon-05c05.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/images/checkmark-icon.png
const checkmark_icon_namespaceObject = __webpack_require__.p + "assets/checkmark-icon-bcfbf.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/AddFriendAccordion.tsx













function AddFriendAccordion_AddFriendAccordion_AddFriendAccordion({
  title,
  players,
  accordionId,
  scrollViewRef,
  position
}) {
  const {
    t
  } = useLocalization('AddFriendAccordion');
  const {
    t: narration
  } = useLocalization('AddFriendAccordion.narration');
  const accordionTitle = useFacetMap(players => {
    return t('.accordionTitle', [title, `${players.length}`]);
  }, [t, title], [players]);
  const [numberOfPlayersShown, setNumberOfPlayersShown] = useFacetState(0);
  const visiblePlayers = useFacetMap((totalPlayers, number) => {
    return totalPlayers.slice(0, number);
  }, [], [players, numberOfPlayersShown]);
  const allPlayersVisible = useFacetMap((totalPlayers, numberShown) => totalPlayers.length <= numberShown, [], [players, numberOfPlayersShown]);
  const setFocusedId = useSetFocusedId();
  const amountOfItemsPerLoad = 5;
  const focusNewItem = useFacetCallback(visiblePlayers => () => {
    if (visiblePlayers != null && visiblePlayers.length > amountOfItemsPerLoad) {
      const player = visiblePlayers[visiblePlayers.length - amountOfItemsPerLoad];
      setFocusedId(player.gamertag + player.xuid + accordionId);
    }
  }, [setFocusedId, accordionId, amountOfItemsPerLoad], [visiblePlayers]);
  const loadMoreResults = useCallback(() => {
    setNumberOfPlayersShown(prev => prev === NO_VALUE ? prev : prev + amountOfItemsPerLoad);
  }, [setNumberOfPlayersShown, amountOfItemsPerLoad]);
  useEffect(loadMoreResults, [loadMoreResults]);
  const accordionRef = useRef(null);
  const isLastInputPointerFacet = useIsLastInputPointer();
  const scrollToTop = useFacetCallback(isLastInputPointerFacet => () => {
    setFocusedId(accordionId);

    if (isLastInputPointerFacet && scrollViewRef && scrollViewRef.current && accordionRef.current) {
      if (scrollViewRef.current.scrollHeight && accordionRef.current.offsetTop) {
        scrollViewRef.current.scrollTop = accordionRef.current.offsetTop;
      } else {
        requestAnimationFrame(scrollToTop);
      }
    }
  }, [scrollViewRef, accordionRef, setFocusedId, accordionId], [isLastInputPointerFacet]);
  const accordionNarrationText = useFacetMap(players => [narration('.enumeration', [`${position[0]}`, `${position[1]}`]), `${players.length} ${title} ${narration('.suggestions')}`].join(' . '), [title, position, narration], [players]);
  return /*#__PURE__*/React.createElement("div", {
    ref: accordionRef,
    id: accordionId
  }, /*#__PURE__*/React.createElement(Accordion, {
    label: accordionTitle,
    gamepadIndex: 0,
    narrationHint: accordionNarrationText,
    onExpandNarrationHint: t('.genericOnExpandNarrationHint'),
    gamepadAlias: accordionId,
    alwaysShowHint: true
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.accordionButtonContainer
  }, /*#__PURE__*/React.createElement(Map, {
    array: visiblePlayers
  }, (player, index) => /*#__PURE__*/React.createElement(AddFriendAccordionButton, {
    player: player,
    accordionId: accordionId,
    index: index + 1,
    visiblePlayers: visiblePlayers,
    afterLoad: focusNewItem
  })), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.accordionButtons
  }, /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 2,
    horizontal: true,
    narrationSuffix: narration('.enumeration', [`1`, `2`]),
    inputLegend: t('.backToTop'),
    onClick: scrollToTop
  }, t('.backToTop')), /*#__PURE__*/React.createElement(PanelButton.ButtonSpacing, null), /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 3,
    horizontal: true,
    inputLegend: t('.loadMoreResults'),
    narrationSuffix: narration('.enumeration', [`2`, `2`]),
    onClick: loadMoreResults,
    disabled: allPlayersVisible
  }, t('.loadMoreResults'))))));
}

function AddFriendAccordionButton({
  player,
  accordionId,
  index,
  visiblePlayers,
  afterLoad
}) {
  const {
    t
  } = useLocalization('AddFriendAccordion');
  const {
    t: narration
  } = useLocalization('AddFriendAccordion.narration');
  const gamertag = useFacetMap(player => player.gamertag, [], [player]);
  const description = useFacetMap(player => player.description, [], [player]);
  const [isAdded, setIsAdded] = useFacetState(false);
  const isFriend = useFacetMap((player, isAdded) => player.isFollowingMe && (isAdded || player.isFollowedByMe), [], [player, isAdded]);
  const playerGuid = useFacetMap(player => player.gamertag + player.xuid + accordionId, [accordionId], [player]);
  const setFocusedId = useSetFocusedId();
  const narrationText = useFacetMap((gamertag, visiblePlayers, isFriend, isAdded) => [gamertag, narration('.buttonRole'), narration('.enumeration', [`${index}`, `${visiblePlayers.length}`]), narration(isFriend ? '.friendsHint' : isAdded ? '.addedHint' : '.playerHint')].join(' . '), [narration, index], [gamertag, visiblePlayers, isFriend, isAdded]);
  const addFriend = useFacetCallback(playerGuid => () => {
    setIsAdded(true);
    setFocusedId(playerGuid);
  }, [setFocusedId, setIsAdded], [playerGuid]);

  function onClick() {}

  useFacetEffect(visiblePlayers => {
    if (index === visiblePlayers.length) {
      requestAnimationFrame(afterLoad);
    }
  }, [afterLoad, index], [visiblePlayers]);
  return /*#__PURE__*/React.createElement(ListItem, {
    gamepadIndex: 1,
    defaultFocusedChildBehavior: "grid"
  }, /*#__PURE__*/React.createElement(ListItem.Action, {
    gamepadAlias: playerGuid,
    inputLegend: t('.openPlayer'),
    narrationText: narrationText,
    onClick: onClick
  }, /*#__PURE__*/React.createElement(ListItem.Cell, null, /*#__PURE__*/React.createElement(PlayerAvatar, {
    src: gamertagImage,
    variant: "large",
    status: 'offline'
  })), /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement("div", {
    className: styles.playerButtonTextWrap
  }, /*#__PURE__*/React.createElement(Typography, {
    type: "body"
  }, gamertag), /*#__PURE__*/React.createElement(Typography, {
    variant: "dimmer",
    type: "captionShort"
  }, /*#__PURE__*/React.createElement(EllipsisPrimitive, null, description)))), /*#__PURE__*/React.createElement(Mount, {
    when: isAdded
  }, /*#__PURE__*/React.createElement(ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/React.createElement(Image, {
    className: styles.addedAsFriendCheckmark,
    src: checkmarkIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Typography, {
    variant: "dimmer",
    type: "captionShort"
  }, t('.friends')), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  })))), /*#__PURE__*/React.createElement(Mount, {
    when: isAdded,
    condition: false
  }, /*#__PURE__*/React.createElement(ListItem.AdditionalAction, {
    inputLegend: t('.addButtonInputLegend'),
    onClick: addFriend,
    narrationText: [t('.addButtonText'), narration('.buttonRole')].join(' . '),
    gamepadIndex: 2
  }, /*#__PURE__*/React.createElement(ListItem.Cell, {
    align: "center"
  }, /*#__PURE__*/React.createElement(Image, {
    src: addPlayerIcon,
    className: styles.addPlayerIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }), /*#__PURE__*/React.createElement(Typography, {
    align: "center",
    type: "captionTiny"
  }, t('.addButtonText'))))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/AddFriendAccordion/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AddFriendRoute/modals/AddFriendTutorial/AddFriendTutorialModal.tsx






const AddFriendTutorialModal_AddFriendTutorialModal = registerModal(({
  onClose
}) => {
  const {
    t
  } = useLocalization_useLocalization('AddFriendRoute.addFriendTutorialModal');
  const [doNotShowAgain, setDoNotShowAgain] = (0,react_facet_src.useFacetState)(false);
  const optionsSharedFacet = (0,react_facet_src.useSharedFacet)(notificationOptionsFacet_notificationOptionsFacet);
  const handleClose = (0,react_facet_src.useFacetCallback)((optionsSharedFacet, doNotShowAgain) => () => {
    if (doNotShowAgain) {
      optionsSharedFacet.doNotShowAddFriendTutorialMessage = true;
    }

    onClose();
  }, [onClose], [optionsSharedFacet, doNotShowAgain]);
  return /*#__PURE__*/react.createElement(Modal_Modal_Modal, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Header, null, t('.title')), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Content, null, /*#__PURE__*/react.createElement(Modal_Modal_Modal.Text, {
    gamepadIndex: 0,
    narrationText: t('.body'),
    center: true
  }, t('.body'))), /*#__PURE__*/react.createElement(Modal_Modal_Modal.Buttons, {
    header: /*#__PURE__*/react.createElement(Modal_Modal_Modal.Checkbox, {
      value: doNotShowAgain,
      onChange: setDoNotShowAgain,
      title: t('.checkbox')
    })
  }, /*#__PURE__*/react.createElement(Button_Button_Button, {
    gamepadIndex: 0,
    inputLegend: t('.close'),
    variant: "primary",
    onClick: handleClose
  }, t('.close'))));
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AddFriendRoute/AddFriendRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddFriendRoute = ({"desktopMainMenu":"uWyEk","columnsContainer":"DnCO_"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/AddFriendRoute/AddFriendRoute.tsx














function AddFriendRoute_AddFriendRoute() {
  const {
    t
  } = useLocalization('AddFriendRoute');
  const optionsSharedFacet = useSharedFacet(notificationOptionsFacet);
  const addFriendTutorialModal = AddFriendTutorialModal.useModal();
  const doNotShowAddFriendTutorialMessage = useFacetMap(optionsSharedFacet => optionsSharedFacet.doNotShowAddFriendTutorialMessage, [], [optionsSharedFacet]);
  useFacetEffect(doNotShow => {
    if (!doNotShow) {
      addFriendTutorialModal.show();
    }
  }, [addFriendTutorialModal], [doNotShowAddFriendTutorialMessage]);
  const recentlyPlayedWith = useFacetMap(recentlyPlayedWith => recentlyPlayedWith.playerList, [], [useSharedFacet(recentlyPlayedWithListFacet)]);
  const followers = useFacetMap(followers => followers.playerList, [], [useSharedFacet(followersListFacet)]);
  const realmMembers = useFacetMap(realmMembers => realmMembers.playerList, [], [useSharedFacet(realmMembersListFacet)]);
  const mutualFriends = useFacetMap(mutualFriends => mutualFriends.playerList, [], [useSharedFacet(mutualFriendsListFacet)]);
  const familyMembers = useFacetMap(familyMembers => familyMembers.playerList, [], [useSharedFacet(familyMembersListFacet)]);
  const breakpoint = useWindowBreakpoint();
  const scrollViewRef = useRef(null);
  const accordionsData = [{
    title: t('.recentlyPlayedWith'),
    players: recentlyPlayedWith,
    accordionId: t('.recentlyPlayedWithAccordionId')
  }, {
    title: t('.followers'),
    players: followers,
    accordionId: t('.followersAccordionId')
  }, {
    title: t('.realmMembers'),
    players: realmMembers,
    accordionId: t('.realmMembersAccordionId')
  }, {
    title: t('.mutualFriends'),
    players: mutualFriends,
    accordionId: t('.mutualFriendsAccordionId')
  }, {
    title: t('.familyMembers'),
    players: familyMembers,
    accordionId: t('.familyMembersAccordionId')
  }];
  const accordions = accordionsData.map((data, index) => /*#__PURE__*/React.createElement("div", {
    key: data.title
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 4
  }), /*#__PURE__*/React.createElement(AddFriendAccordion, {
    title: data.title,
    players: data.players,
    accordionId: data.accordionId,
    scrollViewRef: scrollViewRef,
    position: [index + 1, accordionsData.length]
  })));
  return /*#__PURE__*/React.createElement(VanillaScreenLayout, {
    title: t('.header'),
    screenAnalyticsId: "AddFriend",
    gamepadAlias: "add-friend-route",
    delegateByAlias: "add-friend-route"
  }, () => /*#__PURE__*/React.createElement(Grid, {
    narrowBreakpointWidth: 0
  }, /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.columnsContainer
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 1,
    wideSize: 8,
    narrowSize: 5
  }, /*#__PURE__*/React.createElement(ScrollView, {
    floating: breakpoint !== 'desktop',
    gamepadIndex: 0,
    innerRef: scrollViewRef
  }, /*#__PURE__*/React.createElement("div", {
    className: `${breakpoint === 'desktop' ? styles.desktopMainMenu : ''}`
  }, breakpoint === 'desktop' && /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(AddFriendSearchByGamertag, null), accordions))), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/React.createElement(AddFriendSideMenu, null)))), /*#__PURE__*/React.createElement(Mount, {
    when: addFriendTutorialModal.isVisible
  }, /*#__PURE__*/React.createElement(AddFriendTutorialModal.Component, {
    onClose: addFriendTutorialModal.hide
  }))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/hanger.png
const hanger_namespaceObject = __webpack_require__.p + "assets/hanger-3e72e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/options.png
const PlayerCard_images_options_namespaceObject = __webpack_require__.p + "assets/options-4558c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/screenshot_placeholder.png
const screenshot_placeholder_namespaceObject = __webpack_require__.p + "assets/screenshot_placeholder-798c9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/paperdoll_placeholder.png
const paperdoll_placeholder_namespaceObject = __webpack_require__.p + "assets/paperdoll_placeholder-26d4c.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/play.png
const PlayerCard_images_play_namespaceObject = __webpack_require__.p + "assets/play-7c0c9.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/friends.png
const friends_namespaceObject = __webpack_require__.p + "assets/friends-6037f.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/add_friend.png
const add_friend_namespaceObject = __webpack_require__.p + "assets/add_friend-05c05.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/external_link.png
const PlayerCard_images_external_link_namespaceObject = __webpack_require__.p + "assets/external_link-0e493.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/images/checkmark_square.png
const checkmark_square_namespaceObject = __webpack_require__.p + "assets/checkmark_square-3c7c4.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/PlayerCard.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const PlayerCard_PlayerCard = ({"card":"DNV19","screenshot":"TS1P0","headshot":"gJfaZ","paperdoll":"s1JOv","paperdollPositionNoRealName":"Hs6TZ","textContainer":"D2cU3","buttonContainer":"LRdj7","imageContainer":"JmycD","squareButton":"GeM93","statusBox":"wJgSN","muteBlockStatus":"ts5CU"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/PlayerCard/PlayerCard.tsx
function PlayerCard_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function PlayerCard_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PlayerCard_ownKeys(Object(source), true).forEach(function (key) { PlayerCard_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PlayerCard_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PlayerCard_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























function PlayerCard_PlayerCard_PlayerCard({
  player
}) {
  const {
    t
  } = useLocalization('PlayerCard');
  const semanticColors = useSemanticColors('neutral80');
  const [showOptionsModal, setShowOptionsModal] = useFacetState(false);
  const playerFacet = useFacetWrap(player);
  const socialManagerFacet = useSharedFacet(playerSocialManagerFacet);
  const paperdollClassname = useFacetMap(player => classnames(styles.paperdoll, {
    [styles.paperdollPositionNoRealName]: !player.realName
  }), [], [playerFacet]);
  const addFriendClick = useFacetCallback((socialManager, player) => () => socialManager.addFriend(player.xuid), [], [socialManagerFacet, playerFacet]);
  return /*#__PURE__*/React.createElement(SemanticRoleProvider, {
    role: "neutral"
  }, /*#__PURE__*/React.createElement(NarrationContext, {
    text: t('.cardNarration')
  }, /*#__PURE__*/React.createElement("div", {
    className: classnames(styles.card, semanticColors.background.base, semanticColors.border.base)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.imageContainer
  }, /*#__PURE__*/React.createElement(Image, {
    className: classnames(styles.screenshot, semanticColors.border.base),
    src: screenshotPlaceholder,
    imageRendering: "pixelated",
    aspectRatio: Image.AspectRatio['16:9']
  }), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.isBlocked, [], [playerFacet])
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.muteBlockStatus
  }, /*#__PURE__*/React.createElement(Tag, {
    role: "destructiveTint"
  }, t('.blocked')))), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.isMuted && !player.isBlocked, [], [playerFacet])
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.muteBlockStatus
  }, /*#__PURE__*/React.createElement(Tag, {
    role: "noticeTint"
  }, t('.muted')))), /*#__PURE__*/React.createElement(Image, {
    className: paperdollClassname,
    src: paperdollPlaceholder,
    imageRendering: "pixelated"
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.headshot
  }, /*#__PURE__*/React.createElement(PlayerAvatar, {
    src: useFacetMap(player => player.gamerIcon, [], [playerFacet]),
    variant: "large",
    status: useFacetMap(player => player.isOnline ? 'online' : 'offline', [], [playerFacet])
  }))), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.textContainer
  }, /*#__PURE__*/React.createElement(Typography, {
    type: "header5B"
  }, /*#__PURE__*/React.createElement(EllipsisPrimitive, null, useFacetMap(player => player.gamerTag, [], [playerFacet]))), /*#__PURE__*/React.createElement(With, {
    data: useFacetMap(player => player.realName, [], [playerFacet])
  }, realName => /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmer"
  }, /*#__PURE__*/React.createElement(EllipsisPrimitive, null, realName)))), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.buttonContainer
  }, /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.relation === PlayerRelation.Self, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.dressingRoomButton'),
    imgSrc: hangerIcon,
    horizontal: true
  }, t('.dressingRoomButton'))), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.relation === PlayerRelation.Friend && !player.isCurrentlyPlaying, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(StatusBox, {
    narrationText: t('.friendsButton')
  }, /*#__PURE__*/React.createElement(ButtonContent, {
    typeVariant: "dimmer",
    imgSrc: friendsIcon,
    role: "neutral100"
  }, t('.friendsButton')))), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.relation === PlayerRelation.Friend && player.isCurrentlyPlaying, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.joinButton'),
    variant: "primary",
    imgSrc: playIcon,
    horizontal: true
  }, t('.joinButton'))), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.relation === PlayerRelation.Following, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(StatusBox, {
    narrationText: t('.addedButton')
  }, /*#__PURE__*/React.createElement(ButtonContent, {
    typeVariant: "dimmer",
    imgSrc: checkmarkSquareIcon
  }, t('.addedButton')))), /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.relation === PlayerRelation.Follower || player.relation === PlayerRelation.Stranger, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.addFriendButton'),
    variant: "primary",
    imgSrc: addFriendIcon,
    horizontal: true,
    onClick: addFriendClick
  }, t('.addFriendButton'))), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.squareButton
  }, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.optionsButton'),
    narrationPrefix: t('.optionsButton'),
    imgSrc: optionsIcon,
    onClick: () => setShowOptionsModal(true)
  }))))), /*#__PURE__*/React.createElement(Mount, {
    when: showOptionsModal
  }, /*#__PURE__*/React.createElement(PlayerCardOptionsModal.Component, {
    onClose: () => setShowOptionsModal(false),
    player: player
  })));
}

function StatusBox({
  children,
  narrationText
}) {
  return /*#__PURE__*/React.createElement(BoxBorder, {
    gamepadIndex: 0,
    inputLegend: false,
    narrationText: narrationText,
    onClick: () => {},
    className: styles.statusBox
  }, children);
}

var PlayerCardOptionValue;

(function (PlayerCardOptionValue) {
  PlayerCardOptionValue[PlayerCardOptionValue["RemoveFriend"] = 0] = "RemoveFriend";
  PlayerCardOptionValue[PlayerCardOptionValue["Block"] = 1] = "Block";
  PlayerCardOptionValue[PlayerCardOptionValue["Mute"] = 2] = "Mute";
  PlayerCardOptionValue[PlayerCardOptionValue["Report"] = 3] = "Report";
  PlayerCardOptionValue[PlayerCardOptionValue["ViewXboxProfile"] = 4] = "ViewXboxProfile";
})(PlayerCardOptionValue || (PlayerCardOptionValue = {}));

const PlayerCardOptionsModal = registerModal(function PlayerCardOptions({
  onClose,
  player
}) {
  const {
    t
  } = useLocalization_useLocalization('PlayerCard');
  const socialManagerFacet = (0,react_facet_src.useSharedFacet)(playerSocialManagerFacet_playerSocialManagerFacet);
  const playerFacet = (0,react_facet_src.useFacetWrap)(player);
  const removeFriendClick = (0,react_facet_src.useFacetCallback)((socialManager, player) => () => socialManager.removeFriend(player.xuid), [], [socialManagerFacet, playerFacet]);
  const blockClick = (0,react_facet_src.useFacetCallback)((socialManager, player) => () => player.isBlocked ? socialManager.unblock(player.xuid) : socialManager.block(player.xuid), [], [socialManagerFacet, playerFacet]);
  const muteClick = (0,react_facet_src.useFacetCallback)((socialManager, player) => () => player.isMuted ? socialManager.unmute(player.xuid) : socialManager.mute(player.xuid), [], [socialManagerFacet, playerFacet]); // todo: other options for different variants

  const items = (0,react_facet_src.useFacetMap)(player => {
    const options = [{
      label: t('.removeFriend'),
      value: PlayerCardOptionValue.RemoveFriend
    }, {
      label: t('.block'),
      value: PlayerCardOptionValue.Block,
      isSelected: player.isBlocked,
      isSelectable: true
    }, {
      label: t('.mute'),
      value: PlayerCardOptionValue.Mute,
      isSelected: player.isMuted,
      isSelectable: true
    }, {
      label: t('.report'),
      value: PlayerCardOptionValue.Report
    }, {
      label: t('.viewXboxProfile'),
      value: PlayerCardOptionValue.ViewXboxProfile,
      imageSource: PlayerCard_images_external_link_namespaceObject
    }];
    return options.map((item, index) => PlayerCard_objectSpread(PlayerCard_objectSpread({}, item), {}, {
      gamepadAlias: `options${index}`,
      enumeration: t('.optionsEnumeration', [`${index + 1}`, `${options.length}`])
    }));
  }, [t], [playerFacet]);
  const onItemSelect = (0,react.useCallback)(optionValue => {
    switch (optionValue) {
      case PlayerCardOptionValue.RemoveFriend:
        removeFriendClick();
        break;

      case PlayerCardOptionValue.Block:
        blockClick();
        break;

      case PlayerCardOptionValue.Mute:
        muteClick();
        break;

      case PlayerCardOptionValue.Report:
        break;
    }
  }, [removeFriendClick, blockClick, muteClick]);
  return /*#__PURE__*/react.createElement(ModalMenu_ModalMenu, {
    onClose: onClose,
    onItemSelect: onItemSelect,
    isOpen: true,
    title: t('.optionsButton'),
    items: items
  });
});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/images/achievements.png
const images_achievements_namespaceObject = __webpack_require__.p + "assets/achievements-301b6.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/images/friends.png
const ProfileRoute_images_friends_namespaceObject = __webpack_require__.p + "assets/friends-046cd.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/images/screenshots.png
const screenshots_namespaceObject = __webpack_require__.p + "assets/screenshots-5c5f5.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/images/gamerscore_filled.png
const gamerscore_filled_namespaceObject = __webpack_require__.p + "assets/gamerscore_filled-60e3e.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/ProfileRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const ProfileRoute = ({"compareButtonContainer":"J35O9","overviewItemImage":"hfWsq"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/StatListItem/images/achievements.png
const StatListItem_images_achievements_namespaceObject = __webpack_require__.p + "assets/achievements-01d19.png";
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/StatListItem/StatListItem.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const StatListItem_StatListItem = ({"valueRow":"gQkMG"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/components/StatListItem/StatListItem.tsx








const StatListItem_StatListItem_StatListItem = ({
  item,
  index,
  listLength
}) => {
  const {
    t
  } = useLocalization('StatListItem');
  return /*#__PURE__*/React.createElement(ListItem, {
    gamepadIndex: index,
    isFocusable: true,
    narrationText: useFacetMap((item, listLength) => [item.label, item.compareValue == null ? item.value : t('.compareNarration', [`${item.value}`, `${item.compareValue}`]), t('.itemNarration', [`${index + 1}`, `${listLength}`])].join(' . '), [index, t], [item, listLength])
  }, /*#__PURE__*/React.createElement(ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Image, {
    src: achievementsIcon,
    imageRendering: "pixelated"
  })), /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, useFacetMap(item => item.label, [], [item])), /*#__PURE__*/React.createElement("div", {
    className: styles.valueRow
  }, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort"
  }, useFacetMap(item => item.value, [], [item])), /*#__PURE__*/React.createElement(With, {
    data: useFacetMap(item => item.compareValue, [], [item])
  }, compareValue => /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort"
  }, compareValue))), /*#__PURE__*/React.createElement(With, {
    data: useFacetMap(item => item.compareValue != null ? item.value / (item.compareValue + item.value) : undefined, [], [item])
  }, percentage => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }), /*#__PURE__*/React.createElement(ProgressBar, {
    percentage: percentage
  })))));
};
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/hooks/useLoadPlayerAchievementsFacet.ts



/**
 * A hook to load the achievement data for the given id
 * (populates playerAchievementsFacet)
 * @param playerId player xuid from url param
 */

function useLoadPlayerAchievementsFacet_useLoadPlayerAchievementsFacet(playerId) {
  const load = useFacetCallback(playerAchievements => playerId => {
    playerAchievements.load(playerId);
  }, [], [useSharedFacet(playerAchievementsFacet)]);
  useEffect(() => {
    load(playerId);
  }, [load, playerId]);
}
/**
 * A hook to clear the achievement data
 */

function useLoadPlayerAchievementsFacet_useUnloadPlayerAchievementsFacet() {
  const unload = useFacetCallback(facet => () => {
    facet.unload();
  }, [], [useSharedFacet(playerAchievementsFacet)]);
  useEffect(() => () => {
    unload();
  }, [unload]);
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/ProfileRoute/ProfileRoute.tsx
























function ProfileRoute_ProfileRoute() {
  const {
    t
  } = useLocalization('ProfileRoute');
  const params = useRouteParamsUnwrapped();
  useLoadPlayerProfileFacet(params.id);
  useLoadPlayerAchievementsFacet(params.id);
  useUnloadPlayerAchievementsFacet();
  const playerFacet = useSharedFacet(playerProfileFacet);
  return /*#__PURE__*/React.createElement(VanillaScreenLayout, {
    title: useFacetMap(player => !player.loaded || player.data.relation === PlayerRelation.Self ? t('.headerSelf') : t('.headerOther', [`${player.data.gamerTag}`]), [t], [playerFacet]),
    screenAnalyticsId: "Profile",
    gamepadAlias: "profile-route",
    delegateByAlias: "profile-route"
  }, () => /*#__PURE__*/React.createElement(ProfileContent, null));
}

const ProfileContent = () => {
  const setFocusedId = useSetFocusedId();
  const playerFacet = useSharedFacet(playerProfileFacet);
  const params = useRouteParamsUnwrapped();
  const {
    t
  } = useLocalization('ProfileRoute');
  const tabs = [{
    label: t('.overviewTabButtonLabel'),
    value: 'overview'
  }, {
    label: t('.statsTabButtonLabel'),
    value: 'stats'
  }];
  const historyAPI = useRouteHistory();
  return /*#__PURE__*/React.createElement(Grid, {
    narrowBreakpointWidth: 102
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 4,
    narrowSize: 3
  }, /*#__PURE__*/React.createElement(Mount, {
    when: useFacetMap(player => player.loaded, [], [playerFacet])
  }, /*#__PURE__*/React.createElement(PlayerCard, {
    player: useFacetMap(player => player.data, [], [playerFacet])
  }))), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 1,
    wideSize: 8,
    narrowSize: 5
  }, /*#__PURE__*/React.createElement(TabBar, {
    gamepadAliasNamespace: 'profile-route',
    gamepadIndex: 0,
    value: params.tab,
    onChange: newValue => {
      setFocusedId(TabBar.getFocusAlias('profile-route', newValue));
      historyAPI.replace(`/profile/${params.id}/${newValue}`);
    },
    tabs: tabs,
    narrationTitle: t('.narration.title')
  }), /*#__PURE__*/React.createElement(TabWrapper, {
    tab: "overview",
    component: OverviewTab
  }), /*#__PURE__*/React.createElement(TabWrapper, {
    tab: "stats",
    component: StatsTab
  }))));
};

const OverviewWrapper = () => {
  const routerAPI = useRouterAPI();
  const {
    t
  } = useLocalization('ProfileRoute');
  const friends = 34;
  const followers = 125;
  const screenshots = 0;
  const screenshotsTotal = 160;
  const achievementsLoaded = useFacetMap(facet => facet.status === AchievementFacetStatus.LOADED, [], [useSharedFacet(playerAchievementsFacet)]);
  const playerAchievementsSummaryFacet = useSharedFacet(playerAchievementsSummarySelector);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ListItem, {
    gamepadIndex: 0
  }, /*#__PURE__*/React.createElement(ListItem.Action, {
    gamepadIndex: 0,
    narrationText: t('.friendsNarration', [`${friends}`]),
    inputLegend: t('.friendsInputLegend'),
    onClick: () => routerAPI.push(`/player-list/id/friends`)
  }, /*#__PURE__*/React.createElement(ListItem.Cell, null, /*#__PURE__*/React.createElement(Image, {
    src: friendsIcon,
    imageRendering: "pixelated",
    className: styles.overviewItemImage
  })), /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, t('.friendsItemLabel')), /*#__PURE__*/React.createElement(Typography, {
    type: "body"
  }, friends))), /*#__PURE__*/React.createElement(ListItem.Action, {
    gamepadIndex: 1,
    narrationText: t('.followersNarration', [`${followers}`]),
    inputLegend: t('.followersInputLegend'),
    onClick: () => routerAPI.push(`/player-list/id/followers`)
  }, /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, t('.followersItemLabel')), /*#__PURE__*/React.createElement(Typography, {
    type: "body"
  }, followers)))), /*#__PURE__*/React.createElement(ListItem, {
    gamepadIndex: 1
  }, /*#__PURE__*/React.createElement(ListItem.Action, {
    gamepadIndex: 0,
    narrationText: t('.screenshotsNarration', [`${screenshots}`, `${screenshotsTotal}`]),
    inputLegend: t('.screenshotsInputLegend'),
    onClick: () => {}
  }, /*#__PURE__*/React.createElement(ListItem.Cell, null, /*#__PURE__*/React.createElement(Image, {
    src: screenshotsIcon,
    imageRendering: "pixelated",
    className: styles.overviewItemImage
  })), /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, t('.screenshotsItemLabel')), /*#__PURE__*/React.createElement(Typography, {
    type: "body"
  }, t('.listItemFractionValue', [`${screenshots}`, `${screenshotsTotal}`]))))), /*#__PURE__*/React.createElement(Mount, {
    when: achievementsLoaded
  }, /*#__PURE__*/React.createElement(ListItem, {
    gamepadIndex: 2
  }, /*#__PURE__*/React.createElement(ListItem.Action, {
    gamepadIndex: 0,
    narrationText: useFacetMap(summary => [t('.achievementsNarration', [`${summary.unlocked}`, `${summary.total}`]), t('.gamerscoreNarration', [`${summary.gamerScore}`, `${summary.maxGamerScore}`])].join(' . '), [t], [playerAchievementsSummaryFacet]),
    inputLegend: t('.achievementsInputLegend'),
    onClick: () => {}
  }, /*#__PURE__*/React.createElement(ListItem.Cell, null, /*#__PURE__*/React.createElement(Image, {
    src: achievementsIcon,
    imageRendering: "pixelated",
    className: styles.overviewItemImage
  })), /*#__PURE__*/React.createElement(ListItem.Main, null, /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, t('.achievementsItemLabel')), /*#__PURE__*/React.createElement(Typography, {
    type: "body"
  }, useFacetMap(summary => t('.listItemFractionValue', [`${summary.unlocked}`, `${summary.total}`]), [t], [playerAchievementsSummaryFacet]))), /*#__PURE__*/React.createElement(ListItem.Cell, {
    direction: "row"
  }, /*#__PURE__*/React.createElement(Image, {
    src: gamerscoreFilledIcon,
    imageRendering: "pixelated"
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Typography, {
    type: "captionShort",
    variant: "dimmest"
  }, useFacetMap(summary => t('.listItemFractionValue', [`${summary.gamerScore}`, `${summary.maxGamerScore}`]), [t], [playerAchievementsSummaryFacet])), /*#__PURE__*/React.createElement(Spacing, {
    size: 1
  }))))));
};

function OverviewTab() {
  const {
    t
  } = useLocalization('ProfileRoute');
  const breakpoint = useWindowBreakpoint();
  return /*#__PURE__*/React.createElement(ScrollView, {
    gamepadIndex: 1,
    floating: breakpoint !== 'desktop',
    defaultFocusedChildBehavior: "remember"
  }, /*#__PURE__*/React.createElement(NarrationContext, {
    text: t('.tabNarration', [t('.overviewTabButtonLabel'), '1', '2'])
  }, /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RenderTrackingEvent, {
    type: "contentful",
    renderingCompleted: true
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(OverviewWrapper, null), /*#__PURE__*/React.createElement(SectionList, {
    gamepadIndex: 3,
    header: /*#__PURE__*/React.createElement(Spacing, {
      size: 4
    }),
    loading: useFacetMap(loaded => !loaded, [], [useSharedFacet(isPlayerAchievementsLoadedSelector)]),
    data: useFacetMap(allAchievementsSorted => [{
      role: 'informativeTint',
      title: t('.suggestedAchievementsListLabel'),
      data: allAchievementsSorted.suggested.slice(0, 3)
    }, {
      role: 'successTint',
      title: t('.completedAchievementsListLabel'),
      data: allAchievementsSorted.completed.slice(0, 10)
    }], [t], [useSharedFacet(playerGroupedAchievementsSelector)]),
    footer: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLegend.Space, {
      extraSpace: /*#__PURE__*/React.createElement(Spacing, {
        size: 1
      })
    }), /*#__PURE__*/React.createElement(Spacing, {
      size: 1
    })),
    sectionSeparator: /*#__PURE__*/React.createElement(Spacing, {
      size: 4
    }),
    renderSectionHeader: (title, role) => /*#__PURE__*/React.createElement(ListHeader, {
      role: role,
      label: title
    }),
    renderItem: ({
      itemFacet,
      index,
      sectionIndex,
      listLengthFacet
    }) => /*#__PURE__*/React.createElement(ProfileRoute_AchievementListItemWrapper, {
      item: itemFacet,
      index: index,
      sectionIndex: sectionIndex,
      listLength: listLengthFacet
    }),
    renderTracker: isContentShown => /*#__PURE__*/React.createElement(RenderTrackingEvent, {
      type: "meaningful",
      renderingCompleted: isContentShown
    }),
    padSpinnerVertically: true
  }))));
}

const ProfileRoute_AchievementListItemWrapper = ({
  item,
  index,
  listLength
}) => {
  const historyAPI = useRouteHistory();
  return /*#__PURE__*/React.createElement(AchievementListItem, {
    item: item,
    onClick: useFacetCallback(item => () => {
      historyAPI.push(`/achievement-detail/${item.id}`);
    }, [historyAPI], [item]),
    index: index,
    listLength: listLength
  });
};

function StatsTab() {
  const {
    t
  } = useLocalization('ProfileRoute');
  const routerAPI = useRouterAPI();
  const data = Array.from(Array(20).keys()).map(key => ({
    label: `Label ${key}`,
    value: key
  }));
  return /*#__PURE__*/React.createElement(NarrationContext, {
    text: t('.tabNarration', [t('.statsTabButtonLabel'), '2', '2'])
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.compareButtonContainer
  }, /*#__PURE__*/React.createElement(Button, {
    inputLegend: t('.compareStats'),
    onClick: () => routerAPI.push('/compare-stats/id')
  }, t('.compareStats'))), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(FlatList, {
    gamepadIndex: 0,
    data: data,
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/React.createElement(StatListItem, {
      item: itemFacet,
      index: index,
      listLength: listLengthFacet
    }),
    footer: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLegend.Space, {
      extraSpace: /*#__PURE__*/React.createElement(Spacing, {
        size: 1
      })
    }), /*#__PURE__*/React.createElement(Spacing, {
      size: 1
    }))
  }));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/PlayerListRoute/PlayerListRoute.tsx
function PlayerListRoute_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function PlayerListRoute_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { PlayerListRoute_ownKeys(Object(source), true).forEach(function (key) { PlayerListRoute_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { PlayerListRoute_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function PlayerListRoute_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function PlayerListRoute() {
  const {
    t
  } = useLocalization('PlayerListRoute');
  const params = useRouteParamsUnwrapped();
  const header = params.type === 'friends' ? t('.headerFriends') : t('.headerFollowers');
  const friendsLoading = useFacetMap(friendsList => !friendsList.isLoaded, [], [useSharedFacet(friendsListFacet)]);
  const friends = useFacetMap(friendsList => friendsList.friends.map(item => PlayerListRoute_objectSpread(PlayerListRoute_objectSpread({}, item), {}, {
    variant: 'friend'
  })), [], [useSharedFacet(friendsListFacet)]);
  return /*#__PURE__*/React.createElement(VanillaScreenLayout, {
    title: header,
    screenAnalyticsId: "PlayerList",
    gamepadAlias: "player-list-route",
    delegateByAlias: "player-list-route"
  }, () => /*#__PURE__*/React.createElement(Grid, {
    narrowBreakpointWidth: 102
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 10,
    narrowSize: 8
  }, /*#__PURE__*/React.createElement(FlatList, {
    gamepadIndex: 0,
    header: /*#__PURE__*/React.createElement(Spacing, {
      size: 2
    }),
    loading: friendsLoading,
    data: friends,
    footer: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLegend.Space, null), /*#__PURE__*/React.createElement(Spacing, {
      size: 2
    })),
    renderItem: FriendListItemRouteOnClick
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CompareStatsRoute/CompareStatsRoute.css
// extracted by mini-css-extract-plugin
/* harmony default export */ const CompareStatsRoute = ({"playerCompareRow":"bo_jd"});
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/CompareStatsRoute/CompareStatsRoute.tsx










function CompareStatsRoute_CompareStatsRoute() {
  const {
    t
  } = useLocalization('CompareStatsRoute');
  const data = Array.from(Array(21).keys()).map(key => ({
    label: `Label ${key}`,
    value: key,
    compareValue: 20 - key
  }));
  const friendsFacet = useSharedFacet(friendsListFacet);
  const friendsLoaded = useFacetMap(friendsList => friendsList.isLoaded, [], [friendsFacet]);
  const friend0 = useFacetMap(friendsList => friendsList.friends.map(item => withVariant(item, 'friend'))[0], [], [friendsFacet]);
  const friend1 = useFacetMap(friendsList => friendsList.friends.map(item => withVariant(item, 'friend'))[1], [], [friendsFacet]);
  const listLengthFacet = useFacetWrap(2);
  return /*#__PURE__*/React.createElement(VanillaScreenLayout, {
    title: t('.header'),
    screenAnalyticsId: "CompareStats",
    gamepadAlias: "compare-stats-route",
    delegateByAlias: "compare-stats-route"
  }, () => /*#__PURE__*/React.createElement(Grid, {
    narrowBreakpointWidth: 102
  }, /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(Grid.Row, {
    gamepadIndex: 0,
    fullHeight: true
  }, /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 1,
    narrowSize: 0
  }), /*#__PURE__*/React.createElement(Grid.Column, {
    gamepadIndex: 0,
    wideSize: 10,
    narrowSize: 8
  }, /*#__PURE__*/React.createElement(Mount, {
    when: friendsLoaded
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.playerCompareRow
  }, /*#__PURE__*/React.createElement(FriendListItem, {
    item: friend0,
    onClick: () => {},
    listLength: listLengthFacet,
    gamepadIndex: 0
  }), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(FriendListItem, {
    item: friend1,
    onClick: () => {},
    listLength: listLengthFacet,
    gamepadIndex: 0
  }))), /*#__PURE__*/React.createElement(Spacing, {
    size: 2
  }), /*#__PURE__*/React.createElement(FlatList, {
    gamepadIndex: 0,
    data: data,
    renderItem: ({
      itemFacet,
      index,
      listLengthFacet
    }) => /*#__PURE__*/React.createElement(StatListItem, {
      item: itemFacet,
      index: index,
      listLength: listLengthFacet
    }),
    footer: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLegend.Space, null), /*#__PURE__*/React.createElement(Spacing, {
      size: 2
    }))
  })))));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsPDPRoute/RealmsPDPRoute.tsx



function RealmsPDPRoute() {
  const {
    t
  } = useLocalization('RealmsPDPScreen');
  return /*#__PURE__*/React.createElement(VanillaScreenLayout, {
    screenAnalyticsId: "Realms-PDP",
    gamepadAlias: "realms-pdp",
    title: t('.title')
  }, () => /*#__PURE__*/React.createElement("div", null));
}
;// CONCATENATED MODULE: ./games/vanilla/main/src/routes/RealmsPDPRoute/index.ts

;// CONCATENATED MODULE: ./games/vanilla/main/src/index.screen.tsx




















































 // eslint-disable-next-line @typescript-eslint/no-unused-vars

const EmptyRoute = () => {
  const history = useRouteHistory();
  return /*#__PURE__*/React.createElement(Modal, null, /*#__PURE__*/React.createElement(Modal.Header, null, "Missing Route"), /*#__PURE__*/React.createElement(Modal.Content, null, /*#__PURE__*/React.createElement(Modal.Text, {
    gamepadIndex: 0,
    narrationText: "The route you're trying to access isn't included in this build. Did you remember to enable the environment variable?"
  }, "The route you're trying to access isn't included in this build. Did you remember to enable the environment variable?")), /*#__PURE__*/React.createElement(Modal.Buttons, null, /*#__PURE__*/React.createElement(Button, {
    gamepadIndex: 0,
    autofocus: true,
    inputLegend: "Go Back",
    variant: "primary",
    onClick: () => history.goBack()
  }, "Go Back")));
}; // eslint-disable-next-line import/no-default-export


function App() {
  return /*#__PURE__*/react.createElement(Application, {
    scalingMode: 'legacy',
    defaultRoute:  false ? 0 : '/create-new-world',
    scope: ['in-game', 'out-of-game'],
    errorComponent: ErrorModal_ErrorModal,
    developmentTranslations: allTranslationsUsedByVanilla,
    gamepadAdapterVersion: GamepadAdapterVersion.VISUAL,
    semanticCollection: vanillaCollection
  }, /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/achievements/:tab?",
    component: AchievementsRoute_AchievementsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['completed', 'locked'].map(status => ({
      status: status
    }))
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/achievement-detail/:id",
    component: AchievementDetailsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: [{
      id: '0'
    }]
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/quick-create-new-world/mode",
    component: QuickWorldCreationRoute_QuickWorldCreationRoute.Mode,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/quick-create-new-world/survival/difficulty",
    component: QuickWorldCreationRoute_QuickWorldCreationRoute.Difficulty,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/quick-create-new-world/:mode/:difficulty/touch-control-selection",
    component: QuickWorldCreationRoute_QuickWorldCreationRoute.TouchControlSelection,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/create-new-world/seed-templates",
    component: SeedTemplateRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/create-new-world/:tab/:worldTemplateId?",
    component: CreateNewWorldRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: createNewWorldTabValues.map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(Redirect, {
    from: "/create-new-world",
    to: "/create-new-world/general"
  }),  false && /*#__PURE__*/0, /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/play/touch-control-selection/:id",
    component: WorldStartupTouchControlSelectionRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }),  false && /*#__PURE__*/0, /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/play/:tab/:id?/:type?",
    component: PlayScreenRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['all', 'realms', 'servers', 'friends'].map(tab => ({
      tab: tab
    }))
  }),  false && /*#__PURE__*/0, /*#__PURE__*/react.createElement(Redirect, {
    from: "/play",
    to: "/play/all"
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/mobile-data-blocked-modal/show-modal",
    component: MobileDataBlockedModalRoute_MobileDataBlockedModalRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/render-distance-warning-modal",
    component: RenderDistanceWarningRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/touch-control-selection",
    component: TouchControlSelectionRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-choose-realm/:tab",
    component: ChooseRealmRoute_ChooseRealmRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['preview-realms', 'realm-subscriptions'].map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-choose-slot/:id",
    component: ChooseSlotRoute_ChooseSlotRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['12345'].map(id => ({
      id: id
    }))
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-stories/:tab/:realmId?",
    component: RealmsStoriesRoute_RealmsStoriesRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: realmsStoriesTabValues.map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(Redirect, {
    from: "/realms-stories",
    to: "/realms-stories/feed"
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-story-comments/:id",
    component: RealmsStoriesCommentsRoute_RealmsStoriesCommentsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-story-entry-route/:tab/:realmId?",
    component: RealmsStoryEntryRoute,
    knownEntries: realmsStoriesTabValues.map(tab => ({
      tab: tab
    })),
    modes: ['modal']
  }), /*#__PURE__*/react.createElement(Redirect, {
    from: "/realms-story-entry-route",
    to: "/realms-story-entry-route/feed"
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-story-opt-in/:realmId?",
    component: RealmsStoryOptInRoute_RealmsStoryOptInRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-new-story",
    component: RealmsNewStoryRoute_RealmsNewStoryRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-new-story/image-select",
    component: RealmsNewStoryImageSelectRoute_RealmsNewStoryImageSelectRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/announcement-modal/:id",
    component: AnnouncementModalRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition,
    knownEntries: [{
      id: '0'
    }]
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-stories-settings/:realmId?",
    component: RealmsStoriesSettingsRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/player-banned-modal",
    component: PlayerBannedModalRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/player-report",
    component: ReportPlayerRoute,
    transitionComponent: RouteInstantTransition_RouteInstantTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-achievements",
    component: SignInAchievementsRoute_SignInAchievementsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    unmountOnPush: true
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-add-friend",
    component: SignInAddFriendRoute_SignInAddFriendRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-play-on-server",
    component: SignInPlayOnServerRoute_SignInPlayOnServerRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-save-purchases",
    component: SignInSavePurchasesRoute_SignInSavePurchasesRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-dressing-room",
    component: SignInDressingRoomRoute_SignInDressingRoomRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-marketplace",
    component: SignInMarketplaceRoute_SignInMarketplaceRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/sign-in-worlds-friends-servers",
    component: SignInWorldsFriendsServersRoute_SignInWorldsFriendsServersRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/first-time-sign-in",
    component: FirstTimeSignInRoute_FirstTimeSignInRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/inbox/:tab",
    component: InboxRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition,
    knownEntries: ['news', 'invites', 'realms'].map(tab => ({
      tab: tab
    }))
  }), /*#__PURE__*/react.createElement(Redirect, {
    from: "/inbox",
    to: "/inbox/news"
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/inbox-settings",
    component: InboxSettingsRoute_InboxSettingsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/message/:messageId",
    component: InboxMessageDetailsRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/edit-world/:id/:tab/:worldTemplateId?",
    component: EditWorldRoute,
    transitionComponent: RouteSlideTransition_RouteSlideTransition
  }), /*#__PURE__*/react.createElement(Redirect, {
    from: "/edit-world/:id",
    to: "/edit-world/:id/general"
  }), /*#__PURE__*/react.createElement(RouterEngineProvider_Route, {
    route: "/realms-create-preview-with-only-one-subscription",
    component: CreatePreviewRealmWithOnlyOneSubscriptionRoute,
    modes: ['modal']
  }),  false && /*#__PURE__*/0,  false && /*#__PURE__*/0,  false && /*#__PURE__*/0,  false && /*#__PURE__*/0,  false && /*#__PURE__*/0, /*#__PURE__*/react.createElement(InputLegend_InputLegend_InputLegend, null));
}
render( /*#__PURE__*/react.createElement(App, null), document.getElementById('root'));
})();

/******/ })()
;